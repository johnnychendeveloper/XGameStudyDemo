// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xgame.proto

#ifndef PROTOBUF_xgame_2eproto__INCLUDED
#define PROTOBUF_xgame_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pp {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xgame_2eproto();
void protobuf_AssignDesc_xgame_2eproto();
void protobuf_ShutdownFile_xgame_2eproto();

class AdListReq;
class AdListRes;
class AdEntity;
class AdModifyReq;
class AdModifyRes;
class AdRemoveReq;
class AdRemoveRes;
class UserForbidInfo;
class UserForbidOpReq;
class UserForbidOpRes;
class UserForbidSearchReq;
class UserForbidSearchRes;
class PublicNumAddReq;
class IDCodeApplyReq;
class IDCodeApplyRes;
class IDReplaceReq;
class UserRoleModifyReq;
class BackstageGidSidReq;
class BackstageGidSid;
class BackstageGidSidRes;
class GroupStatInfo;
class GroupTag;
class GroupTags;
class UserInfoBrief;
class ExtComment;
class ExtProps;
class UserFamily;
class UserStamp;
class UserInfoProp;
class UserActiveData;
class GameInfo;
class GameReservableRecord;
class ConfigJsonReq;
class ConfigJsonRes;
class ConfigJsonListReq;
class ConfigJsonListRes;
class ConfigJsonData;
class SysConfReq;
class SysConfRes;
class UserSettingItem;
class UserSettingSetReq;
class UserSettingSetRes;
class UserSettingGetReq;
class UserSettingGetRes;
class AppStateCheckReq;
class AppState;
class AppStateCheckRes;
class AppStateUpdateReq;
class AppStateUpdateRes;
class AppActConfigReq;
class AppActConfigRes;
class AppProtoVersionUpdateReq;
class AppProtoVersionUpdateRes;
class ContactInfo;
class ContactIncrement;
class ContactListReq;
class ContactListRes;
class ContactAddReq;
class ContactAddRes;
class ContactApproveReq;
class ContactApproveRes;
class ContactModifyReq;
class ContactModifyRes;
class KeyExchangeReq;
class KeyExchangeRes;
class Result;
class UserGameListReq;
class UserGameListRes;
class GameReport;
class UserGameListReportReq;
class UserGameListReportRes;
class UserGameRunReportReq;
class UserGameRunReportRes;
class GameGiftListReq;
class GameGiftListRes;
class GameGiftBookReq;
class GameReservableListReq;
class GameReservableListRes;
class GameSearchReq;
class GameSearchRes;
class ModifyGroupGameReq;
class ModifyGroupGameRes;
class DiscountInfo;
class GameDiscountListReq;
class GameDiscountListRes;
class ModifyGroupGameApkurlReq;
class ModifyGroupGameApkurlRes;
class SendInstallGameMsgReq;
class SendInstallGameMsgRes;
class GameAddReq;
class GameAddRes;
class GameModifyReq;
class GameModifyRes;
class ModifyOurGameStateReq;
class ModifyOurGameStateRes;
class SearchGamesListReq;
class SearchGamesListRes;
class GameCountReq;
class GameCountRes;
class RecommendPackNameReq;
class RecommendPackNameRes;
class ModifyGameFilterReq;
class ModifyGameFilterRes;
class GameFilterInfo;
class GameFilterSearchReq;
class GameFilterSearchRes;
class GameSpiderReq;
class GameSpiderRes;
class ModifyGameDiscountReq;
class ModifyGameDiscountRes;
class ModifyGroupDiscountReq;
class ModifyGroupDiscountRes;
class GroupDiscountListReq;
class GroupDiscountListRes;
class UserYYCoinsPayMethodReq;
class UserYYCoinsPayMethod;
class UserYYCoinsPayMethodRes;
class UserYYCoinsBuyReq;
class UserYYCoinsBuyRes;
class UserYYCoinsBuyFeedbackReq;
class UserYYCoinsBuyFeedbackRes;
class UserYYCoinsRecord;
class UserYYCoinsQueryReq;
class UserYYCoinsQueryRes;
class UserYYCoinsHistoryReq;
class UserYYCoinsHistoryRes;
class UserYYCoinsPayGateCallbackReq;
class UserYYCoinsShopListReq;
class UserYYCoinsShopListRes;
class UserYYCoinsShopItem;
class GroupRolerState;
class GroupLabel;
class GroupInfo;
class GroupGames;
class GroupPresents;
class GroupData;
class GroupTeamOpReq;
class GroupApplyReq;
class GroupApplyRes;
class GroupApproveReq;
class GroupApproveRes;
class GroupQuitReq;
class GroupInfoReq;
class GroupCheckinReq;
class GroupCheckinRes;
class GroupSearchReq;
class GroupSearchRes;
class GroupSearchKeywordsReq;
class GroupSearchKeywordsRes;
class GroupListReq;
class GroupIncrement;
class GroupInfoList;
class GroupListRes;
class GroupLobbyOrderModifyReq;
class GroupLobbyOrderModifyRes;
class GroupLabelOpReq;
class GroupAppSendReq;
class GroupAppSendRes;
class GroupAppReq;
class GroupApp;
class GroupAppList;
class GroupAppListReq;
class GroupAppListRes;
class GroupMsgAppReq;
class GroupMsgApp;
class GroupMsgAppRes;
class GroupMemberRolerItem;
class GroupMemberRolerListReq;
class GroupMemberRolerListRes;
class GroupMemberRolerSetReq;
class GroupMemberCheckinState;
class GroupMember;
class GroupMemberListReq;
class GroupMemberIncrement;
class GroupMemberList;
class GroupMemberListRes;
class GroupMemberReq;
class GroupMemberRes;
class GroupMemberModifyReq;
class GroupMemberKickReq;
class GroupMemberSearchReq;
class GroupMemberSearchRes;
class GroupMemberCountReq;
class GroupMemberCountRes;
class GroupMsgVoiceReq;
class GroupMsgVoiceRes;
class GroupMsgReq;
class GroupMsgListReq;
class GroupMsg;
class GroupMsgList;
class GroupMsgListRes;
class GroupMsgSearchReq;
class GroupMsgSearchRes;
class GroupMsgSendReq;
class YYAccountInfo;
class UserLoginReq;
class UserLoginRes;
class UserLogoutReq;
class UserLogoutRes;
class UserPushTokenRegisterReq;
class UserPushTokenRegisterRes;
class UserWebLoginReq;
class UserWebLoginRes;
class UserTokenReq;
class UserTokenRes;
class UserActivateReq;
class UserActivateRes;
class AccountBindReq;
class AccountBindRes;
class CpsAccountBindReq;
class CpsAccountBindRes;
class CpsWebLoginReq;
class CpsWebLoginRes;
class UserHeartBeat;
class UserHeartBeatReq;
class UserHeartBeatRes;
class SessionResumeReq;
class SessionResumeRes;
class SessionSuspendReq;
class UptokenReq;
class Uptoken;
class UptokenRes;
class MessageImage;
class MessageVoice;
class MessageVideo;
class MessagePub;
class MessageTxtlink;
class MessageGroupNotice;
class MessageInputStatus;
class MessageEvent;
class MessageUserApply;
class MessageGroupApply;
class MessageUserTask;
class MessageBody;
class PresentInfo;
class PresentInfoReq;
class PresentInfoRes;
class PresentAddReq;
class PresentModifyReq;
class PresentListReq;
class PresentListRes;
class PresentCountReq;
class PresentCountRes;
class UserPresentListReq;
class UserPresent;
class UserPresentListRes;
class UserPresentReq;
class UserPresentRes;
class PresentGroupListReq;
class PresentGroupListRes;
class PresentUserTakeReq;
class PresentUserTakeRes;
class GroupPresent;
class GroupPresentOpReq;
class GroupPresentOpRes;
class GroupPresentListReq;
class GroupPresentListRes;
class GetPresentsByGameIdReq;
class GetPresentsByGameIdRes;
class PresentUserListReq;
class PresentUserListRes;
class PresentUser;
class MsgPush;
class ForceLogoutPush;
class RedPacketInfo;
class RedPacketBlessInfo;
class RedPacketAddReq;
class RedPacketTakeReq;
class RedPacketTakeRes;
class ShowRedPacketListReq;
class ShowRedPacketListRes;
class UserRedPacketStatReq;
class UserRedPacketStatRes;
class RedPacketRecord;
class RedPacketRankListReq;
class RedPacketRankListRes;
class BlessGiftInfo;
class BlessGiftListReq;
class BlessGiftListRes;
class BlessGiftExchangeReq;
class BlessGiftExchangeRes;
class ReportViolatorReq;
class ReportLogReq;
class ProductInfo;
class ProductListReq;
class ProductListRes;
class ProductOpReq;
class ProductBuyReq;
class UserTradeRecord;
class UserWithdrawReq;
class UserMoneyStatReq;
class UserMoneyStatRes;
class UserBankInfo;
class UserBankInfoOpReq;
class UserBankInfoOpRes;
class BankListReq;
class BankListRes;
class UserCoinRecord;
class YYGiftInfo;
class YYGiftListReq;
class YYGiftListRes;
class YYGiftDonateReq;
class YYGiftDonateRes;
class YYGiftPayConfirmReq;
class YYGiftPayConfirmRes;
class UserTaskState;
class UserTaskStateReq;
class UserTaskStateRes;
class UserTaskTakeAwardReq;
class UserTaskTakeAwardRes;
class UserTaskCheckReq;
class UserTaskCheckRes;
class UserInfo;
class UserPasswordModifyReq;
class UserPasswordModifyRes;
class UserInfoModifyReq;
class UserInfoModifyRes;
class UserInfoReq;
class UserInfoRes;
class UserInfoListReq;
class UserInfoListRes;
class UserActiveDataReq;
class UserActiveDataRes;
class UserActiveDataListReq;
class UserActiveDataListRes;
class UserSearchReq;
class UserSearchRes;
class UserImageListReq;
class UserImageListRes;
class UserImage;
class UserImageOpReq;
class UserImageOpRes;
class UserImageLikeReq;
class UserImageLikeRes;
class UserShowShareReq;
class UserShowShareRes;
class UserRecommendRegisterReq;
class UserRecommendRegisterRes;
class UserRefererListReq;
class UserRefererListRes;
class UserProductListReq;
class UserProductListRes;
class UserProduct;
class UserStatDataReq;
class UserStatDataRes;
class UserProfileViewReq;
class UserProfileViewRes;
class AutoTaskUserListReq;
class AutoTaskUserListRes;
class UserAppRateReq;
class UserAppRateRes;
class UserExpressAddrOpReq;
class ExpressAddr;
class UserExpressAddrOpRes;
class UserThirdPartyAccountReq;
class UserThirdPartyAccountRes;
class UserMsgReq;
class UserMsgListReq;
class UserMsg;
class UserMsgList;
class UserMsgListRes;
class UidRange;
class UserMsgBroadcastReq;
class UserMsgRejectList;
class UserMsgRejectListSetReq;
class UserMsgRejectListSetRes;
class UserMsgRejectListGetReq;
class UserMsgRejectListGetRes;
class MsgReadItem;
class MsgReadRevisionSetReq;
class MsgReadRevisionSetRes;
class MsgReadRevisionGetReq;
class MsgReadRevisionGetRes;
class MsgBroadcastQueryReq;
class MsgBroadcastQuery;
class MsgBroadcastQueryRes;
class WeiLianJoinReq;
class WeiLianJoinRes;
class WeiLianGoddessRankReq;
class WeiLianGoddess;
class WeiLianGoddessRankRes;
class WeiLianSearchReq;
class WeiLianSearchRes;
class WeiLianVoteReq;
class WeiLianVoteRes;
class WeiLianMyRankReq;
class WeiLianMyRankRes;
class GroupOwnerTransferReq;
class TopicListReq;
class TopicListRes;
class WebQRCodeScanReq;
class WebTokenVerifyReq;
class SysParamSetReq;
class CoinStatItem;
class UserCoinStatReq;
class UserCoinStatRes;
class UserAllStatReq;
class UserAllStatRes;
class GroupMembersStat;
class GroupMembersStatReq;
class GroupMembersStatRes;
class DailyTaskList;
class UserTaskCompleteStatReq;
class UserTaskCompleteStatRes;
class FromStoreItems;
class UserNewStatReq;
class UserNewStatRes;
class UserLevelStatReq;
class UserLevelStatRes;
class LevelNumberItems;
class UserTradeNumReq;
class UserTradeNumRes;
class UserPaymentReq;
class UserPaymentRes;
class CreamFamilyReq;
class CreamFamilyRes;
class YYuserList;
class TopCharmReq;
class TopCharmRes;
class TopCharm;
class UserLoginStatItems;
class UserLoginStatReq;
class UserLoginStatRes;
class ConfigJsonActData;
class ConfigJsonActListReq;
class ConfigJsonActListRes;
class ConfigJsonActStarReq;
class ConfigJsonActRes;
class ConfigJsonActModifyReq;
class ActStarFormReq;
class ActMsgListReq;
class ActMsgListRes;
class ActMsgList;
class ActMsgModifyReq;
class ActRegMemberAddReq;
class ActRegMemberModifyReq;
class ActRegMemberStateReq;
class ActRegMemberStateRes;
class ActRegMemberListReq;
class ActRegMemberListRes;
class ActRegMemberList;
class CoinAwardRecordReq;
class CoinAwardRecordRes;
class CoreUserListReq;
class CoreUserListRes;
class CoreUser;
class CoreUserModifyReq;
class CoinAwardRecord;
class ActRegMemberState;
class ActRegMembers;
class ActRegVoice;
class InvitationReq;
class InvitationRes;
class InvitationLv;
class UserDataAdjustReq;
class PCGiftNotifyRecord;
class PCGiftNotifyReq;
class ConfigDataReq;
class TradeConfigData;
class ConfigDataRes;
class DailyTaskStatReq;
class DailyTaskStat;
class DailyTaskStatRes;
class BabyDataStatReq;
class BabyDataStatRes;
class PageDataExchangeReq;
class PageDataExchangeRes;
class ActLuckyTryReq;
class ActLuckyTryRes;
class ActRecvDynamicReq;
class ActRecvDynamicRes;
class DevFinger;
class YYChannelTreeInfoReq;
class YYChannelBranch;
class YYChannelTreeInfoRes;
class ProtoBody;
class WebReq;

enum AppState_Type {
  AppState_Type_Activities = 1,
  AppState_Type_ProductShop = 2
};
bool AppState_Type_IsValid(int value);
const AppState_Type AppState_Type_Type_MIN = AppState_Type_Activities;
const AppState_Type AppState_Type_Type_MAX = AppState_Type_ProductShop;
const int AppState_Type_Type_ARRAYSIZE = AppState_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* AppState_Type_descriptor();
inline const ::std::string& AppState_Type_Name(AppState_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    AppState_Type_descriptor(), value);
}
inline bool AppState_Type_Parse(
    const ::std::string& name, AppState_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AppState_Type>(
    AppState_Type_descriptor(), name, value);
}
enum ContactIncrement_ContactIncrementType {
  ContactIncrement_ContactIncrementType_Contact_Add = 1,
  ContactIncrement_ContactIncrementType_Contact_Remove = 2,
  ContactIncrement_ContactIncrementType_Contact_Update = 3,
  ContactIncrement_ContactIncrementType_Contact_Reject = 4,
  ContactIncrement_ContactIncrementType_Contact_ApplyPass = 5,
  ContactIncrement_ContactIncrementType_Contact_Black = 6
};
bool ContactIncrement_ContactIncrementType_IsValid(int value);
const ContactIncrement_ContactIncrementType ContactIncrement_ContactIncrementType_ContactIncrementType_MIN = ContactIncrement_ContactIncrementType_Contact_Add;
const ContactIncrement_ContactIncrementType ContactIncrement_ContactIncrementType_ContactIncrementType_MAX = ContactIncrement_ContactIncrementType_Contact_Black;
const int ContactIncrement_ContactIncrementType_ContactIncrementType_ARRAYSIZE = ContactIncrement_ContactIncrementType_ContactIncrementType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContactIncrement_ContactIncrementType_descriptor();
inline const ::std::string& ContactIncrement_ContactIncrementType_Name(ContactIncrement_ContactIncrementType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContactIncrement_ContactIncrementType_descriptor(), value);
}
inline bool ContactIncrement_ContactIncrementType_Parse(
    const ::std::string& name, ContactIncrement_ContactIncrementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContactIncrement_ContactIncrementType>(
    ContactIncrement_ContactIncrementType_descriptor(), name, value);
}
enum UserYYCoinsRecord_OrderType {
  UserYYCoinsRecord_OrderType_Buy = 1
};
bool UserYYCoinsRecord_OrderType_IsValid(int value);
const UserYYCoinsRecord_OrderType UserYYCoinsRecord_OrderType_OrderType_MIN = UserYYCoinsRecord_OrderType_Buy;
const UserYYCoinsRecord_OrderType UserYYCoinsRecord_OrderType_OrderType_MAX = UserYYCoinsRecord_OrderType_Buy;
const int UserYYCoinsRecord_OrderType_OrderType_ARRAYSIZE = UserYYCoinsRecord_OrderType_OrderType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserYYCoinsRecord_OrderType_descriptor();
inline const ::std::string& UserYYCoinsRecord_OrderType_Name(UserYYCoinsRecord_OrderType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserYYCoinsRecord_OrderType_descriptor(), value);
}
inline bool UserYYCoinsRecord_OrderType_Parse(
    const ::std::string& name, UserYYCoinsRecord_OrderType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserYYCoinsRecord_OrderType>(
    UserYYCoinsRecord_OrderType_descriptor(), name, value);
}
enum UserPushTokenRegisterReq_DeviceType {
  UserPushTokenRegisterReq_DeviceType_Android = 1,
  UserPushTokenRegisterReq_DeviceType_Ios = 2
};
bool UserPushTokenRegisterReq_DeviceType_IsValid(int value);
const UserPushTokenRegisterReq_DeviceType UserPushTokenRegisterReq_DeviceType_DeviceType_MIN = UserPushTokenRegisterReq_DeviceType_Android;
const UserPushTokenRegisterReq_DeviceType UserPushTokenRegisterReq_DeviceType_DeviceType_MAX = UserPushTokenRegisterReq_DeviceType_Ios;
const int UserPushTokenRegisterReq_DeviceType_DeviceType_ARRAYSIZE = UserPushTokenRegisterReq_DeviceType_DeviceType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserPushTokenRegisterReq_DeviceType_descriptor();
inline const ::std::string& UserPushTokenRegisterReq_DeviceType_Name(UserPushTokenRegisterReq_DeviceType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserPushTokenRegisterReq_DeviceType_descriptor(), value);
}
inline bool UserPushTokenRegisterReq_DeviceType_Parse(
    const ::std::string& name, UserPushTokenRegisterReq_DeviceType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserPushTokenRegisterReq_DeviceType>(
    UserPushTokenRegisterReq_DeviceType_descriptor(), name, value);
}
enum MessageUserApply_OpType {
  MessageUserApply_OpType_None = 0,
  MessageUserApply_OpType_Apply = 1,
  MessageUserApply_OpType_Pass = 2,
  MessageUserApply_OpType_Add = 3,
  MessageUserApply_OpType_Refuse = 4
};
bool MessageUserApply_OpType_IsValid(int value);
const MessageUserApply_OpType MessageUserApply_OpType_OpType_MIN = MessageUserApply_OpType_None;
const MessageUserApply_OpType MessageUserApply_OpType_OpType_MAX = MessageUserApply_OpType_Refuse;
const int MessageUserApply_OpType_OpType_ARRAYSIZE = MessageUserApply_OpType_OpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageUserApply_OpType_descriptor();
inline const ::std::string& MessageUserApply_OpType_Name(MessageUserApply_OpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageUserApply_OpType_descriptor(), value);
}
inline bool MessageUserApply_OpType_Parse(
    const ::std::string& name, MessageUserApply_OpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageUserApply_OpType>(
    MessageUserApply_OpType_descriptor(), name, value);
}
enum MessageGroupApply_OpType {
  MessageGroupApply_OpType_None = 0,
  MessageGroupApply_OpType_Apply = 1,
  MessageGroupApply_OpType_Pass = 2,
  MessageGroupApply_OpType_Add = 3,
  MessageGroupApply_OpType_Refuse = 4,
  MessageGroupApply_OpType_Upgrade = 5,
  MessageGroupApply_OpType_Kick = 6,
  MessageGroupApply_OpType_Quit = 7,
  MessageGroupApply_OpType_Destroy = 8
};
bool MessageGroupApply_OpType_IsValid(int value);
const MessageGroupApply_OpType MessageGroupApply_OpType_OpType_MIN = MessageGroupApply_OpType_None;
const MessageGroupApply_OpType MessageGroupApply_OpType_OpType_MAX = MessageGroupApply_OpType_Destroy;
const int MessageGroupApply_OpType_OpType_ARRAYSIZE = MessageGroupApply_OpType_OpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageGroupApply_OpType_descriptor();
inline const ::std::string& MessageGroupApply_OpType_Name(MessageGroupApply_OpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageGroupApply_OpType_descriptor(), value);
}
inline bool MessageGroupApply_OpType_Parse(
    const ::std::string& name, MessageGroupApply_OpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageGroupApply_OpType>(
    MessageGroupApply_OpType_descriptor(), name, value);
}
enum RedPacketInfo_ItemType {
  RedPacketInfo_ItemType_Normal = 1,
  RedPacketInfo_ItemType_Super = 2
};
bool RedPacketInfo_ItemType_IsValid(int value);
const RedPacketInfo_ItemType RedPacketInfo_ItemType_ItemType_MIN = RedPacketInfo_ItemType_Normal;
const RedPacketInfo_ItemType RedPacketInfo_ItemType_ItemType_MAX = RedPacketInfo_ItemType_Super;
const int RedPacketInfo_ItemType_ItemType_ARRAYSIZE = RedPacketInfo_ItemType_ItemType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RedPacketInfo_ItemType_descriptor();
inline const ::std::string& RedPacketInfo_ItemType_Name(RedPacketInfo_ItemType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RedPacketInfo_ItemType_descriptor(), value);
}
inline bool RedPacketInfo_ItemType_Parse(
    const ::std::string& name, RedPacketInfo_ItemType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RedPacketInfo_ItemType>(
    RedPacketInfo_ItemType_descriptor(), name, value);
}
enum ReportViolatorReq_ViolatorType {
  ReportViolatorReq_ViolatorType_ViolatorTypeUser = 1,
  ReportViolatorReq_ViolatorType_ViolatorTypeTopic = 2
};
bool ReportViolatorReq_ViolatorType_IsValid(int value);
const ReportViolatorReq_ViolatorType ReportViolatorReq_ViolatorType_ViolatorType_MIN = ReportViolatorReq_ViolatorType_ViolatorTypeUser;
const ReportViolatorReq_ViolatorType ReportViolatorReq_ViolatorType_ViolatorType_MAX = ReportViolatorReq_ViolatorType_ViolatorTypeTopic;
const int ReportViolatorReq_ViolatorType_ViolatorType_ARRAYSIZE = ReportViolatorReq_ViolatorType_ViolatorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReportViolatorReq_ViolatorType_descriptor();
inline const ::std::string& ReportViolatorReq_ViolatorType_Name(ReportViolatorReq_ViolatorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReportViolatorReq_ViolatorType_descriptor(), value);
}
inline bool ReportViolatorReq_ViolatorType_Parse(
    const ::std::string& name, ReportViolatorReq_ViolatorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReportViolatorReq_ViolatorType>(
    ReportViolatorReq_ViolatorType_descriptor(), name, value);
}
enum ReportViolatorReq_ViolatorReason {
  ReportViolatorReq_ViolatorReason_ViolatorReasonAdvertisement = 1,
  ReportViolatorReq_ViolatorReason_ViolatorReasonHarassment = 2,
  ReportViolatorReq_ViolatorReason_ViolatorReasonSex = 3,
  ReportViolatorReq_ViolatorReason_ViolatorReasonPolitical = 4,
  ReportViolatorReq_ViolatorReason_ViolatorReasonAttack = 5,
  ReportViolatorReq_ViolatorReason_ViolatorReasonPseudo = 6,
  ReportViolatorReq_ViolatorReason_ViolatorReasonFakeWinning = 7,
  ReportViolatorReq_ViolatorReason_ViolatorReasonOther = 99
};
bool ReportViolatorReq_ViolatorReason_IsValid(int value);
const ReportViolatorReq_ViolatorReason ReportViolatorReq_ViolatorReason_ViolatorReason_MIN = ReportViolatorReq_ViolatorReason_ViolatorReasonAdvertisement;
const ReportViolatorReq_ViolatorReason ReportViolatorReq_ViolatorReason_ViolatorReason_MAX = ReportViolatorReq_ViolatorReason_ViolatorReasonOther;
const int ReportViolatorReq_ViolatorReason_ViolatorReason_ARRAYSIZE = ReportViolatorReq_ViolatorReason_ViolatorReason_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReportViolatorReq_ViolatorReason_descriptor();
inline const ::std::string& ReportViolatorReq_ViolatorReason_Name(ReportViolatorReq_ViolatorReason value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReportViolatorReq_ViolatorReason_descriptor(), value);
}
inline bool ReportViolatorReq_ViolatorReason_Parse(
    const ::std::string& name, ReportViolatorReq_ViolatorReason* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReportViolatorReq_ViolatorReason>(
    ReportViolatorReq_ViolatorReason_descriptor(), name, value);
}
enum ProductInfo_Type {
  ProductInfo_Type_Normal = 0,
  ProductInfo_Type_Coins = 1
};
bool ProductInfo_Type_IsValid(int value);
const ProductInfo_Type ProductInfo_Type_Type_MIN = ProductInfo_Type_Normal;
const ProductInfo_Type ProductInfo_Type_Type_MAX = ProductInfo_Type_Coins;
const int ProductInfo_Type_Type_ARRAYSIZE = ProductInfo_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProductInfo_Type_descriptor();
inline const ::std::string& ProductInfo_Type_Name(ProductInfo_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProductInfo_Type_descriptor(), value);
}
inline bool ProductInfo_Type_Parse(
    const ::std::string& name, ProductInfo_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProductInfo_Type>(
    ProductInfo_Type_descriptor(), name, value);
}
enum UserTradeRecord_Type {
  UserTradeRecord_Type_GiftReceive = 1,
  UserTradeRecord_Type_ProductPurchase = 50,
  UserTradeRecord_Type_Withdraw = 51,
  UserTradeRecord_Type_WithdrawBaby = 52,
  UserTradeRecord_Type_GiftForLottery = 60,
  UserTradeRecord_Type_ProductFromLottery = 61
};
bool UserTradeRecord_Type_IsValid(int value);
const UserTradeRecord_Type UserTradeRecord_Type_Type_MIN = UserTradeRecord_Type_GiftReceive;
const UserTradeRecord_Type UserTradeRecord_Type_Type_MAX = UserTradeRecord_Type_ProductFromLottery;
const int UserTradeRecord_Type_Type_ARRAYSIZE = UserTradeRecord_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserTradeRecord_Type_descriptor();
inline const ::std::string& UserTradeRecord_Type_Name(UserTradeRecord_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserTradeRecord_Type_descriptor(), value);
}
inline bool UserTradeRecord_Type_Parse(
    const ::std::string& name, UserTradeRecord_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserTradeRecord_Type>(
    UserTradeRecord_Type_descriptor(), name, value);
}
enum UserCoinRecord_Type {
  UserCoinRecord_Type_Unknown = 0,
  UserCoinRecord_Type_Newbie_Signature = 1,
  UserCoinRecord_Type_Newbie_ImageLike5 = 2,
  UserCoinRecord_Type_Newbie_ImageUpload = 3,
  UserCoinRecord_Type_Newbie_UserFollow = 4,
  UserCoinRecord_Type_Newbie_GiftDonate = 5,
  UserCoinRecord_Type_Newbie_AppRate = 6,
  UserCoinRecord_Type_Newbie_LogoUpload = 7,
  UserCoinRecord_Type_Newbie_ShowWatch10D2 = 8,
  UserCoinRecord_Type_Newbie_NickModify = 9,
  UserCoinRecord_Type_Threshold = 15,
  UserCoinRecord_Type_Daily_Checkin = 16,
  UserCoinRecord_Type_Daily_ShowWatch = 32,
  UserCoinRecord_Type_Daily_ShowWatch10 = 33,
  UserCoinRecord_Type_Daily_ShowWatch30 = 34,
  UserCoinRecord_Type_Daily_ShowWatch50 = 35,
  UserCoinRecord_Type_Daily_GiftDonate = 48,
  UserCoinRecord_Type_Daily_GiftDonate5 = 49,
  UserCoinRecord_Type_Daily_GiftDonate10 = 50,
  UserCoinRecord_Type_Daily_GiftDonate30 = 51,
  UserCoinRecord_Type_Daily_ShowVoice5 = 65,
  UserCoinRecord_Type_Daily_ShowVideo = 80,
  UserCoinRecord_Type_Daily_PublicShowSpeak = 96,
  UserCoinRecord_Type_Daily_UserFollowed10 = 101,
  UserCoinRecord_Type_Daily_ReceiveGift10 = 106,
  UserCoinRecord_Type_Daily_ShowShare = 112,
  UserCoinRecord_Type_Daily_RefererAdd = 117,
  UserCoinRecord_Type_Shop10PercentAward = 222,
  UserCoinRecord_Type_Shop05PercentAward = 223,
  UserCoinRecord_Type_ShopPurchase = 224,
  UserCoinRecord_Type_CompanyAward = 225,
  UserCoinRecord_Type_ProductTrade = 226,
  UserCoinRecord_Type_YYGiftHitAward = 227,
  UserCoinRecord_Type_ChrisLottery = 228,
  UserCoinRecord_Type_MarryAward = 229,
  UserCoinRecord_Type_RedPacketAward = 230,
  UserCoinRecord_Type_RedPacketBlessGiftAward = 231,
  UserCoinRecord_Type_ProductCoinExchange = 232,
  UserCoinRecord_Type_RefereeAward = 233,
  UserCoinRecord_Type_RefererAward = 234,
  UserCoinRecord_Type_ActLuckyAward = 235,
  UserCoinRecord_Type_ShowGameAward = 236,
  UserCoinRecord_Type_GiftDonate = 240,
  UserCoinRecord_Type_MessageTop = 241,
  UserCoinRecord_Type_FamilyCreate = 242,
  UserCoinRecord_Type_RedPacketCreate = 243,
  UserCoinRecord_Type_HallShare = 244,
  UserCoinRecord_Type_NationalDayAuction = 245
};
bool UserCoinRecord_Type_IsValid(int value);
const UserCoinRecord_Type UserCoinRecord_Type_Type_MIN = UserCoinRecord_Type_Unknown;
const UserCoinRecord_Type UserCoinRecord_Type_Type_MAX = UserCoinRecord_Type_NationalDayAuction;
const int UserCoinRecord_Type_Type_ARRAYSIZE = UserCoinRecord_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserCoinRecord_Type_descriptor();
inline const ::std::string& UserCoinRecord_Type_Name(UserCoinRecord_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserCoinRecord_Type_descriptor(), value);
}
inline bool UserCoinRecord_Type_Parse(
    const ::std::string& name, UserCoinRecord_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserCoinRecord_Type>(
    UserCoinRecord_Type_descriptor(), name, value);
}
enum UserTaskState_TaskCategory {
  UserTaskState_TaskCategory_Unknown = 0,
  UserTaskState_TaskCategory_Newbie = 1,
  UserTaskState_TaskCategory_Daily = 2
};
bool UserTaskState_TaskCategory_IsValid(int value);
const UserTaskState_TaskCategory UserTaskState_TaskCategory_TaskCategory_MIN = UserTaskState_TaskCategory_Unknown;
const UserTaskState_TaskCategory UserTaskState_TaskCategory_TaskCategory_MAX = UserTaskState_TaskCategory_Daily;
const int UserTaskState_TaskCategory_TaskCategory_ARRAYSIZE = UserTaskState_TaskCategory_TaskCategory_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserTaskState_TaskCategory_descriptor();
inline const ::std::string& UserTaskState_TaskCategory_Name(UserTaskState_TaskCategory value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserTaskState_TaskCategory_descriptor(), value);
}
inline bool UserTaskState_TaskCategory_Parse(
    const ::std::string& name, UserTaskState_TaskCategory* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserTaskState_TaskCategory>(
    UserTaskState_TaskCategory_descriptor(), name, value);
}
enum UserImageOpReq_Type {
  UserImageOpReq_Type_Upload = 1,
  UserImageOpReq_Type_Delete = 2
};
bool UserImageOpReq_Type_IsValid(int value);
const UserImageOpReq_Type UserImageOpReq_Type_Type_MIN = UserImageOpReq_Type_Upload;
const UserImageOpReq_Type UserImageOpReq_Type_Type_MAX = UserImageOpReq_Type_Delete;
const int UserImageOpReq_Type_Type_ARRAYSIZE = UserImageOpReq_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserImageOpReq_Type_descriptor();
inline const ::std::string& UserImageOpReq_Type_Name(UserImageOpReq_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserImageOpReq_Type_descriptor(), value);
}
inline bool UserImageOpReq_Type_Parse(
    const ::std::string& name, UserImageOpReq_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserImageOpReq_Type>(
    UserImageOpReq_Type_descriptor(), name, value);
}
enum PType {
  PEncrypt = 255,
  PLogin = 1,
  PUser = 2,
  PUserMsg = 3,
  PUserTask = 4,
  PGroup = 5,
  PGroupMsg = 6,
  PPush = 7,
  PGroupApp = 8,
  PGroupMember = 9,
  PReport = 10,
  PGoldCoin = 11,
  PGift = 12,
  PShop = 17,
  PWeb = 18,
  PAdmin = 19,
  PAd = 20,
  PConfig = 25,
  PStat = 48,
  PGame = 49,
  PContact = 50,
  PPresent = 51,
  PWebActivity = 52,
  PBackstage = 53,
  PYYChannel = 54
};
bool PType_IsValid(int value);
const PType PType_MIN = PLogin;
const PType PType_MAX = PEncrypt;
const int PType_ARRAYSIZE = PType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PType_descriptor();
inline const ::std::string& PType_Name(PType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PType_descriptor(), value);
}
inline bool PType_Parse(
    const ::std::string& name, PType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PType>(
    PType_descriptor(), name, value);
}
enum SPAd {
  PAdListReq = 0,
  PAdListRes = 1,
  PAdModifyReq = 2,
  PAdModifyRes = 3,
  PAdRemoveReq = 4,
  PAdRemoveRes = 5
};
bool SPAd_IsValid(int value);
const SPAd SPAd_MIN = PAdListReq;
const SPAd SPAd_MAX = PAdRemoveRes;
const int SPAd_ARRAYSIZE = SPAd_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPAd_descriptor();
inline const ::std::string& SPAd_Name(SPAd value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPAd_descriptor(), value);
}
inline bool SPAd_Parse(
    const ::std::string& name, SPAd* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPAd>(
    SPAd_descriptor(), name, value);
}
enum AdPage {
  AdPage_Popular = 1,
  AdPage_Active = 2,
  AdPage_Star = 3,
  AdPage_Fllow = 4
};
bool AdPage_IsValid(int value);
const AdPage AdPage_MIN = AdPage_Popular;
const AdPage AdPage_MAX = AdPage_Fllow;
const int AdPage_ARRAYSIZE = AdPage_MAX + 1;

const ::google::protobuf::EnumDescriptor* AdPage_descriptor();
inline const ::std::string& AdPage_Name(AdPage value) {
  return ::google::protobuf::internal::NameOfEnum(
    AdPage_descriptor(), value);
}
inline bool AdPage_Parse(
    const ::std::string& name, AdPage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AdPage>(
    AdPage_descriptor(), name, value);
}
enum SPAdmin {
  PIDCodeApplyReq = 0,
  PIDCodeApplyRes = 1,
  PIDReplaceReq = 2,
  PIDReplaceRes = 3,
  PPublicNumAddReq = 16,
  PPublicNumAddRes = 17,
  PUserForbidOpReq = 18,
  PUserForbidOpRes = 19,
  PUserForbidSearchReq = 20,
  PUserForbidSearchRes = 21,
  PUserRoleModifyReq = 26,
  PUserRoleModifyRes = 27,
  PUserCoinStatReq = 33,
  PUserCoinStatRes = 34,
  PSysParamSetReq = 48,
  PSysParamSetRes = 49
};
bool SPAdmin_IsValid(int value);
const SPAdmin SPAdmin_MIN = PIDCodeApplyReq;
const SPAdmin SPAdmin_MAX = PSysParamSetRes;
const int SPAdmin_ARRAYSIZE = SPAdmin_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPAdmin_descriptor();
inline const ::std::string& SPAdmin_Name(SPAdmin value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPAdmin_descriptor(), value);
}
inline bool SPAdmin_Parse(
    const ::std::string& name, SPAdmin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPAdmin>(
    SPAdmin_descriptor(), name, value);
}
enum ForbidReasonType {
  ForbidReasonType_Defalut = 0,
  ForbidReasonType_Sexual = 1,
  ForbidReasonType_Political = 2,
  ForbidReasonType_Steal = 3,
  ForbidReasonType_Spam = 11,
  ForbidReasonType_Berascal = 12,
  ForbidReasonType_Advertisement = 13
};
bool ForbidReasonType_IsValid(int value);
const ForbidReasonType ForbidReasonType_MIN = ForbidReasonType_Defalut;
const ForbidReasonType ForbidReasonType_MAX = ForbidReasonType_Advertisement;
const int ForbidReasonType_ARRAYSIZE = ForbidReasonType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForbidReasonType_descriptor();
inline const ::std::string& ForbidReasonType_Name(ForbidReasonType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForbidReasonType_descriptor(), value);
}
inline bool ForbidReasonType_Parse(
    const ::std::string& name, ForbidReasonType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForbidReasonType>(
    ForbidReasonType_descriptor(), name, value);
}
enum ForbidStateType {
  ForbidStateType_Normal = 0,
  ForbidStateType_SayLimit = 1,
  ForbidStateType_SayForbidden = 2,
  ForbidStateType_LoginForbidden = 3
};
bool ForbidStateType_IsValid(int value);
const ForbidStateType ForbidStateType_MIN = ForbidStateType_Normal;
const ForbidStateType ForbidStateType_MAX = ForbidStateType_LoginForbidden;
const int ForbidStateType_ARRAYSIZE = ForbidStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForbidStateType_descriptor();
inline const ::std::string& ForbidStateType_Name(ForbidStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForbidStateType_descriptor(), value);
}
inline bool ForbidStateType_Parse(
    const ::std::string& name, ForbidStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForbidStateType>(
    ForbidStateType_descriptor(), name, value);
}
enum ForbidDevType {
  ForbidDevType_None = 0,
  ForbidDevType_Uid = 1,
  ForbidDevType_Mac = 2,
  ForbidDevType_Ip = 3
};
bool ForbidDevType_IsValid(int value);
const ForbidDevType ForbidDevType_MIN = ForbidDevType_None;
const ForbidDevType ForbidDevType_MAX = ForbidDevType_Ip;
const int ForbidDevType_ARRAYSIZE = ForbidDevType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForbidDevType_descriptor();
inline const ::std::string& ForbidDevType_Name(ForbidDevType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForbidDevType_descriptor(), value);
}
inline bool ForbidDevType_Parse(
    const ::std::string& name, ForbidDevType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForbidDevType>(
    ForbidDevType_descriptor(), name, value);
}
enum ForbidSearchBy {
  ForbidSearchBy_None = 0,
  ForbidSearchBy_Uid = 1
};
bool ForbidSearchBy_IsValid(int value);
const ForbidSearchBy ForbidSearchBy_MIN = ForbidSearchBy_None;
const ForbidSearchBy ForbidSearchBy_MAX = ForbidSearchBy_Uid;
const int ForbidSearchBy_ARRAYSIZE = ForbidSearchBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* ForbidSearchBy_descriptor();
inline const ::std::string& ForbidSearchBy_Name(ForbidSearchBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    ForbidSearchBy_descriptor(), value);
}
inline bool ForbidSearchBy_Parse(
    const ::std::string& name, ForbidSearchBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ForbidSearchBy>(
    ForbidSearchBy_descriptor(), name, value);
}
enum SPBackstage {
  PBackstageGidSidReq = 1,
  PBackstageGidSidRes = 2
};
bool SPBackstage_IsValid(int value);
const SPBackstage SPBackstage_MIN = PBackstageGidSidReq;
const SPBackstage SPBackstage_MAX = PBackstageGidSidRes;
const int SPBackstage_ARRAYSIZE = SPBackstage_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPBackstage_descriptor();
inline const ::std::string& SPBackstage_Name(SPBackstage value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPBackstage_descriptor(), value);
}
inline bool SPBackstage_Parse(
    const ::std::string& name, SPBackstage* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPBackstage>(
    SPBackstage_descriptor(), name, value);
}
enum SexType {
  Unknow = 0,
  Female = 1,
  Male = 2
};
bool SexType_IsValid(int value);
const SexType SexType_MIN = Unknow;
const SexType SexType_MAX = Male;
const int SexType_ARRAYSIZE = SexType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SexType_descriptor();
inline const ::std::string& SexType_Name(SexType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SexType_descriptor(), value);
}
inline bool SexType_Parse(
    const ::std::string& name, SexType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SexType>(
    SexType_descriptor(), name, value);
}
enum ContactState {
  Contact_None = 0,
  Contact_Friend = 1,
  Contact_Black = 2
};
bool ContactState_IsValid(int value);
const ContactState ContactState_MIN = Contact_None;
const ContactState ContactState_MAX = Contact_Black;
const int ContactState_ARRAYSIZE = ContactState_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContactState_descriptor();
inline const ::std::string& ContactState_Name(ContactState value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContactState_descriptor(), value);
}
inline bool ContactState_Parse(
    const ::std::string& name, ContactState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContactState>(
    ContactState_descriptor(), name, value);
}
enum SPConfig {
  PConfigJsonReq = 1,
  PConfigJsonRes = 2,
  PConfigJsonListReq = 3,
  PConfigJsonListRes = 4,
  PSysConfReq = 5,
  PSysConfRes = 6,
  PUserSettingSetReq = 52,
  PUserSettingSetRes = 53,
  PUserSettingGetReq = 54,
  PUserSettingGetRes = 55,
  PAppStateCheckReq = 64,
  PAppStateCheckRes = 65,
  PAppStateUpdateReq = 66,
  PAppStateUpdateRes = 67,
  PAppActConfigReq = 68,
  PAppActConfigRes = 69,
  PAppProtoVersionUpdateReq = 70,
  PAppProtoVersionUpdateRes = 71
};
bool SPConfig_IsValid(int value);
const SPConfig SPConfig_MIN = PConfigJsonReq;
const SPConfig SPConfig_MAX = PAppProtoVersionUpdateRes;
const int SPConfig_ARRAYSIZE = SPConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPConfig_descriptor();
inline const ::std::string& SPConfig_Name(SPConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPConfig_descriptor(), value);
}
inline bool SPConfig_Parse(
    const ::std::string& name, SPConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPConfig>(
    SPConfig_descriptor(), name, value);
}
enum SPContact {
  PContactListReq = 1,
  PContactListRes = 2,
  PContactListSearchReq = 5,
  PContactListSearchRes = 6,
  PContactAddReq = 7,
  PContactAddRes = 8,
  PContactApproveReq = 9,
  PContactApproveRes = 10,
  PContactModifyReq = 11,
  PContactModifyRes = 12
};
bool SPContact_IsValid(int value);
const SPContact SPContact_MIN = PContactListReq;
const SPContact SPContact_MAX = PContactModifyRes;
const int SPContact_ARRAYSIZE = SPContact_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPContact_descriptor();
inline const ::std::string& SPContact_Name(SPContact value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPContact_descriptor(), value);
}
inline bool SPContact_Parse(
    const ::std::string& name, SPContact* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPContact>(
    SPContact_descriptor(), name, value);
}
enum ContactType {
  ContactTypeFriend = 0,
  ContactTypeSystem = 1
};
bool ContactType_IsValid(int value);
const ContactType ContactType_MIN = ContactTypeFriend;
const ContactType ContactType_MAX = ContactTypeSystem;
const int ContactType_ARRAYSIZE = ContactType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContactType_descriptor();
inline const ::std::string& ContactType_Name(ContactType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContactType_descriptor(), value);
}
inline bool ContactType_Parse(
    const ::std::string& name, ContactType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContactType>(
    ContactType_descriptor(), name, value);
}
enum ContactApplyResult {
  ContactApplyApprovaling = 0,
  ContactApplyPassed = 1,
  ContactApplyReject = 2,
  ContactApplyErrorUid = 3,
  ContactApplyErrorServer = 4,
  ContactApplyApprovaled = 5,
  ContactApplyRecommendByAddresBook = 10,
  ContactApplyRecommendByYY = 11,
  ContactApplyRecommendByFriendship = 12,
  ContactApplyRecommendByLocation = 13,
  ContactApplyFriendsLimit = 128,
  ContactApplyFriendsLimitPeer = 129,
  ContactApplyRepeat = 130,
  ContactApplyFriendAlready = 131
};
bool ContactApplyResult_IsValid(int value);
const ContactApplyResult ContactApplyResult_MIN = ContactApplyApprovaling;
const ContactApplyResult ContactApplyResult_MAX = ContactApplyFriendAlready;
const int ContactApplyResult_ARRAYSIZE = ContactApplyResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContactApplyResult_descriptor();
inline const ::std::string& ContactApplyResult_Name(ContactApplyResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContactApplyResult_descriptor(), value);
}
inline bool ContactApplyResult_Parse(
    const ::std::string& name, ContactApplyResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContactApplyResult>(
    ContactApplyResult_descriptor(), name, value);
}
enum ContactOpType {
  ContactOpTypeRemove = 1,
  ContactOpTypeBlack = 2,
  ContactOpTypeModifyName = 3
};
bool ContactOpType_IsValid(int value);
const ContactOpType ContactOpType_MIN = ContactOpTypeRemove;
const ContactOpType ContactOpType_MAX = ContactOpTypeModifyName;
const int ContactOpType_ARRAYSIZE = ContactOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ContactOpType_descriptor();
inline const ::std::string& ContactOpType_Name(ContactOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ContactOpType_descriptor(), value);
}
inline bool ContactOpType_Parse(
    const ::std::string& name, ContactOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ContactOpType>(
    ContactOpType_descriptor(), name, value);
}
enum SPEncrypt {
  PKeyExchangeReq = 0,
  PKeyExchangeRes = 1
};
bool SPEncrypt_IsValid(int value);
const SPEncrypt SPEncrypt_MIN = PKeyExchangeReq;
const SPEncrypt SPEncrypt_MAX = PKeyExchangeRes;
const int SPEncrypt_ARRAYSIZE = SPEncrypt_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPEncrypt_descriptor();
inline const ::std::string& SPEncrypt_Name(SPEncrypt value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPEncrypt_descriptor(), value);
}
inline bool SPEncrypt_Parse(
    const ::std::string& name, SPEncrypt* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPEncrypt>(
    SPEncrypt_descriptor(), name, value);
}
enum EncryptType {
  EncryptTypeNone = 0,
  EncryptTypeRC4 = 1
};
bool EncryptType_IsValid(int value);
const EncryptType EncryptType_MIN = EncryptTypeNone;
const EncryptType EncryptType_MAX = EncryptTypeRC4;
const int EncryptType_ARRAYSIZE = EncryptType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EncryptType_descriptor();
inline const ::std::string& EncryptType_Name(EncryptType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EncryptType_descriptor(), value);
}
inline bool EncryptType_Parse(
    const ::std::string& name, EncryptType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EncryptType>(
    EncryptType_descriptor(), name, value);
}
enum ErrCode {
  Success = 0,
  ServerError = 1,
  DatabaseError = 2,
  UnkownRequest = 3,
  NotPrivilege = 4,
  NotMobilePhone = 5,
  ParamInvalid = 6,
  Invalid = 7,
  Repeat = 8,
  NotEnough = 9,
  OldVersion = 10,
  UserNotExist = 11,
  UserNotAdmin = 12,
  Refuse = 13,
  AlreadyExist = 14,
  TempUnavailable = 31,
  TokenInvalid = 32,
  PasswordInvalid = 33,
  LoginFailed = 34,
  BindTokenVerifyError = 35,
  YYBindTokenVerifyError = 36,
  NotLogin = 37,
  UserNickTooLong = 49,
  UserNickTooShort = 50,
  AccountBindTypeInvalid = 64,
  MobilePhoneInvalid = 65,
  MobilePhoneBoundWithOtherUser = 66,
  MobilePhoneBindSendSmsError = 67,
  MobilePhoneBindIdentifyingCodeError = 68,
  MobilePhoneBindIdentifyingCodeExpired = 69,
  ThirdPartyUidBoundWithOtherUser = 70,
  ThirdPartyBindUidHasBound = 71,
  GroupPasswordRequired = 80,
  GroupPasswordError = 81,
  GroupNotExist = 82,
  GroupRolerClosed = 83,
  GroupRolerOccupied = 84,
  GroupApplyApproved = 85,
  NotGroupMember = 86,
  PayGateError = 513,
  PaySignError = 514,
  PayTicketRepeat = 515,
  PayNeedAuth = 516,
  StockNotEnough = 769,
  NotInTradeTime = 770,
  UserLevelNotEnough = 771,
  UserMoneyNotEnough = 772,
  UserBankInfoNotExist = 773,
  UserWithdrawLimit = 774,
  NoPresentCode = 1024,
  RepeatePickPresentCode = 1025,
  PresentDistributionError = 1026,
  WebSessionNotFound = 8193,
  WebSessionError = 8194,
  WebSessionRecvError = 8195,
  WebSessionSendError = 8196,
  WebSessionJsonParseError = 8197,
  WebSessionJsonPacketError = 8198
};
bool ErrCode_IsValid(int value);
const ErrCode ErrCode_MIN = Success;
const ErrCode ErrCode_MAX = WebSessionJsonPacketError;
const int ErrCode_ARRAYSIZE = ErrCode_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrCode_descriptor();
inline const ::std::string& ErrCode_Name(ErrCode value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrCode_descriptor(), value);
}
inline bool ErrCode_Parse(
    const ::std::string& name, ErrCode* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrCode>(
    ErrCode_descriptor(), name, value);
}
enum SPGame {
  PUserGameListReq = 1,
  PUserGameListRes = 2,
  PUserGameListReportReq = 3,
  PUserGameListReportRes = 4,
  PUserGameRunReportReq = 5,
  PUserGameRunReportRes = 6,
  PGameAddReq = 13,
  PGameAddRes = 14,
  PGameModifyReq = 15,
  PGameModifyRes = 16,
  PGameRemoveReq = 17,
  PGameRemoveRes = 18,
  PGameSearchReq = 25,
  PGameSearchRes = 26,
  PModifyGroupGameReq = 27,
  PModifyGroupGameRes = 28,
  PGameDiscountListReq = 32,
  PGameDiscountListRes = 33,
  PModifyGroupGameApkurlReq = 34,
  PModifyGroupGameApkurlRes = 35,
  PSendInstallGameMsgReq = 48,
  PSendInstallGameMsgRes = 49,
  PModifyOurGameStateReq = 64,
  PModifyOurGameStateRes = 65,
  PSearchGamesListReq = 66,
  PSearchGamesListRes = 67,
  PGameCountReq = 80,
  PGameCountRes = 81,
  PRecommendPackNameReq = 82,
  PRecommendPackNameRes = 83,
  PGameFilterSearchReq = 84,
  PGameFilterSearchRes = 85,
  PModifyGameFilterReq = 86,
  PModifyGameFilterRes = 87,
  PGameSpiderReq = 88,
  PGameSpiderRes = 89,
  PModifyGameDiscountReq = 90,
  PModifyGameDiscountRes = 91,
  PModifyGroupDiscountReq = 92,
  PModifyGroupDiscountRes = 93,
  PGroupDiscountListReq = 94,
  PGroupDiscountListRes = 95
};
bool SPGame_IsValid(int value);
const SPGame SPGame_MIN = PUserGameListReq;
const SPGame SPGame_MAX = PGroupDiscountListRes;
const int SPGame_ARRAYSIZE = SPGame_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPGame_descriptor();
inline const ::std::string& SPGame_Name(SPGame value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPGame_descriptor(), value);
}
inline bool SPGame_Parse(
    const ::std::string& name, SPGame* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPGame>(
    SPGame_descriptor(), name, value);
}
enum GameRunReportType {
  GameRunReportType_InstallGame = 1,
  GameRunReportType_StartGame = 2
};
bool GameRunReportType_IsValid(int value);
const GameRunReportType GameRunReportType_MIN = GameRunReportType_InstallGame;
const GameRunReportType GameRunReportType_MAX = GameRunReportType_StartGame;
const int GameRunReportType_ARRAYSIZE = GameRunReportType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameRunReportType_descriptor();
inline const ::std::string& GameRunReportType_Name(GameRunReportType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameRunReportType_descriptor(), value);
}
inline bool GameRunReportType_Parse(
    const ::std::string& name, GameRunReportType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameRunReportType>(
    GameRunReportType_descriptor(), name, value);
}
enum GameSearchSortBy {
  GameSortById = 0,
  GameSortByUserCount = 1,
  GameSortByHot = 2
};
bool GameSearchSortBy_IsValid(int value);
const GameSearchSortBy GameSearchSortBy_MIN = GameSortById;
const GameSearchSortBy GameSearchSortBy_MAX = GameSortByHot;
const int GameSearchSortBy_ARRAYSIZE = GameSearchSortBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameSearchSortBy_descriptor();
inline const ::std::string& GameSearchSortBy_Name(GameSearchSortBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameSearchSortBy_descriptor(), value);
}
inline bool GameSearchSortBy_Parse(
    const ::std::string& name, GameSearchSortBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameSearchSortBy>(
    GameSearchSortBy_descriptor(), name, value);
}
enum GameSearchFilter {
  UnknownFilter = 0,
  KeywordFilter = 1,
  GameIdFilter = 2,
  RecommendFilter = 3,
  GroupIdFilter = 4,
  OurGamesFilter = 5,
  DiscountGames = 6
};
bool GameSearchFilter_IsValid(int value);
const GameSearchFilter GameSearchFilter_MIN = UnknownFilter;
const GameSearchFilter GameSearchFilter_MAX = DiscountGames;
const int GameSearchFilter_ARRAYSIZE = GameSearchFilter_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameSearchFilter_descriptor();
inline const ::std::string& GameSearchFilter_Name(GameSearchFilter value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameSearchFilter_descriptor(), value);
}
inline bool GameSearchFilter_Parse(
    const ::std::string& name, GameSearchFilter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameSearchFilter>(
    GameSearchFilter_descriptor(), name, value);
}
enum SendMsgType {
  SendMsgTypeAll = 0,
  SendMsgTypeUids = 1
};
bool SendMsgType_IsValid(int value);
const SendMsgType SendMsgType_MIN = SendMsgTypeAll;
const SendMsgType SendMsgType_MAX = SendMsgTypeUids;
const int SendMsgType_ARRAYSIZE = SendMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SendMsgType_descriptor();
inline const ::std::string& SendMsgType_Name(SendMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SendMsgType_descriptor(), value);
}
inline bool SendMsgType_Parse(
    const ::std::string& name, SendMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SendMsgType>(
    SendMsgType_descriptor(), name, value);
}
enum GameLibType {
  GameLibOur = 0,
  GameLibCommon = 1,
  GameLibGlobal = 2,
  GameLibQQUrl = 3,
  GameLibWdjUrl = 4
};
bool GameLibType_IsValid(int value);
const GameLibType GameLibType_MIN = GameLibOur;
const GameLibType GameLibType_MAX = GameLibWdjUrl;
const int GameLibType_ARRAYSIZE = GameLibType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameLibType_descriptor();
inline const ::std::string& GameLibType_Name(GameLibType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameLibType_descriptor(), value);
}
inline bool GameLibType_Parse(
    const ::std::string& name, GameLibType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameLibType>(
    GameLibType_descriptor(), name, value);
}
enum ModifyGameOpType {
  Add = 0,
  Remove = 1,
  Modify = 2
};
bool ModifyGameOpType_IsValid(int value);
const ModifyGameOpType ModifyGameOpType_MIN = Add;
const ModifyGameOpType ModifyGameOpType_MAX = Modify;
const int ModifyGameOpType_ARRAYSIZE = ModifyGameOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ModifyGameOpType_descriptor();
inline const ::std::string& ModifyGameOpType_Name(ModifyGameOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ModifyGameOpType_descriptor(), value);
}
inline bool ModifyGameOpType_Parse(
    const ::std::string& name, ModifyGameOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ModifyGameOpType>(
    ModifyGameOpType_descriptor(), name, value);
}
enum GameFilterType {
  GameFilterAll = 0,
  GameFilterKeyword = 1
};
bool GameFilterType_IsValid(int value);
const GameFilterType GameFilterType_MIN = GameFilterAll;
const GameFilterType GameFilterType_MAX = GameFilterKeyword;
const int GameFilterType_ARRAYSIZE = GameFilterType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameFilterType_descriptor();
inline const ::std::string& GameFilterType_Name(GameFilterType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameFilterType_descriptor(), value);
}
inline bool GameFilterType_Parse(
    const ::std::string& name, GameFilterType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameFilterType>(
    GameFilterType_descriptor(), name, value);
}
enum SpiderSrcFliter {
  SpiderSrc_wdj = 1,
  SpiderSrc_qq = 2,
  SpiderSrc_lib = 3,
  SpiderSrc_libext = 4
};
bool SpiderSrcFliter_IsValid(int value);
const SpiderSrcFliter SpiderSrcFliter_MIN = SpiderSrc_wdj;
const SpiderSrcFliter SpiderSrcFliter_MAX = SpiderSrc_libext;
const int SpiderSrcFliter_ARRAYSIZE = SpiderSrcFliter_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpiderSrcFliter_descriptor();
inline const ::std::string& SpiderSrcFliter_Name(SpiderSrcFliter value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpiderSrcFliter_descriptor(), value);
}
inline bool SpiderSrcFliter_Parse(
    const ::std::string& name, SpiderSrcFliter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpiderSrcFliter>(
    SpiderSrcFliter_descriptor(), name, value);
}
enum SpiderMethodFilter {
  SpiderMethod_import = 1,
  SpiderMethod_search = 2,
  SpiderMethod_update = 3,
  SpiderMethod_detect = 4
};
bool SpiderMethodFilter_IsValid(int value);
const SpiderMethodFilter SpiderMethodFilter_MIN = SpiderMethod_import;
const SpiderMethodFilter SpiderMethodFilter_MAX = SpiderMethod_detect;
const int SpiderMethodFilter_ARRAYSIZE = SpiderMethodFilter_MAX + 1;

const ::google::protobuf::EnumDescriptor* SpiderMethodFilter_descriptor();
inline const ::std::string& SpiderMethodFilter_Name(SpiderMethodFilter value) {
  return ::google::protobuf::internal::NameOfEnum(
    SpiderMethodFilter_descriptor(), value);
}
inline bool SpiderMethodFilter_Parse(
    const ::std::string& name, SpiderMethodFilter* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SpiderMethodFilter>(
    SpiderMethodFilter_descriptor(), name, value);
}
enum SPGoldCoin {
  PUserYYCoinsPayMethodReq = 1,
  PUserYYCoinsPayMethodRes = 2,
  PUserYYCoinsShopListReq = 5,
  PUserYYCoinsShopListRes = 6,
  PUserYYCoinsQueryReq = 9,
  PUserYYCoinsQueryRes = 10,
  PUserYYCoinsBuyReq = 17,
  PUserYYCoinsBuyRes = 18,
  PUserYYCoinsBuyFeedbackReq = 19,
  PUserYYCoinsBuyFeedbackRes = 20,
  PUserYYCoinsHistoryReq = 21,
  PUserYYCoinsHistoryRes = 22,
  PUserYYCoinsPayGateCallbackReq = 23,
  PUserYYCoinsPayGateCallbackRes = 24
};
bool SPGoldCoin_IsValid(int value);
const SPGoldCoin SPGoldCoin_MIN = PUserYYCoinsPayMethodReq;
const SPGoldCoin SPGoldCoin_MAX = PUserYYCoinsPayGateCallbackRes;
const int SPGoldCoin_ARRAYSIZE = SPGoldCoin_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPGoldCoin_descriptor();
inline const ::std::string& SPGoldCoin_Name(SPGoldCoin value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPGoldCoin_descriptor(), value);
}
inline bool SPGoldCoin_Parse(
    const ::std::string& name, SPGoldCoin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPGoldCoin>(
    SPGoldCoin_descriptor(), name, value);
}
enum UserYYCoinsOrderState {
  OrderStateNone = 0,
  OrderStateClosed = 1,
  OrderStatePayWait = 2,
  OrderStatePaySuccess = 3
};
bool UserYYCoinsOrderState_IsValid(int value);
const UserYYCoinsOrderState UserYYCoinsOrderState_MIN = OrderStateNone;
const UserYYCoinsOrderState UserYYCoinsOrderState_MAX = OrderStatePaySuccess;
const int UserYYCoinsOrderState_ARRAYSIZE = UserYYCoinsOrderState_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserYYCoinsOrderState_descriptor();
inline const ::std::string& UserYYCoinsOrderState_Name(UserYYCoinsOrderState value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserYYCoinsOrderState_descriptor(), value);
}
inline bool UserYYCoinsOrderState_Parse(
    const ::std::string& name, UserYYCoinsOrderState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserYYCoinsOrderState>(
    UserYYCoinsOrderState_descriptor(), name, value);
}
enum SPGroup {
  PGroupCreateReq = 0,
  PGroupCreateRes = 1,
  PGroupApplyReq = 2,
  PGroupApplyRes = 3,
  PGroupCheckinReq = 4,
  PGroupCheckinRes = 5,
  PGroupQuitReq = 6,
  PGroupQuitRes = 7,
  PGroupInfoReq = 8,
  PGroupInfoRes = 9,
  PGroupInfoModifyReq = 10,
  PGroupInfoModifyRes = 11,
  PGroupSearchReq = 12,
  PGroupSearchRes = 13,
  PGroupSearchKeywordsReq = 14,
  PGroupSearchKeywordsRes = 15,
  PGroupListReq = 16,
  PGroupListRes = 17,
  PGroupDestroyReq = 28,
  PGroupDestroyRes = 29,
  PGroupOwnerTransferReq = 30,
  PGroupOwnerTransferRes = 31,
  PGroupApproveReq = 32,
  PGroupApproveRes = 33,
  PGroupLobbyOrderModifyReq = 54,
  PGroupLobbyOrderModifyRes = 55,
  PGroupJoinedListReq = 58,
  PGroupJoinedListRes = 59,
  PTopicListReq = 64,
  PTopicListRes = 65,
  PGroupTagCreateReq = 66,
  PGroupTagCreateRes = 67,
  PGroupTagModifyReq = 68,
  PGroupTagModifyRes = 69,
  PGroupTagListReq = 70,
  PGroupTagListRes = 71,
  PGroupPropReq = 80,
  PGroupPropRes = 81,
  PFamilyStatReq = 82,
  PFamilyStatRes = 83,
  PFamilyGroupSetReq = 84,
  PFamilyGroupSetRes = 85,
  PShowGameStartReq = 101,
  PShowGameStartRes = 102,
  PGroupTeamOpReq = 103,
  PGroupTeamOpRes = 104,
  PGroupLabelOpReq = 105,
  PGroupLabelOpRes = 106
};
bool SPGroup_IsValid(int value);
const SPGroup SPGroup_MIN = PGroupCreateReq;
const SPGroup SPGroup_MAX = PGroupLabelOpRes;
const int SPGroup_ARRAYSIZE = SPGroup_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPGroup_descriptor();
inline const ::std::string& SPGroup_Name(SPGroup value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPGroup_descriptor(), value);
}
inline bool SPGroup_Parse(
    const ::std::string& name, SPGroup* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPGroup>(
    SPGroup_descriptor(), name, value);
}
enum GroupType {
  Group_Unknown = 0,
  Group_Guild = 1,
  Group_Team = 2,
  Group_Lobby = 3,
  Group_Public = 4,
  Group_Video = 5
};
bool GroupType_IsValid(int value);
const GroupType GroupType_MIN = Group_Unknown;
const GroupType GroupType_MAX = Group_Video;
const int GroupType_ARRAYSIZE = GroupType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupType_descriptor();
inline const ::std::string& GroupType_Name(GroupType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupType_descriptor(), value);
}
inline bool GroupType_Parse(
    const ::std::string& name, GroupType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupType>(
    GroupType_descriptor(), name, value);
}
enum GroupState {
  GroupState_Unknown = 0,
  GroupState_OK = 1,
  GroupState_Destroy = 2,
  GroupState_Freeze = 3
};
bool GroupState_IsValid(int value);
const GroupState GroupState_MIN = GroupState_Unknown;
const GroupState GroupState_MAX = GroupState_Freeze;
const int GroupState_ARRAYSIZE = GroupState_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupState_descriptor();
inline const ::std::string& GroupState_Name(GroupState value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupState_descriptor(), value);
}
inline bool GroupState_Parse(
    const ::std::string& name, GroupState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupState>(
    GroupState_descriptor(), name, value);
}
enum GroupRolerStateType {
  GroupRolerStateClosed = 0,
  GroupRolerStateOpen = 1
};
bool GroupRolerStateType_IsValid(int value);
const GroupRolerStateType GroupRolerStateType_MIN = GroupRolerStateClosed;
const GroupRolerStateType GroupRolerStateType_MAX = GroupRolerStateOpen;
const int GroupRolerStateType_ARRAYSIZE = GroupRolerStateType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupRolerStateType_descriptor();
inline const ::std::string& GroupRolerStateType_Name(GroupRolerStateType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupRolerStateType_descriptor(), value);
}
inline bool GroupRolerStateType_Parse(
    const ::std::string& name, GroupRolerStateType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupRolerStateType>(
    GroupRolerStateType_descriptor(), name, value);
}
enum GroupApprove {
  Needless = 0,
  NeedApprove = 1,
  RefuseAnybody = 2,
  Password = 3,
  RefuseUpgrade = 5
};
bool GroupApprove_IsValid(int value);
const GroupApprove GroupApprove_MIN = Needless;
const GroupApprove GroupApprove_MAX = RefuseUpgrade;
const int GroupApprove_ARRAYSIZE = GroupApprove_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupApprove_descriptor();
inline const ::std::string& GroupApprove_Name(GroupApprove value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupApprove_descriptor(), value);
}
inline bool GroupApprove_Parse(
    const ::std::string& name, GroupApprove* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupApprove>(
    GroupApprove_descriptor(), name, value);
}
enum GroupModeType {
  GroupModeNone = 0,
  GroupModeContinous = 1,
  GroupModeWelcome = 2,
  GroupModeFree = 3,
  GroupModeVideo = 4,
  GroupModeAudio = 5
};
bool GroupModeType_IsValid(int value);
const GroupModeType GroupModeType_MIN = GroupModeNone;
const GroupModeType GroupModeType_MAX = GroupModeAudio;
const int GroupModeType_ARRAYSIZE = GroupModeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupModeType_descriptor();
inline const ::std::string& GroupModeType_Name(GroupModeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupModeType_descriptor(), value);
}
inline bool GroupModeType_Parse(
    const ::std::string& name, GroupModeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupModeType>(
    GroupModeType_descriptor(), name, value);
}
enum GroupSearchBy {
  GroupSearchByUnknown = 0,
  GroupSearchByKeyword = 1,
  GroupSearchByDGid = 2,
  GroupSearchByLobbyHot = 3,
  GroupSearchByGuild = 4,
  GroupSearchByGuildTeam = 5,
  GroupSearchByGuildLobby = 6,
  GroupSearchByGuildRecommend = 7,
  GroupSearchByGameDiscount = 8,
  GroupSearchByGameGift = 9,
  GroupSearchByVideoHot = 10,
  GroupSearchByChannelSid = 11,
    
  GroupSearchByHotType = 12
};
bool GroupSearchBy_IsValid(int value);
const GroupSearchBy GroupSearchBy_MIN = GroupSearchByUnknown;
const GroupSearchBy GroupSearchBy_MAX = GroupSearchByHotType;
const int GroupSearchBy_ARRAYSIZE = GroupSearchBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupSearchBy_descriptor();
inline const ::std::string& GroupSearchBy_Name(GroupSearchBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupSearchBy_descriptor(), value);
}
inline bool GroupSearchBy_Parse(
    const ::std::string& name, GroupSearchBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupSearchBy>(
    GroupSearchBy_descriptor(), name, value);
}
enum GroupSearchOrderBy {
  GroupSearchOrderByDesc = 0,
  GroupSearchOrderByAsc = 1
};
bool GroupSearchOrderBy_IsValid(int value);
const GroupSearchOrderBy GroupSearchOrderBy_MIN = GroupSearchOrderByDesc;
const GroupSearchOrderBy GroupSearchOrderBy_MAX = GroupSearchOrderByAsc;
const int GroupSearchOrderBy_ARRAYSIZE = GroupSearchOrderBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupSearchOrderBy_descriptor();
inline const ::std::string& GroupSearchOrderBy_Name(GroupSearchOrderBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupSearchOrderBy_descriptor(), value);
}
inline bool GroupSearchOrderBy_Parse(
    const ::std::string& name, GroupSearchOrderBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupSearchOrderBy>(
    GroupSearchOrderBy_descriptor(), name, value);
}
enum GroupIncrementType {
  GroupNone = 0,
  GroupCreate = 1,
  GroupApplyPassed = 2,
  GroupDestroyed = 3,
  GroupKick = 4,
  GroupQuit = 5,
  GroupRolerUpdate = 6,
  GroupJoined = 7
};
bool GroupIncrementType_IsValid(int value);
const GroupIncrementType GroupIncrementType_MIN = GroupNone;
const GroupIncrementType GroupIncrementType_MAX = GroupJoined;
const int GroupIncrementType_ARRAYSIZE = GroupIncrementType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupIncrementType_descriptor();
inline const ::std::string& GroupIncrementType_Name(GroupIncrementType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupIncrementType_descriptor(), value);
}
inline bool GroupIncrementType_Parse(
    const ::std::string& name, GroupIncrementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupIncrementType>(
    GroupIncrementType_descriptor(), name, value);
}
enum SPGroupApp {
  PGroupAppSendReq = 0,
  PGroupAppSendRes = 1,
  PGroupAppListReq = 2,
  PGroupAppListRes = 3,
  PGroupMsgAppReq = 4,
  PGroupMsgAppRes = 5
};
bool SPGroupApp_IsValid(int value);
const SPGroupApp SPGroupApp_MIN = PGroupAppSendReq;
const SPGroupApp SPGroupApp_MAX = PGroupMsgAppRes;
const int SPGroupApp_ARRAYSIZE = SPGroupApp_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPGroupApp_descriptor();
inline const ::std::string& SPGroupApp_Name(SPGroupApp value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPGroupApp_descriptor(), value);
}
inline bool SPGroupApp_Parse(
    const ::std::string& name, SPGroupApp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPGroupApp>(
    SPGroupApp_descriptor(), name, value);
}
enum GroupAppType {
  GroupAppTypeNone = 0,
  GroupAppTypeComment = 1,
  GroupAppTypeConsent = 2,
  GroupAppTypeDissent = 3,
  GroupAppTypeDestroy = 4,
  GroupAppTypeHit = 5,
  GroupAppTypeTop = 6
};
bool GroupAppType_IsValid(int value);
const GroupAppType GroupAppType_MIN = GroupAppTypeNone;
const GroupAppType GroupAppType_MAX = GroupAppTypeTop;
const int GroupAppType_ARRAYSIZE = GroupAppType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupAppType_descriptor();
inline const ::std::string& GroupAppType_Name(GroupAppType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupAppType_descriptor(), value);
}
inline bool GroupAppType_Parse(
    const ::std::string& name, GroupAppType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupAppType>(
    GroupAppType_descriptor(), name, value);
}
enum GroupAppOp {
  GroupAppOpAdd = 0,
  GroupAppOpDel = 1
};
bool GroupAppOp_IsValid(int value);
const GroupAppOp GroupAppOp_MIN = GroupAppOpAdd;
const GroupAppOp GroupAppOp_MAX = GroupAppOpDel;
const int GroupAppOp_ARRAYSIZE = GroupAppOp_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupAppOp_descriptor();
inline const ::std::string& GroupAppOp_Name(GroupAppOp value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupAppOp_descriptor(), value);
}
inline bool GroupAppOp_Parse(
    const ::std::string& name, GroupAppOp* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupAppOp>(
    GroupAppOp_descriptor(), name, value);
}
enum SPGroupMember {
  PGroupMemberKickReq = 16,
  PGroupMemberKickRes = 17,
  PGroupMemberListReq = 32,
  PGroupMemberListRes = 33,
  PGroupMemberReq = 34,
  PGroupMemberRes = 35,
  PGroupMemberModifyReq = 36,
  PGroupMemberModifyRes = 37,
  PGroupMemberSearchReq = 38,
  PGroupMemberSearchRes = 39,
  PGroupMemberCountReq = 40,
  PGroupMemberCountRes = 41,
  PGroupMemberRolerListReq = 97,
  PGroupMemberRolerListRes = 98,
  PGroupMemberRolerSetReq = 99,
  PGroupMemberRolerSetRes = 100
};
bool SPGroupMember_IsValid(int value);
const SPGroupMember SPGroupMember_MIN = PGroupMemberKickReq;
const SPGroupMember SPGroupMember_MAX = PGroupMemberRolerSetRes;
const int SPGroupMember_ARRAYSIZE = SPGroupMember_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPGroupMember_descriptor();
inline const ::std::string& SPGroupMember_Name(SPGroupMember value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPGroupMember_descriptor(), value);
}
inline bool SPGroupMember_Parse(
    const ::std::string& name, SPGroupMember* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPGroupMember>(
    SPGroupMember_descriptor(), name, value);
}
enum GroupMemberRoler {
  GroupMemberRoler_None = 0,
  GroupMemberRoler_Guest = 10,
  GroupMemberRoler_Subscriber = 15,
  GroupMemberRoler_Member = 20,
  GroupMemberRoler_CheckinMember = 25,
  GroupMemberRoler_SeniorMember = 30,
  GroupMemberRoler_EilteMember = 35,
  GroupMemberRoler_EilteMemberX5 = 41,
  GroupMemberRoler_EilteMemberX4 = 42,
  GroupMemberRoler_EilteMemberX3 = 43,
  GroupMemberRoler_EilteMemberX2 = 44,
  GroupMemberRoler_EilteMemberX1 = 45,
  GroupMemberRoler_EilteMemberXX = 50,
  GroupMemberRoler_Manager = 60,
  GroupMemberRoler_Assistant = 70,
  GroupMemberRoler_Owner = 99
};
bool GroupMemberRoler_IsValid(int value);
const GroupMemberRoler GroupMemberRoler_MIN = GroupMemberRoler_None;
const GroupMemberRoler GroupMemberRoler_MAX = GroupMemberRoler_Owner;
const int GroupMemberRoler_ARRAYSIZE = GroupMemberRoler_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberRoler_descriptor();
inline const ::std::string& GroupMemberRoler_Name(GroupMemberRoler value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberRoler_descriptor(), value);
}
inline bool GroupMemberRoler_Parse(
    const ::std::string& name, GroupMemberRoler* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberRoler>(
    GroupMemberRoler_descriptor(), name, value);
}
enum GroupMemberState {
  GroupMemberStateNone = 0,
  GroupMemberStateActive = 1,
  GroupMemberStateDestroy = 3,
  GroupMemberStateKick = 4,
  GroupMemberStateQuit = 5
};
bool GroupMemberState_IsValid(int value);
const GroupMemberState GroupMemberState_MIN = GroupMemberStateNone;
const GroupMemberState GroupMemberState_MAX = GroupMemberStateQuit;
const int GroupMemberState_ARRAYSIZE = GroupMemberState_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberState_descriptor();
inline const ::std::string& GroupMemberState_Name(GroupMemberState value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberState_descriptor(), value);
}
inline bool GroupMemberState_Parse(
    const ::std::string& name, GroupMemberState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberState>(
    GroupMemberState_descriptor(), name, value);
}
enum GroupMemberIncrementType {
  GroupMemberNone = 0,
  GroupMemberAdd = 1,
  GroupMemberUpdate = 2,
  GroupMemberDestroy = 3,
  GroupMemberKick = 4,
  GroupMemberQuit = 5,
  GroupMemberRolerListUpdate = 6
};
bool GroupMemberIncrementType_IsValid(int value);
const GroupMemberIncrementType GroupMemberIncrementType_MIN = GroupMemberNone;
const GroupMemberIncrementType GroupMemberIncrementType_MAX = GroupMemberRolerListUpdate;
const int GroupMemberIncrementType_ARRAYSIZE = GroupMemberIncrementType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberIncrementType_descriptor();
inline const ::std::string& GroupMemberIncrementType_Name(GroupMemberIncrementType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberIncrementType_descriptor(), value);
}
inline bool GroupMemberIncrementType_Parse(
    const ::std::string& name, GroupMemberIncrementType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberIncrementType>(
    GroupMemberIncrementType_descriptor(), name, value);
}
enum GroupMemberSearchBy {
  GroupMemberSearchByAll = 0,
  GroupMemberSearchByKeyword = 1,
  GroupMemberSearchByCheckin = 3,
  GroupMemberSearchByGameidUninstall = 4
};
bool GroupMemberSearchBy_IsValid(int value);
const GroupMemberSearchBy GroupMemberSearchBy_MIN = GroupMemberSearchByAll;
const GroupMemberSearchBy GroupMemberSearchBy_MAX = GroupMemberSearchByGameidUninstall;
const int GroupMemberSearchBy_ARRAYSIZE = GroupMemberSearchBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberSearchBy_descriptor();
inline const ::std::string& GroupMemberSearchBy_Name(GroupMemberSearchBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberSearchBy_descriptor(), value);
}
inline bool GroupMemberSearchBy_Parse(
    const ::std::string& name, GroupMemberSearchBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberSearchBy>(
    GroupMemberSearchBy_descriptor(), name, value);
}
enum GroupMemberSortBy {
  GroupMemberSortByRoler = 1,
  GroupMemberSortByContribute = 2,
  GroupMemberSortByCheckinProgress = 3,
  GroupMemberSortByGuildRoler = 4,
  GroupMemberSortByCheckinTime = 5
};
bool GroupMemberSortBy_IsValid(int value);
const GroupMemberSortBy GroupMemberSortBy_MIN = GroupMemberSortByRoler;
const GroupMemberSortBy GroupMemberSortBy_MAX = GroupMemberSortByCheckinTime;
const int GroupMemberSortBy_ARRAYSIZE = GroupMemberSortBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberSortBy_descriptor();
inline const ::std::string& GroupMemberSortBy_Name(GroupMemberSortBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberSortBy_descriptor(), value);
}
inline bool GroupMemberSortBy_Parse(
    const ::std::string& name, GroupMemberSortBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberSortBy>(
    GroupMemberSortBy_descriptor(), name, value);
}
enum GroupMemberOrderBy {
  GroupMemberOrderByDesc = 0,
  GroupMemberOrderByAsc = 1
};
bool GroupMemberOrderBy_IsValid(int value);
const GroupMemberOrderBy GroupMemberOrderBy_MIN = GroupMemberOrderByDesc;
const GroupMemberOrderBy GroupMemberOrderBy_MAX = GroupMemberOrderByAsc;
const int GroupMemberOrderBy_ARRAYSIZE = GroupMemberOrderBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberOrderBy_descriptor();
inline const ::std::string& GroupMemberOrderBy_Name(GroupMemberOrderBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberOrderBy_descriptor(), value);
}
inline bool GroupMemberOrderBy_Parse(
    const ::std::string& name, GroupMemberOrderBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberOrderBy>(
    GroupMemberOrderBy_descriptor(), name, value);
}
enum GroupMemberCountType {
  GroupMemberCountAll = 0,
  GroupMemberCountCheckin = 1,
  GroupMemberGameidUninstall = 2
};
bool GroupMemberCountType_IsValid(int value);
const GroupMemberCountType GroupMemberCountType_MIN = GroupMemberCountAll;
const GroupMemberCountType GroupMemberCountType_MAX = GroupMemberGameidUninstall;
const int GroupMemberCountType_ARRAYSIZE = GroupMemberCountType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMemberCountType_descriptor();
inline const ::std::string& GroupMemberCountType_Name(GroupMemberCountType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMemberCountType_descriptor(), value);
}
inline bool GroupMemberCountType_Parse(
    const ::std::string& name, GroupMemberCountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMemberCountType>(
    GroupMemberCountType_descriptor(), name, value);
}
enum SPGroupMsg {
  PGroupMsgListReq = 0,
  PGroupMsgListRes = 1,
  PGroupMsgVoiceReq = 6,
  PGroupMsgVoiceRes = 7,
  PGroupMsgSendReq = 16,
  PGroupMsgSendRes = 17,
  PGroupMsgSearchReq = 18,
  PGroupMsgSearchRes = 19
};
bool SPGroupMsg_IsValid(int value);
const SPGroupMsg SPGroupMsg_MIN = PGroupMsgListReq;
const SPGroupMsg SPGroupMsg_MAX = PGroupMsgSearchRes;
const int SPGroupMsg_ARRAYSIZE = SPGroupMsg_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPGroupMsg_descriptor();
inline const ::std::string& SPGroupMsg_Name(SPGroupMsg value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPGroupMsg_descriptor(), value);
}
inline bool SPGroupMsg_Parse(
    const ::std::string& name, SPGroupMsg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPGroupMsg>(
    SPGroupMsg_descriptor(), name, value);
}
enum GroupMsgSortBy {
  GroupMsgSortByRevision = 0,
  GroupMsgSortByConsentCount = 1,
  GroupMsgSortByTopTime = 2
};
bool GroupMsgSortBy_IsValid(int value);
const GroupMsgSortBy GroupMsgSortBy_MIN = GroupMsgSortByRevision;
const GroupMsgSortBy GroupMsgSortBy_MAX = GroupMsgSortByTopTime;
const int GroupMsgSortBy_ARRAYSIZE = GroupMsgSortBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMsgSortBy_descriptor();
inline const ::std::string& GroupMsgSortBy_Name(GroupMsgSortBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMsgSortBy_descriptor(), value);
}
inline bool GroupMsgSortBy_Parse(
    const ::std::string& name, GroupMsgSortBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMsgSortBy>(
    GroupMsgSortBy_descriptor(), name, value);
}
enum GroupMsgOrderBy {
  GroupMsgOrderByDesc = 0,
  GroupMsgOrderByAsc = 1
};
bool GroupMsgOrderBy_IsValid(int value);
const GroupMsgOrderBy GroupMsgOrderBy_MIN = GroupMsgOrderByDesc;
const GroupMsgOrderBy GroupMsgOrderBy_MAX = GroupMsgOrderByAsc;
const int GroupMsgOrderBy_ARRAYSIZE = GroupMsgOrderBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMsgOrderBy_descriptor();
inline const ::std::string& GroupMsgOrderBy_Name(GroupMsgOrderBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMsgOrderBy_descriptor(), value);
}
inline bool GroupMsgOrderBy_Parse(
    const ::std::string& name, GroupMsgOrderBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMsgOrderBy>(
    GroupMsgOrderBy_descriptor(), name, value);
}
enum SPLogin {
  PUserLoginReq = 0,
  PUserLoginRes = 1,
  PUserActivateReq = 2,
  PUserActivateRes = 3,
  PUserHeartBeatReq = 4,
  PUserHeartBeatRes = 5,
  PAccountBindReq = 6,
  PAccountBindRes = 7,
  PUserWebLoginReq = 8,
  PUserWebLoginRes = 9,
  PSessionResumeReq = 16,
  PSessionResumeRes = 17,
  PSessionSuspendReq = 18,
  PUserTokenReq = 34,
  PUserTokenRes = 35,
  PUserTokenLoginedReq = 36,
  PUserTokenLoginedRes = 37,
  PUptokenReq = 48,
  PUptokenRes = 49,
  PUserPushTokenRegisterReq = 50,
  PUserPushTokenRegisterRes = 51,
  PUserLogoutReq = 52,
  PUserLogoutRes = 53,
  PCpsWebLoginReq = 64,
  PCpsWebLoginRes = 65,
  PCpsAccountBindReq = 66,
  PCpsAccountBindRes = 67
};
bool SPLogin_IsValid(int value);
const SPLogin SPLogin_MIN = PUserLoginReq;
const SPLogin SPLogin_MAX = PCpsAccountBindRes;
const int SPLogin_ARRAYSIZE = SPLogin_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPLogin_descriptor();
inline const ::std::string& SPLogin_Name(SPLogin value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPLogin_descriptor(), value);
}
inline bool SPLogin_Parse(
    const ::std::string& name, SPLogin* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPLogin>(
    SPLogin_descriptor(), name, value);
}
enum ProtoVersion {
  ProtoVersion_None = 0,
  ProtoVersion_Current = 1
};
bool ProtoVersion_IsValid(int value);
const ProtoVersion ProtoVersion_MIN = ProtoVersion_None;
const ProtoVersion ProtoVersion_MAX = ProtoVersion_Current;
const int ProtoVersion_ARRAYSIZE = ProtoVersion_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProtoVersion_descriptor();
inline const ::std::string& ProtoVersion_Name(ProtoVersion value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProtoVersion_descriptor(), value);
}
inline bool ProtoVersion_Parse(
    const ::std::string& name, ProtoVersion* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProtoVersion>(
    ProtoVersion_descriptor(), name, value);
}
enum DevType {
  DevType_Unknown = 0,
  DevType_Android = 1,
  DevType_Ios = 2,
  DevType_Pc = 3,
  DevType_Web = 4,
  DevType_Sdk = 5
};
bool DevType_IsValid(int value);
const DevType DevType_MIN = DevType_Unknown;
const DevType DevType_MAX = DevType_Sdk;
const int DevType_ARRAYSIZE = DevType_MAX + 1;

const ::google::protobuf::EnumDescriptor* DevType_descriptor();
inline const ::std::string& DevType_Name(DevType value) {
  return ::google::protobuf::internal::NameOfEnum(
    DevType_descriptor(), value);
}
inline bool DevType_Parse(
    const ::std::string& name, DevType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DevType>(
    DevType_descriptor(), name, value);
}
enum GroupMsgType {
  GroupMsgNormal = 0,
  GroupMsgBroadcast = 1,
  GroupDestroy = 2,
  GroupInfoUpdate = 3,
  GroupTopicCreate = 4,
  GroupMsgNotice = 5,
  GroupMemberNotice = 6,
  GroupGameDownloadUrl = 7,
  GroupConsentNotice = 8,
  GroupGiftNotice = 9,
  GroupShowTopMessage = 10,
  GroupShowLike = 11,
  GroupShowGiftDonate = 12,
  GroupRolerNotice = 13,
  GroupHallShare = 14,
  GroupFamilyDynamic = 15,
  GroupEventNotice = 16,
  GroupNoticeChange = 17
};
bool GroupMsgType_IsValid(int value);
const GroupMsgType GroupMsgType_MIN = GroupMsgNormal;
const GroupMsgType GroupMsgType_MAX = GroupNoticeChange;
const int GroupMsgType_ARRAYSIZE = GroupMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupMsgType_descriptor();
inline const ::std::string& GroupMsgType_Name(GroupMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupMsgType_descriptor(), value);
}
inline bool GroupMsgType_Parse(
    const ::std::string& name, GroupMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupMsgType>(
    GroupMsgType_descriptor(), name, value);
}
enum MessageImageType {
  MessageImageTypeImage = 0,
  MessageImageTypeGif = 1
};
bool MessageImageType_IsValid(int value);
const MessageImageType MessageImageType_MIN = MessageImageTypeImage;
const MessageImageType MessageImageType_MAX = MessageImageTypeGif;
const int MessageImageType_ARRAYSIZE = MessageImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageImageType_descriptor();
inline const ::std::string& MessageImageType_Name(MessageImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageImageType_descriptor(), value);
}
inline bool MessageImageType_Parse(
    const ::std::string& name, MessageImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageImageType>(
    MessageImageType_descriptor(), name, value);
}
enum MessageEventType {
  MessageEventTypeNone = 0,
  MessageEventTypeContactFollow = 1,
  MessageEventTypeContactDelete = 2,
  MessageEventTypeWatchedMe = 3,
  MessageEventTypeLikedMe = 4,
  MessageEventTypeGiftDonate = 5,
  MessageEventTypeRedPacketRefresh = 6,
  MessageEventTypeRedPacketNotice = 7,
  MessageEventTypeGiftDonateNotice = 8,
  MessageEventTypeDynamic = 9,
  MessageEventTypeGroupEffect = 10,
  MessageEventTypeGiftStamp = 11,
  MessageEventTypePlayDice = 12,
  MessageEventTypeGroupModeChange = 13,
  MessageEventTypeGroupRolerChange = 14,
  MessageEventTypeGroupRolerStateChange = 15,
  MessageEventTypeGroupNoticeChange = 16
};
bool MessageEventType_IsValid(int value);
const MessageEventType MessageEventType_MIN = MessageEventTypeNone;
const MessageEventType MessageEventType_MAX = MessageEventTypeGroupNoticeChange;
const int MessageEventType_ARRAYSIZE = MessageEventType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageEventType_descriptor();
inline const ::std::string& MessageEventType_Name(MessageEventType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageEventType_descriptor(), value);
}
inline bool MessageEventType_Parse(
    const ::std::string& name, MessageEventType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageEventType>(
    MessageEventType_descriptor(), name, value);
}
enum MessageContentType {
  MessageContentTypeTxt = 0,
  MessageContentTypeImg = 1,
  MessageContentTypeVoice = 2,
  MessageContentTypeVideo = 3,
  MessageContentTypePubMsg = 4,
  MessageContentTypeHidden = 6,
  MessageContentTypeHtml = 7,
  MessageContentTypeAd = 8,
  MessageContentTypeActivity = 9,
  MessageContentTypeGroupNotice = 11,
  MessageContentTypeUserApply = 12,
  MessageContentTypeGroupApply = 13,
  MessageContentTypeUserTask = 14,
  MessageContentTypeUserLevelUpgrade = 15
};
bool MessageContentType_IsValid(int value);
const MessageContentType MessageContentType_MIN = MessageContentTypeTxt;
const MessageContentType MessageContentType_MAX = MessageContentTypeUserLevelUpgrade;
const int MessageContentType_ARRAYSIZE = MessageContentType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageContentType_descriptor();
inline const ::std::string& MessageContentType_Name(MessageContentType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageContentType_descriptor(), value);
}
inline bool MessageContentType_Parse(
    const ::std::string& name, MessageContentType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageContentType>(
    MessageContentType_descriptor(), name, value);
}
enum SPPresent {
  PPresentInfoReq = 1,
  PPresentInfoRes = 2,
  PPresentAddReq = 3,
  PPresentAddRes = 4,
  PGetPresentsByGameIdReq = 5,
  PGetPresentsByGameIdRes = 6,
  PPresentListReq = 7,
  PPresentListRes = 8,
  PPresentCountReq = 9,
  PPresentCountRes = 10,
  PPresentGroupListReq = 11,
  PPresentGroupListRes = 12,
  PPresentUserTakeReq = 13,
  PPresentUserTakeRes = 14,
  PPresentModifyReq = 17,
  PPresentModifyRes = 18,
  PUserPresentReq = 32,
  PUserPresentRes = 33,
  PUserPresentListReq = 34,
  PUserPresentListRes = 35,
  PGroupPresentOpReq = 36,
  PGroupPresentOpRes = 37,
  PGroupPresentListReq = 38,
  PGroupPresentListRes = 39,
  PPresentUserListReq = 40,
  PPresentUserListRes = 41
};
bool SPPresent_IsValid(int value);
const SPPresent SPPresent_MIN = PPresentInfoReq;
const SPPresent SPPresent_MAX = PPresentUserListRes;
const int SPPresent_ARRAYSIZE = SPPresent_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPPresent_descriptor();
inline const ::std::string& SPPresent_Name(SPPresent value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPPresent_descriptor(), value);
}
inline bool SPPresent_Parse(
    const ::std::string& name, SPPresent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPPresent>(
    SPPresent_descriptor(), name, value);
}
enum GroupPresentApplyType {
  GroupPresentApplyType_User = 0,
  GroupPresentApplyType_Config = 1
};
bool GroupPresentApplyType_IsValid(int value);
const GroupPresentApplyType GroupPresentApplyType_MIN = GroupPresentApplyType_User;
const GroupPresentApplyType GroupPresentApplyType_MAX = GroupPresentApplyType_Config;
const int GroupPresentApplyType_ARRAYSIZE = GroupPresentApplyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GroupPresentApplyType_descriptor();
inline const ::std::string& GroupPresentApplyType_Name(GroupPresentApplyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GroupPresentApplyType_descriptor(), value);
}
inline bool GroupPresentApplyType_Parse(
    const ::std::string& name, GroupPresentApplyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GroupPresentApplyType>(
    GroupPresentApplyType_descriptor(), name, value);
}
enum SPPush {
  PPushPack = 0,
  PForceLogout = 1
};
bool SPPush_IsValid(int value);
const SPPush SPPush_MIN = PPushPack;
const SPPush SPPush_MAX = PForceLogout;
const int SPPush_ARRAYSIZE = SPPush_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPPush_descriptor();
inline const ::std::string& SPPush_Name(SPPush value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPPush_descriptor(), value);
}
inline bool SPPush_Parse(
    const ::std::string& name, SPPush* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPPush>(
    SPPush_descriptor(), name, value);
}
enum MsgPushType {
  PPushContactUpdate = 1,
  PPushUserMsgUpdate = 2,
  PPushGroupListUpdate = 4,
  PPushGroupMemberUpdate = 16,
  PPushGroupMsgUpdate = 32,
  PPushGroupAppUpdate = 128,
  PPushWebSessionUpdate = 4096,
  PPushGroupRealTimeMsg = 8192,
  PPushUserRealTimeMsg = 16384,
  PPushGroupInfoUpdateRealTime = 16640,
  PPushLogUpdate = 32768
};
bool MsgPushType_IsValid(int value);
const MsgPushType MsgPushType_MIN = PPushContactUpdate;
const MsgPushType MsgPushType_MAX = PPushLogUpdate;
const int MsgPushType_ARRAYSIZE = MsgPushType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MsgPushType_descriptor();
inline const ::std::string& MsgPushType_Name(MsgPushType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MsgPushType_descriptor(), value);
}
inline bool MsgPushType_Parse(
    const ::std::string& name, MsgPushType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MsgPushType>(
    MsgPushType_descriptor(), name, value);
}
enum SPRedPacket {
  PRedPacketAddReq = 1,
  PRedPacketAddRes = 2,
  PRedPacketTakeReq = 3,
  PRedPacketTakeRes = 4,
  PShowRedPacketListReq = 11,
  PShowRedPacketListRes = 12,
  PUserRedPacketStatReq = 13,
  PUserRedPacketStatRes = 14,
  PRedPacketRankListReq = 21,
  PRedPacketRankListRes = 22,
  PBlessGiftListReq = 31,
  PBlessGiftListRes = 32,
  PBlessGiftExchangeReq = 33,
  PBlessGiftExchangeRes = 34
};
bool SPRedPacket_IsValid(int value);
const SPRedPacket SPRedPacket_MIN = PRedPacketAddReq;
const SPRedPacket SPRedPacket_MAX = PBlessGiftExchangeRes;
const int SPRedPacket_ARRAYSIZE = SPRedPacket_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPRedPacket_descriptor();
inline const ::std::string& SPRedPacket_Name(SPRedPacket value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPRedPacket_descriptor(), value);
}
inline bool SPRedPacket_Parse(
    const ::std::string& name, SPRedPacket* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPRedPacket>(
    SPRedPacket_descriptor(), name, value);
}
enum SPReport {
  PReportViolatorReq = 1,
  PReportViolatorRes = 2,
  PReportLogReq = 3,
  PReportLogRes = 4
};
bool SPReport_IsValid(int value);
const SPReport SPReport_MIN = PReportViolatorReq;
const SPReport SPReport_MAX = PReportLogRes;
const int SPReport_ARRAYSIZE = SPReport_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPReport_descriptor();
inline const ::std::string& SPReport_Name(SPReport value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPReport_descriptor(), value);
}
inline bool SPReport_Parse(
    const ::std::string& name, SPReport* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPReport>(
    SPReport_descriptor(), name, value);
}
enum SPShop {
  PYYGiftListReq = 0,
  PYYGiftListRes = 1,
  PYYGiftDonateReq = 2,
  PYYGiftDonateRes = 3,
  PYYGiftPayConfirmReq = 4,
  PYYGiftPayConfirmRes = 5,
  PProductListReq = 17,
  PProductListRes = 18,
  PProductOpReq = 19,
  PProductOpRes = 20,
  PProductBuyReq = 21,
  PProductBuyRes = 22,
  PUserWithdrawReq = 25,
  PUserWithdrawRes = 26,
  PUserMoneyStatReq = 32,
  PUserMoneyStatRes = 33,
  PUserBankInfoOpReq = 34,
  PUserBankInfoOpRes = 35,
  PBankListReq = 36,
  PBankListRes = 37
};
bool SPShop_IsValid(int value);
const SPShop SPShop_MIN = PYYGiftListReq;
const SPShop SPShop_MAX = PBankListRes;
const int SPShop_ARRAYSIZE = SPShop_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPShop_descriptor();
inline const ::std::string& SPShop_Name(SPShop value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPShop_descriptor(), value);
}
inline bool SPShop_Parse(
    const ::std::string& name, SPShop* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPShop>(
    SPShop_descriptor(), name, value);
}
enum YYGiftPayConfirmOpType {
  YYGiftPayConfirmOpType_Agree = 1,
  YYGiftPayConfirmOpType_Remember = 2,
  YYGiftPayConfirmOpType_Disagree = 3
};
bool YYGiftPayConfirmOpType_IsValid(int value);
const YYGiftPayConfirmOpType YYGiftPayConfirmOpType_MIN = YYGiftPayConfirmOpType_Agree;
const YYGiftPayConfirmOpType YYGiftPayConfirmOpType_MAX = YYGiftPayConfirmOpType_Disagree;
const int YYGiftPayConfirmOpType_ARRAYSIZE = YYGiftPayConfirmOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* YYGiftPayConfirmOpType_descriptor();
inline const ::std::string& YYGiftPayConfirmOpType_Name(YYGiftPayConfirmOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    YYGiftPayConfirmOpType_descriptor(), value);
}
inline bool YYGiftPayConfirmOpType_Parse(
    const ::std::string& name, YYGiftPayConfirmOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<YYGiftPayConfirmOpType>(
    YYGiftPayConfirmOpType_descriptor(), name, value);
}
enum SPUserTask {
  PUserTaskStateReq = 1,
  PUserTaskStateRes = 2,
  PUserTaskTakeAwardReq = 3,
  PUserTaskTakeAwardRes = 4,
  PUserTaskCheckReq = 5,
  PUserTaskCheckRes = 6
};
bool SPUserTask_IsValid(int value);
const SPUserTask SPUserTask_MIN = PUserTaskStateReq;
const SPUserTask SPUserTask_MAX = PUserTaskCheckRes;
const int SPUserTask_ARRAYSIZE = SPUserTask_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPUserTask_descriptor();
inline const ::std::string& SPUserTask_Name(SPUserTask value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPUserTask_descriptor(), value);
}
inline bool SPUserTask_Parse(
    const ::std::string& name, SPUserTask* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPUserTask>(
    SPUserTask_descriptor(), name, value);
}
enum UserTaskType {
  UserTaskType_Welcome = 1,
  UserTaskType_EditLogoSignature = 4,
  UserTaskType_JoinGuild = 7,
  UserTaskType_InstallGame = 11,
  UserTaskType_StartAPP = 20,
  UserTaskType_CheckinGuild = 25,
  UserTaskType_StartGame = 30,
  UserTaskType_SendGiftInRoom = 31,
  UserTaskType_SpeakInLobby = 35,
  UserTaskType_WatchLobbies5 = 40
};
bool UserTaskType_IsValid(int value);
const UserTaskType UserTaskType_MIN = UserTaskType_Welcome;
const UserTaskType UserTaskType_MAX = UserTaskType_WatchLobbies5;
const int UserTaskType_ARRAYSIZE = UserTaskType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserTaskType_descriptor();
inline const ::std::string& UserTaskType_Name(UserTaskType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserTaskType_descriptor(), value);
}
inline bool UserTaskType_Parse(
    const ::std::string& name, UserTaskType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserTaskType>(
    UserTaskType_descriptor(), name, value);
}
enum SPUser {
  PUserInfoReq = 0,
  PUserInfoRes = 1,
  PUserInfoModifyReq = 2,
  PUserInfoModifyRes = 3,
  PUserInfoListReq = 6,
  PUserInfoListRes = 7,
  PUserPasswordModifyReq = 10,
  PUserPasswordModifyRes = 11,
  PUserSearchReq = 16,
  PUserSearchRes = 17,
  PUserImageReq = 48,
  PUserImageRes = 49,
  PUserImageListReq = 50,
  PUserImageListRes = 51,
  PUserImageOpReq = 52,
  PUserImageOpRes = 53,
  PUserImageLikeReq = 54,
  PUserImageLikeRes = 55,
  PUserRecommendRegisterReq = 96,
  PUserRecommendRegisterRes = 97,
  PUserRefererListReq = 98,
  PUserRefererListRes = 99,
  PUserProductListReq = 114,
  PUserProductListRes = 115,
  PUserActiveDataReq = 116,
  PUserActiveDataRes = 117,
  PUserStatDataReq = 124,
  PUserStatDataRes = 125,
  PUserActiveDataListReq = 126,
  PUserActiveDataListRes = 127,
  PUserProfileViewReq = 130,
  PUserProfileViewRes = 131,
  PUserAppRateReq = 132,
  PUserAppRateRes = 133,
  PUserExpressAddrOpReq = 134,
  PUserExpressAddrOpRes = 135,
  PAutoTaskUserListReq = 136,
  PAutoTaskUserListRes = 137,
  PUserShowShareReq = 138,
  PUserShowShareRes = 139,
  PUserThirdPartyAccountReq = 140,
  PUserThirdPartyAccountRes = 141
};
bool SPUser_IsValid(int value);
const SPUser SPUser_MIN = PUserInfoReq;
const SPUser SPUser_MAX = PUserThirdPartyAccountRes;
const int SPUser_ARRAYSIZE = SPUser_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPUser_descriptor();
inline const ::std::string& SPUser_Name(SPUser value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPUser_descriptor(), value);
}
inline bool SPUser_Parse(
    const ::std::string& name, SPUser* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPUser>(
    SPUser_descriptor(), name, value);
}
enum AccountType {
  AccountType_Mac = 0,
  AccountType_Cookie = 1,
  AccountType_YY = 2,
  AccountType_MobilePhone = 3,
  AccountType_Tencent = 4,
  AccountType_Sina = 5,
  AccountType_Uid = 6,
  AccountType_WeiXin = 7,
  AccountType_CpsMac = 8
};
bool AccountType_IsValid(int value);
const AccountType AccountType_MIN = AccountType_Mac;
const AccountType AccountType_MAX = AccountType_CpsMac;
const int AccountType_ARRAYSIZE = AccountType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountType_descriptor();
inline const ::std::string& AccountType_Name(AccountType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountType_descriptor(), value);
}
inline bool AccountType_Parse(
    const ::std::string& name, AccountType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountType>(
    AccountType_descriptor(), name, value);
}
enum RolePrivilege {
  Privilege_Broadcast = 8,
  Privilege_Sms = 16,
  Privilege_GroupSuper = 32,
  Privilege_GroupSort = 64,
  Privilege_GroupId = 128,
  Privilege_GroupYYChannel = 256,
  Privilege_Group = 512,
  Privilege_Ad = 1024,
  Privilege_Forbid = 2048,
  Privilege_Present = 32768,
  Privilege_Game = 65536,
  Privilege_Role = 8388608
};
bool RolePrivilege_IsValid(int value);
const RolePrivilege RolePrivilege_MIN = Privilege_Broadcast;
const RolePrivilege RolePrivilege_MAX = Privilege_Role;
const int RolePrivilege_ARRAYSIZE = RolePrivilege_MAX + 1;

const ::google::protobuf::EnumDescriptor* RolePrivilege_descriptor();
inline const ::std::string& RolePrivilege_Name(RolePrivilege value) {
  return ::google::protobuf::internal::NameOfEnum(
    RolePrivilege_descriptor(), value);
}
inline bool RolePrivilege_Parse(
    const ::std::string& name, RolePrivilege* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RolePrivilege>(
    RolePrivilege_descriptor(), name, value);
}
enum RoleType {
  RoleType_Normal = 0,
  RoleType_Broadcast = 8,
  RoleType_GroupAdmin = 512,
  RoleType_SysAdmin = 2048
};
bool RoleType_IsValid(int value);
const RoleType RoleType_MIN = RoleType_Normal;
const RoleType RoleType_MAX = RoleType_SysAdmin;
const int RoleType_ARRAYSIZE = RoleType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoleType_descriptor();
inline const ::std::string& RoleType_Name(RoleType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoleType_descriptor(), value);
}
inline bool RoleType_Parse(
    const ::std::string& name, RoleType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoleType>(
    RoleType_descriptor(), name, value);
}
enum UserInfoFlags {
  UserInfoFlags_MobilePhone = 1,
  UserInfoFlags_Official = 2
};
bool UserInfoFlags_IsValid(int value);
const UserInfoFlags UserInfoFlags_MIN = UserInfoFlags_MobilePhone;
const UserInfoFlags UserInfoFlags_MAX = UserInfoFlags_Official;
const int UserInfoFlags_ARRAYSIZE = UserInfoFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserInfoFlags_descriptor();
inline const ::std::string& UserInfoFlags_Name(UserInfoFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserInfoFlags_descriptor(), value);
}
inline bool UserInfoFlags_Parse(
    const ::std::string& name, UserInfoFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserInfoFlags>(
    UserInfoFlags_descriptor(), name, value);
}
enum UserActiveDataFlags {
  UserActiveDataFlagsYYBaby = 1
};
bool UserActiveDataFlags_IsValid(int value);
const UserActiveDataFlags UserActiveDataFlags_MIN = UserActiveDataFlagsYYBaby;
const UserActiveDataFlags UserActiveDataFlags_MAX = UserActiveDataFlagsYYBaby;
const int UserActiveDataFlags_ARRAYSIZE = UserActiveDataFlags_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserActiveDataFlags_descriptor();
inline const ::std::string& UserActiveDataFlags_Name(UserActiveDataFlags value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserActiveDataFlags_descriptor(), value);
}
inline bool UserActiveDataFlags_Parse(
    const ::std::string& name, UserActiveDataFlags* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserActiveDataFlags>(
    UserActiveDataFlags_descriptor(), name, value);
}
enum UserSearchBy {
  UserSearchByUnKnow = 0,
  UserSearchByKeyWord = 1,
  UserSearchByUid = 2
};
bool UserSearchBy_IsValid(int value);
const UserSearchBy UserSearchBy_MIN = UserSearchByUnKnow;
const UserSearchBy UserSearchBy_MAX = UserSearchByUid;
const int UserSearchBy_ARRAYSIZE = UserSearchBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserSearchBy_descriptor();
inline const ::std::string& UserSearchBy_Name(UserSearchBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserSearchBy_descriptor(), value);
}
inline bool UserSearchBy_Parse(
    const ::std::string& name, UserSearchBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserSearchBy>(
    UserSearchBy_descriptor(), name, value);
}
enum UserSearchOrderBy {
  UserSearchOrderByDesc = 0,
  UserSearchOrderByAsc = 1
};
bool UserSearchOrderBy_IsValid(int value);
const UserSearchOrderBy UserSearchOrderBy_MIN = UserSearchOrderByDesc;
const UserSearchOrderBy UserSearchOrderBy_MAX = UserSearchOrderByAsc;
const int UserSearchOrderBy_ARRAYSIZE = UserSearchOrderBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserSearchOrderBy_descriptor();
inline const ::std::string& UserSearchOrderBy_Name(UserSearchOrderBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserSearchOrderBy_descriptor(), value);
}
inline bool UserSearchOrderBy_Parse(
    const ::std::string& name, UserSearchOrderBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserSearchOrderBy>(
    UserSearchOrderBy_descriptor(), name, value);
}
enum UserImageOrderBy {
  UserImageOrderBy_Default = 1,
  UserImageOrderBy_LikesDesc = 2
};
bool UserImageOrderBy_IsValid(int value);
const UserImageOrderBy UserImageOrderBy_MIN = UserImageOrderBy_Default;
const UserImageOrderBy UserImageOrderBy_MAX = UserImageOrderBy_LikesDesc;
const int UserImageOrderBy_ARRAYSIZE = UserImageOrderBy_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserImageOrderBy_descriptor();
inline const ::std::string& UserImageOrderBy_Name(UserImageOrderBy value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserImageOrderBy_descriptor(), value);
}
inline bool UserImageOrderBy_Parse(
    const ::std::string& name, UserImageOrderBy* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserImageOrderBy>(
    UserImageOrderBy_descriptor(), name, value);
}
enum UserImageType {
  UserImageType_Default = 0,
  UserImageType_ShowAlbum = 1
};
bool UserImageType_IsValid(int value);
const UserImageType UserImageType_MIN = UserImageType_Default;
const UserImageType UserImageType_MAX = UserImageType_ShowAlbum;
const int UserImageType_ARRAYSIZE = UserImageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserImageType_descriptor();
inline const ::std::string& UserImageType_Name(UserImageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserImageType_descriptor(), value);
}
inline bool UserImageType_Parse(
    const ::std::string& name, UserImageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserImageType>(
    UserImageType_descriptor(), name, value);
}
enum EntityOpType {
  EntityOpType_Get = 0,
  EntityOpType_Add = 1,
  EntityOpType_Remove = 2,
  EntityOpType_Modify = 3,
  EntityOpType_List = 4
};
bool EntityOpType_IsValid(int value);
const EntityOpType EntityOpType_MIN = EntityOpType_Get;
const EntityOpType EntityOpType_MAX = EntityOpType_List;
const int EntityOpType_ARRAYSIZE = EntityOpType_MAX + 1;

const ::google::protobuf::EnumDescriptor* EntityOpType_descriptor();
inline const ::std::string& EntityOpType_Name(EntityOpType value) {
  return ::google::protobuf::internal::NameOfEnum(
    EntityOpType_descriptor(), value);
}
inline bool EntityOpType_Parse(
    const ::std::string& name, EntityOpType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<EntityOpType>(
    EntityOpType_descriptor(), name, value);
}
enum SPUserMsg {
  PUserMsgListReq = 0,
  PUserMsgListRes = 1,
  PUserMsgSendReq = 16,
  PUserMsgSendRes = 17,
  PUserMsgBroadcastReq = 18,
  PUserMsgBroadcastRes = 19,
  PUserMsgRejectListSetReq = 32,
  PUserMsgRejectListSetRes = 33,
  PUserMsgRejectListGetReq = 34,
  PUserMsgRejectListGetRes = 35,
  PMsgReadRevisionSetReq = 48,
  PMsgReadRevisionSetRes = 49,
  PMsgReadRevisionGetReq = 50,
  PMsgReadRevisionGetRes = 51,
  PMsgBroadcastQueryReq = 52,
  PMsgBroadcastQueryRes = 53
};
bool SPUserMsg_IsValid(int value);
const SPUserMsg SPUserMsg_MIN = PUserMsgListReq;
const SPUserMsg SPUserMsg_MAX = PMsgBroadcastQueryRes;
const int SPUserMsg_ARRAYSIZE = SPUserMsg_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPUserMsg_descriptor();
inline const ::std::string& SPUserMsg_Name(SPUserMsg value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPUserMsg_descriptor(), value);
}
inline bool SPUserMsg_Parse(
    const ::std::string& name, SPUserMsg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPUserMsg>(
    SPUserMsg_descriptor(), name, value);
}
enum UserMsgType {
  UserMsgContactReceive = 0,
  UserMsgContactSend = 1,
  UserMsgSystemBroadcast = 2,
  UserMsgDynamic = 3,
  UserMsgSms = 4,
  UserMsgBroadcast = 5,
  UserMsgSystemBroadcastRef = 6
};
bool UserMsgType_IsValid(int value);
const UserMsgType UserMsgType_MIN = UserMsgContactReceive;
const UserMsgType UserMsgType_MAX = UserMsgSystemBroadcastRef;
const int UserMsgType_ARRAYSIZE = UserMsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserMsgType_descriptor();
inline const ::std::string& UserMsgType_Name(UserMsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserMsgType_descriptor(), value);
}
inline bool UserMsgType_Parse(
    const ::std::string& name, UserMsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserMsgType>(
    UserMsgType_descriptor(), name, value);
}
enum BroadcastRange {
  BroadcastRange_Specified = 0,
  BroadcastRange_AllUsers = 1,
  BroadcastRange_LoginTimeLimit = 2,
  BroadcastRange_MyFans = 4,
  BroadcastRange_OnlyShowOwner = 5,
  BroadcastRange_OnlyGroupOwner = 6,
  BroadcastRange_OnlyFamilyOwner = 7,
  BroadcastRange_Lost3Days = 8,
  BroadcastRange_Lost3DaysPay = 9
};
bool BroadcastRange_IsValid(int value);
const BroadcastRange BroadcastRange_MIN = BroadcastRange_Specified;
const BroadcastRange BroadcastRange_MAX = BroadcastRange_Lost3DaysPay;
const int BroadcastRange_ARRAYSIZE = BroadcastRange_MAX + 1;

const ::google::protobuf::EnumDescriptor* BroadcastRange_descriptor();
inline const ::std::string& BroadcastRange_Name(BroadcastRange value) {
  return ::google::protobuf::internal::NameOfEnum(
    BroadcastRange_descriptor(), value);
}
inline bool BroadcastRange_Parse(
    const ::std::string& name, BroadcastRange* value) {
  return ::google::protobuf::internal::ParseNamedEnum<BroadcastRange>(
    BroadcastRange_descriptor(), name, value);
}
enum UserMsgBroadcastEvent {
  UserMsgBroadcastEventNone = 0,
  UserMsgBroadcastEventStartShow = 1,
  UserMsgBroadcastEventHallShare = 2
};
bool UserMsgBroadcastEvent_IsValid(int value);
const UserMsgBroadcastEvent UserMsgBroadcastEvent_MIN = UserMsgBroadcastEventNone;
const UserMsgBroadcastEvent UserMsgBroadcastEvent_MAX = UserMsgBroadcastEventHallShare;
const int UserMsgBroadcastEvent_ARRAYSIZE = UserMsgBroadcastEvent_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserMsgBroadcastEvent_descriptor();
inline const ::std::string& UserMsgBroadcastEvent_Name(UserMsgBroadcastEvent value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserMsgBroadcastEvent_descriptor(), value);
}
inline bool UserMsgBroadcastEvent_Parse(
    const ::std::string& name, UserMsgBroadcastEvent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserMsgBroadcastEvent>(
    UserMsgBroadcastEvent_descriptor(), name, value);
}
enum SPWebActivity {
  PWeiLianJoinReq = 1,
  PWeiLianJoinRes = 2,
  PWeiLianGoddessRankReq = 3,
  PWeiLianGoddessRankRes = 4,
  PWeiLianSearchReq = 5,
  PWeiLianSearchRes = 6,
  PWeiLianVoteReq = 7,
  PWeiLianVoteRes = 8,
  PWeiLianMyRankReq = 9,
  PWeiLianMyRankRes = 10
};
bool SPWebActivity_IsValid(int value);
const SPWebActivity SPWebActivity_MIN = PWeiLianJoinReq;
const SPWebActivity SPWebActivity_MAX = PWeiLianMyRankRes;
const int SPWebActivity_ARRAYSIZE = SPWebActivity_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPWebActivity_descriptor();
inline const ::std::string& SPWebActivity_Name(SPWebActivity value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPWebActivity_descriptor(), value);
}
inline bool SPWebActivity_Parse(
    const ::std::string& name, SPWebActivity* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPWebActivity>(
    SPWebActivity_descriptor(), name, value);
}
enum SPWeb {
  PWebQRCodeScanReq = 1,
  PWebQRCodeScanRes = 2,
  PWebUserInfoReq = 3,
  PWebUserInfoRes = 4,
  PWebRecommendsReq = 32,
  PWebRecommendsRes = 33,
  PWebYYIconOnReq = 34,
  PWebYYIconOnRes = 35,
  PWebRankingReq = 36,
  PWebRankingRes = 37,
  PChrisLotHitListReq = 38,
  PChrisLotHitListRes = 39,
  PWebReportReq = 48,
  PWebReportRes = 49,
  PWebTokenVerifyReq = 64,
  PWebTokenVerifyRes = 65,
  PWebUserTokenReq = 66,
  PWebUserTokenRes = 67,
  PUserDataAdjustReq = 97,
  PUserDataAdjustRes = 98,
  PConfigDataReq = 101,
  PConfigDataRes = 102,
  PPageDataExchangeReq = 118,
  PPageDataExchangeRes = 119,
  PUserForbidListReq = 122,
  PUserForbidListRes = 123,
  PActLuckyTryReq = 128,
  PActLuckyTryRes = 129,
  PActRecvDynamicReq = 130,
  PActRecvDynamicRes = 131,
  PConfigJsonActListReq = 132,
  PConfigJsonActListRes = 133,
  PConfigJsonActModifyReq = 134,
  PActStarFormReq = 135,
  PConfigJsonActStarReq = 136,
  PConfigJsonActRes = 137,
  PActMsgListReq = 144,
  PActMsgListRes = 145,
  PActMsgModifyReq = 146,
  PCoinAwardRecordReq = 153,
  PCoinAwardRecordRes = 154,
  PCoreUserListReq = 155,
  PCoreUserListRes = 156,
  PCoreUserModifyReq = 157
};
bool SPWeb_IsValid(int value);
const SPWeb SPWeb_MIN = PWebQRCodeScanReq;
const SPWeb SPWeb_MAX = PCoreUserModifyReq;
const int SPWeb_ARRAYSIZE = SPWeb_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPWeb_descriptor();
inline const ::std::string& SPWeb_Name(SPWeb value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPWeb_descriptor(), value);
}
inline bool SPWeb_Parse(
    const ::std::string& name, SPWeb* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPWeb>(
    SPWeb_descriptor(), name, value);
}
enum SPYYChannel {
  PYYChannelTreeInfoReq = 0,
  PYYChannelTreeInfoRes = 1
};
bool SPYYChannel_IsValid(int value);
const SPYYChannel SPYYChannel_MIN = PYYChannelTreeInfoReq;
const SPYYChannel SPYYChannel_MAX = PYYChannelTreeInfoRes;
const int SPYYChannel_ARRAYSIZE = SPYYChannel_MAX + 1;

const ::google::protobuf::EnumDescriptor* SPYYChannel_descriptor();
inline const ::std::string& SPYYChannel_Name(SPYYChannel value) {
  return ::google::protobuf::internal::NameOfEnum(
    SPYYChannel_descriptor(), value);
}
inline bool SPYYChannel_Parse(
    const ::std::string& name, SPYYChannel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SPYYChannel>(
    SPYYChannel_descriptor(), name, value);
}
// ===================================================================

class AdListReq : public ::google::protobuf::Message {
 public:
  AdListReq();
  virtual ~AdListReq();

  AdListReq(const AdListReq& from);

  inline AdListReq& operator=(const AdListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdListReq& default_instance();

  void Swap(AdListReq* other);

  // implements Message ----------------------------------------------

  AdListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // optional bool web = 2;
  inline bool has_web() const;
  inline void clear_web();
  static const int kWebFieldNumber = 2;
  inline bool web() const;
  inline void set_web(bool value);

  // @@protoc_insertion_point(class_scope:pp.AdListReq)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_web();
  inline void clear_has_web();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 page_;
  bool web_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdListReq* default_instance_;
};
// -------------------------------------------------------------------

class AdListRes : public ::google::protobuf::Message {
 public:
  AdListRes();
  virtual ~AdListRes();

  AdListRes(const AdListRes& from);

  inline AdListRes& operator=(const AdListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdListRes& default_instance();

  void Swap(AdListRes* other);

  // implements Message ----------------------------------------------

  AdListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // optional .pp.MessageBody adbody = 2;
  inline bool has_adbody() const;
  inline void clear_adbody();
  static const int kAdbodyFieldNumber = 2;
  inline const ::pp::MessageBody& adbody() const;
  inline ::pp::MessageBody* mutable_adbody();
  inline ::pp::MessageBody* release_adbody();
  inline void set_allocated_adbody(::pp::MessageBody* adbody);

  // repeated .pp.AdEntity entities = 3;
  inline int entities_size() const;
  inline void clear_entities();
  static const int kEntitiesFieldNumber = 3;
  inline const ::pp::AdEntity& entities(int index) const;
  inline ::pp::AdEntity* mutable_entities(int index);
  inline ::pp::AdEntity* add_entities();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::AdEntity >&
      entities() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::AdEntity >*
      mutable_entities();

  // @@protoc_insertion_point(class_scope:pp.AdListRes)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_adbody();
  inline void clear_has_adbody();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::MessageBody* adbody_;
  ::google::protobuf::RepeatedPtrField< ::pp::AdEntity > entities_;
  ::google::protobuf::uint32 page_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdListRes* default_instance_;
};
// -------------------------------------------------------------------

class AdEntity : public ::google::protobuf::Message {
 public:
  AdEntity();
  virtual ~AdEntity();

  AdEntity(const AdEntity& from);

  inline AdEntity& operator=(const AdEntity& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdEntity& default_instance();

  void Swap(AdEntity* other);

  // implements Message ----------------------------------------------

  AdEntity* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional string FromStore = 5;
  inline bool has_fromstore() const;
  inline void clear_fromstore();
  static const int kFromStoreFieldNumber = 5;
  inline const ::std::string& fromstore() const;
  inline void set_fromstore(const ::std::string& value);
  inline void set_fromstore(const char* value);
  inline void set_fromstore(const char* value, size_t size);
  inline ::std::string* mutable_fromstore();
  inline ::std::string* release_fromstore();
  inline void set_allocated_fromstore(::std::string* fromstore);

  // @@protoc_insertion_point(class_scope:pp.AdEntity)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_fromstore();
  inline void clear_has_fromstore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 page_;
  ::google::protobuf::uint32 id_;
  ::std::string* url_;
  ::std::string* image_;
  ::std::string* fromstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdEntity* default_instance_;
};
// -------------------------------------------------------------------

class AdModifyReq : public ::google::protobuf::Message {
 public:
  AdModifyReq();
  virtual ~AdModifyReq();

  AdModifyReq(const AdModifyReq& from);

  inline AdModifyReq& operator=(const AdModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdModifyReq& default_instance();

  void Swap(AdModifyReq* other);

  // implements Message ----------------------------------------------

  AdModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional string FromStore = 5;
  inline bool has_fromstore() const;
  inline void clear_fromstore();
  static const int kFromStoreFieldNumber = 5;
  inline const ::std::string& fromstore() const;
  inline void set_fromstore(const ::std::string& value);
  inline void set_fromstore(const char* value);
  inline void set_fromstore(const char* value, size_t size);
  inline ::std::string* mutable_fromstore();
  inline ::std::string* release_fromstore();
  inline void set_allocated_fromstore(::std::string* fromstore);

  // @@protoc_insertion_point(class_scope:pp.AdModifyReq)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_fromstore();
  inline void clear_has_fromstore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 page_;
  ::google::protobuf::uint32 id_;
  ::std::string* url_;
  ::std::string* image_;
  ::std::string* fromstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class AdModifyRes : public ::google::protobuf::Message {
 public:
  AdModifyRes();
  virtual ~AdModifyRes();

  AdModifyRes(const AdModifyRes& from);

  inline AdModifyRes& operator=(const AdModifyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdModifyRes& default_instance();

  void Swap(AdModifyRes* other);

  // implements Message ----------------------------------------------

  AdModifyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.AdModifyRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdModifyRes* default_instance_;
};
// -------------------------------------------------------------------

class AdRemoveReq : public ::google::protobuf::Message {
 public:
  AdRemoveReq();
  virtual ~AdRemoveReq();

  AdRemoveReq(const AdRemoveReq& from);

  inline AdRemoveReq& operator=(const AdRemoveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdRemoveReq& default_instance();

  void Swap(AdRemoveReq* other);

  // implements Message ----------------------------------------------

  AdRemoveReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 page = 1;
  inline bool has_page() const;
  inline void clear_page();
  static const int kPageFieldNumber = 1;
  inline ::google::protobuf::uint32 page() const;
  inline void set_page(::google::protobuf::uint32 value);

  // optional uint32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.AdRemoveReq)
 private:
  inline void set_has_page();
  inline void clear_has_page();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 page_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdRemoveReq* default_instance_;
};
// -------------------------------------------------------------------

class AdRemoveRes : public ::google::protobuf::Message {
 public:
  AdRemoveRes();
  virtual ~AdRemoveRes();

  AdRemoveRes(const AdRemoveRes& from);

  inline AdRemoveRes& operator=(const AdRemoveRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdRemoveRes& default_instance();

  void Swap(AdRemoveRes* other);

  // implements Message ----------------------------------------------

  AdRemoveRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.AdRemoveRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AdRemoveRes* default_instance_;
};
// -------------------------------------------------------------------

class UserForbidInfo : public ::google::protobuf::Message {
 public:
  UserForbidInfo();
  virtual ~UserForbidInfo();

  UserForbidInfo(const UserForbidInfo& from);

  inline UserForbidInfo& operator=(const UserForbidInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserForbidInfo& default_instance();

  void Swap(UserForbidInfo* other);

  // implements Message ----------------------------------------------

  UserForbidInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dev = 1;
  inline bool has_dev() const;
  inline void clear_dev();
  static const int kDevFieldNumber = 1;
  inline const ::std::string& dev() const;
  inline void set_dev(const ::std::string& value);
  inline void set_dev(const char* value);
  inline void set_dev(const char* value, size_t size);
  inline ::std::string* mutable_dev();
  inline ::std::string* release_dev();
  inline void set_allocated_dev(::std::string* dev);

  // optional .pp.ForbidDevType devType = 2;
  inline bool has_devtype() const;
  inline void clear_devtype();
  static const int kDevTypeFieldNumber = 2;
  inline ::pp::ForbidDevType devtype() const;
  inline void set_devtype(::pp::ForbidDevType value);

  // optional .pp.ForbidStateType state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::pp::ForbidStateType state() const;
  inline void set_state(::pp::ForbidStateType value);

  // optional int64 forbidtime = 4;
  inline bool has_forbidtime() const;
  inline void clear_forbidtime();
  static const int kForbidtimeFieldNumber = 4;
  inline ::google::protobuf::int64 forbidtime() const;
  inline void set_forbidtime(::google::protobuf::int64 value);

  // optional int64 forbidsecond = 5;
  inline bool has_forbidsecond() const;
  inline void clear_forbidsecond();
  static const int kForbidsecondFieldNumber = 5;
  inline ::google::protobuf::int64 forbidsecond() const;
  inline void set_forbidsecond(::google::protobuf::int64 value);

  // optional .pp.ForbidReasonType reasontype = 6;
  inline bool has_reasontype() const;
  inline void clear_reasontype();
  static const int kReasontypeFieldNumber = 6;
  inline ::pp::ForbidReasonType reasontype() const;
  inline void set_reasontype(::pp::ForbidReasonType value);

  // optional string reason = 7;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 7;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // optional uint64 opuid = 8;
  inline bool has_opuid() const;
  inline void clear_opuid();
  static const int kOpuidFieldNumber = 8;
  inline ::google::protobuf::uint64 opuid() const;
  inline void set_opuid(::google::protobuf::uint64 value);

  // optional uint64 uid = 9;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 9;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserForbidInfo)
 private:
  inline void set_has_dev();
  inline void clear_has_dev();
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_forbidtime();
  inline void clear_has_forbidtime();
  inline void set_has_forbidsecond();
  inline void clear_has_forbidsecond();
  inline void set_has_reasontype();
  inline void clear_has_reasontype();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_opuid();
  inline void clear_has_opuid();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dev_;
  int devtype_;
  int state_;
  ::google::protobuf::int64 forbidtime_;
  ::google::protobuf::int64 forbidsecond_;
  ::std::string* reason_;
  ::google::protobuf::uint64 opuid_;
  ::google::protobuf::uint64 uid_;
  int reasontype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserForbidInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserForbidOpReq : public ::google::protobuf::Message {
 public:
  UserForbidOpReq();
  virtual ~UserForbidOpReq();

  UserForbidOpReq(const UserForbidOpReq& from);

  inline UserForbidOpReq& operator=(const UserForbidOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserForbidOpReq& default_instance();

  void Swap(UserForbidOpReq* other);

  // implements Message ----------------------------------------------

  UserForbidOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserForbidInfo forbidInfo = 1;
  inline bool has_forbidinfo() const;
  inline void clear_forbidinfo();
  static const int kForbidInfoFieldNumber = 1;
  inline const ::pp::UserForbidInfo& forbidinfo() const;
  inline ::pp::UserForbidInfo* mutable_forbidinfo();
  inline ::pp::UserForbidInfo* release_forbidinfo();
  inline void set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo);

  // optional .pp.EntityOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // @@protoc_insertion_point(class_scope:pp.UserForbidOpReq)
 private:
  inline void set_has_forbidinfo();
  inline void clear_has_forbidinfo();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserForbidInfo* forbidinfo_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserForbidOpReq* default_instance_;
};
// -------------------------------------------------------------------

class UserForbidOpRes : public ::google::protobuf::Message {
 public:
  UserForbidOpRes();
  virtual ~UserForbidOpRes();

  UserForbidOpRes(const UserForbidOpRes& from);

  inline UserForbidOpRes& operator=(const UserForbidOpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserForbidOpRes& default_instance();

  void Swap(UserForbidOpRes* other);

  // implements Message ----------------------------------------------

  UserForbidOpRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserForbidInfo forbidInfo = 1;
  inline bool has_forbidinfo() const;
  inline void clear_forbidinfo();
  static const int kForbidInfoFieldNumber = 1;
  inline const ::pp::UserForbidInfo& forbidinfo() const;
  inline ::pp::UserForbidInfo* mutable_forbidinfo();
  inline ::pp::UserForbidInfo* release_forbidinfo();
  inline void set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo);

  // optional .pp.EntityOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // @@protoc_insertion_point(class_scope:pp.UserForbidOpRes)
 private:
  inline void set_has_forbidinfo();
  inline void clear_has_forbidinfo();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserForbidInfo* forbidinfo_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserForbidOpRes* default_instance_;
};
// -------------------------------------------------------------------

class UserForbidSearchReq : public ::google::protobuf::Message {
 public:
  UserForbidSearchReq();
  virtual ~UserForbidSearchReq();

  UserForbidSearchReq(const UserForbidSearchReq& from);

  inline UserForbidSearchReq& operator=(const UserForbidSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserForbidSearchReq& default_instance();

  void Swap(UserForbidSearchReq* other);

  // implements Message ----------------------------------------------

  UserForbidSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserForbidInfo forbidInfo = 1;
  inline bool has_forbidinfo() const;
  inline void clear_forbidinfo();
  static const int kForbidInfoFieldNumber = 1;
  inline const ::pp::UserForbidInfo& forbidinfo() const;
  inline ::pp::UserForbidInfo* mutable_forbidinfo();
  inline ::pp::UserForbidInfo* release_forbidinfo();
  inline void set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo);

  // optional .pp.ForbidSearchBy searchBy = 2;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchByFieldNumber = 2;
  inline ::pp::ForbidSearchBy searchby() const;
  inline void set_searchby(::pp::ForbidSearchBy value);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserForbidSearchReq)
 private:
  inline void set_has_forbidinfo();
  inline void clear_has_forbidinfo();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserForbidInfo* forbidinfo_;
  int searchby_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserForbidSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class UserForbidSearchRes : public ::google::protobuf::Message {
 public:
  UserForbidSearchRes();
  virtual ~UserForbidSearchRes();

  UserForbidSearchRes(const UserForbidSearchRes& from);

  inline UserForbidSearchRes& operator=(const UserForbidSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserForbidSearchRes& default_instance();

  void Swap(UserForbidSearchRes* other);

  // implements Message ----------------------------------------------

  UserForbidSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserForbidInfo forbidInfo = 1;
  inline bool has_forbidinfo() const;
  inline void clear_forbidinfo();
  static const int kForbidInfoFieldNumber = 1;
  inline const ::pp::UserForbidInfo& forbidinfo() const;
  inline ::pp::UserForbidInfo* mutable_forbidinfo();
  inline ::pp::UserForbidInfo* release_forbidinfo();
  inline void set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo);

  // optional .pp.ForbidSearchBy searchBy = 2;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchByFieldNumber = 2;
  inline ::pp::ForbidSearchBy searchby() const;
  inline void set_searchby(::pp::ForbidSearchBy value);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 4;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 4;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.UserForbidInfo forbids = 5;
  inline int forbids_size() const;
  inline void clear_forbids();
  static const int kForbidsFieldNumber = 5;
  inline const ::pp::UserForbidInfo& forbids(int index) const;
  inline ::pp::UserForbidInfo* mutable_forbids(int index);
  inline ::pp::UserForbidInfo* add_forbids();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserForbidInfo >&
      forbids() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserForbidInfo >*
      mutable_forbids();

  // @@protoc_insertion_point(class_scope:pp.UserForbidSearchRes)
 private:
  inline void set_has_forbidinfo();
  inline void clear_has_forbidinfo();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserForbidInfo* forbidinfo_;
  int searchby_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserForbidInfo > forbids_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserForbidSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class PublicNumAddReq : public ::google::protobuf::Message {
 public:
  PublicNumAddReq();
  virtual ~PublicNumAddReq();

  PublicNumAddReq(const PublicNumAddReq& from);

  inline PublicNumAddReq& operator=(const PublicNumAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PublicNumAddReq& default_instance();

  void Swap(PublicNumAddReq* other);

  // implements Message ----------------------------------------------

  PublicNumAddReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required .pp.UidRange uidRange = 2;
  inline bool has_uidrange() const;
  inline void clear_uidrange();
  static const int kUidRangeFieldNumber = 2;
  inline const ::pp::UidRange& uidrange() const;
  inline ::pp::UidRange* mutable_uidrange();
  inline ::pp::UidRange* release_uidrange();
  inline void set_allocated_uidrange(::pp::UidRange* uidrange);

  // optional uint32 remove = 3;
  inline bool has_remove() const;
  inline void clear_remove();
  static const int kRemoveFieldNumber = 3;
  inline ::google::protobuf::uint32 remove() const;
  inline void set_remove(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PublicNumAddReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_uidrange();
  inline void clear_has_uidrange();
  inline void set_has_remove();
  inline void clear_has_remove();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::pp::UidRange* uidrange_;
  ::google::protobuf::uint32 remove_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PublicNumAddReq* default_instance_;
};
// -------------------------------------------------------------------

class IDCodeApplyReq : public ::google::protobuf::Message {
 public:
  IDCodeApplyReq();
  virtual ~IDCodeApplyReq();

  IDCodeApplyReq(const IDCodeApplyReq& from);

  inline IDCodeApplyReq& operator=(const IDCodeApplyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IDCodeApplyReq& default_instance();

  void Swap(IDCodeApplyReq* other);

  // implements Message ----------------------------------------------

  IDCodeApplyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.IDCodeApplyReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static IDCodeApplyReq* default_instance_;
};
// -------------------------------------------------------------------

class IDCodeApplyRes : public ::google::protobuf::Message {
 public:
  IDCodeApplyRes();
  virtual ~IDCodeApplyRes();

  IDCodeApplyRes(const IDCodeApplyRes& from);

  inline IDCodeApplyRes& operator=(const IDCodeApplyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IDCodeApplyRes& default_instance();

  void Swap(IDCodeApplyRes* other);

  // implements Message ----------------------------------------------

  IDCodeApplyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:pp.IDCodeApplyRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static IDCodeApplyRes* default_instance_;
};
// -------------------------------------------------------------------

class IDReplaceReq : public ::google::protobuf::Message {
 public:
  IDReplaceReq();
  virtual ~IDReplaceReq();

  IDReplaceReq(const IDReplaceReq& from);

  inline IDReplaceReq& operator=(const IDReplaceReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const IDReplaceReq& default_instance();

  void Swap(IDReplaceReq* other);

  // implements Message ----------------------------------------------

  IDReplaceReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 old = 1;
  inline bool has_old() const;
  inline void clear_old();
  static const int kOldFieldNumber = 1;
  inline ::google::protobuf::uint64 old() const;
  inline void set_old(::google::protobuf::uint64 value);

  // optional string code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:pp.IDReplaceReq)
 private:
  inline void set_has_old();
  inline void clear_has_old();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 old_;
  ::std::string* code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static IDReplaceReq* default_instance_;
};
// -------------------------------------------------------------------

class UserRoleModifyReq : public ::google::protobuf::Message {
 public:
  UserRoleModifyReq();
  virtual ~UserRoleModifyReq();

  UserRoleModifyReq(const UserRoleModifyReq& from);

  inline UserRoleModifyReq& operator=(const UserRoleModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRoleModifyReq& default_instance();

  void Swap(UserRoleModifyReq* other);

  // implements Message ----------------------------------------------

  UserRoleModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 roletype = 2;
  inline bool has_roletype() const;
  inline void clear_roletype();
  static const int kRoletypeFieldNumber = 2;
  inline ::google::protobuf::uint32 roletype() const;
  inline void set_roletype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserRoleModifyReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_roletype();
  inline void clear_has_roletype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 roletype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRoleModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class BackstageGidSidReq : public ::google::protobuf::Message {
 public:
  BackstageGidSidReq();
  virtual ~BackstageGidSidReq();

  BackstageGidSidReq(const BackstageGidSidReq& from);

  inline BackstageGidSidReq& operator=(const BackstageGidSidReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackstageGidSidReq& default_instance();

  void Swap(BackstageGidSidReq* other);

  // implements Message ----------------------------------------------

  BackstageGidSidReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.BackstageGidSidReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BackstageGidSidReq* default_instance_;
};
// -------------------------------------------------------------------

class BackstageGidSid : public ::google::protobuf::Message {
 public:
  BackstageGidSid();
  virtual ~BackstageGidSid();

  BackstageGidSid(const BackstageGidSid& from);

  inline BackstageGidSid& operator=(const BackstageGidSid& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackstageGidSid& default_instance();

  void Swap(BackstageGidSid* other);

  // implements Message ----------------------------------------------

  BackstageGidSid* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required uint64 ownerId = 3;
  inline bool has_ownerid() const;
  inline void clear_ownerid();
  static const int kOwnerIdFieldNumber = 3;
  inline ::google::protobuf::uint64 ownerid() const;
  inline void set_ownerid(::google::protobuf::uint64 value);

  // required string ownerName = 4;
  inline bool has_ownername() const;
  inline void clear_ownername();
  static const int kOwnerNameFieldNumber = 4;
  inline const ::std::string& ownername() const;
  inline void set_ownername(const ::std::string& value);
  inline void set_ownername(const char* value);
  inline void set_ownername(const char* value, size_t size);
  inline ::std::string* mutable_ownername();
  inline ::std::string* release_ownername();
  inline void set_allocated_ownername(::std::string* ownername);

  // required uint64 sid = 5;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 5;
  inline ::google::protobuf::uint64 sid() const;
  inline void set_sid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.BackstageGidSid)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ownerid();
  inline void clear_has_ownerid();
  inline void set_has_ownername();
  inline void clear_has_ownername();
  inline void set_has_sid();
  inline void clear_has_sid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::std::string* name_;
  ::google::protobuf::uint64 ownerid_;
  ::std::string* ownername_;
  ::google::protobuf::uint64 sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BackstageGidSid* default_instance_;
};
// -------------------------------------------------------------------

class BackstageGidSidRes : public ::google::protobuf::Message {
 public:
  BackstageGidSidRes();
  virtual ~BackstageGidSidRes();

  BackstageGidSidRes(const BackstageGidSidRes& from);

  inline BackstageGidSidRes& operator=(const BackstageGidSidRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BackstageGidSidRes& default_instance();

  void Swap(BackstageGidSidRes* other);

  // implements Message ----------------------------------------------

  BackstageGidSidRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // repeated .pp.BackstageGidSid gidSidList = 3;
  inline int gidsidlist_size() const;
  inline void clear_gidsidlist();
  static const int kGidSidListFieldNumber = 3;
  inline const ::pp::BackstageGidSid& gidsidlist(int index) const;
  inline ::pp::BackstageGidSid* mutable_gidsidlist(int index);
  inline ::pp::BackstageGidSid* add_gidsidlist();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::BackstageGidSid >&
      gidsidlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::BackstageGidSid >*
      mutable_gidsidlist();

  // @@protoc_insertion_point(class_scope:pp.BackstageGidSidRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::RepeatedPtrField< ::pp::BackstageGidSid > gidsidlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BackstageGidSidRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupStatInfo : public ::google::protobuf::Message {
 public:
  GroupStatInfo();
  virtual ~GroupStatInfo();

  GroupStatInfo(const GroupStatInfo& from);

  inline GroupStatInfo& operator=(const GroupStatInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupStatInfo& default_instance();

  void Swap(GroupStatInfo* other);

  // implements Message ----------------------------------------------

  GroupStatInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 msgcount = 1;
  inline bool has_msgcount() const;
  inline void clear_msgcount();
  static const int kMsgcountFieldNumber = 1;
  inline ::google::protobuf::uint32 msgcount() const;
  inline void set_msgcount(::google::protobuf::uint32 value);

  // optional uint32 loginusers = 2;
  inline bool has_loginusers() const;
  inline void clear_loginusers();
  static const int kLoginusersFieldNumber = 2;
  inline ::google::protobuf::uint32 loginusers() const;
  inline void set_loginusers(::google::protobuf::uint32 value);

  // optional uint32 loginmacids = 3;
  inline bool has_loginmacids() const;
  inline void clear_loginmacids();
  static const int kLoginmacidsFieldNumber = 3;
  inline ::google::protobuf::uint32 loginmacids() const;
  inline void set_loginmacids(::google::protobuf::uint32 value);

  // optional uint32 signcount = 4;
  inline bool has_signcount() const;
  inline void clear_signcount();
  static const int kSigncountFieldNumber = 4;
  inline ::google::protobuf::uint32 signcount() const;
  inline void set_signcount(::google::protobuf::uint32 value);

  // optional uint64 coins = 5;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 5;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional uint64 inccoins = 6;
  inline bool has_inccoins() const;
  inline void clear_inccoins();
  static const int kInccoinsFieldNumber = 6;
  inline ::google::protobuf::uint64 inccoins() const;
  inline void set_inccoins(::google::protobuf::uint64 value);

  // optional uint32 hot = 9;
  inline bool has_hot() const;
  inline void clear_hot();
  static const int kHotFieldNumber = 9;
  inline ::google::protobuf::uint32 hot() const;
  inline void set_hot(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupStatInfo)
 private:
  inline void set_has_msgcount();
  inline void clear_has_msgcount();
  inline void set_has_loginusers();
  inline void clear_has_loginusers();
  inline void set_has_loginmacids();
  inline void clear_has_loginmacids();
  inline void set_has_signcount();
  inline void clear_has_signcount();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_inccoins();
  inline void clear_has_inccoins();
  inline void set_has_hot();
  inline void clear_has_hot();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 msgcount_;
  ::google::protobuf::uint32 loginusers_;
  ::google::protobuf::uint32 loginmacids_;
  ::google::protobuf::uint32 signcount_;
  ::google::protobuf::uint64 coins_;
  ::google::protobuf::uint64 inccoins_;
  ::google::protobuf::uint32 hot_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupStatInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupTag : public ::google::protobuf::Message {
 public:
  GroupTag();
  virtual ~GroupTag();

  GroupTag(const GroupTag& from);

  inline GroupTag& operator=(const GroupTag& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupTag& default_instance();

  void Swap(GroupTag* other);

  // implements Message ----------------------------------------------

  GroupTag* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string title = 2;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 2;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional uint32 color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline ::google::protobuf::uint32 color() const;
  inline void set_color(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupTag)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 color_;
  ::std::string* desc_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupTag* default_instance_;
};
// -------------------------------------------------------------------

class GroupTags : public ::google::protobuf::Message {
 public:
  GroupTags();
  virtual ~GroupTags();

  GroupTags(const GroupTags& from);

  inline GroupTags& operator=(const GroupTags& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupTags& default_instance();

  void Swap(GroupTags* other);

  // implements Message ----------------------------------------------

  GroupTags* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupTag items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::GroupTag& items(int index) const;
  inline ::pp::GroupTag* mutable_items(int index);
  inline ::pp::GroupTag* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupTag >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupTag >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.GroupTags)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupTag > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupTags* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoBrief : public ::google::protobuf::Message {
 public:
  UserInfoBrief();
  virtual ~UserInfoBrief();

  UserInfoBrief(const UserInfoBrief& from);

  inline UserInfoBrief& operator=(const UserInfoBrief& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoBrief& default_instance();

  void Swap(UserInfoBrief* other);

  // implements Message ----------------------------------------------

  UserInfoBrief* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional string signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional string logourl = 4;
  inline bool has_logourl() const;
  inline void clear_logourl();
  static const int kLogourlFieldNumber = 4;
  inline const ::std::string& logourl() const;
  inline void set_logourl(const ::std::string& value);
  inline void set_logourl(const char* value);
  inline void set_logourl(const char* value, size_t size);
  inline ::std::string* mutable_logourl();
  inline ::std::string* release_logourl();
  inline void set_allocated_logourl(::std::string* logourl);

  // optional .pp.SexType sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::pp::SexType sex() const;
  inline void set_sex(::pp::SexType value);

  // optional string location = 8;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 8;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string address = 9;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 9;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional .pp.UserFamily family = 11;
  inline bool has_family() const;
  inline void clear_family();
  static const int kFamilyFieldNumber = 11;
  inline const ::pp::UserFamily& family() const;
  inline ::pp::UserFamily* mutable_family();
  inline ::pp::UserFamily* release_family();
  inline void set_allocated_family(::pp::UserFamily* family);

  // optional .pp.ContactState contactState = 12;
  inline bool has_contactstate() const;
  inline void clear_contactstate();
  static const int kContactStateFieldNumber = 12;
  inline ::pp::ContactState contactstate() const;
  inline void set_contactstate(::pp::ContactState value);

  // @@protoc_insertion_point(class_scope:pp.UserInfoBrief)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_logourl();
  inline void clear_has_logourl();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_family();
  inline void clear_has_family();
  inline void set_has_contactstate();
  inline void clear_has_contactstate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* nick_;
  ::std::string* signature_;
  ::std::string* logourl_;
  ::std::string* location_;
  ::std::string* address_;
  int sex_;
  int contactstate_;
  ::pp::UserFamily* family_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoBrief* default_instance_;
};
// -------------------------------------------------------------------

class ExtComment : public ::google::protobuf::Message {
 public:
  ExtComment();
  virtual ~ExtComment();

  ExtComment(const ExtComment& from);

  inline ExtComment& operator=(const ExtComment& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtComment& default_instance();

  void Swap(ExtComment* other);

  // implements Message ----------------------------------------------

  ExtComment* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.ExtComment)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* message_;
  ::google::protobuf::int64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ExtComment* default_instance_;
};
// -------------------------------------------------------------------

class ExtProps : public ::google::protobuf::Message {
 public:
  ExtProps();
  virtual ~ExtProps();

  ExtProps(const ExtProps& from);

  inline ExtProps& operator=(const ExtProps& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExtProps& default_instance();

  void Swap(ExtProps* other);

  // implements Message ----------------------------------------------

  ExtProps* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional bool deleted = 2;
  inline bool has_deleted() const;
  inline void clear_deleted();
  static const int kDeletedFieldNumber = 2;
  inline bool deleted() const;
  inline void set_deleted(bool value);

  // optional uint32 consentCount = 3;
  inline bool has_consentcount() const;
  inline void clear_consentcount();
  static const int kConsentCountFieldNumber = 3;
  inline ::google::protobuf::uint32 consentcount() const;
  inline void set_consentcount(::google::protobuf::uint32 value);

  // repeated uint64 consentUids = 4;
  inline int consentuids_size() const;
  inline void clear_consentuids();
  static const int kConsentUidsFieldNumber = 4;
  inline ::google::protobuf::uint64 consentuids(int index) const;
  inline void set_consentuids(int index, ::google::protobuf::uint64 value);
  inline void add_consentuids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      consentuids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_consentuids();

  // optional uint32 dissentCount = 5;
  inline bool has_dissentcount() const;
  inline void clear_dissentcount();
  static const int kDissentCountFieldNumber = 5;
  inline ::google::protobuf::uint32 dissentcount() const;
  inline void set_dissentcount(::google::protobuf::uint32 value);

  // repeated uint64 dissentUids = 6;
  inline int dissentuids_size() const;
  inline void clear_dissentuids();
  static const int kDissentUidsFieldNumber = 6;
  inline ::google::protobuf::uint64 dissentuids(int index) const;
  inline void set_dissentuids(int index, ::google::protobuf::uint64 value);
  inline void add_dissentuids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      dissentuids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_dissentuids();

  // optional uint32 commentCount = 7;
  inline bool has_commentcount() const;
  inline void clear_commentcount();
  static const int kCommentCountFieldNumber = 7;
  inline ::google::protobuf::uint32 commentcount() const;
  inline void set_commentcount(::google::protobuf::uint32 value);

  // repeated .pp.ExtComment comments = 8;
  inline int comments_size() const;
  inline void clear_comments();
  static const int kCommentsFieldNumber = 8;
  inline const ::pp::ExtComment& comments(int index) const;
  inline ::pp::ExtComment* mutable_comments(int index);
  inline ::pp::ExtComment* add_comments();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ExtComment >&
      comments() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ExtComment >*
      mutable_comments();

  // optional uint32 hitCount = 9;
  inline bool has_hitcount() const;
  inline void clear_hitcount();
  static const int kHitCountFieldNumber = 9;
  inline ::google::protobuf::uint32 hitcount() const;
  inline void set_hitcount(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ExtProps)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_deleted();
  inline void clear_has_deleted();
  inline void set_has_consentcount();
  inline void clear_has_consentcount();
  inline void set_has_dissentcount();
  inline void clear_has_dissentcount();
  inline void set_has_commentcount();
  inline void clear_has_commentcount();
  inline void set_has_hitcount();
  inline void clear_has_hitcount();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  bool deleted_;
  ::google::protobuf::uint32 consentcount_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > consentuids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > dissentuids_;
  ::google::protobuf::uint32 dissentcount_;
  ::google::protobuf::uint32 commentcount_;
  ::google::protobuf::RepeatedPtrField< ::pp::ExtComment > comments_;
  ::google::protobuf::uint32 hitcount_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ExtProps* default_instance_;
};
// -------------------------------------------------------------------

class UserFamily : public ::google::protobuf::Message {
 public:
  UserFamily();
  virtual ~UserFamily();

  UserFamily(const UserFamily& from);

  inline UserFamily& operator=(const UserFamily& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserFamily& default_instance();

  void Swap(UserFamily* other);

  // implements Message ----------------------------------------------

  UserFamily* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupInfo families = 1;
  inline int families_size() const;
  inline void clear_families();
  static const int kFamiliesFieldNumber = 1;
  inline const ::pp::GroupInfo& families(int index) const;
  inline ::pp::GroupInfo* mutable_families(int index);
  inline ::pp::GroupInfo* add_families();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
      families() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
      mutable_families();

  // @@protoc_insertion_point(class_scope:pp.UserFamily)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo > families_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserFamily* default_instance_;
};
// -------------------------------------------------------------------

class UserStamp : public ::google::protobuf::Message {
 public:
  UserStamp();
  virtual ~UserStamp();

  UserStamp(const UserStamp& from);

  inline UserStamp& operator=(const UserStamp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStamp& default_instance();

  void Swap(UserStamp* other);

  // implements Message ----------------------------------------------

  UserStamp* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 fromUid = 1;
  inline bool has_fromuid() const;
  inline void clear_fromuid();
  static const int kFromUidFieldNumber = 1;
  inline ::google::protobuf::uint64 fromuid() const;
  inline void set_fromuid(::google::protobuf::uint64 value);

  // optional uint32 itemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional sint64 updated = 3;
  inline bool has_updated() const;
  inline void clear_updated();
  static const int kUpdatedFieldNumber = 3;
  inline ::google::protobuf::int64 updated() const;
  inline void set_updated(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserStamp)
 private:
  inline void set_has_fromuid();
  inline void clear_has_fromuid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_updated();
  inline void clear_has_updated();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 fromuid_;
  ::google::protobuf::int64 updated_;
  ::google::protobuf::uint32 itemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserStamp* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoProp : public ::google::protobuf::Message {
 public:
  UserInfoProp();
  virtual ~UserInfoProp();

  UserInfoProp(const UserInfoProp& from);

  inline UserInfoProp& operator=(const UserInfoProp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoProp& default_instance();

  void Swap(UserInfoProp* other);

  // implements Message ----------------------------------------------

  UserInfoProp* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string hometown = 10;
  inline bool has_hometown() const;
  inline void clear_hometown();
  static const int kHometownFieldNumber = 10;
  inline const ::std::string& hometown() const;
  inline void set_hometown(const ::std::string& value);
  inline void set_hometown(const char* value);
  inline void set_hometown(const char* value, size_t size);
  inline ::std::string* mutable_hometown();
  inline ::std::string* release_hometown();
  inline void set_allocated_hometown(::std::string* hometown);

  // optional string interest = 11;
  inline bool has_interest() const;
  inline void clear_interest();
  static const int kInterestFieldNumber = 11;
  inline const ::std::string& interest() const;
  inline void set_interest(const ::std::string& value);
  inline void set_interest(const char* value);
  inline void set_interest(const char* value, size_t size);
  inline ::std::string* mutable_interest();
  inline ::std::string* release_interest();
  inline void set_allocated_interest(::std::string* interest);

  // optional string games = 12;
  inline bool has_games() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 12;
  inline const ::std::string& games() const;
  inline void set_games(const ::std::string& value);
  inline void set_games(const char* value);
  inline void set_games(const char* value, size_t size);
  inline ::std::string* mutable_games();
  inline ::std::string* release_games();
  inline void set_allocated_games(::std::string* games);

  // optional .pp.UserStamp stamp = 13;
  inline bool has_stamp() const;
  inline void clear_stamp();
  static const int kStampFieldNumber = 13;
  inline const ::pp::UserStamp& stamp() const;
  inline ::pp::UserStamp* mutable_stamp();
  inline ::pp::UserStamp* release_stamp();
  inline void set_allocated_stamp(::pp::UserStamp* stamp);

  // @@protoc_insertion_point(class_scope:pp.UserInfoProp)
 private:
  inline void set_has_hometown();
  inline void clear_has_hometown();
  inline void set_has_interest();
  inline void clear_has_interest();
  inline void set_has_games();
  inline void clear_has_games();
  inline void set_has_stamp();
  inline void clear_has_stamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* hometown_;
  ::std::string* interest_;
  ::std::string* games_;
  ::pp::UserStamp* stamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoProp* default_instance_;
};
// -------------------------------------------------------------------

class UserActiveData : public ::google::protobuf::Message {
 public:
  UserActiveData();
  virtual ~UserActiveData();

  UserActiveData(const UserActiveData& from);

  inline UserActiveData& operator=(const UserActiveData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActiveData& default_instance();

  void Swap(UserActiveData* other);

  // implements Message ----------------------------------------------

  UserActiveData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional uint32 passion = 3;
  inline bool has_passion() const;
  inline void clear_passion();
  static const int kPassionFieldNumber = 3;
  inline ::google::protobuf::uint32 passion() const;
  inline void set_passion(::google::protobuf::uint32 value);

  // optional uint32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional uint32 nextPassion = 10;
  inline bool has_nextpassion() const;
  inline void clear_nextpassion();
  static const int kNextPassionFieldNumber = 10;
  inline ::google::protobuf::uint32 nextpassion() const;
  inline void set_nextpassion(::google::protobuf::uint32 value);

  // optional uint32 broadcastTimes = 11;
  inline bool has_broadcasttimes() const;
  inline void clear_broadcasttimes();
  static const int kBroadcastTimesFieldNumber = 11;
  inline ::google::protobuf::uint32 broadcasttimes() const;
  inline void set_broadcasttimes(::google::protobuf::uint32 value);

  // optional uint32 broadcastMaxTimes = 12;
  inline bool has_broadcastmaxtimes() const;
  inline void clear_broadcastmaxtimes();
  static const int kBroadcastMaxTimesFieldNumber = 12;
  inline ::google::protobuf::uint32 broadcastmaxtimes() const;
  inline void set_broadcastmaxtimes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserActiveData)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_passion();
  inline void clear_has_passion();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_nextpassion();
  inline void clear_has_nextpassion();
  inline void set_has_broadcasttimes();
  inline void clear_has_broadcasttimes();
  inline void set_has_broadcastmaxtimes();
  inline void clear_has_broadcastmaxtimes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 coins_;
  ::google::protobuf::uint32 passion_;
  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 nextpassion_;
  ::google::protobuf::uint32 broadcasttimes_;
  ::google::protobuf::uint32 broadcastmaxtimes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActiveData* default_instance_;
};
// -------------------------------------------------------------------

class GameInfo : public ::google::protobuf::Message {
 public:
  GameInfo();
  virtual ~GameInfo();

  GameInfo(const GameInfo& from);

  inline GameInfo& operator=(const GameInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameInfo& default_instance();

  void Swap(GameInfo* other);

  // implements Message ----------------------------------------------

  GameInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string icon = 3;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 3;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string intro = 4;
  inline bool has_intro() const;
  inline void clear_intro();
  static const int kIntroFieldNumber = 4;
  inline const ::std::string& intro() const;
  inline void set_intro(const ::std::string& value);
  inline void set_intro(const char* value);
  inline void set_intro(const char* value, size_t size);
  inline ::std::string* mutable_intro();
  inline ::std::string* release_intro();
  inline void set_allocated_intro(::std::string* intro);

  // optional string packname = 5;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 5;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // optional string extjson = 6;
  inline bool has_extjson() const;
  inline void clear_extjson();
  static const int kExtjsonFieldNumber = 6;
  inline const ::std::string& extjson() const;
  inline void set_extjson(const ::std::string& value);
  inline void set_extjson(const char* value);
  inline void set_extjson(const char* value, size_t size);
  inline ::std::string* mutable_extjson();
  inline ::std::string* release_extjson();
  inline void set_allocated_extjson(::std::string* extjson);

  // optional string component = 7;
  inline bool has_component() const;
  inline void clear_component();
  static const int kComponentFieldNumber = 7;
  inline const ::std::string& component() const;
  inline void set_component(const ::std::string& value);
  inline void set_component(const char* value);
  inline void set_component(const char* value, size_t size);
  inline ::std::string* mutable_component();
  inline ::std::string* release_component();
  inline void set_allocated_component(::std::string* component);

  // optional uint32 usercount = 8;
  inline bool has_usercount() const;
  inline void clear_usercount();
  static const int kUsercountFieldNumber = 8;
  inline ::google::protobuf::uint32 usercount() const;
  inline void set_usercount(::google::protobuf::uint32 value);

  // optional uint32 giftLeftNum = 9;
  inline bool has_giftleftnum() const;
  inline void clear_giftleftnum();
  static const int kGiftLeftNumFieldNumber = 9;
  inline ::google::protobuf::uint32 giftleftnum() const;
  inline void set_giftleftnum(::google::protobuf::uint32 value);

  // optional uint32 groupCount = 10;
  inline bool has_groupcount() const;
  inline void clear_groupcount();
  static const int kGroupCountFieldNumber = 10;
  inline ::google::protobuf::uint32 groupcount() const;
  inline void set_groupcount(::google::protobuf::uint32 value);

  // optional uint64 apkSize = 11;
  inline bool has_apksize() const;
  inline void clear_apksize();
  static const int kApkSizeFieldNumber = 11;
  inline ::google::protobuf::uint64 apksize() const;
  inline void set_apksize(::google::protobuf::uint64 value);

  // optional string apkUrl = 12;
  inline bool has_apkurl() const;
  inline void clear_apkurl();
  static const int kApkUrlFieldNumber = 12;
  inline const ::std::string& apkurl() const;
  inline void set_apkurl(const ::std::string& value);
  inline void set_apkurl(const char* value);
  inline void set_apkurl(const char* value, size_t size);
  inline ::std::string* mutable_apkurl();
  inline ::std::string* release_apkurl();
  inline void set_allocated_apkurl(::std::string* apkurl);

  // optional string downloadUrl = 13;
  inline bool has_downloadurl() const;
  inline void clear_downloadurl();
  static const int kDownloadUrlFieldNumber = 13;
  inline const ::std::string& downloadurl() const;
  inline void set_downloadurl(const ::std::string& value);
  inline void set_downloadurl(const char* value);
  inline void set_downloadurl(const char* value, size_t size);
  inline ::std::string* mutable_downloadurl();
  inline ::std::string* release_downloadurl();
  inline void set_allocated_downloadurl(::std::string* downloadurl);

  // optional string apkSrc = 14;
  inline bool has_apksrc() const;
  inline void clear_apksrc();
  static const int kApkSrcFieldNumber = 14;
  inline const ::std::string& apksrc() const;
  inline void set_apksrc(const ::std::string& value);
  inline void set_apksrc(const char* value);
  inline void set_apksrc(const char* value, size_t size);
  inline ::std::string* mutable_apksrc();
  inline ::std::string* release_apksrc();
  inline void set_allocated_apksrc(::std::string* apksrc);

  // optional uint32 giftStyleCount = 15;
  inline bool has_giftstylecount() const;
  inline void clear_giftstylecount();
  static const int kGiftStyleCountFieldNumber = 15;
  inline ::google::protobuf::uint32 giftstylecount() const;
  inline void set_giftstylecount(::google::protobuf::uint32 value);

  // optional string activityTitle = 16;
  inline bool has_activitytitle() const;
  inline void clear_activitytitle();
  static const int kActivityTitleFieldNumber = 16;
  inline const ::std::string& activitytitle() const;
  inline void set_activitytitle(const ::std::string& value);
  inline void set_activitytitle(const char* value);
  inline void set_activitytitle(const char* value, size_t size);
  inline ::std::string* mutable_activitytitle();
  inline ::std::string* release_activitytitle();
  inline void set_allocated_activitytitle(::std::string* activitytitle);

  // optional string activityLink = 17;
  inline bool has_activitylink() const;
  inline void clear_activitylink();
  static const int kActivityLinkFieldNumber = 17;
  inline const ::std::string& activitylink() const;
  inline void set_activitylink(const ::std::string& value);
  inline void set_activitylink(const char* value);
  inline void set_activitylink(const char* value, size_t size);
  inline ::std::string* mutable_activitylink();
  inline ::std::string* release_activitylink();
  inline void set_allocated_activitylink(::std::string* activitylink);

  // optional string discountIntro = 18;
  inline bool has_discountintro() const;
  inline void clear_discountintro();
  static const int kDiscountIntroFieldNumber = 18;
  inline const ::std::string& discountintro() const;
  inline void set_discountintro(const ::std::string& value);
  inline void set_discountintro(const char* value);
  inline void set_discountintro(const char* value, size_t size);
  inline ::std::string* mutable_discountintro();
  inline ::std::string* release_discountintro();
  inline void set_allocated_discountintro(::std::string* discountintro);

  // optional uint32 playerCount = 19;
  inline bool has_playercount() const;
  inline void clear_playercount();
  static const int kPlayerCountFieldNumber = 19;
  inline ::google::protobuf::uint32 playercount() const;
  inline void set_playercount(::google::protobuf::uint32 value);

  // optional string categories = 20;
  inline bool has_categories() const;
  inline void clear_categories();
  static const int kCategoriesFieldNumber = 20;
  inline const ::std::string& categories() const;
  inline void set_categories(const ::std::string& value);
  inline void set_categories(const char* value);
  inline void set_categories(const char* value, size_t size);
  inline ::std::string* mutable_categories();
  inline ::std::string* release_categories();
  inline void set_allocated_categories(::std::string* categories);

  // optional string version = 21;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 21;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string reportPackname = 22;
  inline bool has_reportpackname() const;
  inline void clear_reportpackname();
  static const int kReportPacknameFieldNumber = 22;
  inline const ::std::string& reportpackname() const;
  inline void set_reportpackname(const ::std::string& value);
  inline void set_reportpackname(const char* value);
  inline void set_reportpackname(const char* value, size_t size);
  inline ::std::string* mutable_reportpackname();
  inline ::std::string* release_reportpackname();
  inline void set_allocated_reportpackname(::std::string* reportpackname);

  // optional string groupApkUrl = 23;
  inline bool has_groupapkurl() const;
  inline void clear_groupapkurl();
  static const int kGroupApkUrlFieldNumber = 23;
  inline const ::std::string& groupapkurl() const;
  inline void set_groupapkurl(const ::std::string& value);
  inline void set_groupapkurl(const char* value);
  inline void set_groupapkurl(const char* value, size_t size);
  inline ::std::string* mutable_groupapkurl();
  inline ::std::string* release_groupapkurl();
  inline void set_allocated_groupapkurl(::std::string* groupapkurl);

  // optional uint32 sortOrder = 24;
  inline bool has_sortorder() const;
  inline void clear_sortorder();
  static const int kSortOrderFieldNumber = 24;
  inline ::google::protobuf::uint32 sortorder() const;
  inline void set_sortorder(::google::protobuf::uint32 value);

  // optional string yyPackname = 25;
  inline bool has_yypackname() const;
  inline void clear_yypackname();
  static const int kYyPacknameFieldNumber = 25;
  inline const ::std::string& yypackname() const;
  inline void set_yypackname(const ::std::string& value);
  inline void set_yypackname(const char* value);
  inline void set_yypackname(const char* value, size_t size);
  inline ::std::string* mutable_yypackname();
  inline ::std::string* release_yypackname();
  inline void set_allocated_yypackname(::std::string* yypackname);

  // optional string thumbnails = 30;
  inline bool has_thumbnails() const;
  inline void clear_thumbnails();
  static const int kThumbnailsFieldNumber = 30;
  inline const ::std::string& thumbnails() const;
  inline void set_thumbnails(const ::std::string& value);
  inline void set_thumbnails(const char* value);
  inline void set_thumbnails(const char* value, size_t size);
  inline ::std::string* mutable_thumbnails();
  inline ::std::string* release_thumbnails();
  inline void set_allocated_thumbnails(::std::string* thumbnails);

  // @@protoc_insertion_point(class_scope:pp.GameInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_intro();
  inline void clear_has_intro();
  inline void set_has_packname();
  inline void clear_has_packname();
  inline void set_has_extjson();
  inline void clear_has_extjson();
  inline void set_has_component();
  inline void clear_has_component();
  inline void set_has_usercount();
  inline void clear_has_usercount();
  inline void set_has_giftleftnum();
  inline void clear_has_giftleftnum();
  inline void set_has_groupcount();
  inline void clear_has_groupcount();
  inline void set_has_apksize();
  inline void clear_has_apksize();
  inline void set_has_apkurl();
  inline void clear_has_apkurl();
  inline void set_has_downloadurl();
  inline void clear_has_downloadurl();
  inline void set_has_apksrc();
  inline void clear_has_apksrc();
  inline void set_has_giftstylecount();
  inline void clear_has_giftstylecount();
  inline void set_has_activitytitle();
  inline void clear_has_activitytitle();
  inline void set_has_activitylink();
  inline void clear_has_activitylink();
  inline void set_has_discountintro();
  inline void clear_has_discountintro();
  inline void set_has_playercount();
  inline void clear_has_playercount();
  inline void set_has_categories();
  inline void clear_has_categories();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_reportpackname();
  inline void clear_has_reportpackname();
  inline void set_has_groupapkurl();
  inline void clear_has_groupapkurl();
  inline void set_has_sortorder();
  inline void clear_has_sortorder();
  inline void set_has_yypackname();
  inline void clear_has_yypackname();
  inline void set_has_thumbnails();
  inline void clear_has_thumbnails();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* icon_;
  ::std::string* intro_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 usercount_;
  ::std::string* packname_;
  ::std::string* extjson_;
  ::std::string* component_;
  ::google::protobuf::uint32 giftleftnum_;
  ::google::protobuf::uint32 groupcount_;
  ::google::protobuf::uint64 apksize_;
  ::std::string* apkurl_;
  ::std::string* downloadurl_;
  ::std::string* apksrc_;
  ::std::string* activitytitle_;
  ::std::string* activitylink_;
  ::google::protobuf::uint32 giftstylecount_;
  ::google::protobuf::uint32 playercount_;
  ::std::string* discountintro_;
  ::std::string* categories_;
  ::std::string* version_;
  ::std::string* reportpackname_;
  ::std::string* groupapkurl_;
  ::std::string* yypackname_;
  ::std::string* thumbnails_;
  ::google::protobuf::uint32 sortorder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(26 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameReservableRecord : public ::google::protobuf::Message {
 public:
  GameReservableRecord();
  virtual ~GameReservableRecord();

  GameReservableRecord(const GameReservableRecord& from);

  inline GameReservableRecord& operator=(const GameReservableRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameReservableRecord& default_instance();

  void Swap(GameReservableRecord* other);

  // implements Message ----------------------------------------------

  GameReservableRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GameInfo game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::pp::GameInfo& game() const;
  inline ::pp::GameInfo* mutable_game();
  inline ::pp::GameInfo* release_game();
  inline void set_allocated_game(::pp::GameInfo* game);

  // optional uint32 bookedNum = 2;
  inline bool has_bookednum() const;
  inline void clear_bookednum();
  static const int kBookedNumFieldNumber = 2;
  inline ::google::protobuf::uint32 bookednum() const;
  inline void set_bookednum(::google::protobuf::uint32 value);

  // optional bool booked = 3;
  inline bool has_booked() const;
  inline void clear_booked();
  static const int kBookedFieldNumber = 3;
  inline bool booked() const;
  inline void set_booked(bool value);

  // @@protoc_insertion_point(class_scope:pp.GameReservableRecord)
 private:
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_bookednum();
  inline void clear_has_bookednum();
  inline void set_has_booked();
  inline void clear_has_booked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GameInfo* game_;
  ::google::protobuf::uint32 bookednum_;
  bool booked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameReservableRecord* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonReq : public ::google::protobuf::Message {
 public:
  ConfigJsonReq();
  virtual ~ConfigJsonReq();

  ConfigJsonReq(const ConfigJsonReq& from);

  inline ConfigJsonReq& operator=(const ConfigJsonReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonReq& default_instance();

  void Swap(ConfigJsonReq* other);

  // implements Message ----------------------------------------------

  ConfigJsonReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonReq* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonRes : public ::google::protobuf::Message {
 public:
  ConfigJsonRes();
  virtual ~ConfigJsonRes();

  ConfigJsonRes(const ConfigJsonRes& from);

  inline ConfigJsonRes& operator=(const ConfigJsonRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonRes& default_instance();

  void Swap(ConfigJsonRes* other);

  // implements Message ----------------------------------------------

  ConfigJsonRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string jsondata = 1;
  inline bool has_jsondata() const;
  inline void clear_jsondata();
  static const int kJsondataFieldNumber = 1;
  inline const ::std::string& jsondata() const;
  inline void set_jsondata(const ::std::string& value);
  inline void set_jsondata(const char* value);
  inline void set_jsondata(const char* value, size_t size);
  inline ::std::string* mutable_jsondata();
  inline ::std::string* release_jsondata();
  inline void set_allocated_jsondata(::std::string* jsondata);

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonRes)
 private:
  inline void set_has_jsondata();
  inline void clear_has_jsondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jsondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonRes* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonListReq : public ::google::protobuf::Message {
 public:
  ConfigJsonListReq();
  virtual ~ConfigJsonListReq();

  ConfigJsonListReq(const ConfigJsonListReq& from);

  inline ConfigJsonListReq& operator=(const ConfigJsonListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonListReq& default_instance();

  void Swap(ConfigJsonListReq* other);

  // implements Message ----------------------------------------------

  ConfigJsonListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonListReq* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonListRes : public ::google::protobuf::Message {
 public:
  ConfigJsonListRes();
  virtual ~ConfigJsonListRes();

  ConfigJsonListRes(const ConfigJsonListRes& from);

  inline ConfigJsonListRes& operator=(const ConfigJsonListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonListRes& default_instance();

  void Swap(ConfigJsonListRes* other);

  // implements Message ----------------------------------------------

  ConfigJsonListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.ConfigJsonData items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::ConfigJsonData& items(int index) const;
  inline ::pp::ConfigJsonData* mutable_items(int index);
  inline ::pp::ConfigJsonData* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonData >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonData >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonData > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonListRes* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonData : public ::google::protobuf::Message {
 public:
  ConfigJsonData();
  virtual ~ConfigJsonData();

  ConfigJsonData(const ConfigJsonData& from);

  inline ConfigJsonData& operator=(const ConfigJsonData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonData& default_instance();

  void Swap(ConfigJsonData* other);

  // implements Message ----------------------------------------------

  ConfigJsonData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 devtype = 1;
  inline bool has_devtype() const;
  inline void clear_devtype();
  static const int kDevtypeFieldNumber = 1;
  inline ::google::protobuf::uint32 devtype() const;
  inline void set_devtype(::google::protobuf::uint32 value);

  // required uint32 maxversion = 2;
  inline bool has_maxversion() const;
  inline void clear_maxversion();
  static const int kMaxversionFieldNumber = 2;
  inline ::google::protobuf::uint32 maxversion() const;
  inline void set_maxversion(::google::protobuf::uint32 value);

  // required int64 validtime = 3;
  inline bool has_validtime() const;
  inline void clear_validtime();
  static const int kValidtimeFieldNumber = 3;
  inline ::google::protobuf::int64 validtime() const;
  inline void set_validtime(::google::protobuf::int64 value);

  // optional string jsondata = 4;
  inline bool has_jsondata() const;
  inline void clear_jsondata();
  static const int kJsondataFieldNumber = 4;
  inline const ::std::string& jsondata() const;
  inline void set_jsondata(const ::std::string& value);
  inline void set_jsondata(const char* value);
  inline void set_jsondata(const char* value, size_t size);
  inline ::std::string* mutable_jsondata();
  inline ::std::string* release_jsondata();
  inline void set_allocated_jsondata(::std::string* jsondata);

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonData)
 private:
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_maxversion();
  inline void clear_has_maxversion();
  inline void set_has_validtime();
  inline void clear_has_validtime();
  inline void set_has_jsondata();
  inline void clear_has_jsondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 devtype_;
  ::google::protobuf::uint32 maxversion_;
  ::google::protobuf::int64 validtime_;
  ::std::string* jsondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonData* default_instance_;
};
// -------------------------------------------------------------------

class SysConfReq : public ::google::protobuf::Message {
 public:
  SysConfReq();
  virtual ~SysConfReq();

  SysConfReq(const SysConfReq& from);

  inline SysConfReq& operator=(const SysConfReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysConfReq& default_instance();

  void Swap(SysConfReq* other);

  // implements Message ----------------------------------------------

  SysConfReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:pp.SysConfReq)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SysConfReq* default_instance_;
};
// -------------------------------------------------------------------

class SysConfRes : public ::google::protobuf::Message {
 public:
  SysConfRes();
  virtual ~SysConfRes();

  SysConfRes(const SysConfRes& from);

  inline SysConfRes& operator=(const SysConfRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysConfRes& default_instance();

  void Swap(SysConfRes* other);

  // implements Message ----------------------------------------------

  SysConfRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string jsondata = 1;
  inline bool has_jsondata() const;
  inline void clear_jsondata();
  static const int kJsondataFieldNumber = 1;
  inline const ::std::string& jsondata() const;
  inline void set_jsondata(const ::std::string& value);
  inline void set_jsondata(const char* value);
  inline void set_jsondata(const char* value, size_t size);
  inline ::std::string* mutable_jsondata();
  inline ::std::string* release_jsondata();
  inline void set_allocated_jsondata(::std::string* jsondata);

  // @@protoc_insertion_point(class_scope:pp.SysConfRes)
 private:
  inline void set_has_jsondata();
  inline void clear_has_jsondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jsondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SysConfRes* default_instance_;
};
// -------------------------------------------------------------------

class UserSettingItem : public ::google::protobuf::Message {
 public:
  UserSettingItem();
  virtual ~UserSettingItem();

  UserSettingItem(const UserSettingItem& from);

  inline UserSettingItem& operator=(const UserSettingItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSettingItem& default_instance();

  void Swap(UserSettingItem* other);

  // implements Message ----------------------------------------------

  UserSettingItem* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pp.UserSettingItem)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSettingItem* default_instance_;
};
// -------------------------------------------------------------------

class UserSettingSetReq : public ::google::protobuf::Message {
 public:
  UserSettingSetReq();
  virtual ~UserSettingSetReq();

  UserSettingSetReq(const UserSettingSetReq& from);

  inline UserSettingSetReq& operator=(const UserSettingSetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSettingSetReq& default_instance();

  void Swap(UserSettingSetReq* other);

  // implements Message ----------------------------------------------

  UserSettingSetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserSettingItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::UserSettingItem& items(int index) const;
  inline ::pp::UserSettingItem* mutable_items(int index);
  inline ::pp::UserSettingItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserSettingSetReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSettingSetReq* default_instance_;
};
// -------------------------------------------------------------------

class UserSettingSetRes : public ::google::protobuf::Message {
 public:
  UserSettingSetRes();
  virtual ~UserSettingSetRes();

  UserSettingSetRes(const UserSettingSetRes& from);

  inline UserSettingSetRes& operator=(const UserSettingSetRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSettingSetRes& default_instance();

  void Swap(UserSettingSetRes* other);

  // implements Message ----------------------------------------------

  UserSettingSetRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserSettingItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::UserSettingItem& items(int index) const;
  inline ::pp::UserSettingItem* mutable_items(int index);
  inline ::pp::UserSettingItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserSettingSetRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSettingSetRes* default_instance_;
};
// -------------------------------------------------------------------

class UserSettingGetReq : public ::google::protobuf::Message {
 public:
  UserSettingGetReq();
  virtual ~UserSettingGetReq();

  UserSettingGetReq(const UserSettingGetReq& from);

  inline UserSettingGetReq& operator=(const UserSettingGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSettingGetReq& default_instance();

  void Swap(UserSettingGetReq* other);

  // implements Message ----------------------------------------------

  UserSettingGetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserSettingGetReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSettingGetReq* default_instance_;
};
// -------------------------------------------------------------------

class UserSettingGetRes : public ::google::protobuf::Message {
 public:
  UserSettingGetRes();
  virtual ~UserSettingGetRes();

  UserSettingGetRes(const UserSettingGetRes& from);

  inline UserSettingGetRes& operator=(const UserSettingGetRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSettingGetRes& default_instance();

  void Swap(UserSettingGetRes* other);

  // implements Message ----------------------------------------------

  UserSettingGetRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserSettingItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::UserSettingItem& items(int index) const;
  inline ::pp::UserSettingItem* mutable_items(int index);
  inline ::pp::UserSettingItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserSettingGetRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSettingGetRes* default_instance_;
};
// -------------------------------------------------------------------

class AppStateCheckReq : public ::google::protobuf::Message {
 public:
  AppStateCheckReq();
  virtual ~AppStateCheckReq();

  AppStateCheckReq(const AppStateCheckReq& from);

  inline AppStateCheckReq& operator=(const AppStateCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppStateCheckReq& default_instance();

  void Swap(AppStateCheckReq* other);

  // implements Message ----------------------------------------------

  AppStateCheckReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.AppStateCheckReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppStateCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class AppState : public ::google::protobuf::Message {
 public:
  AppState();
  virtual ~AppState();

  AppState(const AppState& from);

  inline AppState& operator=(const AppState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppState& default_instance();

  void Swap(AppState* other);

  // implements Message ----------------------------------------------

  AppState* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AppState_Type Type;
  static const Type Activities = AppState_Type_Activities;
  static const Type ProductShop = AppState_Type_ProductShop;
  static inline bool Type_IsValid(int value) {
    return AppState_Type_IsValid(value);
  }
  static const Type Type_MIN =
    AppState_Type_Type_MIN;
  static const Type Type_MAX =
    AppState_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    AppState_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return AppState_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return AppState_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return AppState_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint64 version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional bool enable = 4;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 4;
  inline bool enable() const;
  inline void set_enable(bool value);

  // @@protoc_insertion_point(class_scope:pp.AppState)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_enable();
  inline void clear_has_enable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint32 type_;
  bool enable_;
  ::std::string* text_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppState* default_instance_;
};
// -------------------------------------------------------------------

class AppStateCheckRes : public ::google::protobuf::Message {
 public:
  AppStateCheckRes();
  virtual ~AppStateCheckRes();

  AppStateCheckRes(const AppStateCheckRes& from);

  inline AppStateCheckRes& operator=(const AppStateCheckRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppStateCheckRes& default_instance();

  void Swap(AppStateCheckRes* other);

  // implements Message ----------------------------------------------

  AppStateCheckRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.AppState states = 1;
  inline int states_size() const;
  inline void clear_states();
  static const int kStatesFieldNumber = 1;
  inline const ::pp::AppState& states(int index) const;
  inline ::pp::AppState* mutable_states(int index);
  inline ::pp::AppState* add_states();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::AppState >&
      states() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::AppState >*
      mutable_states();

  // @@protoc_insertion_point(class_scope:pp.AppStateCheckRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::AppState > states_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppStateCheckRes* default_instance_;
};
// -------------------------------------------------------------------

class AppStateUpdateReq : public ::google::protobuf::Message {
 public:
  AppStateUpdateReq();
  virtual ~AppStateUpdateReq();

  AppStateUpdateReq(const AppStateUpdateReq& from);

  inline AppStateUpdateReq& operator=(const AppStateUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppStateUpdateReq& default_instance();

  void Swap(AppStateUpdateReq* other);

  // implements Message ----------------------------------------------

  AppStateUpdateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool iosEnable = 1;
  inline bool has_iosenable() const;
  inline void clear_iosenable();
  static const int kIosEnableFieldNumber = 1;
  inline bool iosenable() const;
  inline void set_iosenable(bool value);

  // @@protoc_insertion_point(class_scope:pp.AppStateUpdateReq)
 private:
  inline void set_has_iosenable();
  inline void clear_has_iosenable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool iosenable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppStateUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class AppStateUpdateRes : public ::google::protobuf::Message {
 public:
  AppStateUpdateRes();
  virtual ~AppStateUpdateRes();

  AppStateUpdateRes(const AppStateUpdateRes& from);

  inline AppStateUpdateRes& operator=(const AppStateUpdateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppStateUpdateRes& default_instance();

  void Swap(AppStateUpdateRes* other);

  // implements Message ----------------------------------------------

  AppStateUpdateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool iosEnable = 1;
  inline bool has_iosenable() const;
  inline void clear_iosenable();
  static const int kIosEnableFieldNumber = 1;
  inline bool iosenable() const;
  inline void set_iosenable(bool value);

  // @@protoc_insertion_point(class_scope:pp.AppStateUpdateRes)
 private:
  inline void set_has_iosenable();
  inline void clear_has_iosenable();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool iosenable_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppStateUpdateRes* default_instance_;
};
// -------------------------------------------------------------------

class AppActConfigReq : public ::google::protobuf::Message {
 public:
  AppActConfigReq();
  virtual ~AppActConfigReq();

  AppActConfigReq(const AppActConfigReq& from);

  inline AppActConfigReq& operator=(const AppActConfigReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppActConfigReq& default_instance();

  void Swap(AppActConfigReq* other);

  // implements Message ----------------------------------------------

  AppActConfigReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.AppActConfigReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppActConfigReq* default_instance_;
};
// -------------------------------------------------------------------

class AppActConfigRes : public ::google::protobuf::Message {
 public:
  AppActConfigRes();
  virtual ~AppActConfigRes();

  AppActConfigRes(const AppActConfigRes& from);

  inline AppActConfigRes& operator=(const AppActConfigRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppActConfigRes& default_instance();

  void Swap(AppActConfigRes* other);

  // implements Message ----------------------------------------------

  AppActConfigRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string icon = 1;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 1;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string text = 2;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 2;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint64 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.AppActConfigRes)
 private:
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* icon_;
  ::std::string* text_;
  ::std::string* url_;
  ::google::protobuf::uint64 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppActConfigRes* default_instance_;
};
// -------------------------------------------------------------------

class AppProtoVersionUpdateReq : public ::google::protobuf::Message {
 public:
  AppProtoVersionUpdateReq();
  virtual ~AppProtoVersionUpdateReq();

  AppProtoVersionUpdateReq(const AppProtoVersionUpdateReq& from);

  inline AppProtoVersionUpdateReq& operator=(const AppProtoVersionUpdateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppProtoVersionUpdateReq& default_instance();

  void Swap(AppProtoVersionUpdateReq* other);

  // implements Message ----------------------------------------------

  AppProtoVersionUpdateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.AppProtoVersionUpdateReq)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppProtoVersionUpdateReq* default_instance_;
};
// -------------------------------------------------------------------

class AppProtoVersionUpdateRes : public ::google::protobuf::Message {
 public:
  AppProtoVersionUpdateRes();
  virtual ~AppProtoVersionUpdateRes();

  AppProtoVersionUpdateRes(const AppProtoVersionUpdateRes& from);

  inline AppProtoVersionUpdateRes& operator=(const AppProtoVersionUpdateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AppProtoVersionUpdateRes& default_instance();

  void Swap(AppProtoVersionUpdateRes* other);

  // implements Message ----------------------------------------------

  AppProtoVersionUpdateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.AppProtoVersionUpdateRes)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AppProtoVersionUpdateRes* default_instance_;
};
// -------------------------------------------------------------------

class ContactInfo : public ::google::protobuf::Message {
 public:
  ContactInfo();
  virtual ~ContactInfo();

  ContactInfo(const ContactInfo& from);

  inline ContactInfo& operator=(const ContactInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactInfo& default_instance();

  void Swap(ContactInfo* other);

  // implements Message ----------------------------------------------

  ContactInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::pp::UserInfo& user() const;
  inline ::pp::UserInfo* mutable_user();
  inline ::pp::UserInfo* release_user();
  inline void set_allocated_user(::pp::UserInfo* user);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint64 revread = 3;
  inline bool has_revread() const;
  inline void clear_revread();
  static const int kRevreadFieldNumber = 3;
  inline ::google::protobuf::uint64 revread() const;
  inline void set_revread(::google::protobuf::uint64 value);

  // optional uint64 revmsg = 4;
  inline bool has_revmsg() const;
  inline void clear_revmsg();
  static const int kRevmsgFieldNumber = 4;
  inline ::google::protobuf::uint64 revmsg() const;
  inline void set_revmsg(::google::protobuf::uint64 value);

  // optional string remark = 5;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 5;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional int64 timestamp = 6;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 6;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional uint64 dailyCoin = 7;
  inline bool has_dailycoin() const;
  inline void clear_dailycoin();
  static const int kDailyCoinFieldNumber = 7;
  inline ::google::protobuf::uint64 dailycoin() const;
  inline void set_dailycoin(::google::protobuf::uint64 value);

  // optional uint64 monthCoin = 8;
  inline bool has_monthcoin() const;
  inline void clear_monthcoin();
  static const int kMonthCoinFieldNumber = 8;
  inline ::google::protobuf::uint64 monthcoin() const;
  inline void set_monthcoin(::google::protobuf::uint64 value);

  // optional uint64 totalCoin = 9;
  inline bool has_totalcoin() const;
  inline void clear_totalcoin();
  static const int kTotalCoinFieldNumber = 9;
  inline ::google::protobuf::uint64 totalcoin() const;
  inline void set_totalcoin(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.ContactInfo)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_revread();
  inline void clear_has_revread();
  inline void set_has_revmsg();
  inline void clear_has_revmsg();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_dailycoin();
  inline void clear_has_dailycoin();
  inline void set_has_monthcoin();
  inline void clear_has_monthcoin();
  inline void set_has_totalcoin();
  inline void clear_has_totalcoin();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* user_;
  ::google::protobuf::uint64 revread_;
  ::google::protobuf::uint64 revmsg_;
  ::std::string* remark_;
  ::google::protobuf::int64 timestamp_;
  ::google::protobuf::uint64 dailycoin_;
  ::google::protobuf::uint64 monthcoin_;
  ::google::protobuf::uint64 totalcoin_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactInfo* default_instance_;
};
// -------------------------------------------------------------------

class ContactIncrement : public ::google::protobuf::Message {
 public:
  ContactIncrement();
  virtual ~ContactIncrement();

  ContactIncrement(const ContactIncrement& from);

  inline ContactIncrement& operator=(const ContactIncrement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactIncrement& default_instance();

  void Swap(ContactIncrement* other);

  // implements Message ----------------------------------------------

  ContactIncrement* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ContactIncrement_ContactIncrementType ContactIncrementType;
  static const ContactIncrementType Contact_Add = ContactIncrement_ContactIncrementType_Contact_Add;
  static const ContactIncrementType Contact_Remove = ContactIncrement_ContactIncrementType_Contact_Remove;
  static const ContactIncrementType Contact_Update = ContactIncrement_ContactIncrementType_Contact_Update;
  static const ContactIncrementType Contact_Reject = ContactIncrement_ContactIncrementType_Contact_Reject;
  static const ContactIncrementType Contact_ApplyPass = ContactIncrement_ContactIncrementType_Contact_ApplyPass;
  static const ContactIncrementType Contact_Black = ContactIncrement_ContactIncrementType_Contact_Black;
  static inline bool ContactIncrementType_IsValid(int value) {
    return ContactIncrement_ContactIncrementType_IsValid(value);
  }
  static const ContactIncrementType ContactIncrementType_MIN =
    ContactIncrement_ContactIncrementType_ContactIncrementType_MIN;
  static const ContactIncrementType ContactIncrementType_MAX =
    ContactIncrement_ContactIncrementType_ContactIncrementType_MAX;
  static const int ContactIncrementType_ARRAYSIZE =
    ContactIncrement_ContactIncrementType_ContactIncrementType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ContactIncrementType_descriptor() {
    return ContactIncrement_ContactIncrementType_descriptor();
  }
  static inline const ::std::string& ContactIncrementType_Name(ContactIncrementType value) {
    return ContactIncrement_ContactIncrementType_Name(value);
  }
  static inline bool ContactIncrementType_Parse(const ::std::string& name,
      ContactIncrementType* value) {
    return ContactIncrement_ContactIncrementType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // required .pp.ContactInfo contact = 2;
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 2;
  inline const ::pp::ContactInfo& contact() const;
  inline ::pp::ContactInfo* mutable_contact();
  inline ::pp::ContactInfo* release_contact();
  inline void set_allocated_contact(::pp::ContactInfo* contact);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // required .pp.ContactIncrement.ContactIncrementType incrType = 4;
  inline bool has_incrtype() const;
  inline void clear_incrtype();
  static const int kIncrTypeFieldNumber = 4;
  inline ::pp::ContactIncrement_ContactIncrementType incrtype() const;
  inline void set_incrtype(::pp::ContactIncrement_ContactIncrementType value);

  // @@protoc_insertion_point(class_scope:pp.ContactIncrement)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_incrtype();
  inline void clear_has_incrtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::pp::ContactInfo* contact_;
  ::google::protobuf::int64 timestamp_;
  int incrtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactIncrement* default_instance_;
};
// -------------------------------------------------------------------

class ContactListReq : public ::google::protobuf::Message {
 public:
  ContactListReq();
  virtual ~ContactListReq();

  ContactListReq(const ContactListReq& from);

  inline ContactListReq& operator=(const ContactListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactListReq& default_instance();

  void Swap(ContactListReq* other);

  // implements Message ----------------------------------------------

  ContactListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.ContactListReq)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactListReq* default_instance_;
};
// -------------------------------------------------------------------

class ContactListRes : public ::google::protobuf::Message {
 public:
  ContactListRes();
  virtual ~ContactListRes();

  ContactListRes(const ContactListRes& from);

  inline ContactListRes& operator=(const ContactListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactListRes& default_instance();

  void Swap(ContactListRes* other);

  // implements Message ----------------------------------------------

  ContactListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // repeated .pp.ContactInfo contactList = 2;
  inline int contactlist_size() const;
  inline void clear_contactlist();
  static const int kContactListFieldNumber = 2;
  inline const ::pp::ContactInfo& contactlist(int index) const;
  inline ::pp::ContactInfo* mutable_contactlist(int index);
  inline ::pp::ContactInfo* add_contactlist();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ContactInfo >&
      contactlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ContactInfo >*
      mutable_contactlist();

  // repeated .pp.ContactIncrement increments = 3;
  inline int increments_size() const;
  inline void clear_increments();
  static const int kIncrementsFieldNumber = 3;
  inline const ::pp::ContactIncrement& increments(int index) const;
  inline ::pp::ContactIncrement* mutable_increments(int index);
  inline ::pp::ContactIncrement* add_increments();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ContactIncrement >&
      increments() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ContactIncrement >*
      mutable_increments();

  // required uint64 reqRevision = 4;
  inline bool has_reqrevision() const;
  inline void clear_reqrevision();
  static const int kReqRevisionFieldNumber = 4;
  inline ::google::protobuf::uint64 reqrevision() const;
  inline void set_reqrevision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.ContactListRes)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_reqrevision();
  inline void clear_has_reqrevision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::RepeatedPtrField< ::pp::ContactInfo > contactlist_;
  ::google::protobuf::RepeatedPtrField< ::pp::ContactIncrement > increments_;
  ::google::protobuf::uint64 reqrevision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactListRes* default_instance_;
};
// -------------------------------------------------------------------

class ContactAddReq : public ::google::protobuf::Message {
 public:
  ContactAddReq();
  virtual ~ContactAddReq();

  ContactAddReq(const ContactAddReq& from);

  inline ContactAddReq& operator=(const ContactAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactAddReq& default_instance();

  void Swap(ContactAddReq* other);

  // implements Message ----------------------------------------------

  ContactAddReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 peerUid = 1;
  inline bool has_peeruid() const;
  inline void clear_peeruid();
  static const int kPeerUidFieldNumber = 1;
  inline ::google::protobuf::uint64 peeruid() const;
  inline void set_peeruid(::google::protobuf::uint64 value);

  // optional string remark = 2;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 2;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.ContactAddReq)
 private:
  inline void set_has_peeruid();
  inline void clear_has_peeruid();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 peeruid_;
  ::std::string* remark_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactAddReq* default_instance_;
};
// -------------------------------------------------------------------

class ContactAddRes : public ::google::protobuf::Message {
 public:
  ContactAddRes();
  virtual ~ContactAddRes();

  ContactAddRes(const ContactAddRes& from);

  inline ContactAddRes& operator=(const ContactAddRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactAddRes& default_instance();

  void Swap(ContactAddRes* other);

  // implements Message ----------------------------------------------

  ContactAddRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional .pp.ContactApplyResult appResult = 2;
  inline bool has_appresult() const;
  inline void clear_appresult();
  static const int kAppResultFieldNumber = 2;
  inline ::pp::ContactApplyResult appresult() const;
  inline void set_appresult(::pp::ContactApplyResult value);

  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.ContactAddRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_appresult();
  inline void clear_has_appresult();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* remark_;
  int appresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactAddRes* default_instance_;
};
// -------------------------------------------------------------------

class ContactApproveReq : public ::google::protobuf::Message {
 public:
  ContactApproveReq();
  virtual ~ContactApproveReq();

  ContactApproveReq(const ContactApproveReq& from);

  inline ContactApproveReq& operator=(const ContactApproveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactApproveReq& default_instance();

  void Swap(ContactApproveReq* other);

  // implements Message ----------------------------------------------

  ContactApproveReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 adminUid = 2;
  inline bool has_adminuid() const;
  inline void clear_adminuid();
  static const int kAdminUidFieldNumber = 2;
  inline ::google::protobuf::uint64 adminuid() const;
  inline void set_adminuid(::google::protobuf::uint64 value);

  // required .pp.ContactApplyResult optype = 3;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 3;
  inline ::pp::ContactApplyResult optype() const;
  inline void set_optype(::pp::ContactApplyResult value);

  // optional string remark = 4;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 4;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.ContactApproveReq)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_adminuid();
  inline void clear_has_adminuid();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 adminuid_;
  ::std::string* remark_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactApproveReq* default_instance_;
};
// -------------------------------------------------------------------

class ContactApproveRes : public ::google::protobuf::Message {
 public:
  ContactApproveRes();
  virtual ~ContactApproveRes();

  ContactApproveRes(const ContactApproveRes& from);

  inline ContactApproveRes& operator=(const ContactApproveRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactApproveRes& default_instance();

  void Swap(ContactApproveRes* other);

  // implements Message ----------------------------------------------

  ContactApproveRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.ContactApplyResult applyResult = 1;
  inline bool has_applyresult() const;
  inline void clear_applyresult();
  static const int kApplyResultFieldNumber = 1;
  inline ::pp::ContactApplyResult applyresult() const;
  inline void set_applyresult(::pp::ContactApplyResult value);

  // optional string remark = 2;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 2;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.ContactApproveRes)
 private:
  inline void set_has_applyresult();
  inline void clear_has_applyresult();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* remark_;
  int applyresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactApproveRes* default_instance_;
};
// -------------------------------------------------------------------

class ContactModifyReq : public ::google::protobuf::Message {
 public:
  ContactModifyReq();
  virtual ~ContactModifyReq();

  ContactModifyReq(const ContactModifyReq& from);

  inline ContactModifyReq& operator=(const ContactModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactModifyReq& default_instance();

  void Swap(ContactModifyReq* other);

  // implements Message ----------------------------------------------

  ContactModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 peerUid = 1;
  inline bool has_peeruid() const;
  inline void clear_peeruid();
  static const int kPeerUidFieldNumber = 1;
  inline ::google::protobuf::uint64 peeruid() const;
  inline void set_peeruid(::google::protobuf::uint64 value);

  // required .pp.ContactOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::ContactOpType optype() const;
  inline void set_optype(::pp::ContactOpType value);

  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.ContactModifyReq)
 private:
  inline void set_has_peeruid();
  inline void clear_has_peeruid();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 peeruid_;
  ::std::string* remark_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class ContactModifyRes : public ::google::protobuf::Message {
 public:
  ContactModifyRes();
  virtual ~ContactModifyRes();

  ContactModifyRes(const ContactModifyRes& from);

  inline ContactModifyRes& operator=(const ContactModifyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ContactModifyRes& default_instance();

  void Swap(ContactModifyRes* other);

  // implements Message ----------------------------------------------

  ContactModifyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 peerUid = 1;
  inline bool has_peeruid() const;
  inline void clear_peeruid();
  static const int kPeerUidFieldNumber = 1;
  inline ::google::protobuf::uint64 peeruid() const;
  inline void set_peeruid(::google::protobuf::uint64 value);

  // required .pp.ContactOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::ContactOpType optype() const;
  inline void set_optype(::pp::ContactOpType value);

  // @@protoc_insertion_point(class_scope:pp.ContactModifyRes)
 private:
  inline void set_has_peeruid();
  inline void clear_has_peeruid();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 peeruid_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ContactModifyRes* default_instance_;
};
// -------------------------------------------------------------------

class KeyExchangeReq : public ::google::protobuf::Message {
 public:
  KeyExchangeReq();
  virtual ~KeyExchangeReq();

  KeyExchangeReq(const KeyExchangeReq& from);

  inline KeyExchangeReq& operator=(const KeyExchangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyExchangeReq& default_instance();

  void Swap(KeyExchangeReq* other);

  // implements Message ----------------------------------------------

  KeyExchangeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 random = 1;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 1;
  inline ::google::protobuf::int32 random() const;
  inline void set_random(::google::protobuf::int32 value);

  // optional string rsaPubKeyN = 2;
  inline bool has_rsapubkeyn() const;
  inline void clear_rsapubkeyn();
  static const int kRsaPubKeyNFieldNumber = 2;
  inline const ::std::string& rsapubkeyn() const;
  inline void set_rsapubkeyn(const ::std::string& value);
  inline void set_rsapubkeyn(const char* value);
  inline void set_rsapubkeyn(const char* value, size_t size);
  inline ::std::string* mutable_rsapubkeyn();
  inline ::std::string* release_rsapubkeyn();
  inline void set_allocated_rsapubkeyn(::std::string* rsapubkeyn);

  // optional string rsaPubKeyE = 3;
  inline bool has_rsapubkeye() const;
  inline void clear_rsapubkeye();
  static const int kRsaPubKeyEFieldNumber = 3;
  inline const ::std::string& rsapubkeye() const;
  inline void set_rsapubkeye(const ::std::string& value);
  inline void set_rsapubkeye(const char* value);
  inline void set_rsapubkeye(const char* value, size_t size);
  inline ::std::string* mutable_rsapubkeye();
  inline ::std::string* release_rsapubkeye();
  inline void set_allocated_rsapubkeye(::std::string* rsapubkeye);

  // optional bool gzip = 4;
  inline bool has_gzip() const;
  inline void clear_gzip();
  static const int kGzipFieldNumber = 4;
  inline bool gzip() const;
  inline void set_gzip(bool value);

  // @@protoc_insertion_point(class_scope:pp.KeyExchangeReq)
 private:
  inline void set_has_random();
  inline void clear_has_random();
  inline void set_has_rsapubkeyn();
  inline void clear_has_rsapubkeyn();
  inline void set_has_rsapubkeye();
  inline void clear_has_rsapubkeye();
  inline void set_has_gzip();
  inline void clear_has_gzip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* rsapubkeyn_;
  ::google::protobuf::int32 random_;
  bool gzip_;
  ::std::string* rsapubkeye_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static KeyExchangeReq* default_instance_;
};
// -------------------------------------------------------------------

class KeyExchangeRes : public ::google::protobuf::Message {
 public:
  KeyExchangeRes();
  virtual ~KeyExchangeRes();

  KeyExchangeRes(const KeyExchangeRes& from);

  inline KeyExchangeRes& operator=(const KeyExchangeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyExchangeRes& default_instance();

  void Swap(KeyExchangeRes* other);

  // implements Message ----------------------------------------------

  KeyExchangeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 random = 1;
  inline bool has_random() const;
  inline void clear_random();
  static const int kRandomFieldNumber = 1;
  inline ::google::protobuf::int32 random() const;
  inline void set_random(::google::protobuf::int32 value);

  // required string key = 2;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 2;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required .pp.EncryptType enctype = 3;
  inline bool has_enctype() const;
  inline void clear_enctype();
  static const int kEnctypeFieldNumber = 3;
  inline ::pp::EncryptType enctype() const;
  inline void set_enctype(::pp::EncryptType value);

  // optional bool gzip = 4;
  inline bool has_gzip() const;
  inline void clear_gzip();
  static const int kGzipFieldNumber = 4;
  inline bool gzip() const;
  inline void set_gzip(bool value);

  // @@protoc_insertion_point(class_scope:pp.KeyExchangeRes)
 private:
  inline void set_has_random();
  inline void clear_has_random();
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_enctype();
  inline void clear_has_enctype();
  inline void set_has_gzip();
  inline void clear_has_gzip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::google::protobuf::int32 random_;
  int enctype_;
  bool gzip_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static KeyExchangeRes* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();

  Result(const Result& from);

  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();

  void Swap(Result* other);

  // implements Message ----------------------------------------------

  Result* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool success = 1;
  inline bool has_success() const;
  inline void clear_success();
  static const int kSuccessFieldNumber = 1;
  inline bool success() const;
  inline void set_success(bool value);

  // optional .pp.ErrCode code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline ::pp::ErrCode code() const;
  inline void set_code(::pp::ErrCode value);

  // optional string remarks = 3;
  inline bool has_remarks() const;
  inline void clear_remarks();
  static const int kRemarksFieldNumber = 3;
  inline const ::std::string& remarks() const;
  inline void set_remarks(const ::std::string& value);
  inline void set_remarks(const char* value);
  inline void set_remarks(const char* value, size_t size);
  inline ::std::string* mutable_remarks();
  inline ::std::string* release_remarks();
  inline void set_allocated_remarks(::std::string* remarks);

  // optional uint64 uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 gid = 5;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 5;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 revision = 6;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 6;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional string reason = 7;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 7;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:pp.Result)
 private:
  inline void set_has_success();
  inline void clear_has_success();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_remarks();
  inline void clear_has_remarks();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool success_;
  int code_;
  ::std::string* remarks_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 revision_;
  ::std::string* reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// -------------------------------------------------------------------

class UserGameListReq : public ::google::protobuf::Message {
 public:
  UserGameListReq();
  virtual ~UserGameListReq();

  UserGameListReq(const UserGameListReq& from);

  inline UserGameListReq& operator=(const UserGameListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGameListReq& default_instance();

  void Swap(UserGameListReq* other);

  // implements Message ----------------------------------------------

  UserGameListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .pp.GameInfo template = 3;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 3;
  inline const ::pp::GameInfo& template_() const;
  inline ::pp::GameInfo* mutable_template_();
  inline ::pp::GameInfo* release_template_();
  inline void set_allocated_template_(::pp::GameInfo* template_);

  // @@protoc_insertion_point(class_scope:pp.UserGameListReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_template_();
  inline void clear_has_template_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* name_;
  ::pp::GameInfo* template__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserGameListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserGameListRes : public ::google::protobuf::Message {
 public:
  UserGameListRes();
  virtual ~UserGameListRes();

  UserGameListRes(const UserGameListRes& from);

  inline UserGameListRes& operator=(const UserGameListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGameListRes& default_instance();

  void Swap(UserGameListRes* other);

  // implements Message ----------------------------------------------

  UserGameListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // repeated .pp.GameInfo games = 2;
  inline int games_size() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 2;
  inline const ::pp::GameInfo& games(int index) const;
  inline ::pp::GameInfo* mutable_games(int index);
  inline ::pp::GameInfo* add_games();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      games() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_games();

  // required .pp.Result result = 3;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 3;
  inline const ::pp::Result& result() const;
  inline ::pp::Result* mutable_result();
  inline ::pp::Result* release_result();
  inline void set_allocated_result(::pp::Result* result);

  // optional string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pp.UserGameListRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > games_;
  ::pp::Result* result_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserGameListRes* default_instance_;
};
// -------------------------------------------------------------------

class GameReport : public ::google::protobuf::Message {
 public:
  GameReport();
  virtual ~GameReport();

  GameReport(const GameReport& from);

  inline GameReport& operator=(const GameReport& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameReport& default_instance();

  void Swap(GameReport* other);

  // implements Message ----------------------------------------------

  GameReport* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string packname = 1;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 1;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // optional string version = 2;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 2;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pp.GameReport)
 private:
  inline void set_has_packname();
  inline void clear_has_packname();
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* packname_;
  ::std::string* version_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameReport* default_instance_;
};
// -------------------------------------------------------------------

class UserGameListReportReq : public ::google::protobuf::Message {
 public:
  UserGameListReportReq();
  virtual ~UserGameListReportReq();

  UserGameListReportReq(const UserGameListReportReq& from);

  inline UserGameListReportReq& operator=(const UserGameListReportReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGameListReportReq& default_instance();

  void Swap(UserGameListReportReq* other);

  // implements Message ----------------------------------------------

  UserGameListReportReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool cleanold = 1;
  inline bool has_cleanold() const;
  inline void clear_cleanold();
  static const int kCleanoldFieldNumber = 1;
  inline bool cleanold() const;
  inline void set_cleanold(bool value);

  // repeated .pp.GameReport addgames = 2;
  inline int addgames_size() const;
  inline void clear_addgames();
  static const int kAddgamesFieldNumber = 2;
  inline const ::pp::GameReport& addgames(int index) const;
  inline ::pp::GameReport* mutable_addgames(int index);
  inline ::pp::GameReport* add_addgames();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameReport >&
      addgames() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameReport >*
      mutable_addgames();

  // repeated .pp.GameReport removegames = 3;
  inline int removegames_size() const;
  inline void clear_removegames();
  static const int kRemovegamesFieldNumber = 3;
  inline const ::pp::GameReport& removegames(int index) const;
  inline ::pp::GameReport* mutable_removegames(int index);
  inline ::pp::GameReport* add_removegames();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameReport >&
      removegames() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameReport >*
      mutable_removegames();

  // @@protoc_insertion_point(class_scope:pp.UserGameListReportReq)
 private:
  inline void set_has_cleanold();
  inline void clear_has_cleanold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameReport > addgames_;
  ::google::protobuf::RepeatedPtrField< ::pp::GameReport > removegames_;
  bool cleanold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserGameListReportReq* default_instance_;
};
// -------------------------------------------------------------------

class UserGameListReportRes : public ::google::protobuf::Message {
 public:
  UserGameListReportRes();
  virtual ~UserGameListReportRes();

  UserGameListReportRes(const UserGameListReportRes& from);

  inline UserGameListReportRes& operator=(const UserGameListReportRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGameListReportRes& default_instance();

  void Swap(UserGameListReportRes* other);

  // implements Message ----------------------------------------------

  UserGameListReportRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool cleanold = 1;
  inline bool has_cleanold() const;
  inline void clear_cleanold();
  static const int kCleanoldFieldNumber = 1;
  inline bool cleanold() const;
  inline void set_cleanold(bool value);

  // repeated .pp.GameInfo addgames = 2;
  inline int addgames_size() const;
  inline void clear_addgames();
  static const int kAddgamesFieldNumber = 2;
  inline const ::pp::GameInfo& addgames(int index) const;
  inline ::pp::GameInfo* mutable_addgames(int index);
  inline ::pp::GameInfo* add_addgames();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      addgames() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_addgames();

  // repeated uint32 removesid = 3;
  inline int removesid_size() const;
  inline void clear_removesid();
  static const int kRemovesidFieldNumber = 3;
  inline ::google::protobuf::uint32 removesid(int index) const;
  inline void set_removesid(int index, ::google::protobuf::uint32 value);
  inline void add_removesid(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      removesid() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_removesid();

  // @@protoc_insertion_point(class_scope:pp.UserGameListReportRes)
 private:
  inline void set_has_cleanold();
  inline void clear_has_cleanold();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > addgames_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > removesid_;
  bool cleanold_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserGameListReportRes* default_instance_;
};
// -------------------------------------------------------------------

class UserGameRunReportReq : public ::google::protobuf::Message {
 public:
  UserGameRunReportReq();
  virtual ~UserGameRunReportReq();

  UserGameRunReportReq(const UserGameRunReportReq& from);

  inline UserGameRunReportReq& operator=(const UserGameRunReportReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGameRunReportReq& default_instance();

  void Swap(UserGameRunReportReq* other);

  // implements Message ----------------------------------------------

  UserGameRunReportReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional .pp.GameRunReportType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::pp::GameRunReportType type() const;
  inline void set_type(::pp::GameRunReportType value);

  // @@protoc_insertion_point(class_scope:pp.UserGameRunReportReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserGameRunReportReq* default_instance_;
};
// -------------------------------------------------------------------

class UserGameRunReportRes : public ::google::protobuf::Message {
 public:
  UserGameRunReportRes();
  virtual ~UserGameRunReportRes();

  UserGameRunReportRes(const UserGameRunReportRes& from);

  inline UserGameRunReportRes& operator=(const UserGameRunReportRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserGameRunReportRes& default_instance();

  void Swap(UserGameRunReportRes* other);

  // implements Message ----------------------------------------------

  UserGameRunReportRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserGameRunReportRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserGameRunReportRes* default_instance_;
};
// -------------------------------------------------------------------

class GameGiftListReq : public ::google::protobuf::Message {
 public:
  GameGiftListReq();
  virtual ~GameGiftListReq();

  GameGiftListReq(const GameGiftListReq& from);

  inline GameGiftListReq& operator=(const GameGiftListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameGiftListReq& default_instance();

  void Swap(GameGiftListReq* other);

  // implements Message ----------------------------------------------

  GameGiftListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameGiftListReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameGiftListReq* default_instance_;
};
// -------------------------------------------------------------------

class GameGiftListRes : public ::google::protobuf::Message {
 public:
  GameGiftListRes();
  virtual ~GameGiftListRes();

  GameGiftListRes(const GameGiftListRes& from);

  inline GameGiftListRes& operator=(const GameGiftListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameGiftListRes& default_instance();

  void Swap(GameGiftListRes* other);

  // implements Message ----------------------------------------------

  GameGiftListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 gameId = 4;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 4;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 bookedNum = 5;
  inline bool has_bookednum() const;
  inline void clear_bookednum();
  static const int kBookedNumFieldNumber = 5;
  inline ::google::protobuf::uint32 bookednum() const;
  inline void set_bookednum(::google::protobuf::uint32 value);

  // optional bool booked = 6;
  inline bool has_booked() const;
  inline void clear_booked();
  static const int kBookedFieldNumber = 6;
  inline bool booked() const;
  inline void set_booked(bool value);

  // @@protoc_insertion_point(class_scope:pp.GameGiftListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_bookednum();
  inline void clear_has_bookednum();
  inline void set_has_booked();
  inline void clear_has_booked();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 bookednum_;
  bool booked_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameGiftListRes* default_instance_;
};
// -------------------------------------------------------------------

class GameGiftBookReq : public ::google::protobuf::Message {
 public:
  GameGiftBookReq();
  virtual ~GameGiftBookReq();

  GameGiftBookReq(const GameGiftBookReq& from);

  inline GameGiftBookReq& operator=(const GameGiftBookReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameGiftBookReq& default_instance();

  void Swap(GameGiftBookReq* other);

  // implements Message ----------------------------------------------

  GameGiftBookReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameGiftBookReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameGiftBookReq* default_instance_;
};
// -------------------------------------------------------------------

class GameReservableListReq : public ::google::protobuf::Message {
 public:
  GameReservableListReq();
  virtual ~GameReservableListReq();

  GameReservableListReq(const GameReservableListReq& from);

  inline GameReservableListReq& operator=(const GameReservableListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameReservableListReq& default_instance();

  void Swap(GameReservableListReq* other);

  // implements Message ----------------------------------------------

  GameReservableListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameReservableListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameReservableListReq* default_instance_;
};
// -------------------------------------------------------------------

class GameReservableListRes : public ::google::protobuf::Message {
 public:
  GameReservableListRes();
  virtual ~GameReservableListRes();

  GameReservableListRes(const GameReservableListRes& from);

  inline GameReservableListRes& operator=(const GameReservableListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameReservableListRes& default_instance();

  void Swap(GameReservableListRes* other);

  // implements Message ----------------------------------------------

  GameReservableListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GameReservableRecord records = 1;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline const ::pp::GameReservableRecord& records(int index) const;
  inline ::pp::GameReservableRecord* mutable_records(int index);
  inline ::pp::GameReservableRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameReservableRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameReservableRecord >*
      mutable_records();

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameReservableListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameReservableRecord > records_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameReservableListRes* default_instance_;
};
// -------------------------------------------------------------------

class GameSearchReq : public ::google::protobuf::Message {
 public:
  GameSearchReq();
  virtual ~GameSearchReq();

  GameSearchReq(const GameSearchReq& from);

  inline GameSearchReq& operator=(const GameSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSearchReq& default_instance();

  void Swap(GameSearchReq* other);

  // implements Message ----------------------------------------------

  GameSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional string keyword = 3;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 3;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // repeated uint32 gameids = 4;
  inline int gameids_size() const;
  inline void clear_gameids();
  static const int kGameidsFieldNumber = 4;
  inline ::google::protobuf::uint32 gameids(int index) const;
  inline void set_gameids(int index, ::google::protobuf::uint32 value);
  inline void add_gameids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gameids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gameids();

  // optional uint64 groupid = 5;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 5;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // optional .pp.GameSearchFilter filterby = 6;
  inline bool has_filterby() const;
  inline void clear_filterby();
  static const int kFilterbyFieldNumber = 6;
  inline ::pp::GameSearchFilter filterby() const;
  inline void set_filterby(::pp::GameSearchFilter value);

  // optional .pp.GameSearchSortBy sortby = 7;
  inline bool has_sortby() const;
  inline void clear_sortby();
  static const int kSortbyFieldNumber = 7;
  inline ::pp::GameSearchSortBy sortby() const;
  inline void set_sortby(::pp::GameSearchSortBy value);

  // optional .pp.GameInfo template = 8;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 8;
  inline const ::pp::GameInfo& template_() const;
  inline ::pp::GameInfo* mutable_template_();
  inline ::pp::GameInfo* release_template_();
  inline void set_allocated_template_(::pp::GameInfo* template_);

  // @@protoc_insertion_point(class_scope:pp.GameSearchReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_filterby();
  inline void clear_has_filterby();
  inline void set_has_sortby();
  inline void clear_has_sortby();
  inline void set_has_template_();
  inline void clear_has_template_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::std::string* keyword_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gameids_;
  ::google::protobuf::uint64 groupid_;
  int filterby_;
  int sortby_;
  ::pp::GameInfo* template__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class GameSearchRes : public ::google::protobuf::Message {
 public:
  GameSearchRes();
  virtual ~GameSearchRes();

  GameSearchRes(const GameSearchRes& from);

  inline GameSearchRes& operator=(const GameSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSearchRes& default_instance();

  void Swap(GameSearchRes* other);

  // implements Message ----------------------------------------------

  GameSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 totalresults = 3;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 3;
  inline ::google::protobuf::uint32 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint32 value);

  // optional string keyword = 4;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 4;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // repeated uint32 gameids = 5;
  inline int gameids_size() const;
  inline void clear_gameids();
  static const int kGameidsFieldNumber = 5;
  inline ::google::protobuf::uint32 gameids(int index) const;
  inline void set_gameids(int index, ::google::protobuf::uint32 value);
  inline void add_gameids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      gameids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_gameids();

  // optional uint64 groupid = 6;
  inline bool has_groupid() const;
  inline void clear_groupid();
  static const int kGroupidFieldNumber = 6;
  inline ::google::protobuf::uint64 groupid() const;
  inline void set_groupid(::google::protobuf::uint64 value);

  // optional .pp.GameSearchFilter filterby = 7;
  inline bool has_filterby() const;
  inline void clear_filterby();
  static const int kFilterbyFieldNumber = 7;
  inline ::pp::GameSearchFilter filterby() const;
  inline void set_filterby(::pp::GameSearchFilter value);

  // optional .pp.GameSearchSortBy sortby = 8;
  inline bool has_sortby() const;
  inline void clear_sortby();
  static const int kSortbyFieldNumber = 8;
  inline ::pp::GameSearchSortBy sortby() const;
  inline void set_sortby(::pp::GameSearchSortBy value);

  // repeated .pp.GameInfo games = 9;
  inline int games_size() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 9;
  inline const ::pp::GameInfo& games(int index) const;
  inline ::pp::GameInfo* mutable_games(int index);
  inline ::pp::GameInfo* add_games();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      games() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_games();

  // @@protoc_insertion_point(class_scope:pp.GameSearchRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_groupid();
  inline void clear_has_groupid();
  inline void set_has_filterby();
  inline void clear_has_filterby();
  inline void set_has_sortby();
  inline void clear_has_sortby();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::std::string* keyword_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > gameids_;
  ::google::protobuf::uint32 totalresults_;
  int filterby_;
  ::google::protobuf::uint64 groupid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > games_;
  int sortby_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupGameReq : public ::google::protobuf::Message {
 public:
  ModifyGroupGameReq();
  virtual ~ModifyGroupGameReq();

  ModifyGroupGameReq(const ModifyGroupGameReq& from);

  inline ModifyGroupGameReq& operator=(const ModifyGroupGameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupGameReq& default_instance();

  void Swap(ModifyGroupGameReq* other);

  // implements Message ----------------------------------------------

  ModifyGroupGameReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated uint32 addgameids = 2;
  inline int addgameids_size() const;
  inline void clear_addgameids();
  static const int kAddgameidsFieldNumber = 2;
  inline ::google::protobuf::uint32 addgameids(int index) const;
  inline void set_addgameids(int index, ::google::protobuf::uint32 value);
  inline void add_addgameids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      addgameids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_addgameids();

  // repeated uint32 removegameids = 3;
  inline int removegameids_size() const;
  inline void clear_removegameids();
  static const int kRemovegameidsFieldNumber = 3;
  inline ::google::protobuf::uint32 removegameids(int index) const;
  inline void set_removegameids(int index, ::google::protobuf::uint32 value);
  inline void add_removegameids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      removegameids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_removegameids();

  // @@protoc_insertion_point(class_scope:pp.ModifyGroupGameReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > addgameids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > removegameids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupGameReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupGameRes : public ::google::protobuf::Message {
 public:
  ModifyGroupGameRes();
  virtual ~ModifyGroupGameRes();

  ModifyGroupGameRes(const ModifyGroupGameRes& from);

  inline ModifyGroupGameRes& operator=(const ModifyGroupGameRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupGameRes& default_instance();

  void Swap(ModifyGroupGameRes* other);

  // implements Message ----------------------------------------------

  ModifyGroupGameRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated uint32 addgameids = 2;
  inline int addgameids_size() const;
  inline void clear_addgameids();
  static const int kAddgameidsFieldNumber = 2;
  inline ::google::protobuf::uint32 addgameids(int index) const;
  inline void set_addgameids(int index, ::google::protobuf::uint32 value);
  inline void add_addgameids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      addgameids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_addgameids();

  // repeated uint32 removegameids = 3;
  inline int removegameids_size() const;
  inline void clear_removegameids();
  static const int kRemovegameidsFieldNumber = 3;
  inline ::google::protobuf::uint32 removegameids(int index) const;
  inline void set_removegameids(int index, ::google::protobuf::uint32 value);
  inline void add_removegameids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      removegameids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_removegameids();

  // @@protoc_insertion_point(class_scope:pp.ModifyGroupGameRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > addgameids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > removegameids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupGameRes* default_instance_;
};
// -------------------------------------------------------------------

class DiscountInfo : public ::google::protobuf::Message {
 public:
  DiscountInfo();
  virtual ~DiscountInfo();

  DiscountInfo(const DiscountInfo& from);

  inline DiscountInfo& operator=(const DiscountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DiscountInfo& default_instance();

  void Swap(DiscountInfo* other);

  // implements Message ----------------------------------------------

  DiscountInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional string goods = 2;
  inline bool has_goods() const;
  inline void clear_goods();
  static const int kGoodsFieldNumber = 2;
  inline const ::std::string& goods() const;
  inline void set_goods(const ::std::string& value);
  inline void set_goods(const char* value);
  inline void set_goods(const char* value, size_t size);
  inline ::std::string* mutable_goods();
  inline ::std::string* release_goods();
  inline void set_allocated_goods(::std::string* goods);

  // optional string OriginalPrice = 3;
  inline bool has_originalprice() const;
  inline void clear_originalprice();
  static const int kOriginalPriceFieldNumber = 3;
  inline const ::std::string& originalprice() const;
  inline void set_originalprice(const ::std::string& value);
  inline void set_originalprice(const char* value);
  inline void set_originalprice(const char* value, size_t size);
  inline ::std::string* mutable_originalprice();
  inline ::std::string* release_originalprice();
  inline void set_allocated_originalprice(::std::string* originalprice);

  // optional string FirstDiscount = 4;
  inline bool has_firstdiscount() const;
  inline void clear_firstdiscount();
  static const int kFirstDiscountFieldNumber = 4;
  inline const ::std::string& firstdiscount() const;
  inline void set_firstdiscount(const ::std::string& value);
  inline void set_firstdiscount(const char* value);
  inline void set_firstdiscount(const char* value, size_t size);
  inline ::std::string* mutable_firstdiscount();
  inline ::std::string* release_firstdiscount();
  inline void set_allocated_firstdiscount(::std::string* firstdiscount);

  // optional string FollowDiscount = 5;
  inline bool has_followdiscount() const;
  inline void clear_followdiscount();
  static const int kFollowDiscountFieldNumber = 5;
  inline const ::std::string& followdiscount() const;
  inline void set_followdiscount(const ::std::string& value);
  inline void set_followdiscount(const char* value);
  inline void set_followdiscount(const char* value, size_t size);
  inline ::std::string* mutable_followdiscount();
  inline ::std::string* release_followdiscount();
  inline void set_allocated_followdiscount(::std::string* followdiscount);

  // optional uint32 id = 6;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 6;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint32 status = 7;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 7;
  inline ::google::protobuf::uint32 status() const;
  inline void set_status(::google::protobuf::uint32 value);

  // optional float original = 8;
  inline bool has_original() const;
  inline void clear_original();
  static const int kOriginalFieldNumber = 8;
  inline float original() const;
  inline void set_original(float value);

  // optional float first = 9;
  inline bool has_first() const;
  inline void clear_first();
  static const int kFirstFieldNumber = 9;
  inline float first() const;
  inline void set_first(float value);

  // optional float follow = 10;
  inline bool has_follow() const;
  inline void clear_follow();
  static const int kFollowFieldNumber = 10;
  inline float follow() const;
  inline void set_follow(float value);

  // optional .pp.GameInfo gameInfo = 11;
  inline bool has_gameinfo() const;
  inline void clear_gameinfo();
  static const int kGameInfoFieldNumber = 11;
  inline const ::pp::GameInfo& gameinfo() const;
  inline ::pp::GameInfo* mutable_gameinfo();
  inline ::pp::GameInfo* release_gameinfo();
  inline void set_allocated_gameinfo(::pp::GameInfo* gameinfo);

  // optional uint32 sortOrder = 12;
  inline bool has_sortorder() const;
  inline void clear_sortorder();
  static const int kSortOrderFieldNumber = 12;
  inline ::google::protobuf::uint32 sortorder() const;
  inline void set_sortorder(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.DiscountInfo)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_goods();
  inline void clear_has_goods();
  inline void set_has_originalprice();
  inline void clear_has_originalprice();
  inline void set_has_firstdiscount();
  inline void clear_has_firstdiscount();
  inline void set_has_followdiscount();
  inline void clear_has_followdiscount();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_original();
  inline void clear_has_original();
  inline void set_has_first();
  inline void clear_has_first();
  inline void set_has_follow();
  inline void clear_has_follow();
  inline void set_has_gameinfo();
  inline void clear_has_gameinfo();
  inline void set_has_sortorder();
  inline void clear_has_sortorder();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* goods_;
  ::std::string* originalprice_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 id_;
  ::std::string* firstdiscount_;
  ::std::string* followdiscount_;
  ::google::protobuf::uint32 status_;
  float original_;
  float first_;
  float follow_;
  ::pp::GameInfo* gameinfo_;
  ::google::protobuf::uint32 sortorder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static DiscountInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameDiscountListReq : public ::google::protobuf::Message {
 public:
  GameDiscountListReq();
  virtual ~GameDiscountListReq();

  GameDiscountListReq(const GameDiscountListReq& from);

  inline GameDiscountListReq& operator=(const GameDiscountListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameDiscountListReq& default_instance();

  void Swap(GameDiscountListReq* other);

  // implements Message ----------------------------------------------

  GameDiscountListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameDiscountListReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameDiscountListReq* default_instance_;
};
// -------------------------------------------------------------------

class GameDiscountListRes : public ::google::protobuf::Message {
 public:
  GameDiscountListRes();
  virtual ~GameDiscountListRes();

  GameDiscountListRes(const GameDiscountListRes& from);

  inline GameDiscountListRes& operator=(const GameDiscountListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameDiscountListRes& default_instance();

  void Swap(GameDiscountListRes* other);

  // implements Message ----------------------------------------------

  GameDiscountListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // repeated .pp.DiscountInfo discounts = 2;
  inline int discounts_size() const;
  inline void clear_discounts();
  static const int kDiscountsFieldNumber = 2;
  inline const ::pp::DiscountInfo& discounts(int index) const;
  inline ::pp::DiscountInfo* mutable_discounts(int index);
  inline ::pp::DiscountInfo* add_discounts();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >&
      discounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >*
      mutable_discounts();

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameDiscountListRes)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo > discounts_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameDiscountListRes* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupGameApkurlReq : public ::google::protobuf::Message {
 public:
  ModifyGroupGameApkurlReq();
  virtual ~ModifyGroupGameApkurlReq();

  ModifyGroupGameApkurlReq(const ModifyGroupGameApkurlReq& from);

  inline ModifyGroupGameApkurlReq& operator=(const ModifyGroupGameApkurlReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupGameApkurlReq& default_instance();

  void Swap(ModifyGroupGameApkurlReq* other);

  // implements Message ----------------------------------------------

  ModifyGroupGameApkurlReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // required uint32 gameid = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 2;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional string apkurl = 3;
  inline bool has_apkurl() const;
  inline void clear_apkurl();
  static const int kApkurlFieldNumber = 3;
  inline const ::std::string& apkurl() const;
  inline void set_apkurl(const ::std::string& value);
  inline void set_apkurl(const char* value);
  inline void set_apkurl(const char* value, size_t size);
  inline ::std::string* mutable_apkurl();
  inline ::std::string* release_apkurl();
  inline void set_allocated_apkurl(::std::string* apkurl);

  // @@protoc_insertion_point(class_scope:pp.ModifyGroupGameApkurlReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_apkurl();
  inline void clear_has_apkurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::std::string* apkurl_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupGameApkurlReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupGameApkurlRes : public ::google::protobuf::Message {
 public:
  ModifyGroupGameApkurlRes();
  virtual ~ModifyGroupGameApkurlRes();

  ModifyGroupGameApkurlRes(const ModifyGroupGameApkurlRes& from);

  inline ModifyGroupGameApkurlRes& operator=(const ModifyGroupGameApkurlRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupGameApkurlRes& default_instance();

  void Swap(ModifyGroupGameApkurlRes* other);

  // implements Message ----------------------------------------------

  ModifyGroupGameApkurlRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.ModifyGroupGameApkurlRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupGameApkurlRes* default_instance_;
};
// -------------------------------------------------------------------

class SendInstallGameMsgReq : public ::google::protobuf::Message {
 public:
  SendInstallGameMsgReq();
  virtual ~SendInstallGameMsgReq();

  SendInstallGameMsgReq(const SendInstallGameMsgReq& from);

  inline SendInstallGameMsgReq& operator=(const SendInstallGameMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendInstallGameMsgReq& default_instance();

  void Swap(SendInstallGameMsgReq* other);

  // implements Message ----------------------------------------------

  SendInstallGameMsgReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // required uint32 gameid = 2;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 2;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional .pp.SendMsgType sendtype = 3;
  inline bool has_sendtype() const;
  inline void clear_sendtype();
  static const int kSendtypeFieldNumber = 3;
  inline ::pp::SendMsgType sendtype() const;
  inline void set_sendtype(::pp::SendMsgType value);

  // repeated uint64 uids = 4;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 4;
  inline ::google::protobuf::uint64 uids(int index) const;
  inline void set_uids(int index, ::google::protobuf::uint64 value);
  inline void add_uids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uids();

  // @@protoc_insertion_point(class_scope:pp.SendInstallGameMsgReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_sendtype();
  inline void clear_has_sendtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 gameid_;
  int sendtype_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SendInstallGameMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class SendInstallGameMsgRes : public ::google::protobuf::Message {
 public:
  SendInstallGameMsgRes();
  virtual ~SendInstallGameMsgRes();

  SendInstallGameMsgRes(const SendInstallGameMsgRes& from);

  inline SendInstallGameMsgRes& operator=(const SendInstallGameMsgRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SendInstallGameMsgRes& default_instance();

  void Swap(SendInstallGameMsgRes* other);

  // implements Message ----------------------------------------------

  SendInstallGameMsgRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.SendInstallGameMsgRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SendInstallGameMsgRes* default_instance_;
};
// -------------------------------------------------------------------

class GameAddReq : public ::google::protobuf::Message {
 public:
  GameAddReq();
  virtual ~GameAddReq();

  GameAddReq(const GameAddReq& from);

  inline GameAddReq& operator=(const GameAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameAddReq& default_instance();

  void Swap(GameAddReq* other);

  // implements Message ----------------------------------------------

  GameAddReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GameInfo game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::pp::GameInfo& game() const;
  inline ::pp::GameInfo* mutable_game();
  inline ::pp::GameInfo* release_game();
  inline void set_allocated_game(::pp::GameInfo* game);

  // @@protoc_insertion_point(class_scope:pp.GameAddReq)
 private:
  inline void set_has_game();
  inline void clear_has_game();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GameInfo* game_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameAddReq* default_instance_;
};
// -------------------------------------------------------------------

class GameAddRes : public ::google::protobuf::Message {
 public:
  GameAddRes();
  virtual ~GameAddRes();

  GameAddRes(const GameAddRes& from);

  inline GameAddRes& operator=(const GameAddRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameAddRes& default_instance();

  void Swap(GameAddRes* other);

  // implements Message ----------------------------------------------

  GameAddRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GameInfo game = 1;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 1;
  inline const ::pp::GameInfo& game() const;
  inline ::pp::GameInfo* mutable_game();
  inline ::pp::GameInfo* release_game();
  inline void set_allocated_game(::pp::GameInfo* game);

  // @@protoc_insertion_point(class_scope:pp.GameAddRes)
 private:
  inline void set_has_game();
  inline void clear_has_game();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GameInfo* game_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameAddRes* default_instance_;
};
// -------------------------------------------------------------------

class GameModifyReq : public ::google::protobuf::Message {
 public:
  GameModifyReq();
  virtual ~GameModifyReq();

  GameModifyReq(const GameModifyReq& from);

  inline GameModifyReq& operator=(const GameModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameModifyReq& default_instance();

  void Swap(GameModifyReq* other);

  // implements Message ----------------------------------------------

  GameModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GameLibType gamelibtype = 1;
  inline bool has_gamelibtype() const;
  inline void clear_gamelibtype();
  static const int kGamelibtypeFieldNumber = 1;
  inline ::pp::GameLibType gamelibtype() const;
  inline void set_gamelibtype(::pp::GameLibType value);

  // repeated .pp.GameInfo games = 2;
  inline int games_size() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 2;
  inline const ::pp::GameInfo& games(int index) const;
  inline ::pp::GameInfo* mutable_games(int index);
  inline ::pp::GameInfo* add_games();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      games() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_games();

  // @@protoc_insertion_point(class_scope:pp.GameModifyReq)
 private:
  inline void set_has_gamelibtype();
  inline void clear_has_gamelibtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > games_;
  int gamelibtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class GameModifyRes : public ::google::protobuf::Message {
 public:
  GameModifyRes();
  virtual ~GameModifyRes();

  GameModifyRes(const GameModifyRes& from);

  inline GameModifyRes& operator=(const GameModifyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameModifyRes& default_instance();

  void Swap(GameModifyRes* other);

  // implements Message ----------------------------------------------

  GameModifyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GameLibType gamelibtype = 1;
  inline bool has_gamelibtype() const;
  inline void clear_gamelibtype();
  static const int kGamelibtypeFieldNumber = 1;
  inline ::pp::GameLibType gamelibtype() const;
  inline void set_gamelibtype(::pp::GameLibType value);

  // repeated .pp.GameInfo games = 2;
  inline int games_size() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 2;
  inline const ::pp::GameInfo& games(int index) const;
  inline ::pp::GameInfo* mutable_games(int index);
  inline ::pp::GameInfo* add_games();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      games() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_games();

  // @@protoc_insertion_point(class_scope:pp.GameModifyRes)
 private:
  inline void set_has_gamelibtype();
  inline void clear_has_gamelibtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > games_;
  int gamelibtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameModifyRes* default_instance_;
};
// -------------------------------------------------------------------

class ModifyOurGameStateReq : public ::google::protobuf::Message {
 public:
  ModifyOurGameStateReq();
  virtual ~ModifyOurGameStateReq();

  ModifyOurGameStateReq(const ModifyOurGameStateReq& from);

  inline ModifyOurGameStateReq& operator=(const ModifyOurGameStateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyOurGameStateReq& default_instance();

  void Swap(ModifyOurGameStateReq* other);

  // implements Message ----------------------------------------------

  ModifyOurGameStateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional .pp.ModifyGameOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::ModifyGameOpType optype() const;
  inline void set_optype(::pp::ModifyGameOpType value);

  // @@protoc_insertion_point(class_scope:pp.ModifyOurGameStateReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyOurGameStateReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyOurGameStateRes : public ::google::protobuf::Message {
 public:
  ModifyOurGameStateRes();
  virtual ~ModifyOurGameStateRes();

  ModifyOurGameStateRes(const ModifyOurGameStateRes& from);

  inline ModifyOurGameStateRes& operator=(const ModifyOurGameStateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyOurGameStateRes& default_instance();

  void Swap(ModifyOurGameStateRes* other);

  // implements Message ----------------------------------------------

  ModifyOurGameStateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional .pp.ModifyGameOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::ModifyGameOpType optype() const;
  inline void set_optype(::pp::ModifyGameOpType value);

  // @@protoc_insertion_point(class_scope:pp.ModifyOurGameStateRes)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyOurGameStateRes* default_instance_;
};
// -------------------------------------------------------------------

class SearchGamesListReq : public ::google::protobuf::Message {
 public:
  SearchGamesListReq();
  virtual ~SearchGamesListReq();

  SearchGamesListReq(const SearchGamesListReq& from);

  inline SearchGamesListReq& operator=(const SearchGamesListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchGamesListReq& default_instance();

  void Swap(SearchGamesListReq* other);

  // implements Message ----------------------------------------------

  SearchGamesListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GameLibType searchType = 1;
  inline bool has_searchtype() const;
  inline void clear_searchtype();
  static const int kSearchTypeFieldNumber = 1;
  inline ::pp::GameLibType searchtype() const;
  inline void set_searchtype(::pp::GameLibType value);

  // optional string keywords = 2;
  inline bool has_keywords() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 2;
  inline const ::std::string& keywords() const;
  inline void set_keywords(const ::std::string& value);
  inline void set_keywords(const char* value);
  inline void set_keywords(const char* value, size_t size);
  inline ::std::string* mutable_keywords();
  inline ::std::string* release_keywords();
  inline void set_allocated_keywords(::std::string* keywords);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.SearchGamesListReq)
 private:
  inline void set_has_searchtype();
  inline void clear_has_searchtype();
  inline void set_has_keywords();
  inline void clear_has_keywords();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keywords_;
  int searchtype_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SearchGamesListReq* default_instance_;
};
// -------------------------------------------------------------------

class SearchGamesListRes : public ::google::protobuf::Message {
 public:
  SearchGamesListRes();
  virtual ~SearchGamesListRes();

  SearchGamesListRes(const SearchGamesListRes& from);

  inline SearchGamesListRes& operator=(const SearchGamesListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SearchGamesListRes& default_instance();

  void Swap(SearchGamesListRes* other);

  // implements Message ----------------------------------------------

  SearchGamesListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GameInfo games = 1;
  inline int games_size() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 1;
  inline const ::pp::GameInfo& games(int index) const;
  inline ::pp::GameInfo* mutable_games(int index);
  inline ::pp::GameInfo* add_games();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      games() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_games();

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.SearchGamesListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > games_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SearchGamesListRes* default_instance_;
};
// -------------------------------------------------------------------

class GameCountReq : public ::google::protobuf::Message {
 public:
  GameCountReq();
  virtual ~GameCountReq();

  GameCountReq(const GameCountReq& from);

  inline GameCountReq& operator=(const GameCountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameCountReq& default_instance();

  void Swap(GameCountReq* other);

  // implements Message ----------------------------------------------

  GameCountReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GameLibType gamelibtype = 1;
  inline bool has_gamelibtype() const;
  inline void clear_gamelibtype();
  static const int kGamelibtypeFieldNumber = 1;
  inline ::pp::GameLibType gamelibtype() const;
  inline void set_gamelibtype(::pp::GameLibType value);

  // @@protoc_insertion_point(class_scope:pp.GameCountReq)
 private:
  inline void set_has_gamelibtype();
  inline void clear_has_gamelibtype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int gamelibtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameCountReq* default_instance_;
};
// -------------------------------------------------------------------

class GameCountRes : public ::google::protobuf::Message {
 public:
  GameCountRes();
  virtual ~GameCountRes();

  GameCountRes(const GameCountRes& from);

  inline GameCountRes& operator=(const GameCountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameCountRes& default_instance();

  void Swap(GameCountRes* other);

  // implements Message ----------------------------------------------

  GameCountRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GameLibType gamelibtype = 1;
  inline bool has_gamelibtype() const;
  inline void clear_gamelibtype();
  static const int kGamelibtypeFieldNumber = 1;
  inline ::pp::GameLibType gamelibtype() const;
  inline void set_gamelibtype(::pp::GameLibType value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameCountRes)
 private:
  inline void set_has_gamelibtype();
  inline void clear_has_gamelibtype();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int gamelibtype_;
  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameCountRes* default_instance_;
};
// -------------------------------------------------------------------

class RecommendPackNameReq : public ::google::protobuf::Message {
 public:
  RecommendPackNameReq();
  virtual ~RecommendPackNameReq();

  RecommendPackNameReq(const RecommendPackNameReq& from);

  inline RecommendPackNameReq& operator=(const RecommendPackNameReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecommendPackNameReq& default_instance();

  void Swap(RecommendPackNameReq* other);

  // implements Message ----------------------------------------------

  RecommendPackNameReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string packname = 1;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 1;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // @@protoc_insertion_point(class_scope:pp.RecommendPackNameReq)
 private:
  inline void set_has_packname();
  inline void clear_has_packname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* packname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RecommendPackNameReq* default_instance_;
};
// -------------------------------------------------------------------

class RecommendPackNameRes : public ::google::protobuf::Message {
 public:
  RecommendPackNameRes();
  virtual ~RecommendPackNameRes();

  RecommendPackNameRes(const RecommendPackNameRes& from);

  inline RecommendPackNameRes& operator=(const RecommendPackNameRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RecommendPackNameRes& default_instance();

  void Swap(RecommendPackNameRes* other);

  // implements Message ----------------------------------------------

  RecommendPackNameRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string packname = 1;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 1;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // repeated string recommendName = 2;
  inline int recommendname_size() const;
  inline void clear_recommendname();
  static const int kRecommendNameFieldNumber = 2;
  inline const ::std::string& recommendname(int index) const;
  inline ::std::string* mutable_recommendname(int index);
  inline void set_recommendname(int index, const ::std::string& value);
  inline void set_recommendname(int index, const char* value);
  inline void set_recommendname(int index, const char* value, size_t size);
  inline ::std::string* add_recommendname();
  inline void add_recommendname(const ::std::string& value);
  inline void add_recommendname(const char* value);
  inline void add_recommendname(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& recommendname() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_recommendname();

  // @@protoc_insertion_point(class_scope:pp.RecommendPackNameRes)
 private:
  inline void set_has_packname();
  inline void clear_has_packname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* packname_;
  ::google::protobuf::RepeatedPtrField< ::std::string> recommendname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RecommendPackNameRes* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGameFilterReq : public ::google::protobuf::Message {
 public:
  ModifyGameFilterReq();
  virtual ~ModifyGameFilterReq();

  ModifyGameFilterReq(const ModifyGameFilterReq& from);

  inline ModifyGameFilterReq& operator=(const ModifyGameFilterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGameFilterReq& default_instance();

  void Swap(ModifyGameFilterReq* other);

  // implements Message ----------------------------------------------

  ModifyGameFilterReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.ModifyGameOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::ModifyGameOpType optype() const;
  inline void set_optype(::pp::ModifyGameOpType value);

  // optional string srcpackname = 2;
  inline bool has_srcpackname() const;
  inline void clear_srcpackname();
  static const int kSrcpacknameFieldNumber = 2;
  inline const ::std::string& srcpackname() const;
  inline void set_srcpackname(const ::std::string& value);
  inline void set_srcpackname(const char* value);
  inline void set_srcpackname(const char* value, size_t size);
  inline ::std::string* mutable_srcpackname();
  inline ::std::string* release_srcpackname();
  inline void set_allocated_srcpackname(::std::string* srcpackname);

  // optional string packname = 3;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 3;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // @@protoc_insertion_point(class_scope:pp.ModifyGameFilterReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_srcpackname();
  inline void clear_has_srcpackname();
  inline void set_has_packname();
  inline void clear_has_packname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* srcpackname_;
  ::std::string* packname_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGameFilterReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGameFilterRes : public ::google::protobuf::Message {
 public:
  ModifyGameFilterRes();
  virtual ~ModifyGameFilterRes();

  ModifyGameFilterRes(const ModifyGameFilterRes& from);

  inline ModifyGameFilterRes& operator=(const ModifyGameFilterRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGameFilterRes& default_instance();

  void Swap(ModifyGameFilterRes* other);

  // implements Message ----------------------------------------------

  ModifyGameFilterRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.ModifyGameOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::ModifyGameOpType optype() const;
  inline void set_optype(::pp::ModifyGameOpType value);

  // optional string srcpackname = 2;
  inline bool has_srcpackname() const;
  inline void clear_srcpackname();
  static const int kSrcpacknameFieldNumber = 2;
  inline const ::std::string& srcpackname() const;
  inline void set_srcpackname(const ::std::string& value);
  inline void set_srcpackname(const char* value);
  inline void set_srcpackname(const char* value, size_t size);
  inline ::std::string* mutable_srcpackname();
  inline ::std::string* release_srcpackname();
  inline void set_allocated_srcpackname(::std::string* srcpackname);

  // optional string packname = 3;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 3;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // @@protoc_insertion_point(class_scope:pp.ModifyGameFilterRes)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_srcpackname();
  inline void clear_has_srcpackname();
  inline void set_has_packname();
  inline void clear_has_packname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* srcpackname_;
  ::std::string* packname_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGameFilterRes* default_instance_;
};
// -------------------------------------------------------------------

class GameFilterInfo : public ::google::protobuf::Message {
 public:
  GameFilterInfo();
  virtual ~GameFilterInfo();

  GameFilterInfo(const GameFilterInfo& from);

  inline GameFilterInfo& operator=(const GameFilterInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameFilterInfo& default_instance();

  void Swap(GameFilterInfo* other);

  // implements Message ----------------------------------------------

  GameFilterInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string srcpackname = 1;
  inline bool has_srcpackname() const;
  inline void clear_srcpackname();
  static const int kSrcpacknameFieldNumber = 1;
  inline const ::std::string& srcpackname() const;
  inline void set_srcpackname(const ::std::string& value);
  inline void set_srcpackname(const char* value);
  inline void set_srcpackname(const char* value, size_t size);
  inline ::std::string* mutable_srcpackname();
  inline ::std::string* release_srcpackname();
  inline void set_allocated_srcpackname(::std::string* srcpackname);

  // optional string packname = 2;
  inline bool has_packname() const;
  inline void clear_packname();
  static const int kPacknameFieldNumber = 2;
  inline const ::std::string& packname() const;
  inline void set_packname(const ::std::string& value);
  inline void set_packname(const char* value);
  inline void set_packname(const char* value, size_t size);
  inline ::std::string* mutable_packname();
  inline ::std::string* release_packname();
  inline void set_allocated_packname(::std::string* packname);

  // @@protoc_insertion_point(class_scope:pp.GameFilterInfo)
 private:
  inline void set_has_srcpackname();
  inline void clear_has_srcpackname();
  inline void set_has_packname();
  inline void clear_has_packname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* srcpackname_;
  ::std::string* packname_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameFilterInfo* default_instance_;
};
// -------------------------------------------------------------------

class GameFilterSearchReq : public ::google::protobuf::Message {
 public:
  GameFilterSearchReq();
  virtual ~GameFilterSearchReq();

  GameFilterSearchReq(const GameFilterSearchReq& from);

  inline GameFilterSearchReq& operator=(const GameFilterSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameFilterSearchReq& default_instance();

  void Swap(GameFilterSearchReq* other);

  // implements Message ----------------------------------------------

  GameFilterSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional string keyword = 3;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 3;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional .pp.GameFilterType filterby = 4;
  inline bool has_filterby() const;
  inline void clear_filterby();
  static const int kFilterbyFieldNumber = 4;
  inline ::pp::GameFilterType filterby() const;
  inline void set_filterby(::pp::GameFilterType value);

  // @@protoc_insertion_point(class_scope:pp.GameFilterSearchReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_filterby();
  inline void clear_has_filterby();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::std::string* keyword_;
  int filterby_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameFilterSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class GameFilterSearchRes : public ::google::protobuf::Message {
 public:
  GameFilterSearchRes();
  virtual ~GameFilterSearchRes();

  GameFilterSearchRes(const GameFilterSearchRes& from);

  inline GameFilterSearchRes& operator=(const GameFilterSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameFilterSearchRes& default_instance();

  void Swap(GameFilterSearchRes* other);

  // implements Message ----------------------------------------------

  GameFilterSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional string keyword = 3;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 3;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional .pp.GameFilterType filterby = 4;
  inline bool has_filterby() const;
  inline void clear_filterby();
  static const int kFilterbyFieldNumber = 4;
  inline ::pp::GameFilterType filterby() const;
  inline void set_filterby(::pp::GameFilterType value);

  // repeated .pp.GameFilterInfo gameFilters = 5;
  inline int gamefilters_size() const;
  inline void clear_gamefilters();
  static const int kGameFiltersFieldNumber = 5;
  inline const ::pp::GameFilterInfo& gamefilters(int index) const;
  inline ::pp::GameFilterInfo* mutable_gamefilters(int index);
  inline ::pp::GameFilterInfo* add_gamefilters();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameFilterInfo >&
      gamefilters() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameFilterInfo >*
      mutable_gamefilters();

  // @@protoc_insertion_point(class_scope:pp.GameFilterSearchRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_filterby();
  inline void clear_has_filterby();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::std::string* keyword_;
  ::google::protobuf::RepeatedPtrField< ::pp::GameFilterInfo > gamefilters_;
  int filterby_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameFilterSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class GameSpiderReq : public ::google::protobuf::Message {
 public:
  GameSpiderReq();
  virtual ~GameSpiderReq();

  GameSpiderReq(const GameSpiderReq& from);

  inline GameSpiderReq& operator=(const GameSpiderReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSpiderReq& default_instance();

  void Swap(GameSpiderReq* other);

  // implements Message ----------------------------------------------

  GameSpiderReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.SpiderSrcFliter srcfilter = 1;
  inline bool has_srcfilter() const;
  inline void clear_srcfilter();
  static const int kSrcfilterFieldNumber = 1;
  inline ::pp::SpiderSrcFliter srcfilter() const;
  inline void set_srcfilter(::pp::SpiderSrcFliter value);

  // optional .pp.SpiderMethodFilter methodfilter = 2;
  inline bool has_methodfilter() const;
  inline void clear_methodfilter();
  static const int kMethodfilterFieldNumber = 2;
  inline ::pp::SpiderMethodFilter methodfilter() const;
  inline void set_methodfilter(::pp::SpiderMethodFilter value);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 pagesize = 4;
  inline bool has_pagesize() const;
  inline void clear_pagesize();
  static const int kPagesizeFieldNumber = 4;
  inline ::google::protobuf::uint32 pagesize() const;
  inline void set_pagesize(::google::protobuf::uint32 value);

  // optional uint32 totalcount = 5;
  inline bool has_totalcount() const;
  inline void clear_totalcount();
  static const int kTotalcountFieldNumber = 5;
  inline ::google::protobuf::uint32 totalcount() const;
  inline void set_totalcount(::google::protobuf::uint32 value);

  // optional uint32 minr = 6;
  inline bool has_minr() const;
  inline void clear_minr();
  static const int kMinrFieldNumber = 6;
  inline ::google::protobuf::uint32 minr() const;
  inline void set_minr(::google::protobuf::uint32 value);

  // optional uint32 maxr = 7;
  inline bool has_maxr() const;
  inline void clear_maxr();
  static const int kMaxrFieldNumber = 7;
  inline ::google::protobuf::uint32 maxr() const;
  inline void set_maxr(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GameSpiderReq)
 private:
  inline void set_has_srcfilter();
  inline void clear_has_srcfilter();
  inline void set_has_methodfilter();
  inline void clear_has_methodfilter();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_pagesize();
  inline void clear_has_pagesize();
  inline void set_has_totalcount();
  inline void clear_has_totalcount();
  inline void set_has_minr();
  inline void clear_has_minr();
  inline void set_has_maxr();
  inline void clear_has_maxr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int srcfilter_;
  int methodfilter_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 pagesize_;
  ::google::protobuf::uint32 totalcount_;
  ::google::protobuf::uint32 minr_;
  ::google::protobuf::uint32 maxr_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameSpiderReq* default_instance_;
};
// -------------------------------------------------------------------

class GameSpiderRes : public ::google::protobuf::Message {
 public:
  GameSpiderRes();
  virtual ~GameSpiderRes();

  GameSpiderRes(const GameSpiderRes& from);

  inline GameSpiderRes& operator=(const GameSpiderRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameSpiderRes& default_instance();

  void Swap(GameSpiderRes* other);

  // implements Message ----------------------------------------------

  GameSpiderRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.GameSpiderRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GameSpiderRes* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGameDiscountReq : public ::google::protobuf::Message {
 public:
  ModifyGameDiscountReq();
  virtual ~ModifyGameDiscountReq();

  ModifyGameDiscountReq(const ModifyGameDiscountReq& from);

  inline ModifyGameDiscountReq& operator=(const ModifyGameDiscountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGameDiscountReq& default_instance();

  void Swap(ModifyGameDiscountReq* other);

  // implements Message ----------------------------------------------

  ModifyGameDiscountReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.ModifyGameOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::ModifyGameOpType optype() const;
  inline void set_optype(::pp::ModifyGameOpType value);

  // repeated .pp.DiscountInfo discounts = 2;
  inline int discounts_size() const;
  inline void clear_discounts();
  static const int kDiscountsFieldNumber = 2;
  inline const ::pp::DiscountInfo& discounts(int index) const;
  inline ::pp::DiscountInfo* mutable_discounts(int index);
  inline ::pp::DiscountInfo* add_discounts();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >&
      discounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >*
      mutable_discounts();

  // @@protoc_insertion_point(class_scope:pp.ModifyGameDiscountReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo > discounts_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGameDiscountReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGameDiscountRes : public ::google::protobuf::Message {
 public:
  ModifyGameDiscountRes();
  virtual ~ModifyGameDiscountRes();

  ModifyGameDiscountRes(const ModifyGameDiscountRes& from);

  inline ModifyGameDiscountRes& operator=(const ModifyGameDiscountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGameDiscountRes& default_instance();

  void Swap(ModifyGameDiscountRes* other);

  // implements Message ----------------------------------------------

  ModifyGameDiscountRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.ModifyGameOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::ModifyGameOpType optype() const;
  inline void set_optype(::pp::ModifyGameOpType value);

  // repeated .pp.DiscountInfo discounts = 2;
  inline int discounts_size() const;
  inline void clear_discounts();
  static const int kDiscountsFieldNumber = 2;
  inline const ::pp::DiscountInfo& discounts(int index) const;
  inline ::pp::DiscountInfo* mutable_discounts(int index);
  inline ::pp::DiscountInfo* add_discounts();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >&
      discounts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >*
      mutable_discounts();

  // @@protoc_insertion_point(class_scope:pp.ModifyGameDiscountRes)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo > discounts_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGameDiscountRes* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupDiscountReq : public ::google::protobuf::Message {
 public:
  ModifyGroupDiscountReq();
  virtual ~ModifyGroupDiscountReq();

  ModifyGroupDiscountReq(const ModifyGroupDiscountReq& from);

  inline ModifyGroupDiscountReq& operator=(const ModifyGroupDiscountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupDiscountReq& default_instance();

  void Swap(ModifyGroupDiscountReq* other);

  // implements Message ----------------------------------------------

  ModifyGroupDiscountReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // repeated uint64 gids = 2;
  inline int gids_size() const;
  inline void clear_gids();
  static const int kGidsFieldNumber = 2;
  inline ::google::protobuf::uint64 gids(int index) const;
  inline void set_gids(int index, ::google::protobuf::uint64 value);
  inline void add_gids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      gids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_gids();

  // @@protoc_insertion_point(class_scope:pp.ModifyGroupDiscountReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > gids_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupDiscountReq* default_instance_;
};
// -------------------------------------------------------------------

class ModifyGroupDiscountRes : public ::google::protobuf::Message {
 public:
  ModifyGroupDiscountRes();
  virtual ~ModifyGroupDiscountRes();

  ModifyGroupDiscountRes(const ModifyGroupDiscountRes& from);

  inline ModifyGroupDiscountRes& operator=(const ModifyGroupDiscountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ModifyGroupDiscountRes& default_instance();

  void Swap(ModifyGroupDiscountRes* other);

  // implements Message ----------------------------------------------

  ModifyGroupDiscountRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // repeated uint64 gids = 2;
  inline int gids_size() const;
  inline void clear_gids();
  static const int kGidsFieldNumber = 2;
  inline ::google::protobuf::uint64 gids(int index) const;
  inline void set_gids(int index, ::google::protobuf::uint64 value);
  inline void add_gids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      gids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_gids();

  // @@protoc_insertion_point(class_scope:pp.ModifyGroupDiscountRes)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > gids_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ModifyGroupDiscountRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupDiscountListReq : public ::google::protobuf::Message {
 public:
  GroupDiscountListReq();
  virtual ~GroupDiscountListReq();

  GroupDiscountListReq(const GroupDiscountListReq& from);

  inline GroupDiscountListReq& operator=(const GroupDiscountListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupDiscountListReq& default_instance();

  void Swap(GroupDiscountListReq* other);

  // implements Message ----------------------------------------------

  GroupDiscountListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupDiscountListReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupDiscountListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupDiscountListRes : public ::google::protobuf::Message {
 public:
  GroupDiscountListRes();
  virtual ~GroupDiscountListRes();

  GroupDiscountListRes(const GroupDiscountListRes& from);

  inline GroupDiscountListRes& operator=(const GroupDiscountListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupDiscountListRes& default_instance();

  void Swap(GroupDiscountListRes* other);

  // implements Message ----------------------------------------------

  GroupDiscountListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gameid = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional string gids = 2;
  inline bool has_gids() const;
  inline void clear_gids();
  static const int kGidsFieldNumber = 2;
  inline const ::std::string& gids() const;
  inline void set_gids(const ::std::string& value);
  inline void set_gids(const char* value);
  inline void set_gids(const char* value, size_t size);
  inline ::std::string* mutable_gids();
  inline ::std::string* release_gids();
  inline void set_allocated_gids(::std::string* gids);

  // @@protoc_insertion_point(class_scope:pp.GroupDiscountListRes)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_gids();
  inline void clear_has_gids();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* gids_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupDiscountListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsPayMethodReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsPayMethodReq();
  virtual ~UserYYCoinsPayMethodReq();

  UserYYCoinsPayMethodReq(const UserYYCoinsPayMethodReq& from);

  inline UserYYCoinsPayMethodReq& operator=(const UserYYCoinsPayMethodReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsPayMethodReq& default_instance();

  void Swap(UserYYCoinsPayMethodReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsPayMethodReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsPayMethodReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsPayMethodReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsPayMethod : public ::google::protobuf::Message {
 public:
  UserYYCoinsPayMethod();
  virtual ~UserYYCoinsPayMethod();

  UserYYCoinsPayMethod(const UserYYCoinsPayMethod& from);

  inline UserYYCoinsPayMethod& operator=(const UserYYCoinsPayMethod& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsPayMethod& default_instance();

  void Swap(UserYYCoinsPayMethod* other);

  // implements Message ----------------------------------------------

  UserYYCoinsPayMethod* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string chId = 2;
  inline bool has_chid() const;
  inline void clear_chid();
  static const int kChIdFieldNumber = 2;
  inline const ::std::string& chid() const;
  inline void set_chid(const ::std::string& value);
  inline void set_chid(const char* value);
  inline void set_chid(const char* value, size_t size);
  inline ::std::string* mutable_chid();
  inline ::std::string* release_chid();
  inline void set_allocated_chid(::std::string* chid);

  // required string payMethod = 3;
  inline bool has_paymethod() const;
  inline void clear_paymethod();
  static const int kPayMethodFieldNumber = 3;
  inline const ::std::string& paymethod() const;
  inline void set_paymethod(const ::std::string& value);
  inline void set_paymethod(const char* value);
  inline void set_paymethod(const char* value, size_t size);
  inline ::std::string* mutable_paymethod();
  inline ::std::string* release_paymethod();
  inline void set_allocated_paymethod(::std::string* paymethod);

  // optional bool tel = 4;
  inline bool has_tel() const;
  inline void clear_tel();
  static const int kTelFieldNumber = 4;
  inline bool tel() const;
  inline void set_tel(bool value);

  // optional bool card = 5;
  inline bool has_card() const;
  inline void clear_card();
  static const int kCardFieldNumber = 5;
  inline bool card() const;
  inline void set_card(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsPayMethod)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_chid();
  inline void clear_has_chid();
  inline void set_has_paymethod();
  inline void clear_has_paymethod();
  inline void set_has_tel();
  inline void clear_has_tel();
  inline void set_has_card();
  inline void clear_has_card();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* chid_;
  ::std::string* paymethod_;
  bool tel_;
  bool card_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsPayMethod* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsPayMethodRes : public ::google::protobuf::Message {
 public:
  UserYYCoinsPayMethodRes();
  virtual ~UserYYCoinsPayMethodRes();

  UserYYCoinsPayMethodRes(const UserYYCoinsPayMethodRes& from);

  inline UserYYCoinsPayMethodRes& operator=(const UserYYCoinsPayMethodRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsPayMethodRes& default_instance();

  void Swap(UserYYCoinsPayMethodRes* other);

  // implements Message ----------------------------------------------

  UserYYCoinsPayMethodRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserYYCoinsPayMethod methods = 1;
  inline int methods_size() const;
  inline void clear_methods();
  static const int kMethodsFieldNumber = 1;
  inline const ::pp::UserYYCoinsPayMethod& methods(int index) const;
  inline ::pp::UserYYCoinsPayMethod* mutable_methods(int index);
  inline ::pp::UserYYCoinsPayMethod* add_methods();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsPayMethod >&
      methods() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsPayMethod >*
      mutable_methods();

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsPayMethodRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsPayMethod > methods_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsPayMethodRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsBuyReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsBuyReq();
  virtual ~UserYYCoinsBuyReq();

  UserYYCoinsBuyReq(const UserYYCoinsBuyReq& from);

  inline UserYYCoinsBuyReq& operator=(const UserYYCoinsBuyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsBuyReq& default_instance();

  void Swap(UserYYCoinsBuyReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsBuyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional string chId = 3 [default = "Zfb"];
  inline bool has_chid() const;
  inline void clear_chid();
  static const int kChIdFieldNumber = 3;
  inline const ::std::string& chid() const;
  inline void set_chid(const ::std::string& value);
  inline void set_chid(const char* value);
  inline void set_chid(const char* value, size_t size);
  inline ::std::string* mutable_chid();
  inline ::std::string* release_chid();
  inline void set_allocated_chid(::std::string* chid);

  // optional string payMethod = 4 [default = "WapAlipay"];
  inline bool has_paymethod() const;
  inline void clear_paymethod();
  static const int kPayMethodFieldNumber = 4;
  inline const ::std::string& paymethod() const;
  inline void set_paymethod(const ::std::string& value);
  inline void set_paymethod(const char* value);
  inline void set_paymethod(const char* value, size_t size);
  inline ::std::string* mutable_paymethod();
  inline ::std::string* release_paymethod();
  inline void set_allocated_paymethod(::std::string* paymethod);

  // optional string tel = 5;
  inline bool has_tel() const;
  inline void clear_tel();
  static const int kTelFieldNumber = 5;
  inline const ::std::string& tel() const;
  inline void set_tel(const ::std::string& value);
  inline void set_tel(const char* value);
  inline void set_tel(const char* value, size_t size);
  inline ::std::string* mutable_tel();
  inline ::std::string* release_tel();
  inline void set_allocated_tel(::std::string* tel);

  // optional string cardNum = 6;
  inline bool has_cardnum() const;
  inline void clear_cardnum();
  static const int kCardNumFieldNumber = 6;
  inline const ::std::string& cardnum() const;
  inline void set_cardnum(const ::std::string& value);
  inline void set_cardnum(const char* value);
  inline void set_cardnum(const char* value, size_t size);
  inline ::std::string* mutable_cardnum();
  inline ::std::string* release_cardnum();
  inline void set_allocated_cardnum(::std::string* cardnum);

  // optional string cardPass = 7;
  inline bool has_cardpass() const;
  inline void clear_cardpass();
  static const int kCardPassFieldNumber = 7;
  inline const ::std::string& cardpass() const;
  inline void set_cardpass(const ::std::string& value);
  inline void set_cardpass(const char* value);
  inline void set_cardpass(const char* value, size_t size);
  inline ::std::string* mutable_cardpass();
  inline ::std::string* release_cardpass();
  inline void set_allocated_cardpass(::std::string* cardpass);

  // optional uint64 uid = 8;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 8;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsBuyReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_chid();
  inline void clear_has_chid();
  inline void set_has_paymethod();
  inline void clear_has_paymethod();
  inline void set_has_tel();
  inline void clear_has_tel();
  inline void set_has_cardnum();
  inline void clear_has_cardnum();
  inline void set_has_cardpass();
  inline void clear_has_cardpass();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 num_;
  ::std::string* chid_;
  static ::std::string* _default_chid_;
  ::std::string* paymethod_;
  static ::std::string* _default_paymethod_;
  ::std::string* tel_;
  ::std::string* cardnum_;
  ::std::string* cardpass_;
  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsBuyReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsBuyRes : public ::google::protobuf::Message {
 public:
  UserYYCoinsBuyRes();
  virtual ~UserYYCoinsBuyRes();

  UserYYCoinsBuyRes(const UserYYCoinsBuyRes& from);

  inline UserYYCoinsBuyRes& operator=(const UserYYCoinsBuyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsBuyRes& default_instance();

  void Swap(UserYYCoinsBuyRes* other);

  // implements Message ----------------------------------------------

  UserYYCoinsBuyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 orderid = 2;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderidFieldNumber = 2;
  inline ::google::protobuf::uint64 orderid() const;
  inline void set_orderid(::google::protobuf::uint64 value);

  // optional string payurl = 3;
  inline bool has_payurl() const;
  inline void clear_payurl();
  static const int kPayurlFieldNumber = 3;
  inline const ::std::string& payurl() const;
  inline void set_payurl(const ::std::string& value);
  inline void set_payurl(const char* value);
  inline void set_payurl(const char* value, size_t size);
  inline ::std::string* mutable_payurl();
  inline ::std::string* release_payurl();
  inline void set_allocated_payurl(::std::string* payurl);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsBuyRes)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_payurl();
  inline void clear_has_payurl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 orderid_;
  ::std::string* payurl_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsBuyRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsBuyFeedbackReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsBuyFeedbackReq();
  virtual ~UserYYCoinsBuyFeedbackReq();

  UserYYCoinsBuyFeedbackReq(const UserYYCoinsBuyFeedbackReq& from);

  inline UserYYCoinsBuyFeedbackReq& operator=(const UserYYCoinsBuyFeedbackReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsBuyFeedbackReq& default_instance();

  void Swap(UserYYCoinsBuyFeedbackReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsBuyFeedbackReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 orderid = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderidFieldNumber = 1;
  inline ::google::protobuf::uint64 orderid() const;
  inline void set_orderid(::google::protobuf::uint64 value);

  // optional string appStoreReceipt = 2;
  inline bool has_appstorereceipt() const;
  inline void clear_appstorereceipt();
  static const int kAppStoreReceiptFieldNumber = 2;
  inline const ::std::string& appstorereceipt() const;
  inline void set_appstorereceipt(const ::std::string& value);
  inline void set_appstorereceipt(const char* value);
  inline void set_appstorereceipt(const char* value, size_t size);
  inline ::std::string* mutable_appstorereceipt();
  inline ::std::string* release_appstorereceipt();
  inline void set_allocated_appstorereceipt(::std::string* appstorereceipt);

  // optional string appStoreTransactionId = 3;
  inline bool has_appstoretransactionid() const;
  inline void clear_appstoretransactionid();
  static const int kAppStoreTransactionIdFieldNumber = 3;
  inline const ::std::string& appstoretransactionid() const;
  inline void set_appstoretransactionid(const ::std::string& value);
  inline void set_appstoretransactionid(const char* value);
  inline void set_appstoretransactionid(const char* value, size_t size);
  inline ::std::string* mutable_appstoretransactionid();
  inline ::std::string* release_appstoretransactionid();
  inline void set_allocated_appstoretransactionid(::std::string* appstoretransactionid);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsBuyFeedbackReq)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_appstorereceipt();
  inline void clear_has_appstorereceipt();
  inline void set_has_appstoretransactionid();
  inline void clear_has_appstoretransactionid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 orderid_;
  ::std::string* appstorereceipt_;
  ::std::string* appstoretransactionid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsBuyFeedbackReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsBuyFeedbackRes : public ::google::protobuf::Message {
 public:
  UserYYCoinsBuyFeedbackRes();
  virtual ~UserYYCoinsBuyFeedbackRes();

  UserYYCoinsBuyFeedbackRes(const UserYYCoinsBuyFeedbackRes& from);

  inline UserYYCoinsBuyFeedbackRes& operator=(const UserYYCoinsBuyFeedbackRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsBuyFeedbackRes& default_instance();

  void Swap(UserYYCoinsBuyFeedbackRes* other);

  // implements Message ----------------------------------------------

  UserYYCoinsBuyFeedbackRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 orderid = 2;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderidFieldNumber = 2;
  inline ::google::protobuf::uint64 orderid() const;
  inline void set_orderid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsBuyFeedbackRes)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 orderid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsBuyFeedbackRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsRecord : public ::google::protobuf::Message {
 public:
  UserYYCoinsRecord();
  virtual ~UserYYCoinsRecord();

  UserYYCoinsRecord(const UserYYCoinsRecord& from);

  inline UserYYCoinsRecord& operator=(const UserYYCoinsRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsRecord& default_instance();

  void Swap(UserYYCoinsRecord* other);

  // implements Message ----------------------------------------------

  UserYYCoinsRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserYYCoinsRecord_OrderType OrderType;
  static const OrderType Buy = UserYYCoinsRecord_OrderType_Buy;
  static inline bool OrderType_IsValid(int value) {
    return UserYYCoinsRecord_OrderType_IsValid(value);
  }
  static const OrderType OrderType_MIN =
    UserYYCoinsRecord_OrderType_OrderType_MIN;
  static const OrderType OrderType_MAX =
    UserYYCoinsRecord_OrderType_OrderType_MAX;
  static const int OrderType_ARRAYSIZE =
    UserYYCoinsRecord_OrderType_OrderType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OrderType_descriptor() {
    return UserYYCoinsRecord_OrderType_descriptor();
  }
  static inline const ::std::string& OrderType_Name(OrderType value) {
    return UserYYCoinsRecord_OrderType_Name(value);
  }
  static inline bool OrderType_Parse(const ::std::string& name,
      OrderType* value) {
    return UserYYCoinsRecord_OrderType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint64 orderId = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  inline ::google::protobuf::uint64 orderid() const;
  inline void set_orderid(::google::protobuf::uint64 value);

  // required uint32 itemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // required uint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // required .pp.UserYYCoinsRecord.OrderType orderType = 4;
  inline bool has_ordertype() const;
  inline void clear_ordertype();
  static const int kOrderTypeFieldNumber = 4;
  inline ::pp::UserYYCoinsRecord_OrderType ordertype() const;
  inline void set_ordertype(::pp::UserYYCoinsRecord_OrderType value);

  // optional int64 createtime = 5;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 5;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional string remarks = 6;
  inline bool has_remarks() const;
  inline void clear_remarks();
  static const int kRemarksFieldNumber = 6;
  inline const ::std::string& remarks() const;
  inline void set_remarks(const ::std::string& value);
  inline void set_remarks(const char* value);
  inline void set_remarks(const char* value, size_t size);
  inline ::std::string* mutable_remarks();
  inline ::std::string* release_remarks();
  inline void set_allocated_remarks(::std::string* remarks);

  // optional .pp.UserYYCoinsOrderState state = 7;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 7;
  inline ::pp::UserYYCoinsOrderState state() const;
  inline void set_state(::pp::UserYYCoinsOrderState value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsRecord)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_ordertype();
  inline void clear_has_ordertype();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_remarks();
  inline void clear_has_remarks();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 orderid_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::int64 createtime_;
  int ordertype_;
  int state_;
  ::std::string* remarks_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsRecord* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsQueryReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsQueryReq();
  virtual ~UserYYCoinsQueryReq();

  UserYYCoinsQueryReq(const UserYYCoinsQueryReq& from);

  inline UserYYCoinsQueryReq& operator=(const UserYYCoinsQueryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsQueryReq& default_instance();

  void Swap(UserYYCoinsQueryReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsQueryReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsQueryReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsQueryReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsQueryRes : public ::google::protobuf::Message {
 public:
  UserYYCoinsQueryRes();
  virtual ~UserYYCoinsQueryRes();

  UserYYCoinsQueryRes(const UserYYCoinsQueryRes& from);

  inline UserYYCoinsQueryRes& operator=(const UserYYCoinsQueryRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsQueryRes& default_instance();

  void Swap(UserYYCoinsQueryRes* other);

  // implements Message ----------------------------------------------

  UserYYCoinsQueryRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 yyuid = 1;
  inline bool has_yyuid() const;
  inline void clear_yyuid();
  static const int kYyuidFieldNumber = 1;
  inline ::google::protobuf::uint64 yyuid() const;
  inline void set_yyuid(::google::protobuf::uint64 value);

  // optional float coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline float coins() const;
  inline void set_coins(float value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsQueryRes)
 private:
  inline void set_has_yyuid();
  inline void clear_has_yyuid();
  inline void set_has_coins();
  inline void clear_has_coins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 yyuid_;
  float coins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsQueryRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsHistoryReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsHistoryReq();
  virtual ~UserYYCoinsHistoryReq();

  UserYYCoinsHistoryReq(const UserYYCoinsHistoryReq& from);

  inline UserYYCoinsHistoryReq& operator=(const UserYYCoinsHistoryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsHistoryReq& default_instance();

  void Swap(UserYYCoinsHistoryReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsHistoryReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserYYCoinsOrderState state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::pp::UserYYCoinsOrderState state() const;
  inline void set_state(::pp::UserYYCoinsOrderState value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsHistoryReq)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsHistoryReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsHistoryRes : public ::google::protobuf::Message {
 public:
  UserYYCoinsHistoryRes();
  virtual ~UserYYCoinsHistoryRes();

  UserYYCoinsHistoryRes(const UserYYCoinsHistoryRes& from);

  inline UserYYCoinsHistoryRes& operator=(const UserYYCoinsHistoryRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsHistoryRes& default_instance();

  void Swap(UserYYCoinsHistoryRes* other);

  // implements Message ----------------------------------------------

  UserYYCoinsHistoryRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 totalnum = 1;
  inline bool has_totalnum() const;
  inline void clear_totalnum();
  static const int kTotalnumFieldNumber = 1;
  inline ::google::protobuf::int32 totalnum() const;
  inline void set_totalnum(::google::protobuf::int32 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 totalrecord = 4;
  inline bool has_totalrecord() const;
  inline void clear_totalrecord();
  static const int kTotalrecordFieldNumber = 4;
  inline ::google::protobuf::uint32 totalrecord() const;
  inline void set_totalrecord(::google::protobuf::uint32 value);

  // repeated .pp.UserYYCoinsRecord records = 5;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 5;
  inline const ::pp::UserYYCoinsRecord& records(int index) const;
  inline ::pp::UserYYCoinsRecord* mutable_records(int index);
  inline ::pp::UserYYCoinsRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsRecord >*
      mutable_records();

  // optional .pp.UserYYCoinsOrderState state = 6;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 6;
  inline ::pp::UserYYCoinsOrderState state() const;
  inline void set_state(::pp::UserYYCoinsOrderState value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsHistoryRes)
 private:
  inline void set_has_totalnum();
  inline void clear_has_totalnum();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_totalrecord();
  inline void clear_has_totalrecord();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 totalnum_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 totalrecord_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsRecord > records_;
  int state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsHistoryRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsPayGateCallbackReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsPayGateCallbackReq();
  virtual ~UserYYCoinsPayGateCallbackReq();

  UserYYCoinsPayGateCallbackReq(const UserYYCoinsPayGateCallbackReq& from);

  inline UserYYCoinsPayGateCallbackReq& operator=(const UserYYCoinsPayGateCallbackReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsPayGateCallbackReq& default_instance();

  void Swap(UserYYCoinsPayGateCallbackReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsPayGateCallbackReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string appId = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppIdFieldNumber = 1;
  inline const ::std::string& appid() const;
  inline void set_appid(const ::std::string& value);
  inline void set_appid(const char* value);
  inline void set_appid(const char* value, size_t size);
  inline ::std::string* mutable_appid();
  inline ::std::string* release_appid();
  inline void set_allocated_appid(::std::string* appid);

  // required string sign = 2;
  inline bool has_sign() const;
  inline void clear_sign();
  static const int kSignFieldNumber = 2;
  inline const ::std::string& sign() const;
  inline void set_sign(const ::std::string& value);
  inline void set_sign(const char* value);
  inline void set_sign(const char* value, size_t size);
  inline ::std::string* mutable_sign();
  inline ::std::string* release_sign();
  inline void set_allocated_sign(::std::string* sign);

  // optional string param = 3;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 3;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // optional string data = 4;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 4;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsPayGateCallbackReq)
 private:
  inline void set_has_appid();
  inline void clear_has_appid();
  inline void set_has_sign();
  inline void clear_has_sign();
  inline void set_has_param();
  inline void clear_has_param();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* appid_;
  ::std::string* sign_;
  ::std::string* param_;
  ::std::string* data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsPayGateCallbackReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsShopListReq : public ::google::protobuf::Message {
 public:
  UserYYCoinsShopListReq();
  virtual ~UserYYCoinsShopListReq();

  UserYYCoinsShopListReq(const UserYYCoinsShopListReq& from);

  inline UserYYCoinsShopListReq& operator=(const UserYYCoinsShopListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsShopListReq& default_instance();

  void Swap(UserYYCoinsShopListReq* other);

  // implements Message ----------------------------------------------

  UserYYCoinsShopListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsShopListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsShopListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsShopListRes : public ::google::protobuf::Message {
 public:
  UserYYCoinsShopListRes();
  virtual ~UserYYCoinsShopListRes();

  UserYYCoinsShopListRes(const UserYYCoinsShopListRes& from);

  inline UserYYCoinsShopListRes& operator=(const UserYYCoinsShopListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsShopListRes& default_instance();

  void Swap(UserYYCoinsShopListRes* other);

  // implements Message ----------------------------------------------

  UserYYCoinsShopListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.UserYYCoinsShopItem records = 3;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 3;
  inline const ::pp::UserYYCoinsShopItem& records(int index) const;
  inline ::pp::UserYYCoinsShopItem* mutable_records(int index);
  inline ::pp::UserYYCoinsShopItem* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsShopItem >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsShopItem >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsShopListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsShopItem > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsShopListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserYYCoinsShopItem : public ::google::protobuf::Message {
 public:
  UserYYCoinsShopItem();
  virtual ~UserYYCoinsShopItem();

  UserYYCoinsShopItem(const UserYYCoinsShopItem& from);

  inline UserYYCoinsShopItem& operator=(const UserYYCoinsShopItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserYYCoinsShopItem& default_instance();

  void Swap(UserYYCoinsShopItem* other);

  // implements Message ----------------------------------------------

  UserYYCoinsShopItem* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional float coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline float coins() const;
  inline void set_coins(float value);

  // optional float price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline float price() const;
  inline void set_price(float value);

  // optional float discount = 4;
  inline bool has_discount() const;
  inline void clear_discount();
  static const int kDiscountFieldNumber = 4;
  inline float discount() const;
  inline void set_discount(float value);

  // optional bool available = 5;
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 5;
  inline bool available() const;
  inline void set_available(bool value);

  // optional string discountText = 6;
  inline bool has_discounttext() const;
  inline void clear_discounttext();
  static const int kDiscountTextFieldNumber = 6;
  inline const ::std::string& discounttext() const;
  inline void set_discounttext(const ::std::string& value);
  inline void set_discounttext(const char* value);
  inline void set_discounttext(const char* value, size_t size);
  inline ::std::string* mutable_discounttext();
  inline ::std::string* release_discounttext();
  inline void set_allocated_discounttext(::std::string* discounttext);

  // @@protoc_insertion_point(class_scope:pp.UserYYCoinsShopItem)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_discount();
  inline void clear_has_discount();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_discounttext();
  inline void clear_has_discounttext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;
  float coins_;
  float price_;
  float discount_;
  ::std::string* discounttext_;
  bool available_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserYYCoinsShopItem* default_instance_;
};
// -------------------------------------------------------------------

class GroupRolerState : public ::google::protobuf::Message {
 public:
  GroupRolerState();
  virtual ~GroupRolerState();

  GroupRolerState(const GroupRolerState& from);

  inline GroupRolerState& operator=(const GroupRolerState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupRolerState& default_instance();

  void Swap(GroupRolerState* other);

  // implements Message ----------------------------------------------

  GroupRolerState* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GroupRolerStateType state = 1;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 1;
  inline ::pp::GroupRolerStateType state() const;
  inline void set_state(::pp::GroupRolerStateType value);

  // optional .pp.GroupMemberRoler roler = 2;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 2;
  inline ::pp::GroupMemberRoler roler() const;
  inline void set_roler(::pp::GroupMemberRoler value);

  // @@protoc_insertion_point(class_scope:pp.GroupRolerState)
 private:
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_roler();
  inline void clear_has_roler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int state_;
  int roler_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupRolerState* default_instance_;
};
// -------------------------------------------------------------------

class GroupLabel : public ::google::protobuf::Message {
 public:
  GroupLabel();
  virtual ~GroupLabel();

  GroupLabel(const GroupLabel& from);

  inline GroupLabel& operator=(const GroupLabel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLabel& default_instance();

  void Swap(GroupLabel* other);

  // implements Message ----------------------------------------------

  GroupLabel* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint64 sid() const;
  inline void set_sid(::google::protobuf::uint64 value);

  // optional string label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional string color = 3;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 3;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // @@protoc_insertion_point(class_scope:pp.GroupLabel)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_color();
  inline void clear_has_color();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 sid_;
  ::std::string* label_;
  ::std::string* color_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupLabel* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfo : public ::google::protobuf::Message {
 public:
  GroupInfo();
  virtual ~GroupInfo();

  GroupInfo(const GroupInfo& from);

  inline GroupInfo& operator=(const GroupInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfo& default_instance();

  void Swap(GroupInfo* other);

  // implements Message ----------------------------------------------

  GroupInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 dGid = 2;
  inline bool has_dgid() const;
  inline void clear_dgid();
  static const int kDGidFieldNumber = 2;
  inline ::google::protobuf::uint64 dgid() const;
  inline void set_dgid(::google::protobuf::uint64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string intro = 4;
  inline bool has_intro() const;
  inline void clear_intro();
  static const int kIntroFieldNumber = 4;
  inline const ::std::string& intro() const;
  inline void set_intro(const ::std::string& value);
  inline void set_intro(const char* value);
  inline void set_intro(const char* value, size_t size);
  inline ::std::string* mutable_intro();
  inline ::std::string* release_intro();
  inline void set_allocated_intro(::std::string* intro);

  // optional string logoUrl = 5;
  inline bool has_logourl() const;
  inline void clear_logourl();
  static const int kLogoUrlFieldNumber = 5;
  inline const ::std::string& logourl() const;
  inline void set_logourl(const ::std::string& value);
  inline void set_logourl(const char* value);
  inline void set_logourl(const char* value, size_t size);
  inline ::std::string* mutable_logourl();
  inline ::std::string* release_logourl();
  inline void set_allocated_logourl(::std::string* logourl);

  // optional string notice = 6;
  inline bool has_notice() const;
  inline void clear_notice();
  static const int kNoticeFieldNumber = 6;
  inline const ::std::string& notice() const;
  inline void set_notice(const ::std::string& value);
  inline void set_notice(const char* value);
  inline void set_notice(const char* value, size_t size);
  inline ::std::string* mutable_notice();
  inline ::std::string* release_notice();
  inline void set_allocated_notice(::std::string* notice);

  // optional .pp.GroupType gtype = 7;
  inline bool has_gtype() const;
  inline void clear_gtype();
  static const int kGtypeFieldNumber = 7;
  inline ::pp::GroupType gtype() const;
  inline void set_gtype(::pp::GroupType value);

  // optional uint64 ownerId = 8;
  inline bool has_ownerid() const;
  inline void clear_ownerid();
  static const int kOwnerIdFieldNumber = 8;
  inline ::google::protobuf::uint64 ownerid() const;
  inline void set_ownerid(::google::protobuf::uint64 value);

  // optional .pp.GroupApprove approve = 9;
  inline bool has_approve() const;
  inline void clear_approve();
  static const int kApproveFieldNumber = 9;
  inline ::pp::GroupApprove approve() const;
  inline void set_approve(::pp::GroupApprove value);

  // optional string password = 10;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 10;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .pp.GroupState state = 11;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 11;
  inline ::pp::GroupState state() const;
  inline void set_state(::pp::GroupState value);

  // optional uint64 maxMsgRev = 12;
  inline bool has_maxmsgrev() const;
  inline void clear_maxmsgrev();
  static const int kMaxMsgRevFieldNumber = 12;
  inline ::google::protobuf::uint64 maxmsgrev() const;
  inline void set_maxmsgrev(::google::protobuf::uint64 value);

  // optional uint32 members = 13;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 13;
  inline ::google::protobuf::uint32 members() const;
  inline void set_members(::google::protobuf::uint32 value);

  // optional uint32 level = 14;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 14;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // optional int64 createTime = 15;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 15;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional .pp.UserInfo ownerInfo = 16;
  inline bool has_ownerinfo() const;
  inline void clear_ownerinfo();
  static const int kOwnerInfoFieldNumber = 16;
  inline const ::pp::UserInfo& ownerinfo() const;
  inline ::pp::UserInfo* mutable_ownerinfo();
  inline ::pp::UserInfo* release_ownerinfo();
  inline void set_allocated_ownerinfo(::pp::UserInfo* ownerinfo);

  // optional uint64 parentGid = 17;
  inline bool has_parentgid() const;
  inline void clear_parentgid();
  static const int kParentGidFieldNumber = 17;
  inline ::google::protobuf::uint64 parentgid() const;
  inline void set_parentgid(::google::protobuf::uint64 value);

  // optional .pp.GroupModeType mode = 18;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 18;
  inline ::pp::GroupModeType mode() const;
  inline void set_mode(::pp::GroupModeType value);

  // repeated .pp.GroupRolerState rolerStates = 19;
  inline int rolerstates_size() const;
  inline void clear_rolerstates();
  static const int kRolerStatesFieldNumber = 19;
  inline const ::pp::GroupRolerState& rolerstates(int index) const;
  inline ::pp::GroupRolerState* mutable_rolerstates(int index);
  inline ::pp::GroupRolerState* add_rolerstates();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupRolerState >&
      rolerstates() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupRolerState >*
      mutable_rolerstates();

  // optional .pp.GroupData gdata = 20;
  inline bool has_gdata() const;
  inline void clear_gdata();
  static const int kGdataFieldNumber = 20;
  inline const ::pp::GroupData& gdata() const;
  inline ::pp::GroupData* mutable_gdata();
  inline ::pp::GroupData* release_gdata();
  inline void set_allocated_gdata(::pp::GroupData* gdata);

  // optional .pp.UserInfo babyInfo = 21;
  inline bool has_babyinfo() const;
  inline void clear_babyinfo();
  static const int kBabyInfoFieldNumber = 21;
  inline const ::pp::UserInfo& babyinfo() const;
  inline ::pp::UserInfo* mutable_babyinfo();
  inline ::pp::UserInfo* release_babyinfo();
  inline void set_allocated_babyinfo(::pp::UserInfo* babyinfo);

  // optional .pp.GroupGames games = 22;
  inline bool has_games() const;
  inline void clear_games();
  static const int kGamesFieldNumber = 22;
  inline const ::pp::GroupGames& games() const;
  inline ::pp::GroupGames* mutable_games();
  inline ::pp::GroupGames* release_games();
  inline void set_allocated_games(::pp::GroupGames* games);

  // optional uint32 mainGameId = 23;
  inline bool has_maingameid() const;
  inline void clear_maingameid();
  static const int kMainGameIdFieldNumber = 23;
  inline ::google::protobuf::uint32 maingameid() const;
  inline void set_maingameid(::google::protobuf::uint32 value);

  // optional uint32 live = 24;
  inline bool has_live() const;
  inline void clear_live();
  static const int kLiveFieldNumber = 24;
  inline ::google::protobuf::uint32 live() const;
  inline void set_live(::google::protobuf::uint32 value);

  // optional uint64 sid = 25;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 25;
  inline ::google::protobuf::uint64 sid() const;
  inline void set_sid(::google::protobuf::uint64 value);

  // optional uint64 asid = 26;
  inline bool has_asid() const;
  inline void clear_asid();
  static const int kAsidFieldNumber = 26;
  inline ::google::protobuf::uint64 asid() const;
  inline void set_asid(::google::protobuf::uint64 value);

  // optional uint32 lobbyOrderIdx = 27;
  inline bool has_lobbyorderidx() const;
  inline void clear_lobbyorderidx();
  static const int kLobbyOrderIdxFieldNumber = 27;
  inline ::google::protobuf::uint32 lobbyorderidx() const;
  inline void set_lobbyorderidx(::google::protobuf::uint32 value);

  // optional .pp.GroupLabel label = 30;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 30;
  inline const ::pp::GroupLabel& label() const;
  inline ::pp::GroupLabel* mutable_label();
  inline ::pp::GroupLabel* release_label();
  inline void set_allocated_label(::pp::GroupLabel* label);

  // optional string code = 100;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 100;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:pp.GroupInfo)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_dgid();
  inline void clear_has_dgid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_intro();
  inline void clear_has_intro();
  inline void set_has_logourl();
  inline void clear_has_logourl();
  inline void set_has_notice();
  inline void clear_has_notice();
  inline void set_has_gtype();
  inline void clear_has_gtype();
  inline void set_has_ownerid();
  inline void clear_has_ownerid();
  inline void set_has_approve();
  inline void clear_has_approve();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_maxmsgrev();
  inline void clear_has_maxmsgrev();
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_ownerinfo();
  inline void clear_has_ownerinfo();
  inline void set_has_parentgid();
  inline void clear_has_parentgid();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_gdata();
  inline void clear_has_gdata();
  inline void set_has_babyinfo();
  inline void clear_has_babyinfo();
  inline void set_has_games();
  inline void clear_has_games();
  inline void set_has_maingameid();
  inline void clear_has_maingameid();
  inline void set_has_live();
  inline void clear_has_live();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_asid();
  inline void clear_has_asid();
  inline void set_has_lobbyorderidx();
  inline void clear_has_lobbyorderidx();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 dgid_;
  ::std::string* name_;
  ::std::string* intro_;
  ::std::string* logourl_;
  ::std::string* notice_;
  ::google::protobuf::uint64 ownerid_;
  int gtype_;
  int approve_;
  ::std::string* password_;
  ::google::protobuf::uint64 maxmsgrev_;
  int state_;
  ::google::protobuf::uint32 members_;
  ::google::protobuf::int64 createtime_;
  ::pp::UserInfo* ownerinfo_;
  ::google::protobuf::uint32 level_;
  int mode_;
  ::google::protobuf::uint64 parentgid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupRolerState > rolerstates_;
  ::pp::GroupData* gdata_;
  ::pp::UserInfo* babyinfo_;
  ::pp::GroupGames* games_;
  ::google::protobuf::uint32 maingameid_;
  ::google::protobuf::uint32 live_;
  ::google::protobuf::uint64 sid_;
  ::google::protobuf::uint64 asid_;
  ::pp::GroupLabel* label_;
  ::std::string* code_;
  ::google::protobuf::uint32 lobbyorderidx_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(29 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupInfo* default_instance_;
};
// -------------------------------------------------------------------

class GroupGames : public ::google::protobuf::Message {
 public:
  GroupGames();
  virtual ~GroupGames();

  GroupGames(const GroupGames& from);

  inline GroupGames& operator=(const GroupGames& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupGames& default_instance();

  void Swap(GroupGames* other);

  // implements Message ----------------------------------------------

  GroupGames* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GameInfo relGames = 1;
  inline int relgames_size() const;
  inline void clear_relgames();
  static const int kRelGamesFieldNumber = 1;
  inline const ::pp::GameInfo& relgames(int index) const;
  inline ::pp::GameInfo* mutable_relgames(int index);
  inline ::pp::GameInfo* add_relgames();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
      relgames() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
      mutable_relgames();

  // @@protoc_insertion_point(class_scope:pp.GroupGames)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GameInfo > relgames_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupGames* default_instance_;
};
// -------------------------------------------------------------------

class GroupPresents : public ::google::protobuf::Message {
 public:
  GroupPresents();
  virtual ~GroupPresents();

  GroupPresents(const GroupPresents& from);

  inline GroupPresents& operator=(const GroupPresents& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPresents& default_instance();

  void Swap(GroupPresents* other);

  // implements Message ----------------------------------------------

  GroupPresents* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.PresentInfo presentlist = 1;
  inline int presentlist_size() const;
  inline void clear_presentlist();
  static const int kPresentlistFieldNumber = 1;
  inline const ::pp::PresentInfo& presentlist(int index) const;
  inline ::pp::PresentInfo* mutable_presentlist(int index);
  inline ::pp::PresentInfo* add_presentlist();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >&
      presentlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >*
      mutable_presentlist();

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupPresents)
 private:
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo > presentlist_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupPresents* default_instance_;
};
// -------------------------------------------------------------------

class GroupData : public ::google::protobuf::Message {
 public:
  GroupData();
  virtual ~GroupData();

  GroupData(const GroupData& from);

  inline GroupData& operator=(const GroupData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupData& default_instance();

  void Swap(GroupData* other);

  // implements Message ----------------------------------------------

  GroupData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 coins = 3;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 3;
  inline ::google::protobuf::uint32 coins() const;
  inline void set_coins(::google::protobuf::uint32 value);

  // optional uint32 passion = 4;
  inline bool has_passion() const;
  inline void clear_passion();
  static const int kPassionFieldNumber = 4;
  inline ::google::protobuf::uint32 passion() const;
  inline void set_passion(::google::protobuf::uint32 value);

  // optional uint32 todayPassion = 5;
  inline bool has_todaypassion() const;
  inline void clear_todaypassion();
  static const int kTodayPassionFieldNumber = 5;
  inline ::google::protobuf::uint32 todaypassion() const;
  inline void set_todaypassion(::google::protobuf::uint32 value);

  // optional uint32 ydIncrPassion = 6;
  inline bool has_ydincrpassion() const;
  inline void clear_ydincrpassion();
  static const int kYdIncrPassionFieldNumber = 6;
  inline ::google::protobuf::uint32 ydincrpassion() const;
  inline void set_ydincrpassion(::google::protobuf::uint32 value);

  // optional uint32 ydLossPassion = 7;
  inline bool has_ydlosspassion() const;
  inline void clear_ydlosspassion();
  static const int kYdLossPassionFieldNumber = 7;
  inline ::google::protobuf::uint32 ydlosspassion() const;
  inline void set_ydlosspassion(::google::protobuf::uint32 value);

  // optional uint32 nextPassion = 8;
  inline bool has_nextpassion() const;
  inline void clear_nextpassion();
  static const int kNextPassionFieldNumber = 8;
  inline ::google::protobuf::uint32 nextpassion() const;
  inline void set_nextpassion(::google::protobuf::uint32 value);

  // optional uint32 nextMembers = 9;
  inline bool has_nextmembers() const;
  inline void clear_nextmembers();
  static const int kNextMembersFieldNumber = 9;
  inline ::google::protobuf::uint32 nextmembers() const;
  inline void set_nextmembers(::google::protobuf::uint32 value);

  // optional uint32 maxMembers = 10;
  inline bool has_maxmembers() const;
  inline void clear_maxmembers();
  static const int kMaxMembersFieldNumber = 10;
  inline ::google::protobuf::uint32 maxmembers() const;
  inline void set_maxmembers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupData)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_passion();
  inline void clear_has_passion();
  inline void set_has_todaypassion();
  inline void clear_has_todaypassion();
  inline void set_has_ydincrpassion();
  inline void clear_has_ydincrpassion();
  inline void set_has_ydlosspassion();
  inline void clear_has_ydlosspassion();
  inline void set_has_nextpassion();
  inline void clear_has_nextpassion();
  inline void set_has_nextmembers();
  inline void clear_has_nextmembers();
  inline void set_has_maxmembers();
  inline void clear_has_maxmembers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 coins_;
  ::google::protobuf::uint32 passion_;
  ::google::protobuf::uint32 todaypassion_;
  ::google::protobuf::uint32 ydincrpassion_;
  ::google::protobuf::uint32 ydlosspassion_;
  ::google::protobuf::uint32 nextpassion_;
  ::google::protobuf::uint32 nextmembers_;
  ::google::protobuf::uint32 maxmembers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupData* default_instance_;
};
// -------------------------------------------------------------------

class GroupTeamOpReq : public ::google::protobuf::Message {
 public:
  GroupTeamOpReq();
  virtual ~GroupTeamOpReq();

  GroupTeamOpReq(const GroupTeamOpReq& from);

  inline GroupTeamOpReq& operator=(const GroupTeamOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupTeamOpReq& default_instance();

  void Swap(GroupTeamOpReq* other);

  // implements Message ----------------------------------------------

  GroupTeamOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 addGids = 1;
  inline int addgids_size() const;
  inline void clear_addgids();
  static const int kAddGidsFieldNumber = 1;
  inline ::google::protobuf::uint64 addgids(int index) const;
  inline void set_addgids(int index, ::google::protobuf::uint64 value);
  inline void add_addgids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      addgids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_addgids();

  // repeated uint64 delGids = 2;
  inline int delgids_size() const;
  inline void clear_delgids();
  static const int kDelGidsFieldNumber = 2;
  inline ::google::protobuf::uint64 delgids(int index) const;
  inline void set_delgids(int index, ::google::protobuf::uint64 value);
  inline void add_delgids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      delgids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_delgids();

  // @@protoc_insertion_point(class_scope:pp.GroupTeamOpReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > addgids_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > delgids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupTeamOpReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupApplyReq : public ::google::protobuf::Message {
 public:
  GroupApplyReq();
  virtual ~GroupApplyReq();

  GroupApplyReq(const GroupApplyReq& from);

  inline GroupApplyReq& operator=(const GroupApplyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupApplyReq& default_instance();

  void Swap(GroupApplyReq* other);

  // implements Message ----------------------------------------------

  GroupApplyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberRoler roler = 3;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 3;
  inline ::pp::GroupMemberRoler roler() const;
  inline void set_roler(::pp::GroupMemberRoler value);

  // optional string password = 4;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 4;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string remark = 5;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 5;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.GroupApplyReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_roler();
  inline void clear_has_roler();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 uid_;
  ::std::string* password_;
  ::std::string* remark_;
  int roler_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupApplyReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupApplyRes : public ::google::protobuf::Message {
 public:
  GroupApplyRes();
  virtual ~GroupApplyRes();

  GroupApplyRes(const GroupApplyRes& from);

  inline GroupApplyRes& operator=(const GroupApplyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupApplyRes& default_instance();

  void Swap(GroupApplyRes* other);

  // implements Message ----------------------------------------------

  GroupApplyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GroupInfo groupInfo = 1;
  inline bool has_groupinfo() const;
  inline void clear_groupinfo();
  static const int kGroupInfoFieldNumber = 1;
  inline const ::pp::GroupInfo& groupinfo() const;
  inline ::pp::GroupInfo* mutable_groupinfo();
  inline ::pp::GroupInfo* release_groupinfo();
  inline void set_allocated_groupinfo(::pp::GroupInfo* groupinfo);

  // optional .pp.GroupMember member = 2;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 2;
  inline const ::pp::GroupMember& member() const;
  inline ::pp::GroupMember* mutable_member();
  inline ::pp::GroupMember* release_member();
  inline void set_allocated_member(::pp::GroupMember* member);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:pp.GroupApplyRes)
 private:
  inline void set_has_groupinfo();
  inline void clear_has_groupinfo();
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GroupInfo* groupinfo_;
  ::pp::GroupMember* member_;
  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupApplyRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupApproveReq : public ::google::protobuf::Message {
 public:
  GroupApproveReq();
  virtual ~GroupApproveReq();

  GroupApproveReq(const GroupApproveReq& from);

  inline GroupApproveReq& operator=(const GroupApproveReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupApproveReq& default_instance();

  void Swap(GroupApproveReq* other);

  // implements Message ----------------------------------------------

  GroupApproveReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 adminUid = 3;
  inline bool has_adminuid() const;
  inline void clear_adminuid();
  static const int kAdminUidFieldNumber = 3;
  inline ::google::protobuf::uint64 adminuid() const;
  inline void set_adminuid(::google::protobuf::uint64 value);

  // required .pp.GroupIncrementType optype = 4;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 4;
  inline ::pp::GroupIncrementType optype() const;
  inline void set_optype(::pp::GroupIncrementType value);

  // optional string remark = 5;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 5;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.GroupApproveReq)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_adminuid();
  inline void clear_has_adminuid();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 adminuid_;
  ::std::string* remark_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupApproveReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupApproveRes : public ::google::protobuf::Message {
 public:
  GroupApproveRes();
  virtual ~GroupApproveRes();

  GroupApproveRes(const GroupApproveRes& from);

  inline GroupApproveRes& operator=(const GroupApproveRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupApproveRes& default_instance();

  void Swap(GroupApproveRes* other);

  // implements Message ----------------------------------------------

  GroupApproveRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.GroupIncrementType applyResult = 1;
  inline bool has_applyresult() const;
  inline void clear_applyresult();
  static const int kApplyResultFieldNumber = 1;
  inline ::pp::GroupIncrementType applyresult() const;
  inline void set_applyresult(::pp::GroupIncrementType value);

  // optional string remark = 2;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 2;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // @@protoc_insertion_point(class_scope:pp.GroupApproveRes)
 private:
  inline void set_has_applyresult();
  inline void clear_has_applyresult();
  inline void set_has_remark();
  inline void clear_has_remark();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* remark_;
  int applyresult_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupApproveRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupQuitReq : public ::google::protobuf::Message {
 public:
  GroupQuitReq();
  virtual ~GroupQuitReq();

  GroupQuitReq(const GroupQuitReq& from);

  inline GroupQuitReq& operator=(const GroupQuitReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupQuitReq& default_instance();

  void Swap(GroupQuitReq* other);

  // implements Message ----------------------------------------------

  GroupQuitReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional bool yyrepeate = 3;
  inline bool has_yyrepeate() const;
  inline void clear_yyrepeate();
  static const int kYyrepeateFieldNumber = 3;
  inline bool yyrepeate() const;
  inline void set_yyrepeate(bool value);

  // @@protoc_insertion_point(class_scope:pp.GroupQuitReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_yyrepeate();
  inline void clear_has_yyrepeate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 uid_;
  bool yyrepeate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupQuitReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfoReq : public ::google::protobuf::Message {
 public:
  GroupInfoReq();
  virtual ~GroupInfoReq();

  GroupInfoReq(const GroupInfoReq& from);

  inline GroupInfoReq& operator=(const GroupInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfoReq& default_instance();

  void Swap(GroupInfoReq* other);

  // implements Message ----------------------------------------------

  GroupInfoReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupInfo template = 2;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 2;
  inline const ::pp::GroupInfo& template_() const;
  inline ::pp::GroupInfo* mutable_template_();
  inline ::pp::GroupInfo* release_template_();
  inline void set_allocated_template_(::pp::GroupInfo* template_);

  // @@protoc_insertion_point(class_scope:pp.GroupInfoReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_template_();
  inline void clear_has_template_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::GroupInfo* template__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupCheckinReq : public ::google::protobuf::Message {
 public:
  GroupCheckinReq();
  virtual ~GroupCheckinReq();

  GroupCheckinReq(const GroupCheckinReq& from);

  inline GroupCheckinReq& operator=(const GroupCheckinReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupCheckinReq& default_instance();

  void Swap(GroupCheckinReq* other);

  // implements Message ----------------------------------------------

  GroupCheckinReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupCheckinReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupCheckinReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupCheckinRes : public ::google::protobuf::Message {
 public:
  GroupCheckinRes();
  virtual ~GroupCheckinRes();

  GroupCheckinRes(const GroupCheckinRes& from);

  inline GroupCheckinRes& operator=(const GroupCheckinRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupCheckinRes& default_instance();

  void Swap(GroupCheckinRes* other);

  // implements Message ----------------------------------------------

  GroupCheckinRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 progress = 1;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 1;
  inline ::google::protobuf::uint32 progress() const;
  inline void set_progress(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupCheckinRes)
 private:
  inline void set_has_progress();
  inline void clear_has_progress();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupCheckinRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupSearchReq : public ::google::protobuf::Message {
 public:
  GroupSearchReq();
  virtual ~GroupSearchReq();

  GroupSearchReq(const GroupSearchReq& from);

  inline GroupSearchReq& operator=(const GroupSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupSearchReq& default_instance();

  void Swap(GroupSearchReq* other);

  // implements Message ----------------------------------------------

  GroupSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.GroupType gtype = 5;
  inline bool has_gtype() const;
  inline void clear_gtype();
  static const int kGtypeFieldNumber = 5;
  inline ::pp::GroupType gtype() const;
  inline void set_gtype(::pp::GroupType value);

  // optional .pp.GroupSearchBy searchBy = 10;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchByFieldNumber = 10;
  inline ::pp::GroupSearchBy searchby() const;
  inline void set_searchby(::pp::GroupSearchBy value);

  // optional .pp.GroupSearchOrderBy orderBy = 11;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 11;
  inline ::pp::GroupSearchOrderBy orderby() const;
  inline void set_orderby(::pp::GroupSearchOrderBy value);

  // optional .pp.GroupInfo template = 15;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 15;
  inline const ::pp::GroupInfo& template_() const;
  inline ::pp::GroupInfo* mutable_template_();
  inline ::pp::GroupInfo* release_template_();
  inline void set_allocated_template_(::pp::GroupInfo* template_);

  // optional uint32 gameid = 16;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 16;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint64 giftid = 17;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftidFieldNumber = 17;
  inline ::google::protobuf::uint64 giftid() const;
  inline void set_giftid(::google::protobuf::uint64 value);

  // optional uint64 cacheKey = 100;
  inline bool has_cachekey() const;
  inline void clear_cachekey();
  static const int kCacheKeyFieldNumber = 100;
  inline ::google::protobuf::uint64 cachekey() const;
  inline void set_cachekey(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupSearchReq)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_gtype();
  inline void clear_has_gtype();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_template_();
  inline void clear_has_template_();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_cachekey();
  inline void clear_has_cachekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keyword_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  int gtype_;
  int searchby_;
  int orderby_;
  ::google::protobuf::uint32 gameid_;
  ::pp::GroupInfo* template__;
  ::google::protobuf::uint64 giftid_;
  ::google::protobuf::uint64 cachekey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupSearchRes : public ::google::protobuf::Message {
 public:
  GroupSearchRes();
  virtual ~GroupSearchRes();

  GroupSearchRes(const GroupSearchRes& from);

  inline GroupSearchRes& operator=(const GroupSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupSearchRes& default_instance();

  void Swap(GroupSearchRes* other);

  // implements Message ----------------------------------------------

  GroupSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.GroupType gtype = 5;
  inline bool has_gtype() const;
  inline void clear_gtype();
  static const int kGtypeFieldNumber = 5;
  inline ::pp::GroupType gtype() const;
  inline void set_gtype(::pp::GroupType value);

  // optional .pp.GroupSearchBy searchBy = 10;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchByFieldNumber = 10;
  inline ::pp::GroupSearchBy searchby() const;
  inline void set_searchby(::pp::GroupSearchBy value);

  // optional .pp.GroupSearchOrderBy orderBy = 11;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 11;
  inline ::pp::GroupSearchOrderBy orderby() const;
  inline void set_orderby(::pp::GroupSearchOrderBy value);

  // repeated .pp.GroupInfo groups = 20;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 20;
  inline const ::pp::GroupInfo& groups(int index) const;
  inline ::pp::GroupInfo* mutable_groups(int index);
  inline ::pp::GroupInfo* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
      mutable_groups();

  // optional uint32 gameid = 21;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 21;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint64 giftid = 22;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftidFieldNumber = 22;
  inline ::google::protobuf::uint64 giftid() const;
  inline void set_giftid(::google::protobuf::uint64 value);

  // optional uint64 cacheKey = 100;
  inline bool has_cachekey() const;
  inline void clear_cachekey();
  static const int kCacheKeyFieldNumber = 100;
  inline ::google::protobuf::uint64 cachekey() const;
  inline void set_cachekey(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupSearchRes)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_gtype();
  inline void clear_has_gtype();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_cachekey();
  inline void clear_has_cachekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keyword_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  int gtype_;
  int searchby_;
  int orderby_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo > groups_;
  ::google::protobuf::uint64 giftid_;
  ::google::protobuf::uint64 cachekey_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupSearchKeywordsReq : public ::google::protobuf::Message {
 public:
  GroupSearchKeywordsReq();
  virtual ~GroupSearchKeywordsReq();

  GroupSearchKeywordsReq(const GroupSearchKeywordsReq& from);

  inline GroupSearchKeywordsReq& operator=(const GroupSearchKeywordsReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupSearchKeywordsReq& default_instance();

  void Swap(GroupSearchKeywordsReq* other);

  // implements Message ----------------------------------------------

  GroupSearchKeywordsReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // @@protoc_insertion_point(class_scope:pp.GroupSearchKeywordsReq)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keyword_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupSearchKeywordsReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupSearchKeywordsRes : public ::google::protobuf::Message {
 public:
  GroupSearchKeywordsRes();
  virtual ~GroupSearchKeywordsRes();

  GroupSearchKeywordsRes(const GroupSearchKeywordsRes& from);

  inline GroupSearchKeywordsRes& operator=(const GroupSearchKeywordsRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupSearchKeywordsRes& default_instance();

  void Swap(GroupSearchKeywordsRes* other);

  // implements Message ----------------------------------------------

  GroupSearchKeywordsRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keywords = 1;
  inline int keywords_size() const;
  inline void clear_keywords();
  static const int kKeywordsFieldNumber = 1;
  inline const ::std::string& keywords(int index) const;
  inline ::std::string* mutable_keywords(int index);
  inline void set_keywords(int index, const ::std::string& value);
  inline void set_keywords(int index, const char* value);
  inline void set_keywords(int index, const char* value, size_t size);
  inline ::std::string* add_keywords();
  inline void add_keywords(const ::std::string& value);
  inline void add_keywords(const char* value);
  inline void add_keywords(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& keywords() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keywords();

  // @@protoc_insertion_point(class_scope:pp.GroupSearchKeywordsRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> keywords_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupSearchKeywordsRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupListReq : public ::google::protobuf::Message {
 public:
  GroupListReq();
  virtual ~GroupListReq();

  GroupListReq(const GroupListReq& from);

  inline GroupListReq& operator=(const GroupListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupListReq& default_instance();

  void Swap(GroupListReq* other);

  // implements Message ----------------------------------------------

  GroupListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupListReq)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupIncrement : public ::google::protobuf::Message {
 public:
  GroupIncrement();
  virtual ~GroupIncrement();

  GroupIncrement(const GroupIncrement& from);

  inline GroupIncrement& operator=(const GroupIncrement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupIncrement& default_instance();

  void Swap(GroupIncrement* other);

  // implements Message ----------------------------------------------

  GroupIncrement* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional .pp.GroupIncrementType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::pp::GroupIncrementType type() const;
  inline void set_type(::pp::GroupIncrementType value);

  // optional .pp.GroupInfo group = 3;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 3;
  inline const ::pp::GroupInfo& group() const;
  inline ::pp::GroupInfo* mutable_group();
  inline ::pp::GroupInfo* release_group();
  inline void set_allocated_group(::pp::GroupInfo* group);

  // @@protoc_insertion_point(class_scope:pp.GroupIncrement)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_group();
  inline void clear_has_group();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::pp::GroupInfo* group_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupIncrement* default_instance_;
};
// -------------------------------------------------------------------

class GroupInfoList : public ::google::protobuf::Message {
 public:
  GroupInfoList();
  virtual ~GroupInfoList();

  GroupInfoList(const GroupInfoList& from);

  inline GroupInfoList& operator=(const GroupInfoList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupInfoList& default_instance();

  void Swap(GroupInfoList* other);

  // implements Message ----------------------------------------------

  GroupInfoList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupInfo groups = 1;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 1;
  inline const ::pp::GroupInfo& groups(int index) const;
  inline ::pp::GroupInfo* mutable_groups(int index);
  inline ::pp::GroupInfo* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
      mutable_groups();

  // @@protoc_insertion_point(class_scope:pp.GroupInfoList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo > groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupInfoList* default_instance_;
};
// -------------------------------------------------------------------

class GroupListRes : public ::google::protobuf::Message {
 public:
  GroupListRes();
  virtual ~GroupListRes();

  GroupListRes(const GroupListRes& from);

  inline GroupListRes& operator=(const GroupListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupListRes& default_instance();

  void Swap(GroupListRes* other);

  // implements Message ----------------------------------------------

  GroupListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional .pp.GroupInfoList grouplist = 2;
  inline bool has_grouplist() const;
  inline void clear_grouplist();
  static const int kGrouplistFieldNumber = 2;
  inline const ::pp::GroupInfoList& grouplist() const;
  inline ::pp::GroupInfoList* mutable_grouplist();
  inline ::pp::GroupInfoList* release_grouplist();
  inline void set_allocated_grouplist(::pp::GroupInfoList* grouplist);

  // repeated .pp.GroupIncrement increments = 3;
  inline int increments_size() const;
  inline void clear_increments();
  static const int kIncrementsFieldNumber = 3;
  inline const ::pp::GroupIncrement& increments(int index) const;
  inline ::pp::GroupIncrement* mutable_increments(int index);
  inline ::pp::GroupIncrement* add_increments();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupIncrement >&
      increments() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupIncrement >*
      mutable_increments();

  // optional uint64 reqrevision = 4;
  inline bool has_reqrevision() const;
  inline void clear_reqrevision();
  static const int kReqrevisionFieldNumber = 4;
  inline ::google::protobuf::uint64 reqrevision() const;
  inline void set_reqrevision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupListRes)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_grouplist();
  inline void clear_has_grouplist();
  inline void set_has_reqrevision();
  inline void clear_has_reqrevision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::pp::GroupInfoList* grouplist_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupIncrement > increments_;
  ::google::protobuf::uint64 reqrevision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupListRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupLobbyOrderModifyReq : public ::google::protobuf::Message {
 public:
  GroupLobbyOrderModifyReq();
  virtual ~GroupLobbyOrderModifyReq();

  GroupLobbyOrderModifyReq(const GroupLobbyOrderModifyReq& from);

  inline GroupLobbyOrderModifyReq& operator=(const GroupLobbyOrderModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLobbyOrderModifyReq& default_instance();

  void Swap(GroupLobbyOrderModifyReq* other);

  // implements Message ----------------------------------------------

  GroupLobbyOrderModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 gids = 1;
  inline int gids_size() const;
  inline void clear_gids();
  static const int kGidsFieldNumber = 1;
  inline ::google::protobuf::uint64 gids(int index) const;
  inline void set_gids(int index, ::google::protobuf::uint64 value);
  inline void add_gids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      gids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_gids();

  // optional uint64 parendGid = 2;
  inline bool has_parendgid() const;
  inline void clear_parendgid();
  static const int kParendGidFieldNumber = 2;
  inline ::google::protobuf::uint64 parendgid() const;
  inline void set_parendgid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupLobbyOrderModifyReq)
 private:
  inline void set_has_parendgid();
  inline void clear_has_parendgid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > gids_;
  ::google::protobuf::uint64 parendgid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupLobbyOrderModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupLobbyOrderModifyRes : public ::google::protobuf::Message {
 public:
  GroupLobbyOrderModifyRes();
  virtual ~GroupLobbyOrderModifyRes();

  GroupLobbyOrderModifyRes(const GroupLobbyOrderModifyRes& from);

  inline GroupLobbyOrderModifyRes& operator=(const GroupLobbyOrderModifyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLobbyOrderModifyRes& default_instance();

  void Swap(GroupLobbyOrderModifyRes* other);

  // implements Message ----------------------------------------------

  GroupLobbyOrderModifyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.GroupLobbyOrderModifyRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupLobbyOrderModifyRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupLabelOpReq : public ::google::protobuf::Message {
 public:
  GroupLabelOpReq();
  virtual ~GroupLabelOpReq();

  GroupLabelOpReq(const GroupLabelOpReq& from);

  inline GroupLabelOpReq& operator=(const GroupLabelOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupLabelOpReq& default_instance();

  void Swap(GroupLabelOpReq* other);

  // implements Message ----------------------------------------------

  GroupLabelOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.EntityOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // optional .pp.GroupLabel label = 2;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 2;
  inline const ::pp::GroupLabel& label() const;
  inline ::pp::GroupLabel* mutable_label();
  inline ::pp::GroupLabel* release_label();
  inline void set_allocated_label(::pp::GroupLabel* label);

  // @@protoc_insertion_point(class_scope:pp.GroupLabelOpReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_label();
  inline void clear_has_label();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GroupLabel* label_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupLabelOpReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupAppSendReq : public ::google::protobuf::Message {
 public:
  GroupAppSendReq();
  virtual ~GroupAppSendReq();

  GroupAppSendReq(const GroupAppSendReq& from);

  inline GroupAppSendReq& operator=(const GroupAppSendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAppSendReq& default_instance();

  void Swap(GroupAppSendReq* other);

  // implements Message ----------------------------------------------

  GroupAppSendReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupApp app = 2;
  inline bool has_app() const;
  inline void clear_app();
  static const int kAppFieldNumber = 2;
  inline const ::pp::GroupApp& app() const;
  inline ::pp::GroupApp* mutable_app();
  inline ::pp::GroupApp* release_app();
  inline void set_allocated_app(::pp::GroupApp* app);

  // @@protoc_insertion_point(class_scope:pp.GroupAppSendReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_app();
  inline void clear_has_app();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::GroupApp* app_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupAppSendReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupAppSendRes : public ::google::protobuf::Message {
 public:
  GroupAppSendRes();
  virtual ~GroupAppSendRes();

  GroupAppSendRes(const GroupAppSendRes& from);

  inline GroupAppSendRes& operator=(const GroupAppSendRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAppSendRes& default_instance();

  void Swap(GroupAppSendRes* other);

  // implements Message ----------------------------------------------

  GroupAppSendRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline ::google::protobuf::uint32 res() const;
  inline void set_res(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupAppSendRes)
 private:
  inline void set_has_res();
  inline void clear_has_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupAppSendRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupAppReq : public ::google::protobuf::Message {
 public:
  GroupAppReq();
  virtual ~GroupAppReq();

  GroupAppReq(const GroupAppReq& from);

  inline GroupAppReq& operator=(const GroupAppReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAppReq& default_instance();

  void Swap(GroupAppReq* other);

  // implements Message ----------------------------------------------

  GroupAppReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 topn = 4;
  inline bool has_topn() const;
  inline void clear_topn();
  static const int kTopnFieldNumber = 4;
  inline ::google::protobuf::uint32 topn() const;
  inline void set_topn(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupAppReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_topn();
  inline void clear_has_topn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 topn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupAppReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupApp : public ::google::protobuf::Message {
 public:
  GroupApp();
  virtual ~GroupApp();

  GroupApp(const GroupApp& from);

  inline GroupApp& operator=(const GroupApp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupApp& default_instance();

  void Swap(GroupApp* other);

  // implements Message ----------------------------------------------

  GroupApp* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 refmsg = 1;
  inline bool has_refmsg() const;
  inline void clear_refmsg();
  static const int kRefmsgFieldNumber = 1;
  inline ::google::protobuf::uint64 refmsg() const;
  inline void set_refmsg(::google::protobuf::uint64 value);

  // required .pp.GroupAppType apptype = 2;
  inline bool has_apptype() const;
  inline void clear_apptype();
  static const int kApptypeFieldNumber = 2;
  inline ::pp::GroupAppType apptype() const;
  inline void set_apptype(::pp::GroupAppType value);

  // optional .pp.GroupAppOp appop = 3;
  inline bool has_appop() const;
  inline void clear_appop();
  static const int kAppopFieldNumber = 3;
  inline ::pp::GroupAppOp appop() const;
  inline void set_appop(::pp::GroupAppOp value);

  // optional string msg = 4;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 4;
  inline const ::std::string& msg() const;
  inline void set_msg(const ::std::string& value);
  inline void set_msg(const char* value);
  inline void set_msg(const char* value, size_t size);
  inline ::std::string* mutable_msg();
  inline ::std::string* release_msg();
  inline void set_allocated_msg(::std::string* msg);

  // optional uint64 uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 revision = 6;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 6;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional int64 timestamp = 7;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 7;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupApp)
 private:
  inline void set_has_refmsg();
  inline void clear_has_refmsg();
  inline void set_has_apptype();
  inline void clear_has_apptype();
  inline void set_has_appop();
  inline void clear_has_appop();
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 refmsg_;
  int apptype_;
  int appop_;
  ::std::string* msg_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 revision_;
  ::google::protobuf::int64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupApp* default_instance_;
};
// -------------------------------------------------------------------

class GroupAppList : public ::google::protobuf::Message {
 public:
  GroupAppList();
  virtual ~GroupAppList();

  GroupAppList(const GroupAppList& from);

  inline GroupAppList& operator=(const GroupAppList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAppList& default_instance();

  void Swap(GroupAppList* other);

  // implements Message ----------------------------------------------

  GroupAppList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // required uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated .pp.GroupApp apps = 3;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 3;
  inline const ::pp::GroupApp& apps(int index) const;
  inline ::pp::GroupApp* mutable_apps(int index);
  inline ::pp::GroupApp* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupApp >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupApp >*
      mutable_apps();

  // @@protoc_insertion_point(class_scope:pp.GroupAppList)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupApp > apps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupAppList* default_instance_;
};
// -------------------------------------------------------------------

class GroupAppListReq : public ::google::protobuf::Message {
 public:
  GroupAppListReq();
  virtual ~GroupAppListReq();

  GroupAppListReq(const GroupAppListReq& from);

  inline GroupAppListReq& operator=(const GroupAppListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAppListReq& default_instance();

  void Swap(GroupAppListReq* other);

  // implements Message ----------------------------------------------

  GroupAppListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupAppReq groups = 1;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 1;
  inline const ::pp::GroupAppReq& groups(int index) const;
  inline ::pp::GroupAppReq* mutable_groups(int index);
  inline ::pp::GroupAppReq* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupAppReq >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupAppReq >*
      mutable_groups();

  // @@protoc_insertion_point(class_scope:pp.GroupAppListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupAppReq > groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupAppListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupAppListRes : public ::google::protobuf::Message {
 public:
  GroupAppListRes();
  virtual ~GroupAppListRes();

  GroupAppListRes(const GroupAppListRes& from);

  inline GroupAppListRes& operator=(const GroupAppListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupAppListRes& default_instance();

  void Swap(GroupAppListRes* other);

  // implements Message ----------------------------------------------

  GroupAppListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupAppList applist = 1;
  inline int applist_size() const;
  inline void clear_applist();
  static const int kApplistFieldNumber = 1;
  inline const ::pp::GroupAppList& applist(int index) const;
  inline ::pp::GroupAppList* mutable_applist(int index);
  inline ::pp::GroupAppList* add_applist();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupAppList >&
      applist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupAppList >*
      mutable_applist();

  // @@protoc_insertion_point(class_scope:pp.GroupAppListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupAppList > applist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupAppListRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgAppReq : public ::google::protobuf::Message {
 public:
  GroupMsgAppReq();
  virtual ~GroupMsgAppReq();

  GroupMsgAppReq(const GroupMsgAppReq& from);

  inline GroupMsgAppReq& operator=(const GroupMsgAppReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgAppReq& default_instance();

  void Swap(GroupMsgAppReq* other);

  // implements Message ----------------------------------------------

  GroupMsgAppReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated uint64 refmsgs = 2;
  inline int refmsgs_size() const;
  inline void clear_refmsgs();
  static const int kRefmsgsFieldNumber = 2;
  inline ::google::protobuf::uint64 refmsgs(int index) const;
  inline void set_refmsgs(int index, ::google::protobuf::uint64 value);
  inline void add_refmsgs(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      refmsgs() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_refmsgs();

  // @@protoc_insertion_point(class_scope:pp.GroupMsgAppReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > refmsgs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgAppReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgApp : public ::google::protobuf::Message {
 public:
  GroupMsgApp();
  virtual ~GroupMsgApp();

  GroupMsgApp(const GroupMsgApp& from);

  inline GroupMsgApp& operator=(const GroupMsgApp& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgApp& default_instance();

  void Swap(GroupMsgApp* other);

  // implements Message ----------------------------------------------

  GroupMsgApp* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 refmsg = 1;
  inline bool has_refmsg() const;
  inline void clear_refmsg();
  static const int kRefmsgFieldNumber = 1;
  inline ::google::protobuf::uint64 refmsg() const;
  inline void set_refmsg(::google::protobuf::uint64 value);

  // optional .pp.ExtProps extprops = 3;
  inline bool has_extprops() const;
  inline void clear_extprops();
  static const int kExtpropsFieldNumber = 3;
  inline const ::pp::ExtProps& extprops() const;
  inline ::pp::ExtProps* mutable_extprops();
  inline ::pp::ExtProps* release_extprops();
  inline void set_allocated_extprops(::pp::ExtProps* extprops);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgApp)
 private:
  inline void set_has_refmsg();
  inline void clear_has_refmsg();
  inline void set_has_extprops();
  inline void clear_has_extprops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 refmsg_;
  ::pp::ExtProps* extprops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgApp* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgAppRes : public ::google::protobuf::Message {
 public:
  GroupMsgAppRes();
  virtual ~GroupMsgAppRes();

  GroupMsgAppRes(const GroupMsgAppRes& from);

  inline GroupMsgAppRes& operator=(const GroupMsgAppRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgAppRes& default_instance();

  void Swap(GroupMsgAppRes* other);

  // implements Message ----------------------------------------------

  GroupMsgAppRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated .pp.GroupMsgApp apps = 2;
  inline int apps_size() const;
  inline void clear_apps();
  static const int kAppsFieldNumber = 2;
  inline const ::pp::GroupMsgApp& apps(int index) const;
  inline ::pp::GroupMsgApp* mutable_apps(int index);
  inline ::pp::GroupMsgApp* add_apps();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgApp >&
      apps() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgApp >*
      mutable_apps();

  // @@protoc_insertion_point(class_scope:pp.GroupMsgAppRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgApp > apps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgAppRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberRolerItem : public ::google::protobuf::Message {
 public:
  GroupMemberRolerItem();
  virtual ~GroupMemberRolerItem();

  GroupMemberRolerItem(const GroupMemberRolerItem& from);

  inline GroupMemberRolerItem& operator=(const GroupMemberRolerItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberRolerItem& default_instance();

  void Swap(GroupMemberRolerItem* other);

  // implements Message ----------------------------------------------

  GroupMemberRolerItem* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 roler = 1;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 1;
  inline ::google::protobuf::uint32 roler() const;
  inline void set_roler(::google::protobuf::uint32 value);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberRolerItem)
 private:
  inline void set_has_roler();
  inline void clear_has_roler();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 roler_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberRolerItem* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberRolerListReq : public ::google::protobuf::Message {
 public:
  GroupMemberRolerListReq();
  virtual ~GroupMemberRolerListReq();

  GroupMemberRolerListReq(const GroupMemberRolerListReq& from);

  inline GroupMemberRolerListReq& operator=(const GroupMemberRolerListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberRolerListReq& default_instance();

  void Swap(GroupMemberRolerListReq* other);

  // implements Message ----------------------------------------------

  GroupMemberRolerListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberRolerListReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberRolerListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberRolerListRes : public ::google::protobuf::Message {
 public:
  GroupMemberRolerListRes();
  virtual ~GroupMemberRolerListRes();

  GroupMemberRolerListRes(const GroupMemberRolerListRes& from);

  inline GroupMemberRolerListRes& operator=(const GroupMemberRolerListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberRolerListRes& default_instance();

  void Swap(GroupMemberRolerListRes* other);

  // implements Message ----------------------------------------------

  GroupMemberRolerListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated .pp.GroupMemberRolerItem items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::pp::GroupMemberRolerItem& items(int index) const;
  inline ::pp::GroupMemberRolerItem* mutable_items(int index);
  inline ::pp::GroupMemberRolerItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberRolerItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberRolerItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.GroupMemberRolerListRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberRolerItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberRolerListRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberRolerSetReq : public ::google::protobuf::Message {
 public:
  GroupMemberRolerSetReq();
  virtual ~GroupMemberRolerSetReq();

  GroupMemberRolerSetReq(const GroupMemberRolerSetReq& from);

  inline GroupMemberRolerSetReq& operator=(const GroupMemberRolerSetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberRolerSetReq& default_instance();

  void Swap(GroupMemberRolerSetReq* other);

  // implements Message ----------------------------------------------

  GroupMemberRolerSetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberRolerItem item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::pp::GroupMemberRolerItem& item() const;
  inline ::pp::GroupMemberRolerItem* mutable_item();
  inline ::pp::GroupMemberRolerItem* release_item();
  inline void set_allocated_item(::pp::GroupMemberRolerItem* item);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberRolerSetReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::GroupMemberRolerItem* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberRolerSetReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberCheckinState : public ::google::protobuf::Message {
 public:
  GroupMemberCheckinState();
  virtual ~GroupMemberCheckinState();

  GroupMemberCheckinState(const GroupMemberCheckinState& from);

  inline GroupMemberCheckinState& operator=(const GroupMemberCheckinState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberCheckinState& default_instance();

  void Swap(GroupMemberCheckinState* other);

  // implements Message ----------------------------------------------

  GroupMemberCheckinState* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 progress = 1;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 1;
  inline ::google::protobuf::uint32 progress() const;
  inline void set_progress(::google::protobuf::uint32 value);

  // optional int64 updateTime = 2;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  static const int kUpdateTimeFieldNumber = 2;
  inline ::google::protobuf::int64 updatetime() const;
  inline void set_updatetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberCheckinState)
 private:
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_updatetime();
  inline void clear_has_updatetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 updatetime_;
  ::google::protobuf::uint32 progress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberCheckinState* default_instance_;
};
// -------------------------------------------------------------------

class GroupMember : public ::google::protobuf::Message {
 public:
  GroupMember();
  virtual ~GroupMember();

  GroupMember(const GroupMember& from);

  inline GroupMember& operator=(const GroupMember& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMember& default_instance();

  void Swap(GroupMember* other);

  // implements Message ----------------------------------------------

  GroupMember* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::pp::UserInfo& user() const;
  inline ::pp::UserInfo* mutable_user();
  inline ::pp::UserInfo* release_user();
  inline void set_allocated_user(::pp::UserInfo* user);

  // optional .pp.GroupMemberRoler roler = 2;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 2;
  inline ::pp::GroupMemberRoler roler() const;
  inline void set_roler(::pp::GroupMemberRoler value);

  // optional string cardname = 3;
  inline bool has_cardname() const;
  inline void clear_cardname();
  static const int kCardnameFieldNumber = 3;
  inline const ::std::string& cardname() const;
  inline void set_cardname(const ::std::string& value);
  inline void set_cardname(const char* value);
  inline void set_cardname(const char* value, size_t size);
  inline ::std::string* mutable_cardname();
  inline ::std::string* release_cardname();
  inline void set_allocated_cardname(::std::string* cardname);

  // optional .pp.GroupMemberState state = 4;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 4;
  inline ::pp::GroupMemberState state() const;
  inline void set_state(::pp::GroupMemberState value);

  // optional uint32 score = 5;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 5;
  inline ::google::protobuf::uint32 score() const;
  inline void set_score(::google::protobuf::uint32 value);

  // optional .pp.GroupMemberCheckinState checkinState = 6;
  inline bool has_checkinstate() const;
  inline void clear_checkinstate();
  static const int kCheckinStateFieldNumber = 6;
  inline const ::pp::GroupMemberCheckinState& checkinstate() const;
  inline ::pp::GroupMemberCheckinState* mutable_checkinstate();
  inline ::pp::GroupMemberCheckinState* release_checkinstate();
  inline void set_allocated_checkinstate(::pp::GroupMemberCheckinState* checkinstate);

  // optional uint32 contrib = 7;
  inline bool has_contrib() const;
  inline void clear_contrib();
  static const int kContribFieldNumber = 7;
  inline ::google::protobuf::uint32 contrib() const;
  inline void set_contrib(::google::protobuf::uint32 value);

  // optional .pp.GroupType gtype = 8;
  inline bool has_gtype() const;
  inline void clear_gtype();
  static const int kGtypeFieldNumber = 8;
  inline ::pp::GroupType gtype() const;
  inline void set_gtype(::pp::GroupType value);

  // optional .pp.GroupMemberRoler guildRoler = 9;
  inline bool has_guildroler() const;
  inline void clear_guildroler();
  static const int kGuildRolerFieldNumber = 9;
  inline ::pp::GroupMemberRoler guildroler() const;
  inline void set_guildroler(::pp::GroupMemberRoler value);

  // @@protoc_insertion_point(class_scope:pp.GroupMember)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_roler();
  inline void clear_has_roler();
  inline void set_has_cardname();
  inline void clear_has_cardname();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_checkinstate();
  inline void clear_has_checkinstate();
  inline void set_has_contrib();
  inline void clear_has_contrib();
  inline void set_has_gtype();
  inline void clear_has_gtype();
  inline void set_has_guildroler();
  inline void clear_has_guildroler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* user_;
  ::std::string* cardname_;
  int roler_;
  int state_;
  ::pp::GroupMemberCheckinState* checkinstate_;
  ::google::protobuf::uint32 score_;
  ::google::protobuf::uint32 contrib_;
  int gtype_;
  int guildroler_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMember* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberListReq : public ::google::protobuf::Message {
 public:
  GroupMemberListReq();
  virtual ~GroupMemberListReq();

  GroupMemberListReq(const GroupMemberListReq& from);

  inline GroupMemberListReq& operator=(const GroupMemberListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberListReq& default_instance();

  void Swap(GroupMemberListReq* other);

  // implements Message ----------------------------------------------

  GroupMemberListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberListReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberIncrement : public ::google::protobuf::Message {
 public:
  GroupMemberIncrement();
  virtual ~GroupMemberIncrement();

  GroupMemberIncrement(const GroupMemberIncrement& from);

  inline GroupMemberIncrement& operator=(const GroupMemberIncrement& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberIncrement& default_instance();

  void Swap(GroupMemberIncrement* other);

  // implements Message ----------------------------------------------

  GroupMemberIncrement* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberIncrementType type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::pp::GroupMemberIncrementType type() const;
  inline void set_type(::pp::GroupMemberIncrementType value);

  // optional .pp.GroupMember member = 3;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 3;
  inline const ::pp::GroupMember& member() const;
  inline ::pp::GroupMember* mutable_member();
  inline ::pp::GroupMember* release_member();
  inline void set_allocated_member(::pp::GroupMember* member);

  // optional string remakrs = 4;
  inline bool has_remakrs() const;
  inline void clear_remakrs();
  static const int kRemakrsFieldNumber = 4;
  inline const ::std::string& remakrs() const;
  inline void set_remakrs(const ::std::string& value);
  inline void set_remakrs(const char* value);
  inline void set_remakrs(const char* value, size_t size);
  inline ::std::string* mutable_remakrs();
  inline ::std::string* release_remakrs();
  inline void set_allocated_remakrs(::std::string* remakrs);

  // optional .pp.GroupMemberRolerItem rolerset = 5;
  inline bool has_rolerset() const;
  inline void clear_rolerset();
  static const int kRolersetFieldNumber = 5;
  inline const ::pp::GroupMemberRolerItem& rolerset() const;
  inline ::pp::GroupMemberRolerItem* mutable_rolerset();
  inline ::pp::GroupMemberRolerItem* release_rolerset();
  inline void set_allocated_rolerset(::pp::GroupMemberRolerItem* rolerset);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberIncrement)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_remakrs();
  inline void clear_has_remakrs();
  inline void set_has_rolerset();
  inline void clear_has_rolerset();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::pp::GroupMember* member_;
  ::std::string* remakrs_;
  ::pp::GroupMemberRolerItem* rolerset_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberIncrement* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberList : public ::google::protobuf::Message {
 public:
  GroupMemberList();
  virtual ~GroupMemberList();

  GroupMemberList(const GroupMemberList& from);

  inline GroupMemberList& operator=(const GroupMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberList& default_instance();

  void Swap(GroupMemberList* other);

  // implements Message ----------------------------------------------

  GroupMemberList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupMember members = 1;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 1;
  inline const ::pp::GroupMember& members(int index) const;
  inline ::pp::GroupMember* mutable_members(int index);
  inline ::pp::GroupMember* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >*
      mutable_members();

  // @@protoc_insertion_point(class_scope:pp.GroupMemberList)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupMember > members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberList* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberListRes : public ::google::protobuf::Message {
 public:
  GroupMemberListRes();
  virtual ~GroupMemberListRes();

  GroupMemberListRes(const GroupMemberListRes& from);

  inline GroupMemberListRes& operator=(const GroupMemberListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberListRes& default_instance();

  void Swap(GroupMemberListRes* other);

  // implements Message ----------------------------------------------

  GroupMemberListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberList memberlist = 3;
  inline bool has_memberlist() const;
  inline void clear_memberlist();
  static const int kMemberlistFieldNumber = 3;
  inline const ::pp::GroupMemberList& memberlist() const;
  inline ::pp::GroupMemberList* mutable_memberlist();
  inline ::pp::GroupMemberList* release_memberlist();
  inline void set_allocated_memberlist(::pp::GroupMemberList* memberlist);

  // repeated .pp.GroupMemberIncrement increment = 4;
  inline int increment_size() const;
  inline void clear_increment();
  static const int kIncrementFieldNumber = 4;
  inline const ::pp::GroupMemberIncrement& increment(int index) const;
  inline ::pp::GroupMemberIncrement* mutable_increment(int index);
  inline ::pp::GroupMemberIncrement* add_increment();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberIncrement >&
      increment() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberIncrement >*
      mutable_increment();

  // optional uint64 reqrevision = 5;
  inline bool has_reqrevision() const;
  inline void clear_reqrevision();
  static const int kReqrevisionFieldNumber = 5;
  inline ::google::protobuf::uint64 reqrevision() const;
  inline void set_reqrevision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberListRes)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_memberlist();
  inline void clear_has_memberlist();
  inline void set_has_reqrevision();
  inline void clear_has_reqrevision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 gid_;
  ::pp::GroupMemberList* memberlist_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberIncrement > increment_;
  ::google::protobuf::uint64 reqrevision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberListRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberReq : public ::google::protobuf::Message {
 public:
  GroupMemberReq();
  virtual ~GroupMemberReq();

  GroupMemberReq(const GroupMemberReq& from);

  inline GroupMemberReq& operator=(const GroupMemberReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberReq& default_instance();

  void Swap(GroupMemberReq* other);

  // implements Message ----------------------------------------------

  GroupMemberReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberRes : public ::google::protobuf::Message {
 public:
  GroupMemberRes();
  virtual ~GroupMemberRes();

  GroupMemberRes(const GroupMemberRes& from);

  inline GroupMemberRes& operator=(const GroupMemberRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberRes& default_instance();

  void Swap(GroupMemberRes* other);

  // implements Message ----------------------------------------------

  GroupMemberRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMember member = 2;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 2;
  inline const ::pp::GroupMember& member() const;
  inline ::pp::GroupMember* mutable_member();
  inline ::pp::GroupMember* release_member();
  inline void set_allocated_member(::pp::GroupMember* member);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_member();
  inline void clear_has_member();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::GroupMember* member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberModifyReq : public ::google::protobuf::Message {
 public:
  GroupMemberModifyReq();
  virtual ~GroupMemberModifyReq();

  GroupMemberModifyReq(const GroupMemberModifyReq& from);

  inline GroupMemberModifyReq& operator=(const GroupMemberModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberModifyReq& default_instance();

  void Swap(GroupMemberModifyReq* other);

  // implements Message ----------------------------------------------

  GroupMemberModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMember member = 2;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 2;
  inline const ::pp::GroupMember& member() const;
  inline ::pp::GroupMember* mutable_member();
  inline ::pp::GroupMember* release_member();
  inline void set_allocated_member(::pp::GroupMember* member);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberModifyReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_member();
  inline void clear_has_member();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::GroupMember* member_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberKickReq : public ::google::protobuf::Message {
 public:
  GroupMemberKickReq();
  virtual ~GroupMemberKickReq();

  GroupMemberKickReq(const GroupMemberKickReq& from);

  inline GroupMemberKickReq& operator=(const GroupMemberKickReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberKickReq& default_instance();

  void Swap(GroupMemberKickReq* other);

  // implements Message ----------------------------------------------

  GroupMemberKickReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 seconds = 3;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 3;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberKickReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberKickReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberSearchReq : public ::google::protobuf::Message {
 public:
  GroupMemberSearchReq();
  virtual ~GroupMemberSearchReq();

  GroupMemberSearchReq(const GroupMemberSearchReq& from);

  inline GroupMemberSearchReq& operator=(const GroupMemberSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberSearchReq& default_instance();

  void Swap(GroupMemberSearchReq* other);

  // implements Message ----------------------------------------------

  GroupMemberSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional string keyword = 4;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 4;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional .pp.GroupMemberRoler miniroler = 5;
  inline bool has_miniroler() const;
  inline void clear_miniroler();
  static const int kMinirolerFieldNumber = 5;
  inline ::pp::GroupMemberRoler miniroler() const;
  inline void set_miniroler(::pp::GroupMemberRoler value);

  // optional .pp.GroupMemberRoler maxiroler = 6;
  inline bool has_maxiroler() const;
  inline void clear_maxiroler();
  static const int kMaxirolerFieldNumber = 6;
  inline ::pp::GroupMemberRoler maxiroler() const;
  inline void set_maxiroler(::pp::GroupMemberRoler value);

  // optional .pp.GroupMemberSortBy sortby = 7;
  inline bool has_sortby() const;
  inline void clear_sortby();
  static const int kSortbyFieldNumber = 7;
  inline ::pp::GroupMemberSortBy sortby() const;
  inline void set_sortby(::pp::GroupMemberSortBy value);

  // optional .pp.GroupMemberOrderBy orderby = 8;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 8;
  inline ::pp::GroupMemberOrderBy orderby() const;
  inline void set_orderby(::pp::GroupMemberOrderBy value);

  // optional .pp.GroupMemberSearchBy searchby = 9;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchbyFieldNumber = 9;
  inline ::pp::GroupMemberSearchBy searchby() const;
  inline void set_searchby(::pp::GroupMemberSearchBy value);

  // optional .pp.GroupMember template = 11;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 11;
  inline const ::pp::GroupMember& template_() const;
  inline ::pp::GroupMember* mutable_template_();
  inline ::pp::GroupMember* release_template_();
  inline void set_allocated_template_(::pp::GroupMember* template_);

  // optional uint32 gameid = 12;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 12;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberSearchReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_miniroler();
  inline void clear_has_miniroler();
  inline void set_has_maxiroler();
  inline void clear_has_maxiroler();
  inline void set_has_sortby();
  inline void clear_has_sortby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_template_();
  inline void clear_has_template_();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::std::string* keyword_;
  int miniroler_;
  int maxiroler_;
  int sortby_;
  int orderby_;
  ::pp::GroupMember* template__;
  int searchby_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberSearchRes : public ::google::protobuf::Message {
 public:
  GroupMemberSearchRes();
  virtual ~GroupMemberSearchRes();

  GroupMemberSearchRes(const GroupMemberSearchRes& from);

  inline GroupMemberSearchRes& operator=(const GroupMemberSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberSearchRes& default_instance();

  void Swap(GroupMemberSearchRes* other);

  // implements Message ----------------------------------------------

  GroupMemberSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 totalresults = 3;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 3;
  inline ::google::protobuf::uint32 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.GroupMemberRoler miniroler = 5;
  inline bool has_miniroler() const;
  inline void clear_miniroler();
  static const int kMinirolerFieldNumber = 5;
  inline ::pp::GroupMemberRoler miniroler() const;
  inline void set_miniroler(::pp::GroupMemberRoler value);

  // optional .pp.GroupMemberRoler maxiroler = 6;
  inline bool has_maxiroler() const;
  inline void clear_maxiroler();
  static const int kMaxirolerFieldNumber = 6;
  inline ::pp::GroupMemberRoler maxiroler() const;
  inline void set_maxiroler(::pp::GroupMemberRoler value);

  // optional .pp.GroupMemberSortBy sortby = 7;
  inline bool has_sortby() const;
  inline void clear_sortby();
  static const int kSortbyFieldNumber = 7;
  inline ::pp::GroupMemberSortBy sortby() const;
  inline void set_sortby(::pp::GroupMemberSortBy value);

  // optional .pp.GroupMemberOrderBy orderby = 8;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 8;
  inline ::pp::GroupMemberOrderBy orderby() const;
  inline void set_orderby(::pp::GroupMemberOrderBy value);

  // optional .pp.GroupMemberSearchBy searchby = 9;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchbyFieldNumber = 9;
  inline ::pp::GroupMemberSearchBy searchby() const;
  inline void set_searchby(::pp::GroupMemberSearchBy value);

  // optional string keyword = 10;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 10;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // repeated .pp.GroupMember members = 11;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 11;
  inline const ::pp::GroupMember& members(int index) const;
  inline ::pp::GroupMember* mutable_members(int index);
  inline ::pp::GroupMember* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >*
      mutable_members();

  // optional uint32 gameid = 12;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 12;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberSearchRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_miniroler();
  inline void clear_has_miniroler();
  inline void set_has_maxiroler();
  inline void clear_has_maxiroler();
  inline void set_has_sortby();
  inline void clear_has_sortby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 totalresults_;
  ::google::protobuf::uint32 fetchs_;
  int miniroler_;
  int maxiroler_;
  int sortby_;
  int orderby_;
  int searchby_;
  ::std::string* keyword_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupMember > members_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberCountReq : public ::google::protobuf::Message {
 public:
  GroupMemberCountReq();
  virtual ~GroupMemberCountReq();

  GroupMemberCountReq(const GroupMemberCountReq& from);

  inline GroupMemberCountReq& operator=(const GroupMemberCountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberCountReq& default_instance();

  void Swap(GroupMemberCountReq* other);

  // implements Message ----------------------------------------------

  GroupMemberCountReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberCountType countType = 2;
  inline bool has_counttype() const;
  inline void clear_counttype();
  static const int kCountTypeFieldNumber = 2;
  inline ::pp::GroupMemberCountType counttype() const;
  inline void set_counttype(::pp::GroupMemberCountType value);

  // optional uint32 gameid = 3;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 3;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberCountReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_counttype();
  inline void clear_has_counttype();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  int counttype_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberCountReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMemberCountRes : public ::google::protobuf::Message {
 public:
  GroupMemberCountRes();
  virtual ~GroupMemberCountRes();

  GroupMemberCountRes(const GroupMemberCountRes& from);

  inline GroupMemberCountRes& operator=(const GroupMemberCountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMemberCountRes& default_instance();

  void Swap(GroupMemberCountRes* other);

  // implements Message ----------------------------------------------

  GroupMemberCountRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberCountType countType = 2;
  inline bool has_counttype() const;
  inline void clear_counttype();
  static const int kCountTypeFieldNumber = 2;
  inline ::pp::GroupMemberCountType counttype() const;
  inline void set_counttype(::pp::GroupMemberCountType value);

  // optional uint32 members = 3;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 3;
  inline ::google::protobuf::uint32 members() const;
  inline void set_members(::google::protobuf::uint32 value);

  // optional uint32 gameid = 4;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameidFieldNumber = 4;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 uninstalls = 5;
  inline bool has_uninstalls() const;
  inline void clear_uninstalls();
  static const int kUninstallsFieldNumber = 5;
  inline ::google::protobuf::uint32 uninstalls() const;
  inline void set_uninstalls(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMemberCountRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_counttype();
  inline void clear_has_counttype();
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_uninstalls();
  inline void clear_has_uninstalls();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  int counttype_;
  ::google::protobuf::uint32 members_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 uninstalls_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMemberCountRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgVoiceReq : public ::google::protobuf::Message {
 public:
  GroupMsgVoiceReq();
  virtual ~GroupMsgVoiceReq();

  GroupMsgVoiceReq(const GroupMsgVoiceReq& from);

  inline GroupMsgVoiceReq& operator=(const GroupMsgVoiceReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgVoiceReq& default_instance();

  void Swap(GroupMsgVoiceReq* other);

  // implements Message ----------------------------------------------

  GroupMsgVoiceReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgVoiceReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_duration();
  inline void clear_has_duration();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 duration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgVoiceReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgVoiceRes : public ::google::protobuf::Message {
 public:
  GroupMsgVoiceRes();
  virtual ~GroupMsgVoiceRes();

  GroupMsgVoiceRes(const GroupMsgVoiceRes& from);

  inline GroupMsgVoiceRes& operator=(const GroupMsgVoiceRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgVoiceRes& default_instance();

  void Swap(GroupMsgVoiceRes* other);

  // implements Message ----------------------------------------------

  GroupMsgVoiceRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 duration = 2;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 2;
  inline ::google::protobuf::uint32 duration() const;
  inline void set_duration(::google::protobuf::uint32 value);

  // optional string token = 3;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 3;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgVoiceRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::std::string* token_;
  ::google::protobuf::uint32 duration_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgVoiceRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgReq : public ::google::protobuf::Message {
 public:
  GroupMsgReq();
  virtual ~GroupMsgReq();

  GroupMsgReq(const GroupMsgReq& from);

  inline GroupMsgReq& operator=(const GroupMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgReq& default_instance();

  void Swap(GroupMsgReq* other);

  // implements Message ----------------------------------------------

  GroupMsgReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 topn = 4;
  inline bool has_topn() const;
  inline void clear_topn();
  static const int kTopnFieldNumber = 4;
  inline ::google::protobuf::uint32 topn() const;
  inline void set_topn(::google::protobuf::uint32 value);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_topn();
  inline void clear_has_topn();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 topn_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgListReq : public ::google::protobuf::Message {
 public:
  GroupMsgListReq();
  virtual ~GroupMsgListReq();

  GroupMsgListReq(const GroupMsgListReq& from);

  inline GroupMsgListReq& operator=(const GroupMsgListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgListReq& default_instance();

  void Swap(GroupMsgListReq* other);

  // implements Message ----------------------------------------------

  GroupMsgListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupMsgReq groups = 1;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 1;
  inline const ::pp::GroupMsgReq& groups(int index) const;
  inline ::pp::GroupMsgReq* mutable_groups(int index);
  inline ::pp::GroupMsgReq* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgReq >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgReq >*
      mutable_groups();

  // @@protoc_insertion_point(class_scope:pp.GroupMsgListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgReq > groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsg : public ::google::protobuf::Message {
 public:
  GroupMsg();
  virtual ~GroupMsg();

  GroupMsg(const GroupMsg& from);

  inline GroupMsg& operator=(const GroupMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsg& default_instance();

  void Swap(GroupMsg* other);

  // implements Message ----------------------------------------------

  GroupMsg* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .pp.GroupMsgType msgtype = 5;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 5;
  inline ::pp::GroupMsgType msgtype() const;
  inline void set_msgtype(::pp::GroupMsgType value);

  // optional .pp.GroupMember groupmember = 6;
  inline bool has_groupmember() const;
  inline void clear_groupmember();
  static const int kGroupmemberFieldNumber = 6;
  inline const ::pp::GroupMember& groupmember() const;
  inline ::pp::GroupMember* mutable_groupmember();
  inline ::pp::GroupMember* release_groupmember();
  inline void set_allocated_groupmember(::pp::GroupMember* groupmember);

  // optional int64 storetime = 8;
  inline bool has_storetime() const;
  inline void clear_storetime();
  static const int kStoretimeFieldNumber = 8;
  inline ::google::protobuf::int64 storetime() const;
  inline void set_storetime(::google::protobuf::int64 value);

  // optional string extfield = 9;
  inline bool has_extfield() const;
  inline void clear_extfield();
  static const int kExtfieldFieldNumber = 9;
  inline const ::std::string& extfield() const;
  inline void set_extfield(const ::std::string& value);
  inline void set_extfield(const char* value);
  inline void set_extfield(const char* value, size_t size);
  inline ::std::string* mutable_extfield();
  inline ::std::string* release_extfield();
  inline void set_allocated_extfield(::std::string* extfield);

  // optional uint64 refmsg = 10;
  inline bool has_refmsg() const;
  inline void clear_refmsg();
  static const int kRefmsgFieldNumber = 10;
  inline ::google::protobuf::uint64 refmsg() const;
  inline void set_refmsg(::google::protobuf::uint64 value);

  // optional .pp.MessageContentType contentType = 12;
  inline bool has_contenttype() const;
  inline void clear_contenttype();
  static const int kContentTypeFieldNumber = 12;
  inline ::pp::MessageContentType contenttype() const;
  inline void set_contenttype(::pp::MessageContentType value);

  // optional .pp.GroupInfo group = 13;
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 13;
  inline const ::pp::GroupInfo& group() const;
  inline ::pp::GroupInfo* mutable_group();
  inline ::pp::GroupInfo* release_group();
  inline void set_allocated_group(::pp::GroupInfo* group);

  // optional .pp.ExtProps extprops = 14;
  inline bool has_extprops() const;
  inline void clear_extprops();
  static const int kExtpropsFieldNumber = 14;
  inline const ::pp::ExtProps& extprops() const;
  inline ::pp::ExtProps* mutable_extprops();
  inline ::pp::ExtProps* release_extprops();
  inline void set_allocated_extprops(::pp::ExtProps* extprops);

  // @@protoc_insertion_point(class_scope:pp.GroupMsg)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_groupmember();
  inline void clear_has_groupmember();
  inline void set_has_storetime();
  inline void clear_has_storetime();
  inline void set_has_extfield();
  inline void clear_has_extfield();
  inline void set_has_refmsg();
  inline void clear_has_refmsg();
  inline void set_has_contenttype();
  inline void clear_has_contenttype();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_extprops();
  inline void clear_has_extprops();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::std::string* message_;
  ::google::protobuf::int64 timestamp_;
  ::pp::GroupMember* groupmember_;
  ::google::protobuf::int64 storetime_;
  int msgtype_;
  int contenttype_;
  ::std::string* extfield_;
  ::google::protobuf::uint64 refmsg_;
  ::pp::GroupInfo* group_;
  ::pp::ExtProps* extprops_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsg* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgList : public ::google::protobuf::Message {
 public:
  GroupMsgList();
  virtual ~GroupMsgList();

  GroupMsgList(const GroupMsgList& from);

  inline GroupMsgList& operator=(const GroupMsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgList& default_instance();

  void Swap(GroupMsgList* other);

  // implements Message ----------------------------------------------

  GroupMsgList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated .pp.GroupMsg msgs = 3;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 3;
  inline const ::pp::GroupMsg& msgs(int index) const;
  inline ::pp::GroupMsg* mutable_msgs(int index);
  inline ::pp::GroupMsg* add_msgs();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >&
      msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >*
      mutable_msgs();

  // optional uint64 apprevision = 5;
  inline bool has_apprevision() const;
  inline void clear_apprevision();
  static const int kApprevisionFieldNumber = 5;
  inline ::google::protobuf::uint64 apprevision() const;
  inline void set_apprevision(::google::protobuf::uint64 value);

  // optional uint64 revread = 7;
  inline bool has_revread() const;
  inline void clear_revread();
  static const int kRevreadFieldNumber = 7;
  inline ::google::protobuf::uint64 revread() const;
  inline void set_revread(::google::protobuf::uint64 value);

  // optional uint32 fetchs = 8;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 8;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 topn = 9;
  inline bool has_topn() const;
  inline void clear_topn();
  static const int kTopnFieldNumber = 9;
  inline ::google::protobuf::uint32 topn() const;
  inline void set_topn(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgList)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_apprevision();
  inline void clear_has_apprevision();
  inline void set_has_revread();
  inline void clear_has_revread();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_topn();
  inline void clear_has_topn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg > msgs_;
  ::google::protobuf::uint64 apprevision_;
  ::google::protobuf::uint64 revread_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 topn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgList* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgListRes : public ::google::protobuf::Message {
 public:
  GroupMsgListRes();
  virtual ~GroupMsgListRes();

  GroupMsgListRes(const GroupMsgListRes& from);

  inline GroupMsgListRes& operator=(const GroupMsgListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgListRes& default_instance();

  void Swap(GroupMsgListRes* other);

  // implements Message ----------------------------------------------

  GroupMsgListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupMsgList msglists = 1;
  inline int msglists_size() const;
  inline void clear_msglists();
  static const int kMsglistsFieldNumber = 1;
  inline const ::pp::GroupMsgList& msglists(int index) const;
  inline ::pp::GroupMsgList* mutable_msglists(int index);
  inline ::pp::GroupMsgList* add_msglists();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgList >&
      msglists() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgList >*
      mutable_msglists();

  // repeated .pp.UserInfo users = 2;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 2;
  inline const ::pp::UserInfo& users(int index) const;
  inline ::pp::UserInfo* mutable_users(int index);
  inline ::pp::UserInfo* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:pp.GroupMsgListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgList > msglists_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserInfo > users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgListRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgSearchReq : public ::google::protobuf::Message {
 public:
  GroupMsgSearchReq();
  virtual ~GroupMsgSearchReq();

  GroupMsgSearchReq(const GroupMsgSearchReq& from);

  inline GroupMsgSearchReq& operator=(const GroupMsgSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgSearchReq& default_instance();

  void Swap(GroupMsgSearchReq* other);

  // implements Message ----------------------------------------------

  GroupMsgSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.GroupMsgType msgtype = 4;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 4;
  inline ::pp::GroupMsgType msgtype() const;
  inline void set_msgtype(::pp::GroupMsgType value);

  // optional string password = 5;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 5;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // repeated .pp.MessageContentType contentTypes = 6;
  inline int contenttypes_size() const;
  inline void clear_contenttypes();
  static const int kContentTypesFieldNumber = 6;
  inline ::pp::MessageContentType contenttypes(int index) const;
  inline void set_contenttypes(int index, ::pp::MessageContentType value);
  inline void add_contenttypes(::pp::MessageContentType value);
  inline const ::google::protobuf::RepeatedField<int>& contenttypes() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_contenttypes();

  // optional .pp.GroupMsgSortBy sortby = 7;
  inline bool has_sortby() const;
  inline void clear_sortby();
  static const int kSortbyFieldNumber = 7;
  inline ::pp::GroupMsgSortBy sortby() const;
  inline void set_sortby(::pp::GroupMsgSortBy value);

  // optional .pp.GroupMsgOrderBy orderby = 8;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 8;
  inline ::pp::GroupMsgOrderBy orderby() const;
  inline void set_orderby(::pp::GroupMsgOrderBy value);

  // optional bool compress = 9;
  inline bool has_compress() const;
  inline void clear_compress();
  static const int kCompressFieldNumber = 9;
  inline bool compress() const;
  inline void set_compress(bool value);

  // optional int64 cacheKey = 10;
  inline bool has_cachekey() const;
  inline void clear_cachekey();
  static const int kCacheKeyFieldNumber = 10;
  inline ::google::protobuf::int64 cachekey() const;
  inline void set_cachekey(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgSearchReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_sortby();
  inline void clear_has_sortby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_compress();
  inline void clear_has_compress();
  inline void set_has_cachekey();
  inline void clear_has_cachekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint32 fetchs_;
  int msgtype_;
  ::std::string* password_;
  ::google::protobuf::RepeatedField<int> contenttypes_;
  int sortby_;
  int orderby_;
  ::google::protobuf::int64 cachekey_;
  bool compress_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgSearchRes : public ::google::protobuf::Message {
 public:
  GroupMsgSearchRes();
  virtual ~GroupMsgSearchRes();

  GroupMsgSearchRes(const GroupMsgSearchRes& from);

  inline GroupMsgSearchRes& operator=(const GroupMsgSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgSearchRes& default_instance();

  void Swap(GroupMsgSearchRes* other);

  // implements Message ----------------------------------------------

  GroupMsgSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // optional uint64 totalresults = 3;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 3;
  inline ::google::protobuf::uint64 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint64 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.GroupMsgType msgtype = 5;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 5;
  inline ::pp::GroupMsgType msgtype() const;
  inline void set_msgtype(::pp::GroupMsgType value);

  // repeated .pp.MessageContentType contentTypes = 6;
  inline int contenttypes_size() const;
  inline void clear_contenttypes();
  static const int kContentTypesFieldNumber = 6;
  inline ::pp::MessageContentType contenttypes(int index) const;
  inline void set_contenttypes(int index, ::pp::MessageContentType value);
  inline void add_contenttypes(::pp::MessageContentType value);
  inline const ::google::protobuf::RepeatedField<int>& contenttypes() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_contenttypes();

  // optional .pp.GroupMsgSortBy sortby = 7;
  inline bool has_sortby() const;
  inline void clear_sortby();
  static const int kSortbyFieldNumber = 7;
  inline ::pp::GroupMsgSortBy sortby() const;
  inline void set_sortby(::pp::GroupMsgSortBy value);

  // optional .pp.GroupMsgOrderBy orderby = 8;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 8;
  inline ::pp::GroupMsgOrderBy orderby() const;
  inline void set_orderby(::pp::GroupMsgOrderBy value);

  // repeated .pp.GroupMsg msgs = 9;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 9;
  inline const ::pp::GroupMsg& msgs(int index) const;
  inline ::pp::GroupMsg* mutable_msgs(int index);
  inline ::pp::GroupMsg* add_msgs();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >&
      msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >*
      mutable_msgs();

  // optional .pp.ErrCode errcode = 10;
  inline bool has_errcode() const;
  inline void clear_errcode();
  static const int kErrcodeFieldNumber = 10;
  inline ::pp::ErrCode errcode() const;
  inline void set_errcode(::pp::ErrCode value);

  // repeated .pp.UserInfo users = 11;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 11;
  inline const ::pp::UserInfo& users(int index) const;
  inline ::pp::UserInfo* mutable_users(int index);
  inline ::pp::UserInfo* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
      mutable_users();

  // optional int64 cacheKey = 12;
  inline bool has_cachekey() const;
  inline void clear_cachekey();
  static const int kCacheKeyFieldNumber = 12;
  inline ::google::protobuf::int64 cachekey() const;
  inline void set_cachekey(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgSearchRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_sortby();
  inline void clear_has_sortby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_errcode();
  inline void clear_has_errcode();
  inline void set_has_cachekey();
  inline void clear_has_cachekey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::uint64 totalresults_;
  ::google::protobuf::uint32 fetchs_;
  int msgtype_;
  ::google::protobuf::RepeatedField<int> contenttypes_;
  int sortby_;
  int orderby_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg > msgs_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserInfo > users_;
  ::google::protobuf::int64 cachekey_;
  int errcode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMsgSendReq : public ::google::protobuf::Message {
 public:
  GroupMsgSendReq();
  virtual ~GroupMsgSendReq();

  GroupMsgSendReq(const GroupMsgSendReq& from);

  inline GroupMsgSendReq& operator=(const GroupMsgSendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMsgSendReq& default_instance();

  void Swap(GroupMsgSendReq* other);

  // implements Message ----------------------------------------------

  GroupMsgSendReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.GroupMsg msg = 2;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 2;
  inline const ::pp::GroupMsg& msg() const;
  inline ::pp::GroupMsg* mutable_msg();
  inline ::pp::GroupMsg* release_msg();
  inline void set_allocated_msg(::pp::GroupMsg* msg);

  // @@protoc_insertion_point(class_scope:pp.GroupMsgSendReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_msg();
  inline void clear_has_msg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::GroupMsg* msg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMsgSendReq* default_instance_;
};
// -------------------------------------------------------------------

class YYAccountInfo : public ::google::protobuf::Message {
 public:
  YYAccountInfo();
  virtual ~YYAccountInfo();

  YYAccountInfo(const YYAccountInfo& from);

  inline YYAccountInfo& operator=(const YYAccountInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYAccountInfo& default_instance();

  void Swap(YYAccountInfo* other);

  // implements Message ----------------------------------------------

  YYAccountInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 yyuid = 1;
  inline bool has_yyuid() const;
  inline void clear_yyuid();
  static const int kYyuidFieldNumber = 1;
  inline ::google::protobuf::uint64 yyuid() const;
  inline void set_yyuid(::google::protobuf::uint64 value);

  // optional .pp.SexType sex = 2;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 2;
  inline ::pp::SexType sex() const;
  inline void set_sex(::pp::SexType value);

  // optional string passport = 3;
  inline bool has_passport() const;
  inline void clear_passport();
  static const int kPassportFieldNumber = 3;
  inline const ::std::string& passport() const;
  inline void set_passport(const ::std::string& value);
  inline void set_passport(const char* value);
  inline void set_passport(const char* value, size_t size);
  inline ::std::string* mutable_passport();
  inline ::std::string* release_passport();
  inline void set_allocated_passport(::std::string* passport);

  // optional string nick = 4;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 4;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional string logourl = 5;
  inline bool has_logourl() const;
  inline void clear_logourl();
  static const int kLogourlFieldNumber = 5;
  inline const ::std::string& logourl() const;
  inline void set_logourl(const ::std::string& value);
  inline void set_logourl(const char* value);
  inline void set_logourl(const char* value, size_t size);
  inline ::std::string* mutable_logourl();
  inline ::std::string* release_logourl();
  inline void set_allocated_logourl(::std::string* logourl);

  // optional string birthday = 6;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 6;
  inline const ::std::string& birthday() const;
  inline void set_birthday(const ::std::string& value);
  inline void set_birthday(const char* value);
  inline void set_birthday(const char* value, size_t size);
  inline ::std::string* mutable_birthday();
  inline ::std::string* release_birthday();
  inline void set_allocated_birthday(::std::string* birthday);

  // optional string openid = 9;
  inline bool has_openid() const;
  inline void clear_openid();
  static const int kOpenidFieldNumber = 9;
  inline const ::std::string& openid() const;
  inline void set_openid(const ::std::string& value);
  inline void set_openid(const char* value);
  inline void set_openid(const char* value, size_t size);
  inline ::std::string* mutable_openid();
  inline ::std::string* release_openid();
  inline void set_allocated_openid(::std::string* openid);

  // @@protoc_insertion_point(class_scope:pp.YYAccountInfo)
 private:
  inline void set_has_yyuid();
  inline void clear_has_yyuid();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_passport();
  inline void clear_has_passport();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_logourl();
  inline void clear_has_logourl();
  inline void set_has_birthday();
  inline void clear_has_birthday();
  inline void set_has_openid();
  inline void clear_has_openid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 yyuid_;
  ::std::string* passport_;
  ::std::string* nick_;
  ::std::string* logourl_;
  ::std::string* birthday_;
  ::std::string* openid_;
  int sex_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYAccountInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginReq : public ::google::protobuf::Message {
 public:
  UserLoginReq();
  virtual ~UserLoginReq();

  UserLoginReq(const UserLoginReq& from);

  inline UserLoginReq& operator=(const UserLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginReq& default_instance();

  void Swap(UserLoginReq* other);

  // implements Message ----------------------------------------------

  UserLoginReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string macid = 3;
  inline bool has_macid() const;
  inline void clear_macid();
  static const int kMacidFieldNumber = 3;
  inline const ::std::string& macid() const;
  inline void set_macid(const ::std::string& value);
  inline void set_macid(const char* value);
  inline void set_macid(const char* value, size_t size);
  inline ::std::string* mutable_macid();
  inline ::std::string* release_macid();
  inline void set_allocated_macid(::std::string* macid);

  // optional string cookie = 4;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 4;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string identifyingCode = 6;
  inline bool has_identifyingcode() const;
  inline void clear_identifyingcode();
  static const int kIdentifyingCodeFieldNumber = 6;
  inline const ::std::string& identifyingcode() const;
  inline void set_identifyingcode(const ::std::string& value);
  inline void set_identifyingcode(const char* value);
  inline void set_identifyingcode(const char* value, size_t size);
  inline ::std::string* mutable_identifyingcode();
  inline ::std::string* release_identifyingcode();
  inline void set_allocated_identifyingcode(::std::string* identifyingcode);

  // optional uint64 yyuid = 7;
  inline bool has_yyuid() const;
  inline void clear_yyuid();
  static const int kYyuidFieldNumber = 7;
  inline ::google::protobuf::uint64 yyuid() const;
  inline void set_yyuid(::google::protobuf::uint64 value);

  // optional uint32 pushSerialnum = 8;
  inline bool has_pushserialnum() const;
  inline void clear_pushserialnum();
  static const int kPushSerialnumFieldNumber = 8;
  inline ::google::protobuf::uint32 pushserialnum() const;
  inline void set_pushserialnum(::google::protobuf::uint32 value);

  // optional bool newsession = 9;
  inline bool has_newsession() const;
  inline void clear_newsession();
  static const int kNewsessionFieldNumber = 9;
  inline bool newsession() const;
  inline void set_newsession(bool value);

  // optional .pp.AccountType accountType = 10;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccountTypeFieldNumber = 10;
  inline ::pp::AccountType accounttype() const;
  inline void set_accounttype(::pp::AccountType value);

  // optional .pp.YYAccountInfo accountInfo = 11;
  inline bool has_accountinfo() const;
  inline void clear_accountinfo();
  static const int kAccountInfoFieldNumber = 11;
  inline const ::pp::YYAccountInfo& accountinfo() const;
  inline ::pp::YYAccountInfo* mutable_accountinfo();
  inline ::pp::YYAccountInfo* release_accountinfo();
  inline void set_allocated_accountinfo(::pp::YYAccountInfo* accountinfo);

  // optional string devtype = 20;
  inline bool has_devtype() const;
  inline void clear_devtype();
  static const int kDevtypeFieldNumber = 20;
  inline const ::std::string& devtype() const;
  inline void set_devtype(const ::std::string& value);
  inline void set_devtype(const char* value);
  inline void set_devtype(const char* value, size_t size);
  inline ::std::string* mutable_devtype();
  inline ::std::string* release_devtype();
  inline void set_allocated_devtype(::std::string* devtype);

  // optional string osinfo = 21;
  inline bool has_osinfo() const;
  inline void clear_osinfo();
  static const int kOsinfoFieldNumber = 21;
  inline const ::std::string& osinfo() const;
  inline void set_osinfo(const ::std::string& value);
  inline void set_osinfo(const char* value);
  inline void set_osinfo(const char* value, size_t size);
  inline ::std::string* mutable_osinfo();
  inline ::std::string* release_osinfo();
  inline void set_allocated_osinfo(::std::string* osinfo);

  // optional string finger = 22;
  inline bool has_finger() const;
  inline void clear_finger();
  static const int kFingerFieldNumber = 22;
  inline const ::std::string& finger() const;
  inline void set_finger(const ::std::string& value);
  inline void set_finger(const char* value);
  inline void set_finger(const char* value, size_t size);
  inline ::std::string* mutable_finger();
  inline ::std::string* release_finger();
  inline void set_allocated_finger(::std::string* finger);

  // optional .pp.ProtoVersion protoVersion = 30;
  inline bool has_protoversion() const;
  inline void clear_protoversion();
  static const int kProtoVersionFieldNumber = 30;
  inline ::pp::ProtoVersion protoversion() const;
  inline void set_protoversion(::pp::ProtoVersion value);

  // optional string ipaddress = 50;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 50;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional string fromStore = 60;
  inline bool has_fromstore() const;
  inline void clear_fromstore();
  static const int kFromStoreFieldNumber = 60;
  inline const ::std::string& fromstore() const;
  inline void set_fromstore(const ::std::string& value);
  inline void set_fromstore(const char* value);
  inline void set_fromstore(const char* value, size_t size);
  inline ::std::string* mutable_fromstore();
  inline ::std::string* release_fromstore();
  inline void set_allocated_fromstore(::std::string* fromstore);

  // @@protoc_insertion_point(class_scope:pp.UserLoginReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_macid();
  inline void clear_has_macid();
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_identifyingcode();
  inline void clear_has_identifyingcode();
  inline void set_has_yyuid();
  inline void clear_has_yyuid();
  inline void set_has_pushserialnum();
  inline void clear_has_pushserialnum();
  inline void set_has_newsession();
  inline void clear_has_newsession();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_accountinfo();
  inline void clear_has_accountinfo();
  inline void set_has_devtype();
  inline void clear_has_devtype();
  inline void set_has_osinfo();
  inline void clear_has_osinfo();
  inline void set_has_finger();
  inline void clear_has_finger();
  inline void set_has_protoversion();
  inline void clear_has_protoversion();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_fromstore();
  inline void clear_has_fromstore();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* password_;
  ::std::string* macid_;
  ::std::string* cookie_;
  ::std::string* name_;
  ::std::string* identifyingcode_;
  ::google::protobuf::uint64 yyuid_;
  ::google::protobuf::uint32 pushserialnum_;
  bool newsession_;
  ::pp::YYAccountInfo* accountinfo_;
  ::std::string* devtype_;
  int accounttype_;
  int protoversion_;
  ::std::string* osinfo_;
  ::std::string* finger_;
  ::std::string* ipaddress_;
  ::std::string* fromstore_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginRes : public ::google::protobuf::Message {
 public:
  UserLoginRes();
  virtual ~UserLoginRes();

  UserLoginRes(const UserLoginRes& from);

  inline UserLoginRes& operator=(const UserLoginRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginRes& default_instance();

  void Swap(UserLoginRes* other);

  // implements Message ----------------------------------------------

  UserLoginRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // optional bool newsession = 2;
  inline bool has_newsession() const;
  inline void clear_newsession();
  static const int kNewsessionFieldNumber = 2;
  inline bool newsession() const;
  inline void set_newsession(bool value);

  // optional .pp.UserInfo userinfo = 3;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 3;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional bool newuser = 4 [default = false];
  inline bool has_newuser() const;
  inline void clear_newuser();
  static const int kNewuserFieldNumber = 4;
  inline bool newuser() const;
  inline void set_newuser(bool value);

  // optional int64 forbidtime = 5;
  inline bool has_forbidtime() const;
  inline void clear_forbidtime();
  static const int kForbidtimeFieldNumber = 5;
  inline ::google::protobuf::int64 forbidtime() const;
  inline void set_forbidtime(::google::protobuf::int64 value);

  // optional int64 currenttime = 6;
  inline bool has_currenttime() const;
  inline void clear_currenttime();
  static const int kCurrenttimeFieldNumber = 6;
  inline ::google::protobuf::int64 currenttime() const;
  inline void set_currenttime(::google::protobuf::int64 value);

  // optional int64 logfileupload = 7;
  inline bool has_logfileupload() const;
  inline void clear_logfileupload();
  static const int kLogfileuploadFieldNumber = 7;
  inline ::google::protobuf::int64 logfileupload() const;
  inline void set_logfileupload(::google::protobuf::int64 value);

  // optional uint32 loglevel = 8;
  inline bool has_loglevel() const;
  inline void clear_loglevel();
  static const int kLoglevelFieldNumber = 8;
  inline ::google::protobuf::uint32 loglevel() const;
  inline void set_loglevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserLoginRes)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_newsession();
  inline void clear_has_newsession();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_newuser();
  inline void clear_has_newuser();
  inline void set_has_forbidtime();
  inline void clear_has_forbidtime();
  inline void set_has_currenttime();
  inline void clear_has_currenttime();
  inline void set_has_logfileupload();
  inline void clear_has_logfileupload();
  inline void set_has_loglevel();
  inline void clear_has_loglevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::pp::UserInfo* userinfo_;
  bool newsession_;
  bool newuser_;
  ::google::protobuf::uint32 loglevel_;
  ::google::protobuf::int64 forbidtime_;
  ::google::protobuf::int64 currenttime_;
  ::google::protobuf::int64 logfileupload_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLoginRes* default_instance_;
};
// -------------------------------------------------------------------

class UserLogoutReq : public ::google::protobuf::Message {
 public:
  UserLogoutReq();
  virtual ~UserLogoutReq();

  UserLogoutReq(const UserLogoutReq& from);

  inline UserLogoutReq& operator=(const UserLogoutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogoutReq& default_instance();

  void Swap(UserLogoutReq* other);

  // implements Message ----------------------------------------------

  UserLogoutReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserLogoutReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLogoutReq* default_instance_;
};
// -------------------------------------------------------------------

class UserLogoutRes : public ::google::protobuf::Message {
 public:
  UserLogoutRes();
  virtual ~UserLogoutRes();

  UserLogoutRes(const UserLogoutRes& from);

  inline UserLogoutRes& operator=(const UserLogoutRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLogoutRes& default_instance();

  void Swap(UserLogoutRes* other);

  // implements Message ----------------------------------------------

  UserLogoutRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserLogoutRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLogoutRes* default_instance_;
};
// -------------------------------------------------------------------

class UserPushTokenRegisterReq : public ::google::protobuf::Message {
 public:
  UserPushTokenRegisterReq();
  virtual ~UserPushTokenRegisterReq();

  UserPushTokenRegisterReq(const UserPushTokenRegisterReq& from);

  inline UserPushTokenRegisterReq& operator=(const UserPushTokenRegisterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPushTokenRegisterReq& default_instance();

  void Swap(UserPushTokenRegisterReq* other);

  // implements Message ----------------------------------------------

  UserPushTokenRegisterReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserPushTokenRegisterReq_DeviceType DeviceType;
  static const DeviceType Android = UserPushTokenRegisterReq_DeviceType_Android;
  static const DeviceType Ios = UserPushTokenRegisterReq_DeviceType_Ios;
  static inline bool DeviceType_IsValid(int value) {
    return UserPushTokenRegisterReq_DeviceType_IsValid(value);
  }
  static const DeviceType DeviceType_MIN =
    UserPushTokenRegisterReq_DeviceType_DeviceType_MIN;
  static const DeviceType DeviceType_MAX =
    UserPushTokenRegisterReq_DeviceType_DeviceType_MAX;
  static const int DeviceType_ARRAYSIZE =
    UserPushTokenRegisterReq_DeviceType_DeviceType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  DeviceType_descriptor() {
    return UserPushTokenRegisterReq_DeviceType_descriptor();
  }
  static inline const ::std::string& DeviceType_Name(DeviceType value) {
    return UserPushTokenRegisterReq_DeviceType_Name(value);
  }
  static inline bool DeviceType_Parse(const ::std::string& name,
      DeviceType* value) {
    return UserPushTokenRegisterReq_DeviceType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string deviceId = 1;
  inline bool has_deviceid() const;
  inline void clear_deviceid();
  static const int kDeviceIdFieldNumber = 1;
  inline const ::std::string& deviceid() const;
  inline void set_deviceid(const ::std::string& value);
  inline void set_deviceid(const char* value);
  inline void set_deviceid(const char* value, size_t size);
  inline ::std::string* mutable_deviceid();
  inline ::std::string* release_deviceid();
  inline void set_allocated_deviceid(::std::string* deviceid);

  // required string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional .pp.UserPushTokenRegisterReq.DeviceType type = 3 [default = Android];
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::pp::UserPushTokenRegisterReq_DeviceType type() const;
  inline void set_type(::pp::UserPushTokenRegisterReq_DeviceType value);

  // @@protoc_insertion_point(class_scope:pp.UserPushTokenRegisterReq)
 private:
  inline void set_has_deviceid();
  inline void clear_has_deviceid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* deviceid_;
  ::std::string* token_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPushTokenRegisterReq* default_instance_;
};
// -------------------------------------------------------------------

class UserPushTokenRegisterRes : public ::google::protobuf::Message {
 public:
  UserPushTokenRegisterRes();
  virtual ~UserPushTokenRegisterRes();

  UserPushTokenRegisterRes(const UserPushTokenRegisterRes& from);

  inline UserPushTokenRegisterRes& operator=(const UserPushTokenRegisterRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPushTokenRegisterRes& default_instance();

  void Swap(UserPushTokenRegisterRes* other);

  // implements Message ----------------------------------------------

  UserPushTokenRegisterRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserPushTokenRegisterRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPushTokenRegisterRes* default_instance_;
};
// -------------------------------------------------------------------

class UserWebLoginReq : public ::google::protobuf::Message {
 public:
  UserWebLoginReq();
  virtual ~UserWebLoginReq();

  UserWebLoginReq(const UserWebLoginReq& from);

  inline UserWebLoginReq& operator=(const UserWebLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserWebLoginReq& default_instance();

  void Swap(UserWebLoginReq* other);

  // implements Message ----------------------------------------------

  UserWebLoginReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string verifycode = 1;
  inline bool has_verifycode() const;
  inline void clear_verifycode();
  static const int kVerifycodeFieldNumber = 1;
  inline const ::std::string& verifycode() const;
  inline void set_verifycode(const ::std::string& value);
  inline void set_verifycode(const char* value);
  inline void set_verifycode(const char* value, size_t size);
  inline ::std::string* mutable_verifycode();
  inline ::std::string* release_verifycode();
  inline void set_allocated_verifycode(::std::string* verifycode);

  // optional uint64 uid = 100;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 100;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 roletype = 101;
  inline bool has_roletype() const;
  inline void clear_roletype();
  static const int kRoletypeFieldNumber = 101;
  inline ::google::protobuf::uint32 roletype() const;
  inline void set_roletype(::google::protobuf::uint32 value);

  // optional string password = 102;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 102;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string mobilephone = 103;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 103;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional bool qmode = 104;
  inline bool has_qmode() const;
  inline void clear_qmode();
  static const int kQmodeFieldNumber = 104;
  inline bool qmode() const;
  inline void set_qmode(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserWebLoginReq)
 private:
  inline void set_has_verifycode();
  inline void clear_has_verifycode();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_roletype();
  inline void clear_has_roletype();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_qmode();
  inline void clear_has_qmode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* verifycode_;
  ::google::protobuf::uint64 uid_;
  ::std::string* password_;
  ::google::protobuf::uint32 roletype_;
  bool qmode_;
  ::std::string* mobilephone_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserWebLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class UserWebLoginRes : public ::google::protobuf::Message {
 public:
  UserWebLoginRes();
  virtual ~UserWebLoginRes();

  UserWebLoginRes(const UserWebLoginRes& from);

  inline UserWebLoginRes& operator=(const UserWebLoginRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserWebLoginRes& default_instance();

  void Swap(UserWebLoginRes* other);

  // implements Message ----------------------------------------------

  UserWebLoginRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserWebLoginRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserWebLoginRes* default_instance_;
};
// -------------------------------------------------------------------

class UserTokenReq : public ::google::protobuf::Message {
 public:
  UserTokenReq();
  virtual ~UserTokenReq();

  UserTokenReq(const UserTokenReq& from);

  inline UserTokenReq& operator=(const UserTokenReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTokenReq& default_instance();

  void Swap(UserTokenReq* other);

  // implements Message ----------------------------------------------

  UserTokenReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string macid = 1;
  inline bool has_macid() const;
  inline void clear_macid();
  static const int kMacidFieldNumber = 1;
  inline const ::std::string& macid() const;
  inline void set_macid(const ::std::string& value);
  inline void set_macid(const char* value);
  inline void set_macid(const char* value, size_t size);
  inline ::std::string* mutable_macid();
  inline ::std::string* release_macid();
  inline void set_allocated_macid(::std::string* macid);

  // optional string mobilephone = 2;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 2;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional bool checkrepeat = 3;
  inline bool has_checkrepeat() const;
  inline void clear_checkrepeat();
  static const int kCheckrepeatFieldNumber = 3;
  inline bool checkrepeat() const;
  inline void set_checkrepeat(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserTokenReq)
 private:
  inline void set_has_macid();
  inline void clear_has_macid();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_checkrepeat();
  inline void clear_has_checkrepeat();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* macid_;
  ::std::string* mobilephone_;
  bool checkrepeat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTokenReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTokenRes : public ::google::protobuf::Message {
 public:
  UserTokenRes();
  virtual ~UserTokenRes();

  UserTokenRes(const UserTokenRes& from);

  inline UserTokenRes& operator=(const UserTokenRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTokenRes& default_instance();

  void Swap(UserTokenRes* other);

  // implements Message ----------------------------------------------

  UserTokenRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:pp.UserTokenRes)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTokenRes* default_instance_;
};
// -------------------------------------------------------------------

class UserActivateReq : public ::google::protobuf::Message {
 public:
  UserActivateReq();
  virtual ~UserActivateReq();

  UserActivateReq(const UserActivateReq& from);

  inline UserActivateReq& operator=(const UserActivateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActivateReq& default_instance();

  void Swap(UserActivateReq* other);

  // implements Message ----------------------------------------------

  UserActivateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string macid = 1;
  inline bool has_macid() const;
  inline void clear_macid();
  static const int kMacidFieldNumber = 1;
  inline const ::std::string& macid() const;
  inline void set_macid(const ::std::string& value);
  inline void set_macid(const char* value);
  inline void set_macid(const char* value, size_t size);
  inline ::std::string* mutable_macid();
  inline ::std::string* release_macid();
  inline void set_allocated_macid(::std::string* macid);

  // optional string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string identifyingCode = 3;
  inline bool has_identifyingcode() const;
  inline void clear_identifyingcode();
  static const int kIdentifyingCodeFieldNumber = 3;
  inline const ::std::string& identifyingcode() const;
  inline void set_identifyingcode(const ::std::string& value);
  inline void set_identifyingcode(const char* value);
  inline void set_identifyingcode(const char* value, size_t size);
  inline ::std::string* mutable_identifyingcode();
  inline ::std::string* release_identifyingcode();
  inline void set_allocated_identifyingcode(::std::string* identifyingcode);

  // optional string password = 10;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 10;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional .pp.UserInfo userInfo = 11;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 11;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional uint64 refereeUid = 15;
  inline bool has_refereeuid() const;
  inline void clear_refereeuid();
  static const int kRefereeUidFieldNumber = 15;
  inline ::google::protobuf::uint64 refereeuid() const;
  inline void set_refereeuid(::google::protobuf::uint64 value);

  // optional string finger = 22;
  inline bool has_finger() const;
  inline void clear_finger();
  static const int kFingerFieldNumber = 22;
  inline const ::std::string& finger() const;
  inline void set_finger(const ::std::string& value);
  inline void set_finger(const char* value);
  inline void set_finger(const char* value, size_t size);
  inline ::std::string* mutable_finger();
  inline ::std::string* release_finger();
  inline void set_allocated_finger(::std::string* finger);

  // optional .pp.ProtoVersion protoVersion = 30;
  inline bool has_protoversion() const;
  inline void clear_protoversion();
  static const int kProtoVersionFieldNumber = 30;
  inline ::pp::ProtoVersion protoversion() const;
  inline void set_protoversion(::pp::ProtoVersion value);

  // optional string ipaddress = 40;
  inline bool has_ipaddress() const;
  inline void clear_ipaddress();
  static const int kIpaddressFieldNumber = 40;
  inline const ::std::string& ipaddress() const;
  inline void set_ipaddress(const ::std::string& value);
  inline void set_ipaddress(const char* value);
  inline void set_ipaddress(const char* value, size_t size);
  inline ::std::string* mutable_ipaddress();
  inline ::std::string* release_ipaddress();
  inline void set_allocated_ipaddress(::std::string* ipaddress);

  // optional bool resetpassword = 50;
  inline bool has_resetpassword() const;
  inline void clear_resetpassword();
  static const int kResetpasswordFieldNumber = 50;
  inline bool resetpassword() const;
  inline void set_resetpassword(bool value);

  // optional string fromStore = 60;
  inline bool has_fromstore() const;
  inline void clear_fromstore();
  static const int kFromStoreFieldNumber = 60;
  inline const ::std::string& fromstore() const;
  inline void set_fromstore(const ::std::string& value);
  inline void set_fromstore(const char* value);
  inline void set_fromstore(const char* value, size_t size);
  inline ::std::string* mutable_fromstore();
  inline ::std::string* release_fromstore();
  inline void set_allocated_fromstore(::std::string* fromstore);

  // optional string inviteCode = 100;
  inline bool has_invitecode() const;
  inline void clear_invitecode();
  static const int kInviteCodeFieldNumber = 100;
  inline const ::std::string& invitecode() const;
  inline void set_invitecode(const ::std::string& value);
  inline void set_invitecode(const char* value);
  inline void set_invitecode(const char* value, size_t size);
  inline ::std::string* mutable_invitecode();
  inline ::std::string* release_invitecode();
  inline void set_allocated_invitecode(::std::string* invitecode);

  // @@protoc_insertion_point(class_scope:pp.UserActivateReq)
 private:
  inline void set_has_macid();
  inline void clear_has_macid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_identifyingcode();
  inline void clear_has_identifyingcode();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_refereeuid();
  inline void clear_has_refereeuid();
  inline void set_has_finger();
  inline void clear_has_finger();
  inline void set_has_protoversion();
  inline void clear_has_protoversion();
  inline void set_has_ipaddress();
  inline void clear_has_ipaddress();
  inline void set_has_resetpassword();
  inline void clear_has_resetpassword();
  inline void set_has_fromstore();
  inline void clear_has_fromstore();
  inline void set_has_invitecode();
  inline void clear_has_invitecode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* macid_;
  ::std::string* token_;
  ::std::string* identifyingcode_;
  ::std::string* password_;
  ::pp::UserInfo* userinfo_;
  ::google::protobuf::uint64 refereeuid_;
  ::std::string* finger_;
  ::std::string* ipaddress_;
  int protoversion_;
  bool resetpassword_;
  ::std::string* fromstore_;
  ::std::string* invitecode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActivateReq* default_instance_;
};
// -------------------------------------------------------------------

class UserActivateRes : public ::google::protobuf::Message {
 public:
  UserActivateRes();
  virtual ~UserActivateRes();

  UserActivateRes(const UserActivateRes& from);

  inline UserActivateRes& operator=(const UserActivateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActivateRes& default_instance();

  void Swap(UserActivateRes* other);

  // implements Message ----------------------------------------------

  UserActivateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserActivateRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActivateRes* default_instance_;
};
// -------------------------------------------------------------------

class AccountBindReq : public ::google::protobuf::Message {
 public:
  AccountBindReq();
  virtual ~AccountBindReq();

  AccountBindReq(const AccountBindReq& from);

  inline AccountBindReq& operator=(const AccountBindReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBindReq& default_instance();

  void Swap(AccountBindReq* other);

  // implements Message ----------------------------------------------

  AccountBindReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string macid = 1;
  inline bool has_macid() const;
  inline void clear_macid();
  static const int kMacidFieldNumber = 1;
  inline const ::std::string& macid() const;
  inline void set_macid(const ::std::string& value);
  inline void set_macid(const char* value);
  inline void set_macid(const char* value, size_t size);
  inline ::std::string* mutable_macid();
  inline ::std::string* release_macid();
  inline void set_allocated_macid(::std::string* macid);

  // optional string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string identifyingCode = 3;
  inline bool has_identifyingcode() const;
  inline void clear_identifyingcode();
  static const int kIdentifyingCodeFieldNumber = 3;
  inline const ::std::string& identifyingcode() const;
  inline void set_identifyingcode(const ::std::string& value);
  inline void set_identifyingcode(const char* value);
  inline void set_identifyingcode(const char* value, size_t size);
  inline ::std::string* mutable_identifyingcode();
  inline ::std::string* release_identifyingcode();
  inline void set_allocated_identifyingcode(::std::string* identifyingcode);

  // optional uint64 uid = 10;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 10;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string password = 11;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 11;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:pp.AccountBindReq)
 private:
  inline void set_has_macid();
  inline void clear_has_macid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_identifyingcode();
  inline void clear_has_identifyingcode();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* macid_;
  ::std::string* token_;
  ::std::string* identifyingcode_;
  ::google::protobuf::uint64 uid_;
  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AccountBindReq* default_instance_;
};
// -------------------------------------------------------------------

class AccountBindRes : public ::google::protobuf::Message {
 public:
  AccountBindRes();
  virtual ~AccountBindRes();

  AccountBindRes(const AccountBindRes& from);

  inline AccountBindRes& operator=(const AccountBindRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountBindRes& default_instance();

  void Swap(AccountBindRes* other);

  // implements Message ----------------------------------------------

  AccountBindRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:pp.AccountBindRes)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AccountBindRes* default_instance_;
};
// -------------------------------------------------------------------

class CpsAccountBindReq : public ::google::protobuf::Message {
 public:
  CpsAccountBindReq();
  virtual ~CpsAccountBindReq();

  CpsAccountBindReq(const CpsAccountBindReq& from);

  inline CpsAccountBindReq& operator=(const CpsAccountBindReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpsAccountBindReq& default_instance();

  void Swap(CpsAccountBindReq* other);

  // implements Message ----------------------------------------------

  CpsAccountBindReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string macid = 1;
  inline bool has_macid() const;
  inline void clear_macid();
  static const int kMacidFieldNumber = 1;
  inline const ::std::string& macid() const;
  inline void set_macid(const ::std::string& value);
  inline void set_macid(const char* value);
  inline void set_macid(const char* value, size_t size);
  inline ::std::string* mutable_macid();
  inline ::std::string* release_macid();
  inline void set_allocated_macid(::std::string* macid);

  // optional string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // optional string identifyingCode = 3;
  inline bool has_identifyingcode() const;
  inline void clear_identifyingcode();
  static const int kIdentifyingCodeFieldNumber = 3;
  inline const ::std::string& identifyingcode() const;
  inline void set_identifyingcode(const ::std::string& value);
  inline void set_identifyingcode(const char* value);
  inline void set_identifyingcode(const char* value, size_t size);
  inline ::std::string* mutable_identifyingcode();
  inline ::std::string* release_identifyingcode();
  inline void set_allocated_identifyingcode(::std::string* identifyingcode);

  // optional uint64 thirdUid = 4;
  inline bool has_thirduid() const;
  inline void clear_thirduid();
  static const int kThirdUidFieldNumber = 4;
  inline ::google::protobuf::uint64 thirduid() const;
  inline void set_thirduid(::google::protobuf::uint64 value);

  // optional .pp.AccountType accountType = 5;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccountTypeFieldNumber = 5;
  inline ::pp::AccountType accounttype() const;
  inline void set_accounttype(::pp::AccountType value);

  // optional uint64 uid = 10;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 10;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string password = 11;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 11;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string ip = 12;
  inline bool has_ip() const;
  inline void clear_ip();
  static const int kIpFieldNumber = 12;
  inline const ::std::string& ip() const;
  inline void set_ip(const ::std::string& value);
  inline void set_ip(const char* value);
  inline void set_ip(const char* value, size_t size);
  inline ::std::string* mutable_ip();
  inline ::std::string* release_ip();
  inline void set_allocated_ip(::std::string* ip);

  // @@protoc_insertion_point(class_scope:pp.CpsAccountBindReq)
 private:
  inline void set_has_macid();
  inline void clear_has_macid();
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_identifyingcode();
  inline void clear_has_identifyingcode();
  inline void set_has_thirduid();
  inline void clear_has_thirduid();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_ip();
  inline void clear_has_ip();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* macid_;
  ::std::string* token_;
  ::std::string* identifyingcode_;
  ::google::protobuf::uint64 thirduid_;
  ::google::protobuf::uint64 uid_;
  ::std::string* password_;
  ::std::string* ip_;
  int accounttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CpsAccountBindReq* default_instance_;
};
// -------------------------------------------------------------------

class CpsAccountBindRes : public ::google::protobuf::Message {
 public:
  CpsAccountBindRes();
  virtual ~CpsAccountBindRes();

  CpsAccountBindRes(const CpsAccountBindRes& from);

  inline CpsAccountBindRes& operator=(const CpsAccountBindRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpsAccountBindRes& default_instance();

  void Swap(CpsAccountBindRes* other);

  // implements Message ----------------------------------------------

  CpsAccountBindRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // optional .pp.UserInfo uinfo = 2;
  inline bool has_uinfo() const;
  inline void clear_uinfo();
  static const int kUinfoFieldNumber = 2;
  inline const ::pp::UserInfo& uinfo() const;
  inline ::pp::UserInfo* mutable_uinfo();
  inline ::pp::UserInfo* release_uinfo();
  inline void set_allocated_uinfo(::pp::UserInfo* uinfo);

  // @@protoc_insertion_point(class_scope:pp.CpsAccountBindRes)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_uinfo();
  inline void clear_has_uinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::pp::UserInfo* uinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CpsAccountBindRes* default_instance_;
};
// -------------------------------------------------------------------

class CpsWebLoginReq : public ::google::protobuf::Message {
 public:
  CpsWebLoginReq();
  virtual ~CpsWebLoginReq();

  CpsWebLoginReq(const CpsWebLoginReq& from);

  inline CpsWebLoginReq& operator=(const CpsWebLoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpsWebLoginReq& default_instance();

  void Swap(CpsWebLoginReq* other);

  // implements Message ----------------------------------------------

  CpsWebLoginReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:pp.CpsWebLoginReq)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CpsWebLoginReq* default_instance_;
};
// -------------------------------------------------------------------

class CpsWebLoginRes : public ::google::protobuf::Message {
 public:
  CpsWebLoginRes();
  virtual ~CpsWebLoginRes();

  CpsWebLoginRes(const CpsWebLoginRes& from);

  inline CpsWebLoginRes& operator=(const CpsWebLoginRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CpsWebLoginRes& default_instance();

  void Swap(CpsWebLoginRes* other);

  // implements Message ----------------------------------------------

  CpsWebLoginRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.CpsWebLoginRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CpsWebLoginRes* default_instance_;
};
// -------------------------------------------------------------------

class UserHeartBeat : public ::google::protobuf::Message {
 public:
  UserHeartBeat();
  virtual ~UserHeartBeat();

  UserHeartBeat(const UserHeartBeat& from);

  inline UserHeartBeat& operator=(const UserHeartBeat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHeartBeat& default_instance();

  void Swap(UserHeartBeat* other);

  // implements Message ----------------------------------------------

  UserHeartBeat* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional int64 currenttime = 2;
  inline bool has_currenttime() const;
  inline void clear_currenttime();
  static const int kCurrenttimeFieldNumber = 2;
  inline ::google::protobuf::int64 currenttime() const;
  inline void set_currenttime(::google::protobuf::int64 value);

  // optional int64 giftListVersion = 101;
  inline bool has_giftlistversion() const;
  inline void clear_giftlistversion();
  static const int kGiftListVersionFieldNumber = 101;
  inline ::google::protobuf::int64 giftlistversion() const;
  inline void set_giftlistversion(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserHeartBeat)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_currenttime();
  inline void clear_has_currenttime();
  inline void set_has_giftlistversion();
  inline void clear_has_giftlistversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 currenttime_;
  ::google::protobuf::int64 giftlistversion_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserHeartBeat* default_instance_;
};
// -------------------------------------------------------------------

class UserHeartBeatReq : public ::google::protobuf::Message {
 public:
  UserHeartBeatReq();
  virtual ~UserHeartBeatReq();

  UserHeartBeatReq(const UserHeartBeatReq& from);

  inline UserHeartBeatReq& operator=(const UserHeartBeatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHeartBeatReq& default_instance();

  void Swap(UserHeartBeatReq* other);

  // implements Message ----------------------------------------------

  UserHeartBeatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional int64 currenttime = 2;
  inline bool has_currenttime() const;
  inline void clear_currenttime();
  static const int kCurrenttimeFieldNumber = 2;
  inline ::google::protobuf::int64 currenttime() const;
  inline void set_currenttime(::google::protobuf::int64 value);

  // optional int64 giftListVersion = 101;
  inline bool has_giftlistversion() const;
  inline void clear_giftlistversion();
  static const int kGiftListVersionFieldNumber = 101;
  inline ::google::protobuf::int64 giftlistversion() const;
  inline void set_giftlistversion(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserHeartBeatReq)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_currenttime();
  inline void clear_has_currenttime();
  inline void set_has_giftlistversion();
  inline void clear_has_giftlistversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 currenttime_;
  ::google::protobuf::int64 giftlistversion_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserHeartBeatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserHeartBeatRes : public ::google::protobuf::Message {
 public:
  UserHeartBeatRes();
  virtual ~UserHeartBeatRes();

  UserHeartBeatRes(const UserHeartBeatRes& from);

  inline UserHeartBeatRes& operator=(const UserHeartBeatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserHeartBeatRes& default_instance();

  void Swap(UserHeartBeatRes* other);

  // implements Message ----------------------------------------------

  UserHeartBeatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 flags = 1;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 1;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional int64 currenttime = 2;
  inline bool has_currenttime() const;
  inline void clear_currenttime();
  static const int kCurrenttimeFieldNumber = 2;
  inline ::google::protobuf::int64 currenttime() const;
  inline void set_currenttime(::google::protobuf::int64 value);

  // optional int64 giftListVersion = 101;
  inline bool has_giftlistversion() const;
  inline void clear_giftlistversion();
  static const int kGiftListVersionFieldNumber = 101;
  inline ::google::protobuf::int64 giftlistversion() const;
  inline void set_giftlistversion(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserHeartBeatRes)
 private:
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_currenttime();
  inline void clear_has_currenttime();
  inline void set_has_giftlistversion();
  inline void clear_has_giftlistversion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 currenttime_;
  ::google::protobuf::int64 giftlistversion_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserHeartBeatRes* default_instance_;
};
// -------------------------------------------------------------------

class SessionResumeReq : public ::google::protobuf::Message {
 public:
  SessionResumeReq();
  virtual ~SessionResumeReq();

  SessionResumeReq(const SessionResumeReq& from);

  inline SessionResumeReq& operator=(const SessionResumeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionResumeReq& default_instance();

  void Swap(SessionResumeReq* other);

  // implements Message ----------------------------------------------

  SessionResumeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 2;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 2;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:pp.SessionResumeReq)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SessionResumeReq* default_instance_;
};
// -------------------------------------------------------------------

class SessionResumeRes : public ::google::protobuf::Message {
 public:
  SessionResumeRes();
  virtual ~SessionResumeRes();

  SessionResumeRes(const SessionResumeRes& from);

  inline SessionResumeRes& operator=(const SessionResumeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionResumeRes& default_instance();

  void Swap(SessionResumeRes* other);

  // implements Message ----------------------------------------------

  SessionResumeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.SessionResumeRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SessionResumeRes* default_instance_;
};
// -------------------------------------------------------------------

class SessionSuspendReq : public ::google::protobuf::Message {
 public:
  SessionSuspendReq();
  virtual ~SessionSuspendReq();

  SessionSuspendReq(const SessionSuspendReq& from);

  inline SessionSuspendReq& operator=(const SessionSuspendReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SessionSuspendReq& default_instance();

  void Swap(SessionSuspendReq* other);

  // implements Message ----------------------------------------------

  SessionSuspendReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool suspend = 1;
  inline bool has_suspend() const;
  inline void clear_suspend();
  static const int kSuspendFieldNumber = 1;
  inline bool suspend() const;
  inline void set_suspend(bool value);

  // @@protoc_insertion_point(class_scope:pp.SessionSuspendReq)
 private:
  inline void set_has_suspend();
  inline void clear_has_suspend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool suspend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SessionSuspendReq* default_instance_;
};
// -------------------------------------------------------------------

class UptokenReq : public ::google::protobuf::Message {
 public:
  UptokenReq();
  virtual ~UptokenReq();

  UptokenReq(const UptokenReq& from);

  inline UptokenReq& operator=(const UptokenReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UptokenReq& default_instance();

  void Swap(UptokenReq* other);

  // implements Message ----------------------------------------------

  UptokenReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // repeated string buckets = 2;
  inline int buckets_size() const;
  inline void clear_buckets();
  static const int kBucketsFieldNumber = 2;
  inline const ::std::string& buckets(int index) const;
  inline ::std::string* mutable_buckets(int index);
  inline void set_buckets(int index, const ::std::string& value);
  inline void set_buckets(int index, const char* value);
  inline void set_buckets(int index, const char* value, size_t size);
  inline ::std::string* add_buckets();
  inline void add_buckets(const ::std::string& value);
  inline void add_buckets(const char* value);
  inline void add_buckets(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& buckets() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_buckets();

  // optional string filename = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional bool needKey = 4;
  inline bool has_needkey() const;
  inline void clear_needkey();
  static const int kNeedKeyFieldNumber = 4;
  inline bool needkey() const;
  inline void set_needkey(bool value);

  // @@protoc_insertion_point(class_scope:pp.UptokenReq)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_needkey();
  inline void clear_has_needkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;
  ::google::protobuf::RepeatedPtrField< ::std::string> buckets_;
  ::std::string* filename_;
  bool needkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UptokenReq* default_instance_;
};
// -------------------------------------------------------------------

class Uptoken : public ::google::protobuf::Message {
 public:
  Uptoken();
  virtual ~Uptoken();

  Uptoken(const Uptoken& from);

  inline Uptoken& operator=(const Uptoken& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Uptoken& default_instance();

  void Swap(Uptoken* other);

  // implements Message ----------------------------------------------

  Uptoken* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // required string bucket = 2;
  inline bool has_bucket() const;
  inline void clear_bucket();
  static const int kBucketFieldNumber = 2;
  inline const ::std::string& bucket() const;
  inline void set_bucket(const ::std::string& value);
  inline void set_bucket(const char* value);
  inline void set_bucket(const char* value, size_t size);
  inline ::std::string* mutable_bucket();
  inline ::std::string* release_bucket();
  inline void set_allocated_bucket(::std::string* bucket);

  // @@protoc_insertion_point(class_scope:pp.Uptoken)
 private:
  inline void set_has_token();
  inline void clear_has_token();
  inline void set_has_bucket();
  inline void clear_has_bucket();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  ::std::string* bucket_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static Uptoken* default_instance_;
};
// -------------------------------------------------------------------

class UptokenRes : public ::google::protobuf::Message {
 public:
  UptokenRes();
  virtual ~UptokenRes();

  UptokenRes(const UptokenRes& from);

  inline UptokenRes& operator=(const UptokenRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UptokenRes& default_instance();

  void Swap(UptokenRes* other);

  // implements Message ----------------------------------------------

  UptokenRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.Uptoken tokens = 1;
  inline int tokens_size() const;
  inline void clear_tokens();
  static const int kTokensFieldNumber = 1;
  inline const ::pp::Uptoken& tokens(int index) const;
  inline ::pp::Uptoken* mutable_tokens(int index);
  inline ::pp::Uptoken* add_tokens();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::Uptoken >&
      tokens() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::Uptoken >*
      mutable_tokens();

  // optional string bs2token = 2;
  inline bool has_bs2token() const;
  inline void clear_bs2token();
  static const int kBs2TokenFieldNumber = 2;
  inline const ::std::string& bs2token() const;
  inline void set_bs2token(const ::std::string& value);
  inline void set_bs2token(const char* value);
  inline void set_bs2token(const char* value, size_t size);
  inline ::std::string* mutable_bs2token();
  inline ::std::string* release_bs2token();
  inline void set_allocated_bs2token(::std::string* bs2token);

  // optional uint32 appkey = 3;
  inline bool has_appkey() const;
  inline void clear_appkey();
  static const int kAppkeyFieldNumber = 3;
  inline ::google::protobuf::uint32 appkey() const;
  inline void set_appkey(::google::protobuf::uint32 value);

  // optional string secret = 4;
  inline bool has_secret() const;
  inline void clear_secret();
  static const int kSecretFieldNumber = 4;
  inline const ::std::string& secret() const;
  inline void set_secret(const ::std::string& value);
  inline void set_secret(const char* value);
  inline void set_secret(const char* value, size_t size);
  inline ::std::string* mutable_secret();
  inline ::std::string* release_secret();
  inline void set_allocated_secret(::std::string* secret);

  // @@protoc_insertion_point(class_scope:pp.UptokenRes)
 private:
  inline void set_has_bs2token();
  inline void clear_has_bs2token();
  inline void set_has_appkey();
  inline void clear_has_appkey();
  inline void set_has_secret();
  inline void clear_has_secret();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::Uptoken > tokens_;
  ::std::string* bs2token_;
  ::std::string* secret_;
  ::google::protobuf::uint32 appkey_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UptokenRes* default_instance_;
};
// -------------------------------------------------------------------

class MessageImage : public ::google::protobuf::Message {
 public:
  MessageImage();
  virtual ~MessageImage();

  MessageImage(const MessageImage& from);

  inline MessageImage& operator=(const MessageImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageImage& default_instance();

  void Swap(MessageImage* other);

  // implements Message ----------------------------------------------

  MessageImage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // repeated string hashs = 2;
  inline int hashs_size() const;
  inline void clear_hashs();
  static const int kHashsFieldNumber = 2;
  inline const ::std::string& hashs(int index) const;
  inline ::std::string* mutable_hashs(int index);
  inline void set_hashs(int index, const ::std::string& value);
  inline void set_hashs(int index, const char* value);
  inline void set_hashs(int index, const char* value, size_t size);
  inline ::std::string* add_hashs();
  inline void add_hashs(const ::std::string& value);
  inline void add_hashs(const char* value);
  inline void add_hashs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& hashs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_hashs();

  // repeated uint32 types = 3;
  inline int types_size() const;
  inline void clear_types();
  static const int kTypesFieldNumber = 3;
  inline ::google::protobuf::uint32 types(int index) const;
  inline void set_types(int index, ::google::protobuf::uint32 value);
  inline void add_types(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      types() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_types();

  // optional string summary = 4;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 4;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // @@protoc_insertion_point(class_scope:pp.MessageImage)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_summary();
  inline void clear_has_summary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> hashs_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > types_;
  ::std::string* summary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageImage* default_instance_;
};
// -------------------------------------------------------------------

class MessageVoice : public ::google::protobuf::Message {
 public:
  MessageVoice();
  virtual ~MessageVoice();

  MessageVoice(const MessageVoice& from);

  inline MessageVoice& operator=(const MessageVoice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageVoice& default_instance();

  void Swap(MessageVoice* other);

  // implements Message ----------------------------------------------

  MessageVoice* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // required string hashs = 2;
  inline bool has_hashs() const;
  inline void clear_hashs();
  static const int kHashsFieldNumber = 2;
  inline const ::std::string& hashs() const;
  inline void set_hashs(const ::std::string& value);
  inline void set_hashs(const char* value);
  inline void set_hashs(const char* value, size_t size);
  inline ::std::string* mutable_hashs();
  inline ::std::string* release_hashs();
  inline void set_allocated_hashs(::std::string* hashs);

  // optional uint32 len = 3;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 3;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // optional string summary = 4;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 4;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // optional string volumns = 5;
  inline bool has_volumns() const;
  inline void clear_volumns();
  static const int kVolumnsFieldNumber = 5;
  inline const ::std::string& volumns() const;
  inline void set_volumns(const ::std::string& value);
  inline void set_volumns(const char* value);
  inline void set_volumns(const char* value, size_t size);
  inline ::std::string* mutable_volumns();
  inline ::std::string* release_volumns();
  inline void set_allocated_volumns(::std::string* volumns);

  // @@protoc_insertion_point(class_scope:pp.MessageVoice)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_hashs();
  inline void clear_has_hashs();
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_volumns();
  inline void clear_has_volumns();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;
  ::std::string* hashs_;
  ::std::string* summary_;
  ::std::string* volumns_;
  ::google::protobuf::uint32 len_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageVoice* default_instance_;
};
// -------------------------------------------------------------------

class MessageVideo : public ::google::protobuf::Message {
 public:
  MessageVideo();
  virtual ~MessageVideo();

  MessageVideo(const MessageVideo& from);

  inline MessageVideo& operator=(const MessageVideo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageVideo& default_instance();

  void Swap(MessageVideo* other);

  // implements Message ----------------------------------------------

  MessageVideo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string prefix = 1;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // required string hashs = 2;
  inline bool has_hashs() const;
  inline void clear_hashs();
  static const int kHashsFieldNumber = 2;
  inline const ::std::string& hashs() const;
  inline void set_hashs(const ::std::string& value);
  inline void set_hashs(const char* value);
  inline void set_hashs(const char* value, size_t size);
  inline ::std::string* mutable_hashs();
  inline ::std::string* release_hashs();
  inline void set_allocated_hashs(::std::string* hashs);

  // optional uint32 len = 3;
  inline bool has_len() const;
  inline void clear_len();
  static const int kLenFieldNumber = 3;
  inline ::google::protobuf::uint32 len() const;
  inline void set_len(::google::protobuf::uint32 value);

  // optional uint32 iframe = 4;
  inline bool has_iframe() const;
  inline void clear_iframe();
  static const int kIframeFieldNumber = 4;
  inline ::google::protobuf::uint32 iframe() const;
  inline void set_iframe(::google::protobuf::uint32 value);

  // optional string summary = 5;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 5;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // @@protoc_insertion_point(class_scope:pp.MessageVideo)
 private:
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_hashs();
  inline void clear_has_hashs();
  inline void set_has_len();
  inline void clear_has_len();
  inline void set_has_iframe();
  inline void clear_has_iframe();
  inline void set_has_summary();
  inline void clear_has_summary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* prefix_;
  ::std::string* hashs_;
  ::google::protobuf::uint32 len_;
  ::google::protobuf::uint32 iframe_;
  ::std::string* summary_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageVideo* default_instance_;
};
// -------------------------------------------------------------------

class MessagePub : public ::google::protobuf::Message {
 public:
  MessagePub();
  virtual ~MessagePub();

  MessagePub(const MessagePub& from);

  inline MessagePub& operator=(const MessagePub& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessagePub& default_instance();

  void Swap(MessagePub* other);

  // implements Message ----------------------------------------------

  MessagePub* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string title = 1;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 1;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string summary = 3;
  inline bool has_summary() const;
  inline void clear_summary();
  static const int kSummaryFieldNumber = 3;
  inline const ::std::string& summary() const;
  inline void set_summary(const ::std::string& value);
  inline void set_summary(const char* value);
  inline void set_summary(const char* value, size_t size);
  inline ::std::string* mutable_summary();
  inline ::std::string* release_summary();
  inline void set_allocated_summary(::std::string* summary);

  // optional string prefix = 4;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 4;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const char* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // repeated string images = 5;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 5;
  inline const ::std::string& images(int index) const;
  inline ::std::string* mutable_images(int index);
  inline void set_images(int index, const ::std::string& value);
  inline void set_images(int index, const char* value);
  inline void set_images(int index, const char* value, size_t size);
  inline ::std::string* add_images();
  inline void add_images(const ::std::string& value);
  inline void add_images(const char* value);
  inline void add_images(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& images() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_images();

  // optional string op = 6;
  inline bool has_op() const;
  inline void clear_op();
  static const int kOpFieldNumber = 6;
  inline const ::std::string& op() const;
  inline void set_op(const ::std::string& value);
  inline void set_op(const char* value);
  inline void set_op(const char* value, size_t size);
  inline ::std::string* mutable_op();
  inline ::std::string* release_op();
  inline void set_allocated_op(::std::string* op);

  // optional int64 starttime = 7;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStarttimeFieldNumber = 7;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional int64 stoptime = 8;
  inline bool has_stoptime() const;
  inline void clear_stoptime();
  static const int kStoptimeFieldNumber = 8;
  inline ::google::protobuf::int64 stoptime() const;
  inline void set_stoptime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.MessagePub)
 private:
  inline void set_has_title();
  inline void clear_has_title();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_summary();
  inline void clear_has_summary();
  inline void set_has_prefix();
  inline void clear_has_prefix();
  inline void set_has_op();
  inline void clear_has_op();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_stoptime();
  inline void clear_has_stoptime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* title_;
  ::std::string* url_;
  ::std::string* summary_;
  ::std::string* prefix_;
  ::google::protobuf::RepeatedPtrField< ::std::string> images_;
  ::std::string* op_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 stoptime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessagePub* default_instance_;
};
// -------------------------------------------------------------------

class MessageTxtlink : public ::google::protobuf::Message {
 public:
  MessageTxtlink();
  virtual ~MessageTxtlink();

  MessageTxtlink(const MessageTxtlink& from);

  inline MessageTxtlink& operator=(const MessageTxtlink& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageTxtlink& default_instance();

  void Swap(MessageTxtlink* other);

  // implements Message ----------------------------------------------

  MessageTxtlink* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txt = 1;
  inline bool has_txt() const;
  inline void clear_txt();
  static const int kTxtFieldNumber = 1;
  inline const ::std::string& txt() const;
  inline void set_txt(const ::std::string& value);
  inline void set_txt(const char* value);
  inline void set_txt(const char* value, size_t size);
  inline ::std::string* mutable_txt();
  inline ::std::string* release_txt();
  inline void set_allocated_txt(::std::string* txt);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string desc = 3;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 3;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string color = 4;
  inline bool has_color() const;
  inline void clear_color();
  static const int kColorFieldNumber = 4;
  inline const ::std::string& color() const;
  inline void set_color(const ::std::string& value);
  inline void set_color(const char* value);
  inline void set_color(const char* value, size_t size);
  inline ::std::string* mutable_color();
  inline ::std::string* release_color();
  inline void set_allocated_color(::std::string* color);

  // optional string icon = 5;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 5;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string bg = 6;
  inline bool has_bg() const;
  inline void clear_bg();
  static const int kBgFieldNumber = 6;
  inline const ::std::string& bg() const;
  inline void set_bg(const ::std::string& value);
  inline void set_bg(const char* value);
  inline void set_bg(const char* value, size_t size);
  inline ::std::string* mutable_bg();
  inline ::std::string* release_bg();
  inline void set_allocated_bg(::std::string* bg);

  // @@protoc_insertion_point(class_scope:pp.MessageTxtlink)
 private:
  inline void set_has_txt();
  inline void clear_has_txt();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_color();
  inline void clear_has_color();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_bg();
  inline void clear_has_bg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txt_;
  ::std::string* url_;
  ::std::string* desc_;
  ::std::string* color_;
  ::std::string* icon_;
  ::std::string* bg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageTxtlink* default_instance_;
};
// -------------------------------------------------------------------

class MessageGroupNotice : public ::google::protobuf::Message {
 public:
  MessageGroupNotice();
  virtual ~MessageGroupNotice();

  MessageGroupNotice(const MessageGroupNotice& from);

  inline MessageGroupNotice& operator=(const MessageGroupNotice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageGroupNotice& default_instance();

  void Swap(MessageGroupNotice* other);

  // implements Message ----------------------------------------------

  MessageGroupNotice* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 memincr = 1;
  inline bool has_memincr() const;
  inline void clear_memincr();
  static const int kMemincrFieldNumber = 1;
  inline ::google::protobuf::uint32 memincr() const;
  inline void set_memincr(::google::protobuf::uint32 value);

  // optional uint32 itemid = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemidFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional uint32 num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint64 showlikeuid = 4;
  inline bool has_showlikeuid() const;
  inline void clear_showlikeuid();
  static const int kShowlikeuidFieldNumber = 4;
  inline ::google::protobuf::uint64 showlikeuid() const;
  inline void set_showlikeuid(::google::protobuf::uint64 value);

  // optional .pp.GroupMemberRolerItem roler = 5;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 5;
  inline const ::pp::GroupMemberRolerItem& roler() const;
  inline ::pp::GroupMemberRolerItem* mutable_roler();
  inline ::pp::GroupMemberRolerItem* release_roler();
  inline void set_allocated_roler(::pp::GroupMemberRolerItem* roler);

  // @@protoc_insertion_point(class_scope:pp.MessageGroupNotice)
 private:
  inline void set_has_memincr();
  inline void clear_has_memincr();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_showlikeuid();
  inline void clear_has_showlikeuid();
  inline void set_has_roler();
  inline void clear_has_roler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 memincr_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint64 showlikeuid_;
  ::pp::GroupMemberRolerItem* roler_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageGroupNotice* default_instance_;
};
// -------------------------------------------------------------------

class MessageInputStatus : public ::google::protobuf::Message {
 public:
  MessageInputStatus();
  virtual ~MessageInputStatus();

  MessageInputStatus(const MessageInputStatus& from);

  inline MessageInputStatus& operator=(const MessageInputStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageInputStatus& default_instance();

  void Swap(MessageInputStatus* other);

  // implements Message ----------------------------------------------

  MessageInputStatus* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 speaking = 1;
  inline bool has_speaking() const;
  inline void clear_speaking();
  static const int kSpeakingFieldNumber = 1;
  inline ::google::protobuf::uint32 speaking() const;
  inline void set_speaking(::google::protobuf::uint32 value);

  // optional uint64 speakeruid = 2;
  inline bool has_speakeruid() const;
  inline void clear_speakeruid();
  static const int kSpeakeruidFieldNumber = 2;
  inline ::google::protobuf::uint64 speakeruid() const;
  inline void set_speakeruid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.MessageInputStatus)
 private:
  inline void set_has_speaking();
  inline void clear_has_speaking();
  inline void set_has_speakeruid();
  inline void clear_has_speakeruid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 speakeruid_;
  ::google::protobuf::uint32 speaking_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageInputStatus* default_instance_;
};
// -------------------------------------------------------------------

class MessageEvent : public ::google::protobuf::Message {
 public:
  MessageEvent();
  virtual ~MessageEvent();

  MessageEvent(const MessageEvent& from);

  inline MessageEvent& operator=(const MessageEvent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageEvent& default_instance();

  void Swap(MessageEvent* other);

  // implements Message ----------------------------------------------

  MessageEvent* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 eventType = 1;
  inline bool has_eventtype() const;
  inline void clear_eventtype();
  static const int kEventTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 eventtype() const;
  inline void set_eventtype(::google::protobuf::uint32 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 itemId = 4;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 4;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // optional uint32 itemNum = 5;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 5;
  inline ::google::protobuf::uint32 itemnum() const;
  inline void set_itemnum(::google::protobuf::uint32 value);

  // optional uint32 itemLevel = 6;
  inline bool has_itemlevel() const;
  inline void clear_itemlevel();
  static const int kItemLevelFieldNumber = 6;
  inline ::google::protobuf::uint32 itemlevel() const;
  inline void set_itemlevel(::google::protobuf::uint32 value);

  // optional string extField = 7;
  inline bool has_extfield() const;
  inline void clear_extfield();
  static const int kExtFieldFieldNumber = 7;
  inline const ::std::string& extfield() const;
  inline void set_extfield(const ::std::string& value);
  inline void set_extfield(const char* value);
  inline void set_extfield(const char* value, size_t size);
  inline ::std::string* mutable_extfield();
  inline ::std::string* release_extfield();
  inline void set_allocated_extfield(::std::string* extfield);

  // @@protoc_insertion_point(class_scope:pp.MessageEvent)
 private:
  inline void set_has_eventtype();
  inline void clear_has_eventtype();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_itemlevel();
  inline void clear_has_itemlevel();
  inline void set_has_extfield();
  inline void clear_has_extfield();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 eventtype_;
  ::google::protobuf::uint32 itemid_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 itemnum_;
  ::google::protobuf::uint32 itemlevel_;
  ::std::string* extfield_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageEvent* default_instance_;
};
// -------------------------------------------------------------------

class MessageUserApply : public ::google::protobuf::Message {
 public:
  MessageUserApply();
  virtual ~MessageUserApply();

  MessageUserApply(const MessageUserApply& from);

  inline MessageUserApply& operator=(const MessageUserApply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageUserApply& default_instance();

  void Swap(MessageUserApply* other);

  // implements Message ----------------------------------------------

  MessageUserApply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageUserApply_OpType OpType;
  static const OpType None = MessageUserApply_OpType_None;
  static const OpType Apply = MessageUserApply_OpType_Apply;
  static const OpType Pass = MessageUserApply_OpType_Pass;
  static const OpType Add = MessageUserApply_OpType_Add;
  static const OpType Refuse = MessageUserApply_OpType_Refuse;
  static inline bool OpType_IsValid(int value) {
    return MessageUserApply_OpType_IsValid(value);
  }
  static const OpType OpType_MIN =
    MessageUserApply_OpType_OpType_MIN;
  static const OpType OpType_MAX =
    MessageUserApply_OpType_OpType_MAX;
  static const int OpType_ARRAYSIZE =
    MessageUserApply_OpType_OpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpType_descriptor() {
    return MessageUserApply_OpType_descriptor();
  }
  static inline const ::std::string& OpType_Name(OpType value) {
    return MessageUserApply_OpType_Name(value);
  }
  static inline bool OpType_Parse(const ::std::string& name,
      OpType* value) {
    return MessageUserApply_OpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional uint32 optype = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 2;
  inline ::google::protobuf::uint32 optype() const;
  inline void set_optype(::google::protobuf::uint32 value);

  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional uint64 opuid = 4;
  inline bool has_opuid() const;
  inline void clear_opuid();
  static const int kOpuidFieldNumber = 4;
  inline ::google::protobuf::uint64 opuid() const;
  inline void set_opuid(::google::protobuf::uint64 value);

  // optional uint32 opresult = 5;
  inline bool has_opresult() const;
  inline void clear_opresult();
  static const int kOpresultFieldNumber = 5;
  inline ::google::protobuf::uint32 opresult() const;
  inline void set_opresult(::google::protobuf::uint32 value);

  // optional uint32 roler = 7;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 7;
  inline ::google::protobuf::uint32 roler() const;
  inline void set_roler(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.MessageUserApply)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_opuid();
  inline void clear_has_opuid();
  inline void set_has_opresult();
  inline void clear_has_opresult();
  inline void set_has_roler();
  inline void clear_has_roler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* userinfo_;
  ::std::string* remark_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 opresult_;
  ::google::protobuf::uint64 opuid_;
  ::google::protobuf::uint32 roler_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageUserApply* default_instance_;
};
// -------------------------------------------------------------------

class MessageGroupApply : public ::google::protobuf::Message {
 public:
  MessageGroupApply();
  virtual ~MessageGroupApply();

  MessageGroupApply(const MessageGroupApply& from);

  inline MessageGroupApply& operator=(const MessageGroupApply& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageGroupApply& default_instance();

  void Swap(MessageGroupApply* other);

  // implements Message ----------------------------------------------

  MessageGroupApply* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef MessageGroupApply_OpType OpType;
  static const OpType None = MessageGroupApply_OpType_None;
  static const OpType Apply = MessageGroupApply_OpType_Apply;
  static const OpType Pass = MessageGroupApply_OpType_Pass;
  static const OpType Add = MessageGroupApply_OpType_Add;
  static const OpType Refuse = MessageGroupApply_OpType_Refuse;
  static const OpType Upgrade = MessageGroupApply_OpType_Upgrade;
  static const OpType Kick = MessageGroupApply_OpType_Kick;
  static const OpType Quit = MessageGroupApply_OpType_Quit;
  static const OpType Destroy = MessageGroupApply_OpType_Destroy;
  static inline bool OpType_IsValid(int value) {
    return MessageGroupApply_OpType_IsValid(value);
  }
  static const OpType OpType_MIN =
    MessageGroupApply_OpType_OpType_MIN;
  static const OpType OpType_MAX =
    MessageGroupApply_OpType_OpType_MAX;
  static const int OpType_ARRAYSIZE =
    MessageGroupApply_OpType_OpType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  OpType_descriptor() {
    return MessageGroupApply_OpType_descriptor();
  }
  static inline const ::std::string& OpType_Name(OpType value) {
    return MessageGroupApply_OpType_Name(value);
  }
  static inline bool OpType_Parse(const ::std::string& name,
      OpType* value) {
    return MessageGroupApply_OpType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo userInfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 1;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional uint32 optype = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 2;
  inline ::google::protobuf::uint32 optype() const;
  inline void set_optype(::google::protobuf::uint32 value);

  // optional string remark = 3;
  inline bool has_remark() const;
  inline void clear_remark();
  static const int kRemarkFieldNumber = 3;
  inline const ::std::string& remark() const;
  inline void set_remark(const ::std::string& value);
  inline void set_remark(const char* value);
  inline void set_remark(const char* value, size_t size);
  inline ::std::string* mutable_remark();
  inline ::std::string* release_remark();
  inline void set_allocated_remark(::std::string* remark);

  // optional uint64 opuid = 4;
  inline bool has_opuid() const;
  inline void clear_opuid();
  static const int kOpuidFieldNumber = 4;
  inline ::google::protobuf::uint64 opuid() const;
  inline void set_opuid(::google::protobuf::uint64 value);

  // optional uint32 opresult = 5;
  inline bool has_opresult() const;
  inline void clear_opresult();
  static const int kOpresultFieldNumber = 5;
  inline ::google::protobuf::uint32 opresult() const;
  inline void set_opresult(::google::protobuf::uint32 value);

  // optional uint64 gid = 6;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 6;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 roler = 7;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 7;
  inline ::google::protobuf::uint32 roler() const;
  inline void set_roler(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.MessageGroupApply)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_remark();
  inline void clear_has_remark();
  inline void set_has_opuid();
  inline void clear_has_opuid();
  inline void set_has_opresult();
  inline void clear_has_opresult();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_roler();
  inline void clear_has_roler();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* userinfo_;
  ::std::string* remark_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 opresult_;
  ::google::protobuf::uint64 opuid_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 roler_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageGroupApply* default_instance_;
};
// -------------------------------------------------------------------

class MessageUserTask : public ::google::protobuf::Message {
 public:
  MessageUserTask();
  virtual ~MessageUserTask();

  MessageUserTask(const MessageUserTask& from);

  inline MessageUserTask& operator=(const MessageUserTask& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageUserTask& default_instance();

  void Swap(MessageUserTask* other);

  // implements Message ----------------------------------------------

  MessageUserTask* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional uint32 coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline ::google::protobuf::uint32 coins() const;
  inline void set_coins(::google::protobuf::uint32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 passion = 4;
  inline bool has_passion() const;
  inline void clear_passion();
  static const int kPassionFieldNumber = 4;
  inline ::google::protobuf::uint32 passion() const;
  inline void set_passion(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.MessageUserTask)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_passion();
  inline void clear_has_passion();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 coins_;
  ::std::string* name_;
  ::google::protobuf::uint32 passion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageUserTask* default_instance_;
};
// -------------------------------------------------------------------

class MessageBody : public ::google::protobuf::Message {
 public:
  MessageBody();
  virtual ~MessageBody();

  MessageBody(const MessageBody& from);

  inline MessageBody& operator=(const MessageBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageBody& default_instance();

  void Swap(MessageBody* other);

  // implements Message ----------------------------------------------

  MessageBody* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 contentType = 1;
  inline bool has_contenttype() const;
  inline void clear_contenttype();
  static const int kContentTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 contenttype() const;
  inline void set_contenttype(::google::protobuf::uint32 value);

  // optional string txt = 2;
  inline bool has_txt() const;
  inline void clear_txt();
  static const int kTxtFieldNumber = 2;
  inline const ::std::string& txt() const;
  inline void set_txt(const ::std::string& value);
  inline void set_txt(const char* value);
  inline void set_txt(const char* value, size_t size);
  inline ::std::string* mutable_txt();
  inline ::std::string* release_txt();
  inline void set_allocated_txt(::std::string* txt);

  // optional .pp.MessageImage img = 3;
  inline bool has_img() const;
  inline void clear_img();
  static const int kImgFieldNumber = 3;
  inline const ::pp::MessageImage& img() const;
  inline ::pp::MessageImage* mutable_img();
  inline ::pp::MessageImage* release_img();
  inline void set_allocated_img(::pp::MessageImage* img);

  // optional .pp.MessageVoice voice = 4;
  inline bool has_voice() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 4;
  inline const ::pp::MessageVoice& voice() const;
  inline ::pp::MessageVoice* mutable_voice();
  inline ::pp::MessageVoice* release_voice();
  inline void set_allocated_voice(::pp::MessageVoice* voice);

  // optional .pp.MessageVideo video = 5;
  inline bool has_video() const;
  inline void clear_video();
  static const int kVideoFieldNumber = 5;
  inline const ::pp::MessageVideo& video() const;
  inline ::pp::MessageVideo* mutable_video();
  inline ::pp::MessageVideo* release_video();
  inline void set_allocated_video(::pp::MessageVideo* video);

  // repeated .pp.MessagePub pub = 6;
  inline int pub_size() const;
  inline void clear_pub();
  static const int kPubFieldNumber = 6;
  inline const ::pp::MessagePub& pub(int index) const;
  inline ::pp::MessagePub* mutable_pub(int index);
  inline ::pp::MessagePub* add_pub();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >&
      pub() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >*
      mutable_pub();

  // optional .pp.MessageGroupNotice gnotice = 7;
  inline bool has_gnotice() const;
  inline void clear_gnotice();
  static const int kGnoticeFieldNumber = 7;
  inline const ::pp::MessageGroupNotice& gnotice() const;
  inline ::pp::MessageGroupNotice* mutable_gnotice();
  inline ::pp::MessageGroupNotice* release_gnotice();
  inline void set_allocated_gnotice(::pp::MessageGroupNotice* gnotice);

  // repeated .pp.MessagePub ad = 8;
  inline int ad_size() const;
  inline void clear_ad();
  static const int kAdFieldNumber = 8;
  inline const ::pp::MessagePub& ad(int index) const;
  inline ::pp::MessagePub* mutable_ad(int index);
  inline ::pp::MessagePub* add_ad();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >&
      ad() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >*
      mutable_ad();

  // optional .pp.MessagePub activity = 9;
  inline bool has_activity() const;
  inline void clear_activity();
  static const int kActivityFieldNumber = 9;
  inline const ::pp::MessagePub& activity() const;
  inline ::pp::MessagePub* mutable_activity();
  inline ::pp::MessagePub* release_activity();
  inline void set_allocated_activity(::pp::MessagePub* activity);

  // optional .pp.MessageInputStatus inputstatus = 10;
  inline bool has_inputstatus() const;
  inline void clear_inputstatus();
  static const int kInputstatusFieldNumber = 10;
  inline const ::pp::MessageInputStatus& inputstatus() const;
  inline ::pp::MessageInputStatus* mutable_inputstatus();
  inline ::pp::MessageInputStatus* release_inputstatus();
  inline void set_allocated_inputstatus(::pp::MessageInputStatus* inputstatus);

  // optional .pp.MessageTxtlink txtlink = 21;
  inline bool has_txtlink() const;
  inline void clear_txtlink();
  static const int kTxtlinkFieldNumber = 21;
  inline const ::pp::MessageTxtlink& txtlink() const;
  inline ::pp::MessageTxtlink* mutable_txtlink();
  inline ::pp::MessageTxtlink* release_txtlink();
  inline void set_allocated_txtlink(::pp::MessageTxtlink* txtlink);

  // optional string html = 33;
  inline bool has_html() const;
  inline void clear_html();
  static const int kHtmlFieldNumber = 33;
  inline const ::std::string& html() const;
  inline void set_html(const ::std::string& value);
  inline void set_html(const char* value);
  inline void set_html(const char* value, size_t size);
  inline ::std::string* mutable_html();
  inline ::std::string* release_html();
  inline void set_allocated_html(::std::string* html);

  // optional .pp.MessageUserApply userApply = 34;
  inline bool has_userapply() const;
  inline void clear_userapply();
  static const int kUserApplyFieldNumber = 34;
  inline const ::pp::MessageUserApply& userapply() const;
  inline ::pp::MessageUserApply* mutable_userapply();
  inline ::pp::MessageUserApply* release_userapply();
  inline void set_allocated_userapply(::pp::MessageUserApply* userapply);

  // optional .pp.MessageEvent event = 35;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 35;
  inline const ::pp::MessageEvent& event() const;
  inline ::pp::MessageEvent* mutable_event();
  inline ::pp::MessageEvent* release_event();
  inline void set_allocated_event(::pp::MessageEvent* event);

  // optional .pp.MessageGroupApply groupApply = 36;
  inline bool has_groupapply() const;
  inline void clear_groupapply();
  static const int kGroupApplyFieldNumber = 36;
  inline const ::pp::MessageGroupApply& groupapply() const;
  inline ::pp::MessageGroupApply* mutable_groupapply();
  inline ::pp::MessageGroupApply* release_groupapply();
  inline void set_allocated_groupapply(::pp::MessageGroupApply* groupapply);

  // optional .pp.MessageUserTask userTask = 37;
  inline bool has_usertask() const;
  inline void clear_usertask();
  static const int kUserTaskFieldNumber = 37;
  inline const ::pp::MessageUserTask& usertask() const;
  inline ::pp::MessageUserTask* mutable_usertask();
  inline ::pp::MessageUserTask* release_usertask();
  inline void set_allocated_usertask(::pp::MessageUserTask* usertask);

  // optional .pp.UserInfo userinfo = 50;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 50;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional .pp.GroupInfo groupInfo = 51;
  inline bool has_groupinfo() const;
  inline void clear_groupinfo();
  static const int kGroupInfoFieldNumber = 51;
  inline const ::pp::GroupInfo& groupinfo() const;
  inline ::pp::GroupInfo* mutable_groupinfo();
  inline ::pp::GroupInfo* release_groupinfo();
  inline void set_allocated_groupinfo(::pp::GroupInfo* groupinfo);

  // optional string title = 98;
  inline bool has_title() const;
  inline void clear_title();
  static const int kTitleFieldNumber = 98;
  inline const ::std::string& title() const;
  inline void set_title(const ::std::string& value);
  inline void set_title(const char* value);
  inline void set_title(const char* value, size_t size);
  inline ::std::string* mutable_title();
  inline ::std::string* release_title();
  inline void set_allocated_title(::std::string* title);

  // @@protoc_insertion_point(class_scope:pp.MessageBody)
 private:
  inline void set_has_contenttype();
  inline void clear_has_contenttype();
  inline void set_has_txt();
  inline void clear_has_txt();
  inline void set_has_img();
  inline void clear_has_img();
  inline void set_has_voice();
  inline void clear_has_voice();
  inline void set_has_video();
  inline void clear_has_video();
  inline void set_has_gnotice();
  inline void clear_has_gnotice();
  inline void set_has_activity();
  inline void clear_has_activity();
  inline void set_has_inputstatus();
  inline void clear_has_inputstatus();
  inline void set_has_txtlink();
  inline void clear_has_txtlink();
  inline void set_has_html();
  inline void clear_has_html();
  inline void set_has_userapply();
  inline void clear_has_userapply();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_groupapply();
  inline void clear_has_groupapply();
  inline void set_has_usertask();
  inline void clear_has_usertask();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_groupinfo();
  inline void clear_has_groupinfo();
  inline void set_has_title();
  inline void clear_has_title();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* txt_;
  ::pp::MessageImage* img_;
  ::pp::MessageVoice* voice_;
  ::pp::MessageVideo* video_;
  ::google::protobuf::RepeatedPtrField< ::pp::MessagePub > pub_;
  ::pp::MessageGroupNotice* gnotice_;
  ::google::protobuf::RepeatedPtrField< ::pp::MessagePub > ad_;
  ::pp::MessagePub* activity_;
  ::pp::MessageInputStatus* inputstatus_;
  ::pp::MessageTxtlink* txtlink_;
  ::std::string* html_;
  ::pp::MessageUserApply* userapply_;
  ::pp::MessageEvent* event_;
  ::pp::MessageGroupApply* groupapply_;
  ::pp::MessageUserTask* usertask_;
  ::pp::UserInfo* userinfo_;
  ::pp::GroupInfo* groupinfo_;
  ::std::string* title_;
  ::google::protobuf::uint32 contenttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(19 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MessageBody* default_instance_;
};
// -------------------------------------------------------------------

class PresentInfo : public ::google::protobuf::Message {
 public:
  PresentInfo();
  virtual ~PresentInfo();

  PresentInfo(const PresentInfo& from);

  inline PresentInfo& operator=(const PresentInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentInfo& default_instance();

  void Swap(PresentInfo* other);

  // implements Message ----------------------------------------------

  PresentInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 gameId = 3;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 3;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 price = 5;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 5;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // optional uint32 total = 6;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 6;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 leftNum = 7;
  inline bool has_leftnum() const;
  inline void clear_leftnum();
  static const int kLeftNumFieldNumber = 7;
  inline ::google::protobuf::uint32 leftnum() const;
  inline void set_leftnum(::google::protobuf::uint32 value);

  // optional string content = 8;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 8;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // optional string intro = 9;
  inline bool has_intro() const;
  inline void clear_intro();
  static const int kIntroFieldNumber = 9;
  inline const ::std::string& intro() const;
  inline void set_intro(const ::std::string& value);
  inline void set_intro(const char* value);
  inline void set_intro(const char* value, size_t size);
  inline ::std::string* mutable_intro();
  inline ::std::string* release_intro();
  inline void set_allocated_intro(::std::string* intro);

  // optional int64 startTime = 10;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 10;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional int64 endTime = 11;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 11;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // optional .pp.GameInfo game = 12;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 12;
  inline const ::pp::GameInfo& game() const;
  inline ::pp::GameInfo* mutable_game();
  inline ::pp::GameInfo* release_game();
  inline void set_allocated_game(::pp::GameInfo* game);

  // optional string label = 18;
  inline bool has_label() const;
  inline void clear_label();
  static const int kLabelFieldNumber = 18;
  inline const ::std::string& label() const;
  inline void set_label(const ::std::string& value);
  inline void set_label(const char* value);
  inline void set_label(const char* value, size_t size);
  inline ::std::string* mutable_label();
  inline ::std::string* release_label();
  inline void set_allocated_label(::std::string* label);

  // optional uint32 state = 40;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 40;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // repeated string codes = 50;
  inline int codes_size() const;
  inline void clear_codes();
  static const int kCodesFieldNumber = 50;
  inline const ::std::string& codes(int index) const;
  inline ::std::string* mutable_codes(int index);
  inline void set_codes(int index, const ::std::string& value);
  inline void set_codes(int index, const char* value);
  inline void set_codes(int index, const char* value, size_t size);
  inline ::std::string* add_codes();
  inline void add_codes(const ::std::string& value);
  inline void add_codes(const char* value);
  inline void add_codes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& codes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_codes();

  // @@protoc_insertion_point(class_scope:pp.PresentInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_leftnum();
  inline void clear_has_leftnum();
  inline void set_has_content();
  inline void clear_has_content();
  inline void set_has_intro();
  inline void clear_has_intro();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_game();
  inline void clear_has_game();
  inline void set_has_label();
  inline void clear_has_label();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 price_;
  ::google::protobuf::uint32 total_;
  ::std::string* content_;
  ::std::string* intro_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::uint32 leftnum_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::int64 endtime_;
  ::pp::GameInfo* game_;
  ::std::string* label_;
  ::google::protobuf::RepeatedPtrField< ::std::string> codes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentInfo* default_instance_;
};
// -------------------------------------------------------------------

class PresentInfoReq : public ::google::protobuf::Message {
 public:
  PresentInfoReq();
  virtual ~PresentInfoReq();

  PresentInfoReq(const PresentInfoReq& from);

  inline PresentInfoReq& operator=(const PresentInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentInfoReq& default_instance();

  void Swap(PresentInfoReq* other);

  // implements Message ----------------------------------------------

  PresentInfoReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 presentId = 1;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 1;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PresentInfoReq)
 private:
  inline void set_has_presentid();
  inline void clear_has_presentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 presentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentInfoRes : public ::google::protobuf::Message {
 public:
  PresentInfoRes();
  virtual ~PresentInfoRes();

  PresentInfoRes(const PresentInfoRes& from);

  inline PresentInfoRes& operator=(const PresentInfoRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentInfoRes& default_instance();

  void Swap(PresentInfoRes* other);

  // implements Message ----------------------------------------------

  PresentInfoRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.PresentInfo present = 1;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 1;
  inline const ::pp::PresentInfo& present() const;
  inline ::pp::PresentInfo* mutable_present();
  inline ::pp::PresentInfo* release_present();
  inline void set_allocated_present(::pp::PresentInfo* present);

  // @@protoc_insertion_point(class_scope:pp.PresentInfoRes)
 private:
  inline void set_has_present();
  inline void clear_has_present();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::PresentInfo* present_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentInfoRes* default_instance_;
};
// -------------------------------------------------------------------

class PresentAddReq : public ::google::protobuf::Message {
 public:
  PresentAddReq();
  virtual ~PresentAddReq();

  PresentAddReq(const PresentAddReq& from);

  inline PresentAddReq& operator=(const PresentAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentAddReq& default_instance();

  void Swap(PresentAddReq* other);

  // implements Message ----------------------------------------------

  PresentAddReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.PresentInfo present = 1;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 1;
  inline const ::pp::PresentInfo& present() const;
  inline ::pp::PresentInfo* mutable_present();
  inline ::pp::PresentInfo* release_present();
  inline void set_allocated_present(::pp::PresentInfo* present);

  // repeated string codes = 2;
  inline int codes_size() const;
  inline void clear_codes();
  static const int kCodesFieldNumber = 2;
  inline const ::std::string& codes(int index) const;
  inline ::std::string* mutable_codes(int index);
  inline void set_codes(int index, const ::std::string& value);
  inline void set_codes(int index, const char* value);
  inline void set_codes(int index, const char* value, size_t size);
  inline ::std::string* add_codes();
  inline void add_codes(const ::std::string& value);
  inline void add_codes(const char* value);
  inline void add_codes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& codes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_codes();

  // @@protoc_insertion_point(class_scope:pp.PresentAddReq)
 private:
  inline void set_has_present();
  inline void clear_has_present();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::PresentInfo* present_;
  ::google::protobuf::RepeatedPtrField< ::std::string> codes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentAddReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentModifyReq : public ::google::protobuf::Message {
 public:
  PresentModifyReq();
  virtual ~PresentModifyReq();

  PresentModifyReq(const PresentModifyReq& from);

  inline PresentModifyReq& operator=(const PresentModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentModifyReq& default_instance();

  void Swap(PresentModifyReq* other);

  // implements Message ----------------------------------------------

  PresentModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.PresentInfo present = 1;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 1;
  inline const ::pp::PresentInfo& present() const;
  inline ::pp::PresentInfo* mutable_present();
  inline ::pp::PresentInfo* release_present();
  inline void set_allocated_present(::pp::PresentInfo* present);

  // repeated string codes = 2;
  inline int codes_size() const;
  inline void clear_codes();
  static const int kCodesFieldNumber = 2;
  inline const ::std::string& codes(int index) const;
  inline ::std::string* mutable_codes(int index);
  inline void set_codes(int index, const ::std::string& value);
  inline void set_codes(int index, const char* value);
  inline void set_codes(int index, const char* value, size_t size);
  inline ::std::string* add_codes();
  inline void add_codes(const ::std::string& value);
  inline void add_codes(const char* value);
  inline void add_codes(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& codes() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_codes();

  // @@protoc_insertion_point(class_scope:pp.PresentModifyReq)
 private:
  inline void set_has_present();
  inline void clear_has_present();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::PresentInfo* present_;
  ::google::protobuf::RepeatedPtrField< ::std::string> codes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentListReq : public ::google::protobuf::Message {
 public:
  PresentListReq();
  virtual ~PresentListReq();

  PresentListReq(const PresentListReq& from);

  inline PresentListReq& operator=(const PresentListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentListReq& default_instance();

  void Swap(PresentListReq* other);

  // implements Message ----------------------------------------------

  PresentListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint64 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.PresentListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint64 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentListReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentListRes : public ::google::protobuf::Message {
 public:
  PresentListRes();
  virtual ~PresentListRes();

  PresentListRes(const PresentListRes& from);

  inline PresentListRes& operator=(const PresentListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentListRes& default_instance();

  void Swap(PresentListRes* other);

  // implements Message ----------------------------------------------

  PresentListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.PresentInfo presents = 3;
  inline int presents_size() const;
  inline void clear_presents();
  static const int kPresentsFieldNumber = 3;
  inline const ::pp::PresentInfo& presents(int index) const;
  inline ::pp::PresentInfo* mutable_presents(int index);
  inline ::pp::PresentInfo* add_presents();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >&
      presents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >*
      mutable_presents();

  // @@protoc_insertion_point(class_scope:pp.PresentListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo > presents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentListRes* default_instance_;
};
// -------------------------------------------------------------------

class PresentCountReq : public ::google::protobuf::Message {
 public:
  PresentCountReq();
  virtual ~PresentCountReq();

  PresentCountReq(const PresentCountReq& from);

  inline PresentCountReq& operator=(const PresentCountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentCountReq& default_instance();

  void Swap(PresentCountReq* other);

  // implements Message ----------------------------------------------

  PresentCountReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.PresentCountReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentCountReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentCountRes : public ::google::protobuf::Message {
 public:
  PresentCountRes();
  virtual ~PresentCountRes();

  PresentCountRes(const PresentCountRes& from);

  inline PresentCountRes& operator=(const PresentCountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentCountRes& default_instance();

  void Swap(PresentCountRes* other);

  // implements Message ----------------------------------------------

  PresentCountRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 1;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PresentCountRes)
 private:
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentCountRes* default_instance_;
};
// -------------------------------------------------------------------

class UserPresentListReq : public ::google::protobuf::Message {
 public:
  UserPresentListReq();
  virtual ~UserPresentListReq();

  UserPresentListReq(const UserPresentListReq& from);

  inline UserPresentListReq& operator=(const UserPresentListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresentListReq& default_instance();

  void Swap(UserPresentListReq* other);

  // implements Message ----------------------------------------------

  UserPresentListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserPresentListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPresentListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserPresent : public ::google::protobuf::Message {
 public:
  UserPresent();
  virtual ~UserPresent();

  UserPresent(const UserPresent& from);

  inline UserPresent& operator=(const UserPresent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresent& default_instance();

  void Swap(UserPresent* other);

  // implements Message ----------------------------------------------

  UserPresent* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.PresentInfo present = 3;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 3;
  inline const ::pp::PresentInfo& present() const;
  inline ::pp::PresentInfo* mutable_present();
  inline ::pp::PresentInfo* release_present();
  inline void set_allocated_present(::pp::PresentInfo* present);

  // optional string code = 4;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 4;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // optional int64 createTime = 5;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 5;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional uint32 presentId = 6;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 6;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserPresent)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_present();
  inline void clear_has_present();
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_presentid();
  inline void clear_has_presentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 gid_;
  ::pp::PresentInfo* present_;
  ::std::string* code_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::uint32 presentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPresent* default_instance_;
};
// -------------------------------------------------------------------

class UserPresentListRes : public ::google::protobuf::Message {
 public:
  UserPresentListRes();
  virtual ~UserPresentListRes();

  UserPresentListRes(const UserPresentListRes& from);

  inline UserPresentListRes& operator=(const UserPresentListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresentListRes& default_instance();

  void Swap(UserPresentListRes* other);

  // implements Message ----------------------------------------------

  UserPresentListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.UserPresent userPresents = 3;
  inline int userpresents_size() const;
  inline void clear_userpresents();
  static const int kUserPresentsFieldNumber = 3;
  inline const ::pp::UserPresent& userpresents(int index) const;
  inline ::pp::UserPresent* mutable_userpresents(int index);
  inline ::pp::UserPresent* add_userpresents();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserPresent >&
      userpresents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserPresent >*
      mutable_userpresents();

  // @@protoc_insertion_point(class_scope:pp.UserPresentListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserPresent > userpresents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPresentListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserPresentReq : public ::google::protobuf::Message {
 public:
  UserPresentReq();
  virtual ~UserPresentReq();

  UserPresentReq(const UserPresentReq& from);

  inline UserPresentReq& operator=(const UserPresentReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresentReq& default_instance();

  void Swap(UserPresentReq* other);

  // implements Message ----------------------------------------------

  UserPresentReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 presentId = 1;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 1;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserPresentReq)
 private:
  inline void set_has_presentid();
  inline void clear_has_presentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 presentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPresentReq* default_instance_;
};
// -------------------------------------------------------------------

class UserPresentRes : public ::google::protobuf::Message {
 public:
  UserPresentRes();
  virtual ~UserPresentRes();

  UserPresentRes(const UserPresentRes& from);

  inline UserPresentRes& operator=(const UserPresentRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPresentRes& default_instance();

  void Swap(UserPresentRes* other);

  // implements Message ----------------------------------------------

  UserPresentRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserPresent userPresent = 1;
  inline bool has_userpresent() const;
  inline void clear_userpresent();
  static const int kUserPresentFieldNumber = 1;
  inline const ::pp::UserPresent& userpresent() const;
  inline ::pp::UserPresent* mutable_userpresent();
  inline ::pp::UserPresent* release_userpresent();
  inline void set_allocated_userpresent(::pp::UserPresent* userpresent);

  // @@protoc_insertion_point(class_scope:pp.UserPresentRes)
 private:
  inline void set_has_userpresent();
  inline void clear_has_userpresent();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserPresent* userpresent_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPresentRes* default_instance_;
};
// -------------------------------------------------------------------

class PresentGroupListReq : public ::google::protobuf::Message {
 public:
  PresentGroupListReq();
  virtual ~PresentGroupListReq();

  PresentGroupListReq(const PresentGroupListReq& from);

  inline PresentGroupListReq& operator=(const PresentGroupListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentGroupListReq& default_instance();

  void Swap(PresentGroupListReq* other);

  // implements Message ----------------------------------------------

  PresentGroupListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 presentId = 1;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 1;
  inline ::google::protobuf::uint64 presentid() const;
  inline void set_presentid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PresentGroupListReq)
 private:
  inline void set_has_presentid();
  inline void clear_has_presentid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 presentid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentGroupListReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentGroupListRes : public ::google::protobuf::Message {
 public:
  PresentGroupListRes();
  virtual ~PresentGroupListRes();

  PresentGroupListRes(const PresentGroupListRes& from);

  inline PresentGroupListRes& operator=(const PresentGroupListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentGroupListRes& default_instance();

  void Swap(PresentGroupListRes* other);

  // implements Message ----------------------------------------------

  PresentGroupListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.GroupInfo groups = 3;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 3;
  inline const ::pp::GroupInfo& groups(int index) const;
  inline ::pp::GroupInfo* mutable_groups(int index);
  inline ::pp::GroupInfo* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
      mutable_groups();

  // @@protoc_insertion_point(class_scope:pp.PresentGroupListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo > groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentGroupListRes* default_instance_;
};
// -------------------------------------------------------------------

class PresentUserTakeReq : public ::google::protobuf::Message {
 public:
  PresentUserTakeReq();
  virtual ~PresentUserTakeReq();

  PresentUserTakeReq(const PresentUserTakeReq& from);

  inline PresentUserTakeReq& operator=(const PresentUserTakeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentUserTakeReq& default_instance();

  void Swap(PresentUserTakeReq* other);

  // implements Message ----------------------------------------------

  PresentUserTakeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 presentId = 2;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 2;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PresentUserTakeReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_presentid();
  inline void clear_has_presentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 presentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentUserTakeReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentUserTakeRes : public ::google::protobuf::Message {
 public:
  PresentUserTakeRes();
  virtual ~PresentUserTakeRes();

  PresentUserTakeRes(const PresentUserTakeRes& from);

  inline PresentUserTakeRes& operator=(const PresentUserTakeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentUserTakeRes& default_instance();

  void Swap(PresentUserTakeRes* other);

  // implements Message ----------------------------------------------

  PresentUserTakeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:pp.PresentUserTakeRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentUserTakeRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupPresent : public ::google::protobuf::Message {
 public:
  GroupPresent();
  virtual ~GroupPresent();

  GroupPresent(const GroupPresent& from);

  inline GroupPresent& operator=(const GroupPresent& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPresent& default_instance();

  void Swap(GroupPresent* other);

  // implements Message ----------------------------------------------

  GroupPresent* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.PresentInfo present = 2;
  inline bool has_present() const;
  inline void clear_present();
  static const int kPresentFieldNumber = 2;
  inline const ::pp::PresentInfo& present() const;
  inline ::pp::PresentInfo* mutable_present();
  inline ::pp::PresentInfo* release_present();
  inline void set_allocated_present(::pp::PresentInfo* present);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional int32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::int32 num() const;
  inline void set_num(::google::protobuf::int32 value);

  // optional uint32 contrib = 5;
  inline bool has_contrib() const;
  inline void clear_contrib();
  static const int kContribFieldNumber = 5;
  inline ::google::protobuf::uint32 contrib() const;
  inline void set_contrib(::google::protobuf::uint32 value);

  // optional uint32 presentId = 6;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 6;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // optional .pp.GroupPresentApplyType applyType = 7;
  inline bool has_applytype() const;
  inline void clear_applytype();
  static const int kApplyTypeFieldNumber = 7;
  inline ::pp::GroupPresentApplyType applytype() const;
  inline void set_applytype(::pp::GroupPresentApplyType value);

  // @@protoc_insertion_point(class_scope:pp.GroupPresent)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_present();
  inline void clear_has_present();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_contrib();
  inline void clear_has_contrib();
  inline void set_has_presentid();
  inline void clear_has_presentid();
  inline void set_has_applytype();
  inline void clear_has_applytype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::pp::PresentInfo* present_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::int32 num_;
  ::google::protobuf::uint32 contrib_;
  ::google::protobuf::uint32 presentid_;
  int applytype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupPresent* default_instance_;
};
// -------------------------------------------------------------------

class GroupPresentOpReq : public ::google::protobuf::Message {
 public:
  GroupPresentOpReq();
  virtual ~GroupPresentOpReq();

  GroupPresentOpReq(const GroupPresentOpReq& from);

  inline GroupPresentOpReq& operator=(const GroupPresentOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPresentOpReq& default_instance();

  void Swap(GroupPresentOpReq* other);

  // implements Message ----------------------------------------------

  GroupPresentOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GroupPresent groupPresent = 1;
  inline bool has_grouppresent() const;
  inline void clear_grouppresent();
  static const int kGroupPresentFieldNumber = 1;
  inline const ::pp::GroupPresent& grouppresent() const;
  inline ::pp::GroupPresent* mutable_grouppresent();
  inline ::pp::GroupPresent* release_grouppresent();
  inline void set_allocated_grouppresent(::pp::GroupPresent* grouppresent);

  // optional .pp.EntityOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // optional bool needcode = 3;
  inline bool has_needcode() const;
  inline void clear_needcode();
  static const int kNeedcodeFieldNumber = 3;
  inline bool needcode() const;
  inline void set_needcode(bool value);

  // optional bool needmoney = 4;
  inline bool has_needmoney() const;
  inline void clear_needmoney();
  static const int kNeedmoneyFieldNumber = 4;
  inline bool needmoney() const;
  inline void set_needmoney(bool value);

  // @@protoc_insertion_point(class_scope:pp.GroupPresentOpReq)
 private:
  inline void set_has_grouppresent();
  inline void clear_has_grouppresent();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_needcode();
  inline void clear_has_needcode();
  inline void set_has_needmoney();
  inline void clear_has_needmoney();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GroupPresent* grouppresent_;
  int optype_;
  bool needcode_;
  bool needmoney_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupPresentOpReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPresentOpRes : public ::google::protobuf::Message {
 public:
  GroupPresentOpRes();
  virtual ~GroupPresentOpRes();

  GroupPresentOpRes(const GroupPresentOpRes& from);

  inline GroupPresentOpRes& operator=(const GroupPresentOpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPresentOpRes& default_instance();

  void Swap(GroupPresentOpRes* other);

  // implements Message ----------------------------------------------

  GroupPresentOpRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GroupPresent groupPresent = 1;
  inline bool has_grouppresent() const;
  inline void clear_grouppresent();
  static const int kGroupPresentFieldNumber = 1;
  inline const ::pp::GroupPresent& grouppresent() const;
  inline ::pp::GroupPresent* mutable_grouppresent();
  inline ::pp::GroupPresent* release_grouppresent();
  inline void set_allocated_grouppresent(::pp::GroupPresent* grouppresent);

  // optional string code = 2;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 2;
  inline const ::std::string& code() const;
  inline void set_code(const ::std::string& value);
  inline void set_code(const char* value);
  inline void set_code(const char* value, size_t size);
  inline ::std::string* mutable_code();
  inline ::std::string* release_code();
  inline void set_allocated_code(::std::string* code);

  // @@protoc_insertion_point(class_scope:pp.GroupPresentOpRes)
 private:
  inline void set_has_grouppresent();
  inline void clear_has_grouppresent();
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GroupPresent* grouppresent_;
  ::std::string* code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupPresentOpRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupPresentListReq : public ::google::protobuf::Message {
 public:
  GroupPresentListReq();
  virtual ~GroupPresentListReq();

  GroupPresentListReq(const GroupPresentListReq& from);

  inline GroupPresentListReq& operator=(const GroupPresentListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPresentListReq& default_instance();

  void Swap(GroupPresentListReq* other);

  // implements Message ----------------------------------------------

  GroupPresentListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 gameId = 4;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 4;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GroupPresentListReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_gameid();
  inline void clear_has_gameid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 gameid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupPresentListReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupPresentListRes : public ::google::protobuf::Message {
 public:
  GroupPresentListRes();
  virtual ~GroupPresentListRes();

  GroupPresentListRes(const GroupPresentListRes& from);

  inline GroupPresentListRes& operator=(const GroupPresentListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupPresentListRes& default_instance();

  void Swap(GroupPresentListRes* other);

  // implements Message ----------------------------------------------

  GroupPresentListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.GroupPresent presents = 3;
  inline int presents_size() const;
  inline void clear_presents();
  static const int kPresentsFieldNumber = 3;
  inline const ::pp::GroupPresent& presents(int index) const;
  inline ::pp::GroupPresent* mutable_presents(int index);
  inline ::pp::GroupPresent* add_presents();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupPresent >&
      presents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupPresent >*
      mutable_presents();

  // @@protoc_insertion_point(class_scope:pp.GroupPresentListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupPresent > presents_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupPresentListRes* default_instance_;
};
// -------------------------------------------------------------------

class GetPresentsByGameIdReq : public ::google::protobuf::Message {
 public:
  GetPresentsByGameIdReq();
  virtual ~GetPresentsByGameIdReq();

  GetPresentsByGameIdReq(const GetPresentsByGameIdReq& from);

  inline GetPresentsByGameIdReq& operator=(const GetPresentsByGameIdReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPresentsByGameIdReq& default_instance();

  void Swap(GetPresentsByGameIdReq* other);

  // implements Message ----------------------------------------------

  GetPresentsByGameIdReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint64 gid = 4;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 4;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.GetPresentsByGameIdReq)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GetPresentsByGameIdReq* default_instance_;
};
// -------------------------------------------------------------------

class GetPresentsByGameIdRes : public ::google::protobuf::Message {
 public:
  GetPresentsByGameIdRes();
  virtual ~GetPresentsByGameIdRes();

  GetPresentsByGameIdRes(const GetPresentsByGameIdRes& from);

  inline GetPresentsByGameIdRes& operator=(const GetPresentsByGameIdRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GetPresentsByGameIdRes& default_instance();

  void Swap(GetPresentsByGameIdRes* other);

  // implements Message ----------------------------------------------

  GetPresentsByGameIdRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 gameId = 1;
  inline bool has_gameid() const;
  inline void clear_gameid();
  static const int kGameIdFieldNumber = 1;
  inline ::google::protobuf::uint32 gameid() const;
  inline void set_gameid(::google::protobuf::uint32 value);

  // repeated .pp.PresentInfo presents = 2;
  inline int presents_size() const;
  inline void clear_presents();
  static const int kPresentsFieldNumber = 2;
  inline const ::pp::PresentInfo& presents(int index) const;
  inline ::pp::PresentInfo* mutable_presents(int index);
  inline ::pp::PresentInfo* add_presents();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >&
      presents() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >*
      mutable_presents();

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 4;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 4;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 total = 5;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 5;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.GetPresentsByGameIdRes)
 private:
  inline void set_has_gameid();
  inline void clear_has_gameid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo > presents_;
  ::google::protobuf::uint32 gameid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GetPresentsByGameIdRes* default_instance_;
};
// -------------------------------------------------------------------

class PresentUserListReq : public ::google::protobuf::Message {
 public:
  PresentUserListReq();
  virtual ~PresentUserListReq();

  PresentUserListReq(const PresentUserListReq& from);

  inline PresentUserListReq& operator=(const PresentUserListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentUserListReq& default_instance();

  void Swap(PresentUserListReq* other);

  // implements Message ----------------------------------------------

  PresentUserListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint64 gid = 4;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 4;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 presentId = 5;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 5;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PresentUserListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_presentid();
  inline void clear_has_presentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 presentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentUserListReq* default_instance_;
};
// -------------------------------------------------------------------

class PresentUserListRes : public ::google::protobuf::Message {
 public:
  PresentUserListRes();
  virtual ~PresentUserListRes();

  PresentUserListRes(const PresentUserListRes& from);

  inline PresentUserListRes& operator=(const PresentUserListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentUserListRes& default_instance();

  void Swap(PresentUserListRes* other);

  // implements Message ----------------------------------------------

  PresentUserListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.PresentUser presentUsers = 1;
  inline int presentusers_size() const;
  inline void clear_presentusers();
  static const int kPresentUsersFieldNumber = 1;
  inline const ::pp::PresentUser& presentusers(int index) const;
  inline ::pp::PresentUser* mutable_presentusers(int index);
  inline ::pp::PresentUser* add_presentusers();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentUser >&
      presentusers() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::PresentUser >*
      mutable_presentusers();

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint64 gid = 4;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 4;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 presentId = 5;
  inline bool has_presentid() const;
  inline void clear_presentid();
  static const int kPresentIdFieldNumber = 5;
  inline ::google::protobuf::uint32 presentid() const;
  inline void set_presentid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.PresentUserListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_presentid();
  inline void clear_has_presentid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::PresentUser > presentusers_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 presentid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentUserListRes* default_instance_;
};
// -------------------------------------------------------------------

class PresentUser : public ::google::protobuf::Message {
 public:
  PresentUser();
  virtual ~PresentUser();

  PresentUser(const PresentUser& from);

  inline PresentUser& operator=(const PresentUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PresentUser& default_instance();

  void Swap(PresentUser* other);

  // implements Message ----------------------------------------------

  PresentUser* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.GroupMember member = 1;
  inline bool has_member() const;
  inline void clear_member();
  static const int kMemberFieldNumber = 1;
  inline const ::pp::GroupMember& member() const;
  inline ::pp::GroupMember* mutable_member();
  inline ::pp::GroupMember* release_member();
  inline void set_allocated_member(::pp::GroupMember* member);

  // optional int64 createTime = 2;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 2;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.PresentUser)
 private:
  inline void set_has_member();
  inline void clear_has_member();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::GroupMember* member_;
  ::google::protobuf::int64 createtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PresentUser* default_instance_;
};
// -------------------------------------------------------------------

class MsgPush : public ::google::protobuf::Message {
 public:
  MsgPush();
  virtual ~MsgPush();

  MsgPush(const MsgPush& from);

  inline MsgPush& operator=(const MsgPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgPush& default_instance();

  void Swap(MsgPush* other);

  // implements Message ----------------------------------------------

  MsgPush* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.MsgPushType pushtype = 1;
  inline bool has_pushtype() const;
  inline void clear_pushtype();
  static const int kPushtypeFieldNumber = 1;
  inline ::pp::MsgPushType pushtype() const;
  inline void set_pushtype(::pp::MsgPushType value);

  // required uint64 revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 parentgid = 4;
  inline bool has_parentgid() const;
  inline void clear_parentgid();
  static const int kParentgidFieldNumber = 4;
  inline ::google::protobuf::uint64 parentgid() const;
  inline void set_parentgid(::google::protobuf::uint64 value);

  // optional uint64 uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 peeruid = 6;
  inline bool has_peeruid() const;
  inline void clear_peeruid();
  static const int kPeeruidFieldNumber = 6;
  inline ::google::protobuf::uint64 peeruid() const;
  inline void set_peeruid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.MsgPush)
 private:
  inline void set_has_pushtype();
  inline void clear_has_pushtype();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_parentgid();
  inline void clear_has_parentgid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_peeruid();
  inline void clear_has_peeruid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 parentgid_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 peeruid_;
  int pushtype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgPush* default_instance_;
};
// -------------------------------------------------------------------

class ForceLogoutPush : public ::google::protobuf::Message {
 public:
  ForceLogoutPush();
  virtual ~ForceLogoutPush();

  ForceLogoutPush(const ForceLogoutPush& from);

  inline ForceLogoutPush& operator=(const ForceLogoutPush& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ForceLogoutPush& default_instance();

  void Swap(ForceLogoutPush* other);

  // implements Message ----------------------------------------------

  ForceLogoutPush* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string whitemac = 1;
  inline int whitemac_size() const;
  inline void clear_whitemac();
  static const int kWhitemacFieldNumber = 1;
  inline const ::std::string& whitemac(int index) const;
  inline ::std::string* mutable_whitemac(int index);
  inline void set_whitemac(int index, const ::std::string& value);
  inline void set_whitemac(int index, const char* value);
  inline void set_whitemac(int index, const char* value, size_t size);
  inline ::std::string* add_whitemac();
  inline void add_whitemac(const ::std::string& value);
  inline void add_whitemac(const char* value);
  inline void add_whitemac(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& whitemac() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_whitemac();

  // repeated string blackmac = 2;
  inline int blackmac_size() const;
  inline void clear_blackmac();
  static const int kBlackmacFieldNumber = 2;
  inline const ::std::string& blackmac(int index) const;
  inline ::std::string* mutable_blackmac(int index);
  inline void set_blackmac(int index, const ::std::string& value);
  inline void set_blackmac(int index, const char* value);
  inline void set_blackmac(int index, const char* value, size_t size);
  inline ::std::string* add_blackmac();
  inline void add_blackmac(const ::std::string& value);
  inline void add_blackmac(const char* value);
  inline void add_blackmac(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& blackmac() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_blackmac();

  // optional string reason = 3;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 3;
  inline const ::std::string& reason() const;
  inline void set_reason(const ::std::string& value);
  inline void set_reason(const char* value);
  inline void set_reason(const char* value, size_t size);
  inline ::std::string* mutable_reason();
  inline ::std::string* release_reason();
  inline void set_allocated_reason(::std::string* reason);

  // @@protoc_insertion_point(class_scope:pp.ForceLogoutPush)
 private:
  inline void set_has_reason();
  inline void clear_has_reason();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> whitemac_;
  ::google::protobuf::RepeatedPtrField< ::std::string> blackmac_;
  ::std::string* reason_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ForceLogoutPush* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketInfo : public ::google::protobuf::Message {
 public:
  RedPacketInfo();
  virtual ~RedPacketInfo();

  RedPacketInfo(const RedPacketInfo& from);

  inline RedPacketInfo& operator=(const RedPacketInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketInfo& default_instance();

  void Swap(RedPacketInfo* other);

  // implements Message ----------------------------------------------

  RedPacketInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RedPacketInfo_ItemType ItemType;
  static const ItemType Normal = RedPacketInfo_ItemType_Normal;
  static const ItemType Super = RedPacketInfo_ItemType_Super;
  static inline bool ItemType_IsValid(int value) {
    return RedPacketInfo_ItemType_IsValid(value);
  }
  static const ItemType ItemType_MIN =
    RedPacketInfo_ItemType_ItemType_MIN;
  static const ItemType ItemType_MAX =
    RedPacketInfo_ItemType_ItemType_MAX;
  static const int ItemType_ARRAYSIZE =
    RedPacketInfo_ItemType_ItemType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ItemType_descriptor() {
    return RedPacketInfo_ItemType_descriptor();
  }
  static inline const ::std::string& ItemType_Name(ItemType value) {
    return RedPacketInfo_ItemType_Name(value);
  }
  static inline bool ItemType_Parse(const ::std::string& name,
      ItemType* value) {
    return RedPacketInfo_ItemType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .pp.UserInfo user = 2;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 2;
  inline const ::pp::UserInfo& user() const;
  inline ::pp::UserInfo* mutable_user();
  inline ::pp::UserInfo* release_user();
  inline void set_allocated_user(::pp::UserInfo* user);

  // optional uint64 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 coins = 4;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 4;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional uint32 num = 5;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 5;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 itemtype = 6;
  inline bool has_itemtype() const;
  inline void clear_itemtype();
  static const int kItemtypeFieldNumber = 6;
  inline ::google::protobuf::uint32 itemtype() const;
  inline void set_itemtype(::google::protobuf::uint32 value);

  // optional uint32 leftnum = 7;
  inline bool has_leftnum() const;
  inline void clear_leftnum();
  static const int kLeftnumFieldNumber = 7;
  inline ::google::protobuf::uint32 leftnum() const;
  inline void set_leftnum(::google::protobuf::uint32 value);

  // optional uint64 leftcoins = 8;
  inline bool has_leftcoins() const;
  inline void clear_leftcoins();
  static const int kLeftcoinsFieldNumber = 8;
  inline ::google::protobuf::uint64 leftcoins() const;
  inline void set_leftcoins(::google::protobuf::uint64 value);

  // optional int64 createtime = 9;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 9;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.RedPacketInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_itemtype();
  inline void clear_has_itemtype();
  inline void set_has_leftnum();
  inline void clear_has_leftnum();
  inline void set_has_leftcoins();
  inline void clear_has_leftcoins();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* user_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint64 coins_;
  ::google::protobuf::uint32 itemtype_;
  ::google::protobuf::uint32 leftnum_;
  ::google::protobuf::uint64 leftcoins_;
  ::google::protobuf::int64 createtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketInfo* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketBlessInfo : public ::google::protobuf::Message {
 public:
  RedPacketBlessInfo();
  virtual ~RedPacketBlessInfo();

  RedPacketBlessInfo(const RedPacketBlessInfo& from);

  inline RedPacketBlessInfo& operator=(const RedPacketBlessInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketBlessInfo& default_instance();

  void Swap(RedPacketBlessInfo* other);

  // implements Message ----------------------------------------------

  RedPacketBlessInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string icon = 2;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 2;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint64 leftnum = 6;
  inline bool has_leftnum() const;
  inline void clear_leftnum();
  static const int kLeftnumFieldNumber = 6;
  inline ::google::protobuf::uint64 leftnum() const;
  inline void set_leftnum(::google::protobuf::uint64 value);

  // optional uint32 rate = 7;
  inline bool has_rate() const;
  inline void clear_rate();
  static const int kRateFieldNumber = 7;
  inline ::google::protobuf::uint32 rate() const;
  inline void set_rate(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.RedPacketBlessInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_leftnum();
  inline void clear_has_leftnum();
  inline void set_has_rate();
  inline void clear_has_rate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* icon_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 num_;
  ::std::string* name_;
  ::google::protobuf::uint64 leftnum_;
  ::google::protobuf::uint32 rate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketBlessInfo* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketAddReq : public ::google::protobuf::Message {
 public:
  RedPacketAddReq();
  virtual ~RedPacketAddReq();

  RedPacketAddReq(const RedPacketAddReq& from);

  inline RedPacketAddReq& operator=(const RedPacketAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketAddReq& default_instance();

  void Swap(RedPacketAddReq* other);

  // implements Message ----------------------------------------------

  RedPacketAddReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool disablenotice = 1 [default = false];
  inline bool has_disablenotice() const;
  inline void clear_disablenotice();
  static const int kDisablenoticeFieldNumber = 1;
  inline bool disablenotice() const;
  inline void set_disablenotice(bool value);

  // optional .pp.RedPacketInfo item = 2;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 2;
  inline const ::pp::RedPacketInfo& item() const;
  inline ::pp::RedPacketInfo* mutable_item();
  inline ::pp::RedPacketInfo* release_item();
  inline void set_allocated_item(::pp::RedPacketInfo* item);

  // @@protoc_insertion_point(class_scope:pp.RedPacketAddReq)
 private:
  inline void set_has_disablenotice();
  inline void clear_has_disablenotice();
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::RedPacketInfo* item_;
  bool disablenotice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketAddReq* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketTakeReq : public ::google::protobuf::Message {
 public:
  RedPacketTakeReq();
  virtual ~RedPacketTakeReq();

  RedPacketTakeReq(const RedPacketTakeReq& from);

  inline RedPacketTakeReq& operator=(const RedPacketTakeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketTakeReq& default_instance();

  void Swap(RedPacketTakeReq* other);

  // implements Message ----------------------------------------------

  RedPacketTakeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 itemId = 2;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 2;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.RedPacketTakeReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_itemid();
  inline void clear_has_itemid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 itemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketTakeReq* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketTakeRes : public ::google::protobuf::Message {
 public:
  RedPacketTakeRes();
  virtual ~RedPacketTakeRes();

  RedPacketTakeRes(const RedPacketTakeRes& from);

  inline RedPacketTakeRes& operator=(const RedPacketTakeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketTakeRes& default_instance();

  void Swap(RedPacketTakeRes* other);

  // implements Message ----------------------------------------------

  RedPacketTakeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::pp::UserInfo& user() const;
  inline ::pp::UserInfo* mutable_user();
  inline ::pp::UserInfo* release_user();
  inline void set_allocated_user(::pp::UserInfo* user);

  // optional uint64 coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional .pp.RedPacketBlessInfo bless = 3;
  inline bool has_bless() const;
  inline void clear_bless();
  static const int kBlessFieldNumber = 3;
  inline const ::pp::RedPacketBlessInfo& bless() const;
  inline ::pp::RedPacketBlessInfo* mutable_bless();
  inline ::pp::RedPacketBlessInfo* release_bless();
  inline void set_allocated_bless(::pp::RedPacketBlessInfo* bless);

  // @@protoc_insertion_point(class_scope:pp.RedPacketTakeRes)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_bless();
  inline void clear_has_bless();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* user_;
  ::google::protobuf::uint64 coins_;
  ::pp::RedPacketBlessInfo* bless_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketTakeRes* default_instance_;
};
// -------------------------------------------------------------------

class ShowRedPacketListReq : public ::google::protobuf::Message {
 public:
  ShowRedPacketListReq();
  virtual ~ShowRedPacketListReq();

  ShowRedPacketListReq(const ShowRedPacketListReq& from);

  inline ShowRedPacketListReq& operator=(const ShowRedPacketListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShowRedPacketListReq& default_instance();

  void Swap(ShowRedPacketListReq* other);

  // implements Message ----------------------------------------------

  ShowRedPacketListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional bool empty = 4;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 4;
  inline bool empty() const;
  inline void set_empty(bool value);

  // @@protoc_insertion_point(class_scope:pp.ShowRedPacketListReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_empty();
  inline void clear_has_empty();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  bool empty_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ShowRedPacketListReq* default_instance_;
};
// -------------------------------------------------------------------

class ShowRedPacketListRes : public ::google::protobuf::Message {
 public:
  ShowRedPacketListRes();
  virtual ~ShowRedPacketListRes();

  ShowRedPacketListRes(const ShowRedPacketListRes& from);

  inline ShowRedPacketListRes& operator=(const ShowRedPacketListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShowRedPacketListRes& default_instance();

  void Swap(ShowRedPacketListRes* other);

  // implements Message ----------------------------------------------

  ShowRedPacketListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional bool empty = 4;
  inline bool has_empty() const;
  inline void clear_empty();
  static const int kEmptyFieldNumber = 4;
  inline bool empty() const;
  inline void set_empty(bool value);

  // optional uint32 totalredpacket = 5;
  inline bool has_totalredpacket() const;
  inline void clear_totalredpacket();
  static const int kTotalredpacketFieldNumber = 5;
  inline ::google::protobuf::uint32 totalredpacket() const;
  inline void set_totalredpacket(::google::protobuf::uint32 value);

  // repeated .pp.RedPacketInfo items = 6;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 6;
  inline const ::pp::RedPacketInfo& items(int index) const;
  inline ::pp::RedPacketInfo* mutable_items(int index);
  inline ::pp::RedPacketInfo* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::RedPacketInfo >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::RedPacketInfo >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.ShowRedPacketListRes)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_empty();
  inline void clear_has_empty();
  inline void set_has_totalredpacket();
  inline void clear_has_totalredpacket();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  bool empty_;
  ::google::protobuf::uint32 totalredpacket_;
  ::google::protobuf::RepeatedPtrField< ::pp::RedPacketInfo > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ShowRedPacketListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserRedPacketStatReq : public ::google::protobuf::Message {
 public:
  UserRedPacketStatReq();
  virtual ~UserRedPacketStatReq();

  UserRedPacketStatReq(const UserRedPacketStatReq& from);

  inline UserRedPacketStatReq& operator=(const UserRedPacketStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRedPacketStatReq& default_instance();

  void Swap(UserRedPacketStatReq* other);

  // implements Message ----------------------------------------------

  UserRedPacketStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool detail = 1 [default = true];
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 1;
  inline bool detail() const;
  inline void set_detail(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserRedPacketStatReq)
 private:
  inline void set_has_detail();
  inline void clear_has_detail();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool detail_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRedPacketStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserRedPacketStatRes : public ::google::protobuf::Message {
 public:
  UserRedPacketStatRes();
  virtual ~UserRedPacketStatRes();

  UserRedPacketStatRes(const UserRedPacketStatRes& from);

  inline UserRedPacketStatRes& operator=(const UserRedPacketStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRedPacketStatRes& default_instance();

  void Swap(UserRedPacketStatRes* other);

  // implements Message ----------------------------------------------

  UserRedPacketStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool detail = 1 [default = true];
  inline bool has_detail() const;
  inline void clear_detail();
  static const int kDetailFieldNumber = 1;
  inline bool detail() const;
  inline void set_detail(bool value);

  // optional uint32 sendNum = 11;
  inline bool has_sendnum() const;
  inline void clear_sendnum();
  static const int kSendNumFieldNumber = 11;
  inline ::google::protobuf::uint32 sendnum() const;
  inline void set_sendnum(::google::protobuf::uint32 value);

  // optional uint64 sendSum = 12;
  inline bool has_sendsum() const;
  inline void clear_sendsum();
  static const int kSendSumFieldNumber = 12;
  inline ::google::protobuf::uint64 sendsum() const;
  inline void set_sendsum(::google::protobuf::uint64 value);

  // optional uint32 recvNum = 13;
  inline bool has_recvnum() const;
  inline void clear_recvnum();
  static const int kRecvNumFieldNumber = 13;
  inline ::google::protobuf::uint32 recvnum() const;
  inline void set_recvnum(::google::protobuf::uint32 value);

  // optional uint64 recvSum = 14;
  inline bool has_recvsum() const;
  inline void clear_recvsum();
  static const int kRecvSumFieldNumber = 14;
  inline ::google::protobuf::uint64 recvsum() const;
  inline void set_recvsum(::google::protobuf::uint64 value);

  // repeated .pp.RedPacketBlessInfo blessList = 15;
  inline int blesslist_size() const;
  inline void clear_blesslist();
  static const int kBlessListFieldNumber = 15;
  inline const ::pp::RedPacketBlessInfo& blesslist(int index) const;
  inline ::pp::RedPacketBlessInfo* mutable_blesslist(int index);
  inline ::pp::RedPacketBlessInfo* add_blesslist();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::RedPacketBlessInfo >&
      blesslist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::RedPacketBlessInfo >*
      mutable_blesslist();

  // @@protoc_insertion_point(class_scope:pp.UserRedPacketStatRes)
 private:
  inline void set_has_detail();
  inline void clear_has_detail();
  inline void set_has_sendnum();
  inline void clear_has_sendnum();
  inline void set_has_sendsum();
  inline void clear_has_sendsum();
  inline void set_has_recvnum();
  inline void clear_has_recvnum();
  inline void set_has_recvsum();
  inline void clear_has_recvsum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool detail_;
  ::google::protobuf::uint32 sendnum_;
  ::google::protobuf::uint64 sendsum_;
  ::google::protobuf::uint64 recvsum_;
  ::google::protobuf::RepeatedPtrField< ::pp::RedPacketBlessInfo > blesslist_;
  ::google::protobuf::uint32 recvnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRedPacketStatRes* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketRecord : public ::google::protobuf::Message {
 public:
  RedPacketRecord();
  virtual ~RedPacketRecord();

  RedPacketRecord(const RedPacketRecord& from);

  inline RedPacketRecord& operator=(const RedPacketRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketRecord& default_instance();

  void Swap(RedPacketRecord* other);

  // implements Message ----------------------------------------------

  RedPacketRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::pp::UserInfo& user() const;
  inline ::pp::UserInfo* mutable_user();
  inline ::pp::UserInfo* release_user();
  inline void set_allocated_user(::pp::UserInfo* user);

  // optional uint64 totalCoin = 2;
  inline bool has_totalcoin() const;
  inline void clear_totalcoin();
  static const int kTotalCoinFieldNumber = 2;
  inline ::google::protobuf::uint64 totalcoin() const;
  inline void set_totalcoin(::google::protobuf::uint64 value);

  // optional uint32 totalNum = 3;
  inline bool has_totalnum() const;
  inline void clear_totalnum();
  static const int kTotalNumFieldNumber = 3;
  inline ::google::protobuf::uint32 totalnum() const;
  inline void set_totalnum(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.RedPacketRecord)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_totalcoin();
  inline void clear_has_totalcoin();
  inline void set_has_totalnum();
  inline void clear_has_totalnum();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* user_;
  ::google::protobuf::uint64 totalcoin_;
  ::google::protobuf::uint32 totalnum_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketRecord* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketRankListReq : public ::google::protobuf::Message {
 public:
  RedPacketRankListReq();
  virtual ~RedPacketRankListReq();

  RedPacketRankListReq(const RedPacketRankListReq& from);

  inline RedPacketRankListReq& operator=(const RedPacketRankListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketRankListReq& default_instance();

  void Swap(RedPacketRankListReq* other);

  // implements Message ----------------------------------------------

  RedPacketRankListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool sponsor = 1;
  inline bool has_sponsor() const;
  inline void clear_sponsor();
  static const int kSponsorFieldNumber = 1;
  inline bool sponsor() const;
  inline void set_sponsor(bool value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.RedPacketRankListReq)
 private:
  inline void set_has_sponsor();
  inline void clear_has_sponsor();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool sponsor_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketRankListReq* default_instance_;
};
// -------------------------------------------------------------------

class RedPacketRankListRes : public ::google::protobuf::Message {
 public:
  RedPacketRankListRes();
  virtual ~RedPacketRankListRes();

  RedPacketRankListRes(const RedPacketRankListRes& from);

  inline RedPacketRankListRes& operator=(const RedPacketRankListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RedPacketRankListRes& default_instance();

  void Swap(RedPacketRankListRes* other);

  // implements Message ----------------------------------------------

  RedPacketRankListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool sponsor = 1;
  inline bool has_sponsor() const;
  inline void clear_sponsor();
  static const int kSponsorFieldNumber = 1;
  inline bool sponsor() const;
  inline void set_sponsor(bool value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 totalresults = 4;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 4;
  inline ::google::protobuf::uint32 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint32 value);

  // repeated .pp.RedPacketRecord records = 5;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 5;
  inline const ::pp::RedPacketRecord& records(int index) const;
  inline ::pp::RedPacketRecord* mutable_records(int index);
  inline ::pp::RedPacketRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::RedPacketRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::RedPacketRecord >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:pp.RedPacketRankListRes)
 private:
  inline void set_has_sponsor();
  inline void clear_has_sponsor();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool sponsor_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 totalresults_;
  ::google::protobuf::RepeatedPtrField< ::pp::RedPacketRecord > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static RedPacketRankListRes* default_instance_;
};
// -------------------------------------------------------------------

class BlessGiftInfo : public ::google::protobuf::Message {
 public:
  BlessGiftInfo();
  virtual ~BlessGiftInfo();

  BlessGiftInfo(const BlessGiftInfo& from);

  inline BlessGiftInfo& operator=(const BlessGiftInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlessGiftInfo& default_instance();

  void Swap(BlessGiftInfo* other);

  // implements Message ----------------------------------------------

  BlessGiftInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string icon = 2;
  inline bool has_icon() const;
  inline void clear_icon();
  static const int kIconFieldNumber = 2;
  inline const ::std::string& icon() const;
  inline void set_icon(const ::std::string& value);
  inline void set_icon(const char* value);
  inline void set_icon(const char* value, size_t size);
  inline ::std::string* mutable_icon();
  inline ::std::string* release_icon();
  inline void set_allocated_icon(::std::string* icon);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 coins = 4;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 4;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional uint32 leftnum = 5;
  inline bool has_leftnum() const;
  inline void clear_leftnum();
  static const int kLeftnumFieldNumber = 5;
  inline ::google::protobuf::uint32 leftnum() const;
  inline void set_leftnum(::google::protobuf::uint32 value);

  // optional string condition = 6;
  inline bool has_condition() const;
  inline void clear_condition();
  static const int kConditionFieldNumber = 6;
  inline const ::std::string& condition() const;
  inline void set_condition(const ::std::string& value);
  inline void set_condition(const char* value);
  inline void set_condition(const char* value, size_t size);
  inline ::std::string* mutable_condition();
  inline ::std::string* release_condition();
  inline void set_allocated_condition(::std::string* condition);

  // @@protoc_insertion_point(class_scope:pp.BlessGiftInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_icon();
  inline void clear_has_icon();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_leftnum();
  inline void clear_has_leftnum();
  inline void set_has_condition();
  inline void clear_has_condition();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* icon_;
  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 leftnum_;
  ::google::protobuf::uint64 coins_;
  ::std::string* condition_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BlessGiftInfo* default_instance_;
};
// -------------------------------------------------------------------

class BlessGiftListReq : public ::google::protobuf::Message {
 public:
  BlessGiftListReq();
  virtual ~BlessGiftListReq();

  BlessGiftListReq(const BlessGiftListReq& from);

  inline BlessGiftListReq& operator=(const BlessGiftListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlessGiftListReq& default_instance();

  void Swap(BlessGiftListReq* other);

  // implements Message ----------------------------------------------

  BlessGiftListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.BlessGiftListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BlessGiftListReq* default_instance_;
};
// -------------------------------------------------------------------

class BlessGiftListRes : public ::google::protobuf::Message {
 public:
  BlessGiftListRes();
  virtual ~BlessGiftListRes();

  BlessGiftListRes(const BlessGiftListRes& from);

  inline BlessGiftListRes& operator=(const BlessGiftListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlessGiftListRes& default_instance();

  void Swap(BlessGiftListRes* other);

  // implements Message ----------------------------------------------

  BlessGiftListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.BlessGiftInfo items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::BlessGiftInfo& items(int index) const;
  inline ::pp::BlessGiftInfo* mutable_items(int index);
  inline ::pp::BlessGiftInfo* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::BlessGiftInfo >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::BlessGiftInfo >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.BlessGiftListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::BlessGiftInfo > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BlessGiftListRes* default_instance_;
};
// -------------------------------------------------------------------

class BlessGiftExchangeReq : public ::google::protobuf::Message {
 public:
  BlessGiftExchangeReq();
  virtual ~BlessGiftExchangeReq();

  BlessGiftExchangeReq(const BlessGiftExchangeReq& from);

  inline BlessGiftExchangeReq& operator=(const BlessGiftExchangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlessGiftExchangeReq& default_instance();

  void Swap(BlessGiftExchangeReq* other);

  // implements Message ----------------------------------------------

  BlessGiftExchangeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint32 itemid() const;
  inline void set_itemid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.BlessGiftExchangeReq)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 itemid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BlessGiftExchangeReq* default_instance_;
};
// -------------------------------------------------------------------

class BlessGiftExchangeRes : public ::google::protobuf::Message {
 public:
  BlessGiftExchangeRes();
  virtual ~BlessGiftExchangeRes();

  BlessGiftExchangeRes(const BlessGiftExchangeRes& from);

  inline BlessGiftExchangeRes& operator=(const BlessGiftExchangeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BlessGiftExchangeRes& default_instance();

  void Swap(BlessGiftExchangeRes* other);

  // implements Message ----------------------------------------------

  BlessGiftExchangeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.BlessGiftInfo item = 1;
  inline bool has_item() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::pp::BlessGiftInfo& item() const;
  inline ::pp::BlessGiftInfo* mutable_item();
  inline ::pp::BlessGiftInfo* release_item();
  inline void set_allocated_item(::pp::BlessGiftInfo* item);

  // @@protoc_insertion_point(class_scope:pp.BlessGiftExchangeRes)
 private:
  inline void set_has_item();
  inline void clear_has_item();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::BlessGiftInfo* item_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BlessGiftExchangeRes* default_instance_;
};
// -------------------------------------------------------------------

class ReportViolatorReq : public ::google::protobuf::Message {
 public:
  ReportViolatorReq();
  virtual ~ReportViolatorReq();

  ReportViolatorReq(const ReportViolatorReq& from);

  inline ReportViolatorReq& operator=(const ReportViolatorReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportViolatorReq& default_instance();

  void Swap(ReportViolatorReq* other);

  // implements Message ----------------------------------------------

  ReportViolatorReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ReportViolatorReq_ViolatorType ViolatorType;
  static const ViolatorType ViolatorTypeUser = ReportViolatorReq_ViolatorType_ViolatorTypeUser;
  static const ViolatorType ViolatorTypeTopic = ReportViolatorReq_ViolatorType_ViolatorTypeTopic;
  static inline bool ViolatorType_IsValid(int value) {
    return ReportViolatorReq_ViolatorType_IsValid(value);
  }
  static const ViolatorType ViolatorType_MIN =
    ReportViolatorReq_ViolatorType_ViolatorType_MIN;
  static const ViolatorType ViolatorType_MAX =
    ReportViolatorReq_ViolatorType_ViolatorType_MAX;
  static const int ViolatorType_ARRAYSIZE =
    ReportViolatorReq_ViolatorType_ViolatorType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViolatorType_descriptor() {
    return ReportViolatorReq_ViolatorType_descriptor();
  }
  static inline const ::std::string& ViolatorType_Name(ViolatorType value) {
    return ReportViolatorReq_ViolatorType_Name(value);
  }
  static inline bool ViolatorType_Parse(const ::std::string& name,
      ViolatorType* value) {
    return ReportViolatorReq_ViolatorType_Parse(name, value);
  }

  typedef ReportViolatorReq_ViolatorReason ViolatorReason;
  static const ViolatorReason ViolatorReasonAdvertisement = ReportViolatorReq_ViolatorReason_ViolatorReasonAdvertisement;
  static const ViolatorReason ViolatorReasonHarassment = ReportViolatorReq_ViolatorReason_ViolatorReasonHarassment;
  static const ViolatorReason ViolatorReasonSex = ReportViolatorReq_ViolatorReason_ViolatorReasonSex;
  static const ViolatorReason ViolatorReasonPolitical = ReportViolatorReq_ViolatorReason_ViolatorReasonPolitical;
  static const ViolatorReason ViolatorReasonAttack = ReportViolatorReq_ViolatorReason_ViolatorReasonAttack;
  static const ViolatorReason ViolatorReasonPseudo = ReportViolatorReq_ViolatorReason_ViolatorReasonPseudo;
  static const ViolatorReason ViolatorReasonFakeWinning = ReportViolatorReq_ViolatorReason_ViolatorReasonFakeWinning;
  static const ViolatorReason ViolatorReasonOther = ReportViolatorReq_ViolatorReason_ViolatorReasonOther;
  static inline bool ViolatorReason_IsValid(int value) {
    return ReportViolatorReq_ViolatorReason_IsValid(value);
  }
  static const ViolatorReason ViolatorReason_MIN =
    ReportViolatorReq_ViolatorReason_ViolatorReason_MIN;
  static const ViolatorReason ViolatorReason_MAX =
    ReportViolatorReq_ViolatorReason_ViolatorReason_MAX;
  static const int ViolatorReason_ARRAYSIZE =
    ReportViolatorReq_ViolatorReason_ViolatorReason_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ViolatorReason_descriptor() {
    return ReportViolatorReq_ViolatorReason_descriptor();
  }
  static inline const ::std::string& ViolatorReason_Name(ViolatorReason value) {
    return ReportViolatorReq_ViolatorReason_Name(value);
  }
  static inline bool ViolatorReason_Parse(const ::std::string& name,
      ViolatorReason* value) {
    return ReportViolatorReq_ViolatorReason_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .pp.ReportViolatorReq.ViolatorType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pp::ReportViolatorReq_ViolatorType type() const;
  inline void set_type(::pp::ReportViolatorReq_ViolatorType value);

  // required .pp.ReportViolatorReq.ViolatorReason reason = 2;
  inline bool has_reason() const;
  inline void clear_reason();
  static const int kReasonFieldNumber = 2;
  inline ::pp::ReportViolatorReq_ViolatorReason reason() const;
  inline void set_reason(::pp::ReportViolatorReq_ViolatorReason value);

  // optional string remarks = 3;
  inline bool has_remarks() const;
  inline void clear_remarks();
  static const int kRemarksFieldNumber = 3;
  inline const ::std::string& remarks() const;
  inline void set_remarks(const ::std::string& value);
  inline void set_remarks(const char* value);
  inline void set_remarks(const char* value, size_t size);
  inline ::std::string* mutable_remarks();
  inline ::std::string* release_remarks();
  inline void set_allocated_remarks(::std::string* remarks);

  // optional uint64 uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 gid = 5;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 5;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.ReportViolatorReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_reason();
  inline void clear_has_reason();
  inline void set_has_remarks();
  inline void clear_has_remarks();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  int reason_;
  ::std::string* remarks_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 gid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ReportViolatorReq* default_instance_;
};
// -------------------------------------------------------------------

class ReportLogReq : public ::google::protobuf::Message {
 public:
  ReportLogReq();
  virtual ~ReportLogReq();

  ReportLogReq(const ReportLogReq& from);

  inline ReportLogReq& operator=(const ReportLogReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportLogReq& default_instance();

  void Swap(ReportLogReq* other);

  // implements Message ----------------------------------------------

  ReportLogReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string report = 1;
  inline bool has_report() const;
  inline void clear_report();
  static const int kReportFieldNumber = 1;
  inline const ::std::string& report() const;
  inline void set_report(const ::std::string& value);
  inline void set_report(const char* value);
  inline void set_report(const char* value, size_t size);
  inline ::std::string* mutable_report();
  inline ::std::string* release_report();
  inline void set_allocated_report(::std::string* report);

  // @@protoc_insertion_point(class_scope:pp.ReportLogReq)
 private:
  inline void set_has_report();
  inline void clear_has_report();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* report_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ReportLogReq* default_instance_;
};
// -------------------------------------------------------------------

class ProductInfo : public ::google::protobuf::Message {
 public:
  ProductInfo();
  virtual ~ProductInfo();

  ProductInfo(const ProductInfo& from);

  inline ProductInfo& operator=(const ProductInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductInfo& default_instance();

  void Swap(ProductInfo* other);

  // implements Message ----------------------------------------------

  ProductInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProductInfo_Type Type;
  static const Type Normal = ProductInfo_Type_Normal;
  static const Type Coins = ProductInfo_Type_Coins;
  static inline bool Type_IsValid(int value) {
    return ProductInfo_Type_IsValid(value);
  }
  static const Type Type_MIN =
    ProductInfo_Type_Type_MIN;
  static const Type Type_MAX =
    ProductInfo_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    ProductInfo_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return ProductInfo_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return ProductInfo_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return ProductInfo_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required uint32 Id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string image = 3;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 3;
  inline const ::std::string& image() const;
  inline void set_image(const ::std::string& value);
  inline void set_image(const char* value);
  inline void set_image(const char* value, size_t size);
  inline ::std::string* mutable_image();
  inline ::std::string* release_image();
  inline void set_allocated_image(::std::string* image);

  // optional uint32 price = 4;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 4;
  inline ::google::protobuf::uint32 price() const;
  inline void set_price(::google::protobuf::uint32 value);

  // optional uint32 num = 5;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 5;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional sint64 createTime = 6;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional uint32 total = 7;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 7;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional bool available = 8 [default = true];
  inline bool has_available() const;
  inline void clear_available();
  static const int kAvailableFieldNumber = 8;
  inline bool available() const;
  inline void set_available(bool value);

  // optional .pp.ProductInfo.Type type = 9;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 9;
  inline ::pp::ProductInfo_Type type() const;
  inline void set_type(::pp::ProductInfo_Type value);

  // optional uint32 prob = 10;
  inline bool has_prob() const;
  inline void clear_prob();
  static const int kProbFieldNumber = 10;
  inline ::google::protobuf::uint32 prob() const;
  inline void set_prob(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ProductInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_available();
  inline void clear_has_available();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_prob();
  inline void clear_has_prob();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 price_;
  ::std::string* image_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 total_;
  bool available_;
  int type_;
  ::google::protobuf::uint32 prob_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ProductInfo* default_instance_;
};
// -------------------------------------------------------------------

class ProductListReq : public ::google::protobuf::Message {
 public:
  ProductListReq();
  virtual ~ProductListReq();

  ProductListReq(const ProductListReq& from);

  inline ProductListReq& operator=(const ProductListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductListReq& default_instance();

  void Swap(ProductListReq* other);

  // implements Message ----------------------------------------------

  ProductListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional bool backend = 3 [default = false];
  inline bool has_backend() const;
  inline void clear_backend();
  static const int kBackendFieldNumber = 3;
  inline bool backend() const;
  inline void set_backend(bool value);

  // @@protoc_insertion_point(class_scope:pp.ProductListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_backend();
  inline void clear_has_backend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  bool backend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ProductListReq* default_instance_;
};
// -------------------------------------------------------------------

class ProductListRes : public ::google::protobuf::Message {
 public:
  ProductListRes();
  virtual ~ProductListRes();

  ProductListRes(const ProductListRes& from);

  inline ProductListRes& operator=(const ProductListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductListRes& default_instance();

  void Swap(ProductListRes* other);

  // implements Message ----------------------------------------------

  ProductListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.ProductInfo products = 3;
  inline int products_size() const;
  inline void clear_products();
  static const int kProductsFieldNumber = 3;
  inline const ::pp::ProductInfo& products(int index) const;
  inline ::pp::ProductInfo* mutable_products(int index);
  inline ::pp::ProductInfo* add_products();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ProductInfo >&
      products() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ProductInfo >*
      mutable_products();

  // @@protoc_insertion_point(class_scope:pp.ProductListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::ProductInfo > products_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ProductListRes* default_instance_;
};
// -------------------------------------------------------------------

class ProductOpReq : public ::google::protobuf::Message {
 public:
  ProductOpReq();
  virtual ~ProductOpReq();

  ProductOpReq(const ProductOpReq& from);

  inline ProductOpReq& operator=(const ProductOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductOpReq& default_instance();

  void Swap(ProductOpReq* other);

  // implements Message ----------------------------------------------

  ProductOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.EntityOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // optional .pp.ProductInfo entity = 2;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::pp::ProductInfo& entity() const;
  inline ::pp::ProductInfo* mutable_entity();
  inline ::pp::ProductInfo* release_entity();
  inline void set_allocated_entity(::pp::ProductInfo* entity);

  // @@protoc_insertion_point(class_scope:pp.ProductOpReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_entity();
  inline void clear_has_entity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::ProductInfo* entity_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ProductOpReq* default_instance_;
};
// -------------------------------------------------------------------

class ProductBuyReq : public ::google::protobuf::Message {
 public:
  ProductBuyReq();
  virtual ~ProductBuyReq();

  ProductBuyReq(const ProductBuyReq& from);

  inline ProductBuyReq& operator=(const ProductBuyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProductBuyReq& default_instance();

  void Swap(ProductBuyReq* other);

  // implements Message ----------------------------------------------

  ProductBuyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 productId = 1;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 1;
  inline ::google::protobuf::uint32 productid() const;
  inline void set_productid(::google::protobuf::uint32 value);

  // optional uint32 num = 2 [default = 1];
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ProductBuyReq)
 private:
  inline void set_has_productid();
  inline void clear_has_productid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 productid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ProductBuyReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTradeRecord : public ::google::protobuf::Message {
 public:
  UserTradeRecord();
  virtual ~UserTradeRecord();

  UserTradeRecord(const UserTradeRecord& from);

  inline UserTradeRecord& operator=(const UserTradeRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTradeRecord& default_instance();

  void Swap(UserTradeRecord* other);

  // implements Message ----------------------------------------------

  UserTradeRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserTradeRecord_Type Type;
  static const Type GiftReceive = UserTradeRecord_Type_GiftReceive;
  static const Type ProductPurchase = UserTradeRecord_Type_ProductPurchase;
  static const Type Withdraw = UserTradeRecord_Type_Withdraw;
  static const Type WithdrawBaby = UserTradeRecord_Type_WithdrawBaby;
  static const Type GiftForLottery = UserTradeRecord_Type_GiftForLottery;
  static const Type ProductFromLottery = UserTradeRecord_Type_ProductFromLottery;
  static inline bool Type_IsValid(int value) {
    return UserTradeRecord_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UserTradeRecord_Type_Type_MIN;
  static const Type Type_MAX =
    UserTradeRecord_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UserTradeRecord_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return UserTradeRecord_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return UserTradeRecord_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return UserTradeRecord_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint64 itemid() const;
  inline void set_itemid(::google::protobuf::uint64 value);

  // optional uint32 itemNum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 itemnum() const;
  inline void set_itemnum(::google::protobuf::uint32 value);

  // optional .pp.UserTradeRecord.Type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::pp::UserTradeRecord_Type type() const;
  inline void set_type(::pp::UserTradeRecord_Type value);

  // optional sint32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::int32 money() const;
  inline void set_money(::google::protobuf::int32 value);

  // optional uint64 targetUid = 5;
  inline bool has_targetuid() const;
  inline void clear_targetuid();
  static const int kTargetUidFieldNumber = 5;
  inline ::google::protobuf::uint64 targetuid() const;
  inline void set_targetuid(::google::protobuf::uint64 value);

  // optional sint64 createTime = 6;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserTradeRecord)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_targetuid();
  inline void clear_has_targetuid();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 itemid_;
  ::google::protobuf::uint32 itemnum_;
  int type_;
  ::google::protobuf::uint64 targetuid_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::int32 money_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTradeRecord* default_instance_;
};
// -------------------------------------------------------------------

class UserWithdrawReq : public ::google::protobuf::Message {
 public:
  UserWithdrawReq();
  virtual ~UserWithdrawReq();

  UserWithdrawReq(const UserWithdrawReq& from);

  inline UserWithdrawReq& operator=(const UserWithdrawReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserWithdrawReq& default_instance();

  void Swap(UserWithdrawReq* other);

  // implements Message ----------------------------------------------

  UserWithdrawReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 cash = 1;
  inline bool has_cash() const;
  inline void clear_cash();
  static const int kCashFieldNumber = 1;
  inline ::google::protobuf::uint32 cash() const;
  inline void set_cash(::google::protobuf::uint32 value);

  // optional bool check = 2 [default = true];
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 2;
  inline bool check() const;
  inline void set_check(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserWithdrawReq)
 private:
  inline void set_has_cash();
  inline void clear_has_cash();
  inline void set_has_check();
  inline void clear_has_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 cash_;
  bool check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserWithdrawReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMoneyStatReq : public ::google::protobuf::Message {
 public:
  UserMoneyStatReq();
  virtual ~UserMoneyStatReq();

  UserMoneyStatReq(const UserMoneyStatReq& from);

  inline UserMoneyStatReq& operator=(const UserMoneyStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMoneyStatReq& default_instance();

  void Swap(UserMoneyStatReq* other);

  // implements Message ----------------------------------------------

  UserMoneyStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserMoneyStatReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMoneyStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMoneyStatRes : public ::google::protobuf::Message {
 public:
  UserMoneyStatRes();
  virtual ~UserMoneyStatRes();

  UserMoneyStatRes(const UserMoneyStatRes& from);

  inline UserMoneyStatRes& operator=(const UserMoneyStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMoneyStatRes& default_instance();

  void Swap(UserMoneyStatRes* other);

  // implements Message ----------------------------------------------

  UserMoneyStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 sysWithdrawTimes = 1;
  inline bool has_syswithdrawtimes() const;
  inline void clear_syswithdrawtimes();
  static const int kSysWithdrawTimesFieldNumber = 1;
  inline ::google::protobuf::uint32 syswithdrawtimes() const;
  inline void set_syswithdrawtimes(::google::protobuf::uint32 value);

  // optional uint32 totalMoney = 2;
  inline bool has_totalmoney() const;
  inline void clear_totalmoney();
  static const int kTotalMoneyFieldNumber = 2;
  inline ::google::protobuf::uint32 totalmoney() const;
  inline void set_totalmoney(::google::protobuf::uint32 value);

  // optional uint32 lastMonthMoney = 3;
  inline bool has_lastmonthmoney() const;
  inline void clear_lastmonthmoney();
  static const int kLastMonthMoneyFieldNumber = 3;
  inline ::google::protobuf::uint32 lastmonthmoney() const;
  inline void set_lastmonthmoney(::google::protobuf::uint32 value);

  // optional uint32 thisMonthMoney = 4;
  inline bool has_thismonthmoney() const;
  inline void clear_thismonthmoney();
  static const int kThisMonthMoneyFieldNumber = 4;
  inline ::google::protobuf::uint32 thismonthmoney() const;
  inline void set_thismonthmoney(::google::protobuf::uint32 value);

  // optional uint32 cashAvailable = 5;
  inline bool has_cashavailable() const;
  inline void clear_cashavailable();
  static const int kCashAvailableFieldNumber = 5;
  inline ::google::protobuf::uint32 cashavailable() const;
  inline void set_cashavailable(::google::protobuf::uint32 value);

  // optional uint32 totalWithdraw = 6;
  inline bool has_totalwithdraw() const;
  inline void clear_totalwithdraw();
  static const int kTotalWithdrawFieldNumber = 6;
  inline ::google::protobuf::uint32 totalwithdraw() const;
  inline void set_totalwithdraw(::google::protobuf::uint32 value);

  // optional bool isbaby = 7;
  inline bool has_isbaby() const;
  inline void clear_isbaby();
  static const int kIsbabyFieldNumber = 7;
  inline bool isbaby() const;
  inline void set_isbaby(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserMoneyStatRes)
 private:
  inline void set_has_syswithdrawtimes();
  inline void clear_has_syswithdrawtimes();
  inline void set_has_totalmoney();
  inline void clear_has_totalmoney();
  inline void set_has_lastmonthmoney();
  inline void clear_has_lastmonthmoney();
  inline void set_has_thismonthmoney();
  inline void clear_has_thismonthmoney();
  inline void set_has_cashavailable();
  inline void clear_has_cashavailable();
  inline void set_has_totalwithdraw();
  inline void clear_has_totalwithdraw();
  inline void set_has_isbaby();
  inline void clear_has_isbaby();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 syswithdrawtimes_;
  ::google::protobuf::uint32 totalmoney_;
  ::google::protobuf::uint32 lastmonthmoney_;
  ::google::protobuf::uint32 thismonthmoney_;
  ::google::protobuf::uint32 cashavailable_;
  ::google::protobuf::uint32 totalwithdraw_;
  bool isbaby_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMoneyStatRes* default_instance_;
};
// -------------------------------------------------------------------

class UserBankInfo : public ::google::protobuf::Message {
 public:
  UserBankInfo();
  virtual ~UserBankInfo();

  UserBankInfo(const UserBankInfo& from);

  inline UserBankInfo& operator=(const UserBankInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBankInfo& default_instance();

  void Swap(UserBankInfo* other);

  // implements Message ----------------------------------------------

  UserBankInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::uint64 id() const;
  inline void set_id(::google::protobuf::uint64 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string idcode = 4;
  inline bool has_idcode() const;
  inline void clear_idcode();
  static const int kIdcodeFieldNumber = 4;
  inline const ::std::string& idcode() const;
  inline void set_idcode(const ::std::string& value);
  inline void set_idcode(const char* value);
  inline void set_idcode(const char* value, size_t size);
  inline ::std::string* mutable_idcode();
  inline ::std::string* release_idcode();
  inline void set_allocated_idcode(::std::string* idcode);

  // optional string sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline const ::std::string& sex() const;
  inline void set_sex(const ::std::string& value);
  inline void set_sex(const char* value);
  inline void set_sex(const char* value, size_t size);
  inline ::std::string* mutable_sex();
  inline ::std::string* release_sex();
  inline void set_allocated_sex(::std::string* sex);

  // optional string city = 6;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 6;
  inline const ::std::string& city() const;
  inline void set_city(const ::std::string& value);
  inline void set_city(const char* value);
  inline void set_city(const char* value, size_t size);
  inline ::std::string* mutable_city();
  inline ::std::string* release_city();
  inline void set_allocated_city(::std::string* city);

  // optional string bankName = 7;
  inline bool has_bankname() const;
  inline void clear_bankname();
  static const int kBankNameFieldNumber = 7;
  inline const ::std::string& bankname() const;
  inline void set_bankname(const ::std::string& value);
  inline void set_bankname(const char* value);
  inline void set_bankname(const char* value, size_t size);
  inline ::std::string* mutable_bankname();
  inline ::std::string* release_bankname();
  inline void set_allocated_bankname(::std::string* bankname);

  // optional string accountNo = 8;
  inline bool has_accountno() const;
  inline void clear_accountno();
  static const int kAccountNoFieldNumber = 8;
  inline const ::std::string& accountno() const;
  inline void set_accountno(const ::std::string& value);
  inline void set_accountno(const char* value);
  inline void set_accountno(const char* value, size_t size);
  inline ::std::string* mutable_accountno();
  inline ::std::string* release_accountno();
  inline void set_allocated_accountno(::std::string* accountno);

  // optional string mobile = 9;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 9;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // @@protoc_insertion_point(class_scope:pp.UserBankInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_idcode();
  inline void clear_has_idcode();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_bankname();
  inline void clear_has_bankname();
  inline void set_has_accountno();
  inline void clear_has_accountno();
  inline void set_has_mobile();
  inline void clear_has_mobile();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 id_;
  ::std::string* name_;
  ::std::string* idcode_;
  ::std::string* sex_;
  ::std::string* city_;
  ::std::string* bankname_;
  ::std::string* accountno_;
  ::std::string* mobile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserBankInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserBankInfoOpReq : public ::google::protobuf::Message {
 public:
  UserBankInfoOpReq();
  virtual ~UserBankInfoOpReq();

  UserBankInfoOpReq(const UserBankInfoOpReq& from);

  inline UserBankInfoOpReq& operator=(const UserBankInfoOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBankInfoOpReq& default_instance();

  void Swap(UserBankInfoOpReq* other);

  // implements Message ----------------------------------------------

  UserBankInfoOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.EntityOpType opType = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // optional .pp.UserBankInfo entity = 2;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::pp::UserBankInfo& entity() const;
  inline ::pp::UserBankInfo* mutable_entity();
  inline ::pp::UserBankInfo* release_entity();
  inline void set_allocated_entity(::pp::UserBankInfo* entity);

  // @@protoc_insertion_point(class_scope:pp.UserBankInfoOpReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_entity();
  inline void clear_has_entity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserBankInfo* entity_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserBankInfoOpReq* default_instance_;
};
// -------------------------------------------------------------------

class UserBankInfoOpRes : public ::google::protobuf::Message {
 public:
  UserBankInfoOpRes();
  virtual ~UserBankInfoOpRes();

  UserBankInfoOpRes(const UserBankInfoOpRes& from);

  inline UserBankInfoOpRes& operator=(const UserBankInfoOpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserBankInfoOpRes& default_instance();

  void Swap(UserBankInfoOpRes* other);

  // implements Message ----------------------------------------------

  UserBankInfoOpRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserBankInfo entity = 1;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 1;
  inline const ::pp::UserBankInfo& entity() const;
  inline ::pp::UserBankInfo* mutable_entity();
  inline ::pp::UserBankInfo* release_entity();
  inline void set_allocated_entity(::pp::UserBankInfo* entity);

  // @@protoc_insertion_point(class_scope:pp.UserBankInfoOpRes)
 private:
  inline void set_has_entity();
  inline void clear_has_entity();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserBankInfo* entity_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserBankInfoOpRes* default_instance_;
};
// -------------------------------------------------------------------

class BankListReq : public ::google::protobuf::Message {
 public:
  BankListReq();
  virtual ~BankListReq();

  BankListReq(const BankListReq& from);

  inline BankListReq& operator=(const BankListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankListReq& default_instance();

  void Swap(BankListReq* other);

  // implements Message ----------------------------------------------

  BankListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string banktype = 1;
  inline bool has_banktype() const;
  inline void clear_banktype();
  static const int kBanktypeFieldNumber = 1;
  inline const ::std::string& banktype() const;
  inline void set_banktype(const ::std::string& value);
  inline void set_banktype(const char* value);
  inline void set_banktype(const char* value, size_t size);
  inline ::std::string* mutable_banktype();
  inline ::std::string* release_banktype();
  inline void set_allocated_banktype(::std::string* banktype);

  // required uint32 province = 2;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 2;
  inline ::google::protobuf::uint32 province() const;
  inline void set_province(::google::protobuf::uint32 value);

  // optional uint32 city = 3;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 3;
  inline ::google::protobuf::uint32 city() const;
  inline void set_city(::google::protobuf::uint32 value);

  // optional uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 5;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 5;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.BankListReq)
 private:
  inline void set_has_banktype();
  inline void clear_has_banktype();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* banktype_;
  ::google::protobuf::uint32 province_;
  ::google::protobuf::uint32 city_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BankListReq* default_instance_;
};
// -------------------------------------------------------------------

class BankListRes : public ::google::protobuf::Message {
 public:
  BankListRes();
  virtual ~BankListRes();

  BankListRes(const BankListRes& from);

  inline BankListRes& operator=(const BankListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BankListRes& default_instance();

  void Swap(BankListRes* other);

  // implements Message ----------------------------------------------

  BankListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string banktype = 1;
  inline bool has_banktype() const;
  inline void clear_banktype();
  static const int kBanktypeFieldNumber = 1;
  inline const ::std::string& banktype() const;
  inline void set_banktype(const ::std::string& value);
  inline void set_banktype(const char* value);
  inline void set_banktype(const char* value, size_t size);
  inline ::std::string* mutable_banktype();
  inline ::std::string* release_banktype();
  inline void set_allocated_banktype(::std::string* banktype);

  // required uint32 province = 2;
  inline bool has_province() const;
  inline void clear_province();
  static const int kProvinceFieldNumber = 2;
  inline ::google::protobuf::uint32 province() const;
  inline void set_province(::google::protobuf::uint32 value);

  // optional uint32 city = 3;
  inline bool has_city() const;
  inline void clear_city();
  static const int kCityFieldNumber = 3;
  inline ::google::protobuf::uint32 city() const;
  inline void set_city(::google::protobuf::uint32 value);

  // optional uint32 index = 4;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 4;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 5;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 5;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // repeated string items = 6;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 6;
  inline const ::std::string& items(int index) const;
  inline ::std::string* mutable_items(int index);
  inline void set_items(int index, const ::std::string& value);
  inline void set_items(int index, const char* value);
  inline void set_items(int index, const char* value, size_t size);
  inline ::std::string* add_items();
  inline void add_items(const ::std::string& value);
  inline void add_items(const char* value);
  inline void add_items(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& items() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_items();

  // optional uint32 totalresults = 7;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 7;
  inline ::google::protobuf::uint32 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.BankListRes)
 private:
  inline void set_has_banktype();
  inline void clear_has_banktype();
  inline void set_has_province();
  inline void clear_has_province();
  inline void set_has_city();
  inline void clear_has_city();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* banktype_;
  ::google::protobuf::uint32 province_;
  ::google::protobuf::uint32 city_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::RepeatedPtrField< ::std::string> items_;
  ::google::protobuf::uint32 totalresults_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BankListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserCoinRecord : public ::google::protobuf::Message {
 public:
  UserCoinRecord();
  virtual ~UserCoinRecord();

  UserCoinRecord(const UserCoinRecord& from);

  inline UserCoinRecord& operator=(const UserCoinRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCoinRecord& default_instance();

  void Swap(UserCoinRecord* other);

  // implements Message ----------------------------------------------

  UserCoinRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserCoinRecord_Type Type;
  static const Type Unknown = UserCoinRecord_Type_Unknown;
  static const Type Newbie_Signature = UserCoinRecord_Type_Newbie_Signature;
  static const Type Newbie_ImageLike5 = UserCoinRecord_Type_Newbie_ImageLike5;
  static const Type Newbie_ImageUpload = UserCoinRecord_Type_Newbie_ImageUpload;
  static const Type Newbie_UserFollow = UserCoinRecord_Type_Newbie_UserFollow;
  static const Type Newbie_GiftDonate = UserCoinRecord_Type_Newbie_GiftDonate;
  static const Type Newbie_AppRate = UserCoinRecord_Type_Newbie_AppRate;
  static const Type Newbie_LogoUpload = UserCoinRecord_Type_Newbie_LogoUpload;
  static const Type Newbie_ShowWatch10D2 = UserCoinRecord_Type_Newbie_ShowWatch10D2;
  static const Type Newbie_NickModify = UserCoinRecord_Type_Newbie_NickModify;
  static const Type Threshold = UserCoinRecord_Type_Threshold;
  static const Type Daily_Checkin = UserCoinRecord_Type_Daily_Checkin;
  static const Type Daily_ShowWatch = UserCoinRecord_Type_Daily_ShowWatch;
  static const Type Daily_ShowWatch10 = UserCoinRecord_Type_Daily_ShowWatch10;
  static const Type Daily_ShowWatch30 = UserCoinRecord_Type_Daily_ShowWatch30;
  static const Type Daily_ShowWatch50 = UserCoinRecord_Type_Daily_ShowWatch50;
  static const Type Daily_GiftDonate = UserCoinRecord_Type_Daily_GiftDonate;
  static const Type Daily_GiftDonate5 = UserCoinRecord_Type_Daily_GiftDonate5;
  static const Type Daily_GiftDonate10 = UserCoinRecord_Type_Daily_GiftDonate10;
  static const Type Daily_GiftDonate30 = UserCoinRecord_Type_Daily_GiftDonate30;
  static const Type Daily_ShowVoice5 = UserCoinRecord_Type_Daily_ShowVoice5;
  static const Type Daily_ShowVideo = UserCoinRecord_Type_Daily_ShowVideo;
  static const Type Daily_PublicShowSpeak = UserCoinRecord_Type_Daily_PublicShowSpeak;
  static const Type Daily_UserFollowed10 = UserCoinRecord_Type_Daily_UserFollowed10;
  static const Type Daily_ReceiveGift10 = UserCoinRecord_Type_Daily_ReceiveGift10;
  static const Type Daily_ShowShare = UserCoinRecord_Type_Daily_ShowShare;
  static const Type Daily_RefererAdd = UserCoinRecord_Type_Daily_RefererAdd;
  static const Type Shop10PercentAward = UserCoinRecord_Type_Shop10PercentAward;
  static const Type Shop05PercentAward = UserCoinRecord_Type_Shop05PercentAward;
  static const Type ShopPurchase = UserCoinRecord_Type_ShopPurchase;
  static const Type CompanyAward = UserCoinRecord_Type_CompanyAward;
  static const Type ProductTrade = UserCoinRecord_Type_ProductTrade;
  static const Type YYGiftHitAward = UserCoinRecord_Type_YYGiftHitAward;
  static const Type ChrisLottery = UserCoinRecord_Type_ChrisLottery;
  static const Type MarryAward = UserCoinRecord_Type_MarryAward;
  static const Type RedPacketAward = UserCoinRecord_Type_RedPacketAward;
  static const Type RedPacketBlessGiftAward = UserCoinRecord_Type_RedPacketBlessGiftAward;
  static const Type ProductCoinExchange = UserCoinRecord_Type_ProductCoinExchange;
  static const Type RefereeAward = UserCoinRecord_Type_RefereeAward;
  static const Type RefererAward = UserCoinRecord_Type_RefererAward;
  static const Type ActLuckyAward = UserCoinRecord_Type_ActLuckyAward;
  static const Type ShowGameAward = UserCoinRecord_Type_ShowGameAward;
  static const Type GiftDonate = UserCoinRecord_Type_GiftDonate;
  static const Type MessageTop = UserCoinRecord_Type_MessageTop;
  static const Type FamilyCreate = UserCoinRecord_Type_FamilyCreate;
  static const Type RedPacketCreate = UserCoinRecord_Type_RedPacketCreate;
  static const Type HallShare = UserCoinRecord_Type_HallShare;
  static const Type NationalDayAuction = UserCoinRecord_Type_NationalDayAuction;
  static inline bool Type_IsValid(int value) {
    return UserCoinRecord_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UserCoinRecord_Type_Type_MIN;
  static const Type Type_MAX =
    UserCoinRecord_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UserCoinRecord_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return UserCoinRecord_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return UserCoinRecord_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return UserCoinRecord_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint64 itemId = 1;
  inline bool has_itemid() const;
  inline void clear_itemid();
  static const int kItemIdFieldNumber = 1;
  inline ::google::protobuf::uint64 itemid() const;
  inline void set_itemid(::google::protobuf::uint64 value);

  // optional uint32 itemNum = 2;
  inline bool has_itemnum() const;
  inline void clear_itemnum();
  static const int kItemNumFieldNumber = 2;
  inline ::google::protobuf::uint32 itemnum() const;
  inline void set_itemnum(::google::protobuf::uint32 value);

  // optional .pp.UserCoinRecord.Type type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::pp::UserCoinRecord_Type type() const;
  inline void set_type(::pp::UserCoinRecord_Type value);

  // optional sint32 coins = 4;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 4;
  inline ::google::protobuf::int32 coins() const;
  inline void set_coins(::google::protobuf::int32 value);

  // optional uint64 targetUid = 5;
  inline bool has_targetuid() const;
  inline void clear_targetuid();
  static const int kTargetUidFieldNumber = 5;
  inline ::google::protobuf::uint64 targetuid() const;
  inline void set_targetuid(::google::protobuf::uint64 value);

  // optional sint64 createTime = 6;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 6;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserCoinRecord)
 private:
  inline void set_has_itemid();
  inline void clear_has_itemid();
  inline void set_has_itemnum();
  inline void clear_has_itemnum();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_targetuid();
  inline void clear_has_targetuid();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 itemid_;
  ::google::protobuf::uint32 itemnum_;
  int type_;
  ::google::protobuf::uint64 targetuid_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::int32 coins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserCoinRecord* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftInfo : public ::google::protobuf::Message {
 public:
  YYGiftInfo();
  virtual ~YYGiftInfo();

  YYGiftInfo(const YYGiftInfo& from);

  inline YYGiftInfo& operator=(const YYGiftInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftInfo& default_instance();

  void Swap(YYGiftInfo* other);

  // implements Message ----------------------------------------------

  YYGiftInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional float price = 3;
  inline bool has_price() const;
  inline void clear_price();
  static const int kPriceFieldNumber = 3;
  inline float price() const;
  inline void set_price(float value);

  // optional uint32 position = 4;
  inline bool has_position() const;
  inline void clear_position();
  static const int kPositionFieldNumber = 4;
  inline ::google::protobuf::uint32 position() const;
  inline void set_position(::google::protobuf::uint32 value);

  // optional string thumbnailUrl = 6;
  inline bool has_thumbnailurl() const;
  inline void clear_thumbnailurl();
  static const int kThumbnailUrlFieldNumber = 6;
  inline const ::std::string& thumbnailurl() const;
  inline void set_thumbnailurl(const ::std::string& value);
  inline void set_thumbnailurl(const char* value);
  inline void set_thumbnailurl(const char* value, size_t size);
  inline ::std::string* mutable_thumbnailurl();
  inline ::std::string* release_thumbnailurl();
  inline void set_allocated_thumbnailurl(::std::string* thumbnailurl);

  // optional string normalUrl = 7;
  inline bool has_normalurl() const;
  inline void clear_normalurl();
  static const int kNormalUrlFieldNumber = 7;
  inline const ::std::string& normalurl() const;
  inline void set_normalurl(const ::std::string& value);
  inline void set_normalurl(const char* value);
  inline void set_normalurl(const char* value, size_t size);
  inline ::std::string* mutable_normalurl();
  inline ::std::string* release_normalurl();
  inline void set_allocated_normalurl(::std::string* normalurl);

  // optional string dynamicUrl = 8;
  inline bool has_dynamicurl() const;
  inline void clear_dynamicurl();
  static const int kDynamicUrlFieldNumber = 8;
  inline const ::std::string& dynamicurl() const;
  inline void set_dynamicurl(const ::std::string& value);
  inline void set_dynamicurl(const char* value);
  inline void set_dynamicurl(const char* value, size_t size);
  inline ::std::string* mutable_dynamicurl();
  inline ::std::string* release_dynamicurl();
  inline void set_allocated_dynamicurl(::std::string* dynamicurl);

  // optional string description = 9;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 9;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional string extJson = 10;
  inline bool has_extjson() const;
  inline void clear_extjson();
  static const int kExtJsonFieldNumber = 10;
  inline const ::std::string& extjson() const;
  inline void set_extjson(const ::std::string& value);
  inline void set_extjson(const char* value);
  inline void set_extjson(const char* value, size_t size);
  inline ::std::string* mutable_extjson();
  inline ::std::string* release_extjson();
  inline void set_allocated_extjson(::std::string* extjson);

  // @@protoc_insertion_point(class_scope:pp.YYGiftInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_price();
  inline void clear_has_price();
  inline void set_has_position();
  inline void clear_has_position();
  inline void set_has_thumbnailurl();
  inline void clear_has_thumbnailurl();
  inline void set_has_normalurl();
  inline void clear_has_normalurl();
  inline void set_has_dynamicurl();
  inline void clear_has_dynamicurl();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_extjson();
  inline void clear_has_extjson();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* id_;
  ::std::string* name_;
  float price_;
  ::google::protobuf::uint32 position_;
  ::std::string* thumbnailurl_;
  ::std::string* normalurl_;
  ::std::string* dynamicurl_;
  ::std::string* description_;
  ::std::string* extjson_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftInfo* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftListReq : public ::google::protobuf::Message {
 public:
  YYGiftListReq();
  virtual ~YYGiftListReq();

  YYGiftListReq(const YYGiftListReq& from);

  inline YYGiftListReq& operator=(const YYGiftListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftListReq& default_instance();

  void Swap(YYGiftListReq* other);

  // implements Message ----------------------------------------------

  YYGiftListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.YYGiftListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftListReq* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftListRes : public ::google::protobuf::Message {
 public:
  YYGiftListRes();
  virtual ~YYGiftListRes();

  YYGiftListRes(const YYGiftListRes& from);

  inline YYGiftListRes& operator=(const YYGiftListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftListRes& default_instance();

  void Swap(YYGiftListRes* other);

  // implements Message ----------------------------------------------

  YYGiftListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.YYGiftInfo yygifts = 3;
  inline int yygifts_size() const;
  inline void clear_yygifts();
  static const int kYygiftsFieldNumber = 3;
  inline const ::pp::YYGiftInfo& yygifts(int index) const;
  inline ::pp::YYGiftInfo* mutable_yygifts(int index);
  inline ::pp::YYGiftInfo* add_yygifts();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::YYGiftInfo >&
      yygifts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::YYGiftInfo >*
      mutable_yygifts();

  // optional uint64 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.YYGiftListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::YYGiftInfo > yygifts_;
  ::google::protobuf::uint64 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftListRes* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftDonateReq : public ::google::protobuf::Message {
 public:
  YYGiftDonateReq();
  virtual ~YYGiftDonateReq();

  YYGiftDonateReq(const YYGiftDonateReq& from);

  inline YYGiftDonateReq& operator=(const YYGiftDonateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftDonateReq& default_instance();

  void Swap(YYGiftDonateReq* other);

  // implements Message ----------------------------------------------

  YYGiftDonateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 touid = 1;
  inline bool has_touid() const;
  inline void clear_touid();
  static const int kTouidFieldNumber = 1;
  inline ::google::protobuf::uint64 touid() const;
  inline void set_touid(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional string giftId = 3;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 3;
  inline const ::std::string& giftid() const;
  inline void set_giftid(const ::std::string& value);
  inline void set_giftid(const char* value);
  inline void set_giftid(const char* value, size_t size);
  inline ::std::string* mutable_giftid();
  inline ::std::string* release_giftid();
  inline void set_allocated_giftid(::std::string* giftid);

  // optional uint32 num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.YYGiftDonateReq)
 private:
  inline void set_has_touid();
  inline void clear_has_touid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_num();
  inline void clear_has_num();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 touid_;
  ::google::protobuf::uint64 gid_;
  ::std::string* giftid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftDonateReq* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftDonateRes : public ::google::protobuf::Message {
 public:
  YYGiftDonateRes();
  virtual ~YYGiftDonateRes();

  YYGiftDonateRes(const YYGiftDonateRes& from);

  inline YYGiftDonateRes& operator=(const YYGiftDonateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftDonateRes& default_instance();

  void Swap(YYGiftDonateRes* other);

  // implements Message ----------------------------------------------

  YYGiftDonateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 touid = 1;
  inline bool has_touid() const;
  inline void clear_touid();
  static const int kTouidFieldNumber = 1;
  inline ::google::protobuf::uint64 touid() const;
  inline void set_touid(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional string giftId = 3;
  inline bool has_giftid() const;
  inline void clear_giftid();
  static const int kGiftIdFieldNumber = 3;
  inline const ::std::string& giftid() const;
  inline void set_giftid(const ::std::string& value);
  inline void set_giftid(const char* value);
  inline void set_giftid(const char* value, size_t size);
  inline ::std::string* mutable_giftid();
  inline ::std::string* release_giftid();
  inline void set_allocated_giftid(::std::string* giftid);

  // optional uint32 Num = 4;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 4;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional string orderId = 5;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 5;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional string authurl = 6;
  inline bool has_authurl() const;
  inline void clear_authurl();
  static const int kAuthurlFieldNumber = 6;
  inline const ::std::string& authurl() const;
  inline void set_authurl(const ::std::string& value);
  inline void set_authurl(const char* value);
  inline void set_authurl(const char* value, size_t size);
  inline ::std::string* mutable_authurl();
  inline ::std::string* release_authurl();
  inline void set_allocated_authurl(::std::string* authurl);

  // optional int64 sid = 7;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 7;
  inline ::google::protobuf::int64 sid() const;
  inline void set_sid(::google::protobuf::int64 value);

  // optional int64 ssid = 8;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 8;
  inline ::google::protobuf::int64 ssid() const;
  inline void set_ssid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.YYGiftDonateRes)
 private:
  inline void set_has_touid();
  inline void clear_has_touid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_giftid();
  inline void clear_has_giftid();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_authurl();
  inline void clear_has_authurl();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_ssid();
  inline void clear_has_ssid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 touid_;
  ::google::protobuf::uint64 gid_;
  ::std::string* giftid_;
  ::std::string* orderid_;
  ::std::string* authurl_;
  ::google::protobuf::int64 sid_;
  ::google::protobuf::int64 ssid_;
  ::google::protobuf::uint32 num_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftDonateRes* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftPayConfirmReq : public ::google::protobuf::Message {
 public:
  YYGiftPayConfirmReq();
  virtual ~YYGiftPayConfirmReq();

  YYGiftPayConfirmReq(const YYGiftPayConfirmReq& from);

  inline YYGiftPayConfirmReq& operator=(const YYGiftPayConfirmReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftPayConfirmReq& default_instance();

  void Swap(YYGiftPayConfirmReq* other);

  // implements Message ----------------------------------------------

  YYGiftPayConfirmReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string orderId = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional .pp.YYGiftPayConfirmOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::YYGiftPayConfirmOpType optype() const;
  inline void set_optype(::pp::YYGiftPayConfirmOpType value);

  // optional int64 sid = 3;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 3;
  inline ::google::protobuf::int64 sid() const;
  inline void set_sid(::google::protobuf::int64 value);

  // optional int64 ssid = 4;
  inline bool has_ssid() const;
  inline void clear_ssid();
  static const int kSsidFieldNumber = 4;
  inline ::google::protobuf::int64 ssid() const;
  inline void set_ssid(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.YYGiftPayConfirmReq)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_ssid();
  inline void clear_has_ssid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* orderid_;
  ::google::protobuf::int64 sid_;
  ::google::protobuf::int64 ssid_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftPayConfirmReq* default_instance_;
};
// -------------------------------------------------------------------

class YYGiftPayConfirmRes : public ::google::protobuf::Message {
 public:
  YYGiftPayConfirmRes();
  virtual ~YYGiftPayConfirmRes();

  YYGiftPayConfirmRes(const YYGiftPayConfirmRes& from);

  inline YYGiftPayConfirmRes& operator=(const YYGiftPayConfirmRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYGiftPayConfirmRes& default_instance();

  void Swap(YYGiftPayConfirmRes* other);

  // implements Message ----------------------------------------------

  YYGiftPayConfirmRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string orderId = 1;
  inline bool has_orderid() const;
  inline void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  inline const ::std::string& orderid() const;
  inline void set_orderid(const ::std::string& value);
  inline void set_orderid(const char* value);
  inline void set_orderid(const char* value, size_t size);
  inline ::std::string* mutable_orderid();
  inline ::std::string* release_orderid();
  inline void set_allocated_orderid(::std::string* orderid);

  // optional .pp.YYGiftPayConfirmOpType opType = 2;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 2;
  inline ::pp::YYGiftPayConfirmOpType optype() const;
  inline void set_optype(::pp::YYGiftPayConfirmOpType value);

  // @@protoc_insertion_point(class_scope:pp.YYGiftPayConfirmRes)
 private:
  inline void set_has_orderid();
  inline void clear_has_orderid();
  inline void set_has_optype();
  inline void clear_has_optype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* orderid_;
  int optype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYGiftPayConfirmRes* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskState : public ::google::protobuf::Message {
 public:
  UserTaskState();
  virtual ~UserTaskState();

  UserTaskState(const UserTaskState& from);

  inline UserTaskState& operator=(const UserTaskState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskState& default_instance();

  void Swap(UserTaskState* other);

  // implements Message ----------------------------------------------

  UserTaskState* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserTaskState_TaskCategory TaskCategory;
  static const TaskCategory Unknown = UserTaskState_TaskCategory_Unknown;
  static const TaskCategory Newbie = UserTaskState_TaskCategory_Newbie;
  static const TaskCategory Daily = UserTaskState_TaskCategory_Daily;
  static inline bool TaskCategory_IsValid(int value) {
    return UserTaskState_TaskCategory_IsValid(value);
  }
  static const TaskCategory TaskCategory_MIN =
    UserTaskState_TaskCategory_TaskCategory_MIN;
  static const TaskCategory TaskCategory_MAX =
    UserTaskState_TaskCategory_TaskCategory_MAX;
  static const int TaskCategory_ARRAYSIZE =
    UserTaskState_TaskCategory_TaskCategory_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  TaskCategory_descriptor() {
    return UserTaskState_TaskCategory_descriptor();
  }
  static inline const ::std::string& TaskCategory_Name(TaskCategory value) {
    return UserTaskState_TaskCategory_Name(value);
  }
  static inline bool TaskCategory_Parse(const ::std::string& name,
      TaskCategory* value) {
    return UserTaskState_TaskCategory_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional uint32 taskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // optional uint32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::uint32 count() const;
  inline void set_count(::google::protobuf::uint32 value);

  // optional uint32 progress = 3;
  inline bool has_progress() const;
  inline void clear_progress();
  static const int kProgressFieldNumber = 3;
  inline ::google::protobuf::uint32 progress() const;
  inline void set_progress(::google::protobuf::uint32 value);

  // optional bool fetched = 4;
  inline bool has_fetched() const;
  inline void clear_fetched();
  static const int kFetchedFieldNumber = 4;
  inline bool fetched() const;
  inline void set_fetched(bool value);

  // optional uint32 coins = 5;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 5;
  inline ::google::protobuf::uint32 coins() const;
  inline void set_coins(::google::protobuf::uint32 value);

  // optional uint32 experience = 6;
  inline bool has_experience() const;
  inline void clear_experience();
  static const int kExperienceFieldNumber = 6;
  inline ::google::protobuf::uint32 experience() const;
  inline void set_experience(::google::protobuf::uint32 value);

  // optional sint64 updateTime = 7;
  inline bool has_updatetime() const;
  inline void clear_updatetime();
  static const int kUpdateTimeFieldNumber = 7;
  inline ::google::protobuf::int64 updatetime() const;
  inline void set_updatetime(::google::protobuf::int64 value);

  // optional .pp.UserTaskState.TaskCategory taskCat = 8;
  inline bool has_taskcat() const;
  inline void clear_taskcat();
  static const int kTaskCatFieldNumber = 8;
  inline ::pp::UserTaskState_TaskCategory taskcat() const;
  inline void set_taskcat(::pp::UserTaskState_TaskCategory value);

  // optional string text = 9;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 9;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:pp.UserTaskState)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();
  inline void set_has_count();
  inline void clear_has_count();
  inline void set_has_progress();
  inline void clear_has_progress();
  inline void set_has_fetched();
  inline void clear_has_fetched();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_experience();
  inline void clear_has_experience();
  inline void set_has_updatetime();
  inline void clear_has_updatetime();
  inline void set_has_taskcat();
  inline void clear_has_taskcat();
  inline void set_has_text();
  inline void clear_has_text();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tasktype_;
  ::google::protobuf::uint32 count_;
  ::google::protobuf::uint32 progress_;
  bool fetched_;
  ::google::protobuf::uint32 coins_;
  ::google::protobuf::uint32 experience_;
  ::google::protobuf::int64 updatetime_;
  ::std::string* text_;
  int taskcat_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskState* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskStateReq : public ::google::protobuf::Message {
 public:
  UserTaskStateReq();
  virtual ~UserTaskStateReq();

  UserTaskStateReq(const UserTaskStateReq& from);

  inline UserTaskStateReq& operator=(const UserTaskStateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskStateReq& default_instance();

  void Swap(UserTaskStateReq* other);

  // implements Message ----------------------------------------------

  UserTaskStateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserTaskStateReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskStateReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskStateRes : public ::google::protobuf::Message {
 public:
  UserTaskStateRes();
  virtual ~UserTaskStateRes();

  UserTaskStateRes(const UserTaskStateRes& from);

  inline UserTaskStateRes& operator=(const UserTaskStateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskStateRes& default_instance();

  void Swap(UserTaskStateRes* other);

  // implements Message ----------------------------------------------

  UserTaskStateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserTaskState taskStates = 1;
  inline int taskstates_size() const;
  inline void clear_taskstates();
  static const int kTaskStatesFieldNumber = 1;
  inline const ::pp::UserTaskState& taskstates(int index) const;
  inline ::pp::UserTaskState* mutable_taskstates(int index);
  inline ::pp::UserTaskState* add_taskstates();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserTaskState >&
      taskstates() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserTaskState >*
      mutable_taskstates();

  // @@protoc_insertion_point(class_scope:pp.UserTaskStateRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserTaskState > taskstates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskStateRes* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskTakeAwardReq : public ::google::protobuf::Message {
 public:
  UserTaskTakeAwardReq();
  virtual ~UserTaskTakeAwardReq();

  UserTaskTakeAwardReq(const UserTaskTakeAwardReq& from);

  inline UserTaskTakeAwardReq& operator=(const UserTaskTakeAwardReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskTakeAwardReq& default_instance();

  void Swap(UserTaskTakeAwardReq* other);

  // implements Message ----------------------------------------------

  UserTaskTakeAwardReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 taskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserTaskTakeAwardReq)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tasktype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskTakeAwardReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskTakeAwardRes : public ::google::protobuf::Message {
 public:
  UserTaskTakeAwardRes();
  virtual ~UserTaskTakeAwardRes();

  UserTaskTakeAwardRes(const UserTaskTakeAwardRes& from);

  inline UserTaskTakeAwardRes& operator=(const UserTaskTakeAwardRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskTakeAwardRes& default_instance();

  void Swap(UserTaskTakeAwardRes* other);

  // implements Message ----------------------------------------------

  UserTaskTakeAwardRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 taskType = 1;
  inline bool has_tasktype() const;
  inline void clear_tasktype();
  static const int kTaskTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 tasktype() const;
  inline void set_tasktype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserTaskTakeAwardRes)
 private:
  inline void set_has_tasktype();
  inline void clear_has_tasktype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 tasktype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskTakeAwardRes* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskCheckReq : public ::google::protobuf::Message {
 public:
  UserTaskCheckReq();
  virtual ~UserTaskCheckReq();

  UserTaskCheckReq(const UserTaskCheckReq& from);

  inline UserTaskCheckReq& operator=(const UserTaskCheckReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskCheckReq& default_instance();

  void Swap(UserTaskCheckReq* other);

  // implements Message ----------------------------------------------

  UserTaskCheckReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserTaskCheckReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskCheckReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskCheckRes : public ::google::protobuf::Message {
 public:
  UserTaskCheckRes();
  virtual ~UserTaskCheckRes();

  UserTaskCheckRes(const UserTaskCheckRes& from);

  inline UserTaskCheckRes& operator=(const UserTaskCheckRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskCheckRes& default_instance();

  void Swap(UserTaskCheckRes* other);

  // implements Message ----------------------------------------------

  UserTaskCheckRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool newtask = 1;
  inline bool has_newtask() const;
  inline void clear_newtask();
  static const int kNewtaskFieldNumber = 1;
  inline bool newtask() const;
  inline void set_newtask(bool value);

  // optional uint32 leftTask = 2;
  inline bool has_lefttask() const;
  inline void clear_lefttask();
  static const int kLeftTaskFieldNumber = 2;
  inline ::google::protobuf::uint32 lefttask() const;
  inline void set_lefttask(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserTaskCheckRes)
 private:
  inline void set_has_newtask();
  inline void clear_has_newtask();
  inline void set_has_lefttask();
  inline void clear_has_lefttask();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool newtask_;
  ::google::protobuf::uint32 lefttask_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskCheckRes* default_instance_;
};
// -------------------------------------------------------------------

class UserInfo : public ::google::protobuf::Message {
 public:
  UserInfo();
  virtual ~UserInfo();

  UserInfo(const UserInfo& from);

  inline UserInfo& operator=(const UserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfo& default_instance();

  void Swap(UserInfo* other);

  // implements Message ----------------------------------------------

  UserInfo* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional string signature = 3;
  inline bool has_signature() const;
  inline void clear_signature();
  static const int kSignatureFieldNumber = 3;
  inline const ::std::string& signature() const;
  inline void set_signature(const ::std::string& value);
  inline void set_signature(const char* value);
  inline void set_signature(const char* value, size_t size);
  inline ::std::string* mutable_signature();
  inline ::std::string* release_signature();
  inline void set_allocated_signature(::std::string* signature);

  // optional string logourl = 4;
  inline bool has_logourl() const;
  inline void clear_logourl();
  static const int kLogourlFieldNumber = 4;
  inline const ::std::string& logourl() const;
  inline void set_logourl(const ::std::string& value);
  inline void set_logourl(const char* value);
  inline void set_logourl(const char* value, size_t size);
  inline ::std::string* mutable_logourl();
  inline ::std::string* release_logourl();
  inline void set_allocated_logourl(::std::string* logourl);

  // optional .pp.SexType sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::pp::SexType sex() const;
  inline void set_sex(::pp::SexType value);

  // optional sint64 birthday = 6;
  inline bool has_birthday() const;
  inline void clear_birthday();
  static const int kBirthdayFieldNumber = 6;
  inline ::google::protobuf::int64 birthday() const;
  inline void set_birthday(::google::protobuf::int64 value);

  // optional string location = 8;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 8;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional string address = 9;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 9;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // optional .pp.GroupInfo guild = 10;
  inline bool has_guild() const;
  inline void clear_guild();
  static const int kGuildFieldNumber = 10;
  inline const ::pp::GroupInfo& guild() const;
  inline ::pp::GroupInfo* mutable_guild();
  inline ::pp::GroupInfo* release_guild();
  inline void set_allocated_guild(::pp::GroupInfo* guild);

  // optional string mobilephone = 11;
  inline bool has_mobilephone() const;
  inline void clear_mobilephone();
  static const int kMobilephoneFieldNumber = 11;
  inline const ::std::string& mobilephone() const;
  inline void set_mobilephone(const ::std::string& value);
  inline void set_mobilephone(const char* value);
  inline void set_mobilephone(const char* value, size_t size);
  inline ::std::string* mutable_mobilephone();
  inline ::std::string* release_mobilephone();
  inline void set_allocated_mobilephone(::std::string* mobilephone);

  // optional .pp.UserInfoProp prop = 14;
  inline bool has_prop() const;
  inline void clear_prop();
  static const int kPropFieldNumber = 14;
  inline const ::pp::UserInfoProp& prop() const;
  inline ::pp::UserInfoProp* mutable_prop();
  inline ::pp::UserInfoProp* release_prop();
  inline void set_allocated_prop(::pp::UserInfoProp* prop);

  // optional .pp.UserActiveData userActiveData = 20;
  inline bool has_useractivedata() const;
  inline void clear_useractivedata();
  static const int kUserActiveDataFieldNumber = 20;
  inline const ::pp::UserActiveData& useractivedata() const;
  inline ::pp::UserActiveData* mutable_useractivedata();
  inline ::pp::UserActiveData* release_useractivedata();
  inline void set_allocated_useractivedata(::pp::UserActiveData* useractivedata);

  // optional uint64 searchResult = 21;
  inline bool has_searchresult() const;
  inline void clear_searchresult();
  static const int kSearchResultFieldNumber = 21;
  inline ::google::protobuf::uint64 searchresult() const;
  inline void set_searchresult(::google::protobuf::uint64 value);

  // optional double searchResultF = 22;
  inline bool has_searchresultf() const;
  inline void clear_searchresultf();
  static const int kSearchResultFFieldNumber = 22;
  inline double searchresultf() const;
  inline void set_searchresultf(double value);

  // optional int64 createtime = 50;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreatetimeFieldNumber = 50;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional uint32 roletype = 51;
  inline bool has_roletype() const;
  inline void clear_roletype();
  static const int kRoletypeFieldNumber = 51;
  inline ::google::protobuf::uint32 roletype() const;
  inline void set_roletype(::google::protobuf::uint32 value);

  // optional int64 loginTime = 52;
  inline bool has_logintime() const;
  inline void clear_logintime();
  static const int kLoginTimeFieldNumber = 52;
  inline ::google::protobuf::int64 logintime() const;
  inline void set_logintime(::google::protobuf::int64 value);

  // optional .pp.AccountType accountType = 53;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccountTypeFieldNumber = 53;
  inline ::pp::AccountType accounttype() const;
  inline void set_accounttype(::pp::AccountType value);

  // optional .pp.UserForbidInfo forbid = 54;
  inline bool has_forbid() const;
  inline void clear_forbid();
  static const int kForbidFieldNumber = 54;
  inline const ::pp::UserForbidInfo& forbid() const;
  inline ::pp::UserForbidInfo* mutable_forbid();
  inline ::pp::UserForbidInfo* release_forbid();
  inline void set_allocated_forbid(::pp::UserForbidInfo* forbid);

  // optional int64 cookieTime = 55;
  inline bool has_cookietime() const;
  inline void clear_cookietime();
  static const int kCookieTimeFieldNumber = 55;
  inline ::google::protobuf::int64 cookietime() const;
  inline void set_cookietime(::google::protobuf::int64 value);

  // optional uint32 flags = 56;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 56;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional uint64 yyuid = 60;
  inline bool has_yyuid() const;
  inline void clear_yyuid();
  static const int kYyuidFieldNumber = 60;
  inline ::google::protobuf::uint64 yyuid() const;
  inline void set_yyuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserInfo)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_signature();
  inline void clear_has_signature();
  inline void set_has_logourl();
  inline void clear_has_logourl();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_birthday();
  inline void clear_has_birthday();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_address();
  inline void clear_has_address();
  inline void set_has_guild();
  inline void clear_has_guild();
  inline void set_has_mobilephone();
  inline void clear_has_mobilephone();
  inline void set_has_prop();
  inline void clear_has_prop();
  inline void set_has_useractivedata();
  inline void clear_has_useractivedata();
  inline void set_has_searchresult();
  inline void clear_has_searchresult();
  inline void set_has_searchresultf();
  inline void clear_has_searchresultf();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_roletype();
  inline void clear_has_roletype();
  inline void set_has_logintime();
  inline void clear_has_logintime();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_forbid();
  inline void clear_has_forbid();
  inline void set_has_cookietime();
  inline void clear_has_cookietime();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_yyuid();
  inline void clear_has_yyuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* nick_;
  ::std::string* signature_;
  ::std::string* logourl_;
  ::google::protobuf::int64 birthday_;
  ::std::string* location_;
  ::std::string* address_;
  ::pp::GroupInfo* guild_;
  ::std::string* mobilephone_;
  int sex_;
  ::google::protobuf::uint32 roletype_;
  ::pp::UserInfoProp* prop_;
  ::pp::UserActiveData* useractivedata_;
  ::google::protobuf::uint64 searchresult_;
  double searchresultf_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::int64 logintime_;
  ::pp::UserForbidInfo* forbid_;
  int accounttype_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::int64 cookietime_;
  ::google::protobuf::uint64 yyuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(22 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfo* default_instance_;
};
// -------------------------------------------------------------------

class UserPasswordModifyReq : public ::google::protobuf::Message {
 public:
  UserPasswordModifyReq();
  virtual ~UserPasswordModifyReq();

  UserPasswordModifyReq(const UserPasswordModifyReq& from);

  inline UserPasswordModifyReq& operator=(const UserPasswordModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPasswordModifyReq& default_instance();

  void Swap(UserPasswordModifyReq* other);

  // implements Message ----------------------------------------------

  UserPasswordModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string newpassword = 1;
  inline bool has_newpassword() const;
  inline void clear_newpassword();
  static const int kNewpasswordFieldNumber = 1;
  inline const ::std::string& newpassword() const;
  inline void set_newpassword(const ::std::string& value);
  inline void set_newpassword(const char* value);
  inline void set_newpassword(const char* value, size_t size);
  inline ::std::string* mutable_newpassword();
  inline ::std::string* release_newpassword();
  inline void set_allocated_newpassword(::std::string* newpassword);

  // optional string oldpassword = 2;
  inline bool has_oldpassword() const;
  inline void clear_oldpassword();
  static const int kOldpasswordFieldNumber = 2;
  inline const ::std::string& oldpassword() const;
  inline void set_oldpassword(const ::std::string& value);
  inline void set_oldpassword(const char* value);
  inline void set_oldpassword(const char* value, size_t size);
  inline ::std::string* mutable_oldpassword();
  inline ::std::string* release_oldpassword();
  inline void set_allocated_oldpassword(::std::string* oldpassword);

  // @@protoc_insertion_point(class_scope:pp.UserPasswordModifyReq)
 private:
  inline void set_has_newpassword();
  inline void clear_has_newpassword();
  inline void set_has_oldpassword();
  inline void clear_has_oldpassword();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* newpassword_;
  ::std::string* oldpassword_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPasswordModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class UserPasswordModifyRes : public ::google::protobuf::Message {
 public:
  UserPasswordModifyRes();
  virtual ~UserPasswordModifyRes();

  UserPasswordModifyRes(const UserPasswordModifyRes& from);

  inline UserPasswordModifyRes& operator=(const UserPasswordModifyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPasswordModifyRes& default_instance();

  void Swap(UserPasswordModifyRes* other);

  // implements Message ----------------------------------------------

  UserPasswordModifyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string cookie = 1;
  inline bool has_cookie() const;
  inline void clear_cookie();
  static const int kCookieFieldNumber = 1;
  inline const ::std::string& cookie() const;
  inline void set_cookie(const ::std::string& value);
  inline void set_cookie(const char* value);
  inline void set_cookie(const char* value, size_t size);
  inline ::std::string* mutable_cookie();
  inline ::std::string* release_cookie();
  inline void set_allocated_cookie(::std::string* cookie);

  // @@protoc_insertion_point(class_scope:pp.UserPasswordModifyRes)
 private:
  inline void set_has_cookie();
  inline void clear_has_cookie();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* cookie_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPasswordModifyRes* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoModifyReq : public ::google::protobuf::Message {
 public:
  UserInfoModifyReq();
  virtual ~UserInfoModifyReq();

  UserInfoModifyReq(const UserInfoModifyReq& from);

  inline UserInfoModifyReq& operator=(const UserInfoModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoModifyReq& default_instance();

  void Swap(UserInfoModifyReq* other);

  // implements Message ----------------------------------------------

  UserInfoModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.UserInfo userinfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 1;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:pp.UserInfoModifyReq)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* userinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoModifyRes : public ::google::protobuf::Message {
 public:
  UserInfoModifyRes();
  virtual ~UserInfoModifyRes();

  UserInfoModifyRes(const UserInfoModifyRes& from);

  inline UserInfoModifyRes& operator=(const UserInfoModifyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoModifyRes& default_instance();

  void Swap(UserInfoModifyRes* other);

  // implements Message ----------------------------------------------

  UserInfoModifyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.UserInfo userinfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 1;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:pp.UserInfoModifyRes)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* userinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoModifyRes* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoReq : public ::google::protobuf::Message {
 public:
  UserInfoReq();
  virtual ~UserInfoReq();

  UserInfoReq(const UserInfoReq& from);

  inline UserInfoReq& operator=(const UserInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoReq& default_instance();

  void Swap(UserInfoReq* other);

  // implements Message ----------------------------------------------

  UserInfoReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string nick = 2;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 2;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // optional .pp.UserInfo template = 3;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 3;
  inline const ::pp::UserInfo& template_() const;
  inline ::pp::UserInfo* mutable_template_();
  inline ::pp::UserInfo* release_template_();
  inline void set_allocated_template_(::pp::UserInfo* template_);

  // optional uint64 yyuid = 4;
  inline bool has_yyuid() const;
  inline void clear_yyuid();
  static const int kYyuidFieldNumber = 4;
  inline ::google::protobuf::uint64 yyuid() const;
  inline void set_yyuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserInfoReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_nick();
  inline void clear_has_nick();
  inline void set_has_template_();
  inline void clear_has_template_();
  inline void set_has_yyuid();
  inline void clear_has_yyuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* nick_;
  ::pp::UserInfo* template__;
  ::google::protobuf::uint64 yyuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoRes : public ::google::protobuf::Message {
 public:
  UserInfoRes();
  virtual ~UserInfoRes();

  UserInfoRes(const UserInfoRes& from);

  inline UserInfoRes& operator=(const UserInfoRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoRes& default_instance();

  void Swap(UserInfoRes* other);

  // implements Message ----------------------------------------------

  UserInfoRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.UserInfo userinfo = 1;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 1;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // @@protoc_insertion_point(class_scope:pp.UserInfoRes)
 private:
  inline void set_has_userinfo();
  inline void clear_has_userinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* userinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoRes* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoListReq : public ::google::protobuf::Message {
 public:
  UserInfoListReq();
  virtual ~UserInfoListReq();

  UserInfoListReq(const UserInfoListReq& from);

  inline UserInfoListReq& operator=(const UserInfoListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoListReq& default_instance();

  void Swap(UserInfoListReq* other);

  // implements Message ----------------------------------------------

  UserInfoListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 uids = 1;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 1;
  inline ::google::protobuf::uint64 uids(int index) const;
  inline void set_uids(int index, ::google::protobuf::uint64 value);
  inline void add_uids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uids();

  // optional .pp.UserInfo template = 3;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 3;
  inline const ::pp::UserInfo& template_() const;
  inline ::pp::UserInfo* mutable_template_();
  inline ::pp::UserInfo* release_template_();
  inline void set_allocated_template_(::pp::UserInfo* template_);

  // @@protoc_insertion_point(class_scope:pp.UserInfoListReq)
 private:
  inline void set_has_template_();
  inline void clear_has_template_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uids_;
  ::pp::UserInfo* template__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserInfoListRes : public ::google::protobuf::Message {
 public:
  UserInfoListRes();
  virtual ~UserInfoListRes();

  UserInfoListRes(const UserInfoListRes& from);

  inline UserInfoListRes& operator=(const UserInfoListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserInfoListRes& default_instance();

  void Swap(UserInfoListRes* other);

  // implements Message ----------------------------------------------

  UserInfoListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserInfo users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::pp::UserInfo& users(int index) const;
  inline ::pp::UserInfo* mutable_users(int index);
  inline ::pp::UserInfo* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
      mutable_users();

  // @@protoc_insertion_point(class_scope:pp.UserInfoListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserInfo > users_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserInfoListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserActiveDataReq : public ::google::protobuf::Message {
 public:
  UserActiveDataReq();
  virtual ~UserActiveDataReq();

  UserActiveDataReq(const UserActiveDataReq& from);

  inline UserActiveDataReq& operator=(const UserActiveDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActiveDataReq& default_instance();

  void Swap(UserActiveDataReq* other);

  // implements Message ----------------------------------------------

  UserActiveDataReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserActiveDataReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActiveDataReq* default_instance_;
};
// -------------------------------------------------------------------

class UserActiveDataRes : public ::google::protobuf::Message {
 public:
  UserActiveDataRes();
  virtual ~UserActiveDataRes();

  UserActiveDataRes(const UserActiveDataRes& from);

  inline UserActiveDataRes& operator=(const UserActiveDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActiveDataRes& default_instance();

  void Swap(UserActiveDataRes* other);

  // implements Message ----------------------------------------------

  UserActiveDataRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserActiveData activeData = 1;
  inline bool has_activedata() const;
  inline void clear_activedata();
  static const int kActiveDataFieldNumber = 1;
  inline const ::pp::UserActiveData& activedata() const;
  inline ::pp::UserActiveData* mutable_activedata();
  inline ::pp::UserActiveData* release_activedata();
  inline void set_allocated_activedata(::pp::UserActiveData* activedata);

  // @@protoc_insertion_point(class_scope:pp.UserActiveDataRes)
 private:
  inline void set_has_activedata();
  inline void clear_has_activedata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserActiveData* activedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActiveDataRes* default_instance_;
};
// -------------------------------------------------------------------

class UserActiveDataListReq : public ::google::protobuf::Message {
 public:
  UserActiveDataListReq();
  virtual ~UserActiveDataListReq();

  UserActiveDataListReq(const UserActiveDataListReq& from);

  inline UserActiveDataListReq& operator=(const UserActiveDataListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActiveDataListReq& default_instance();

  void Swap(UserActiveDataListReq* other);

  // implements Message ----------------------------------------------

  UserActiveDataListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 uids = 1;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 1;
  inline ::google::protobuf::uint64 uids(int index) const;
  inline void set_uids(int index, ::google::protobuf::uint64 value);
  inline void add_uids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uids();

  // @@protoc_insertion_point(class_scope:pp.UserActiveDataListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActiveDataListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserActiveDataListRes : public ::google::protobuf::Message {
 public:
  UserActiveDataListRes();
  virtual ~UserActiveDataListRes();

  UserActiveDataListRes(const UserActiveDataListRes& from);

  inline UserActiveDataListRes& operator=(const UserActiveDataListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserActiveDataListRes& default_instance();

  void Swap(UserActiveDataListRes* other);

  // implements Message ----------------------------------------------

  UserActiveDataListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserActiveData activeDataList = 1;
  inline int activedatalist_size() const;
  inline void clear_activedatalist();
  static const int kActiveDataListFieldNumber = 1;
  inline const ::pp::UserActiveData& activedatalist(int index) const;
  inline ::pp::UserActiveData* mutable_activedatalist(int index);
  inline ::pp::UserActiveData* add_activedatalist();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserActiveData >&
      activedatalist() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserActiveData >*
      mutable_activedatalist();

  // @@protoc_insertion_point(class_scope:pp.UserActiveDataListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserActiveData > activedatalist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserActiveDataListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserSearchReq : public ::google::protobuf::Message {
 public:
  UserSearchReq();
  virtual ~UserSearchReq();

  UserSearchReq(const UserSearchReq& from);

  inline UserSearchReq& operator=(const UserSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSearchReq& default_instance();

  void Swap(UserSearchReq* other);

  // implements Message ----------------------------------------------

  UserSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.SexType sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::pp::SexType sex() const;
  inline void set_sex(::pp::SexType value);

  // optional .pp.UserSearchBy searchby = 6;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchbyFieldNumber = 6;
  inline ::pp::UserSearchBy searchby() const;
  inline void set_searchby(::pp::UserSearchBy value);

  // optional .pp.UserSearchOrderBy orderby = 7;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 7;
  inline ::pp::UserSearchOrderBy orderby() const;
  inline void set_orderby(::pp::UserSearchOrderBy value);

  // optional string location = 8;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 8;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional bool online = 9;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 9;
  inline bool online() const;
  inline void set_online(bool value);

  // optional bool showing = 10;
  inline bool has_showing() const;
  inline void clear_showing();
  static const int kShowingFieldNumber = 10;
  inline bool showing() const;
  inline void set_showing(bool value);

  // optional int64 sortkey = 11;
  inline bool has_sortkey() const;
  inline void clear_sortkey();
  static const int kSortkeyFieldNumber = 11;
  inline ::google::protobuf::int64 sortkey() const;
  inline void set_sortkey(::google::protobuf::int64 value);

  // optional .pp.UserInfo template = 20;
  inline bool has_template_() const;
  inline void clear_template_();
  static const int kTemplateFieldNumber = 20;
  inline const ::pp::UserInfo& template_() const;
  inline ::pp::UserInfo* mutable_template_();
  inline ::pp::UserInfo* release_template_();
  inline void set_allocated_template_(::pp::UserInfo* template_);

  // @@protoc_insertion_point(class_scope:pp.UserSearchReq)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_showing();
  inline void clear_has_showing();
  inline void set_has_sortkey();
  inline void clear_has_sortkey();
  inline void set_has_template_();
  inline void clear_has_template_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keyword_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  int sex_;
  int searchby_;
  ::std::string* location_;
  int orderby_;
  bool online_;
  bool showing_;
  ::google::protobuf::int64 sortkey_;
  ::pp::UserInfo* template__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(11 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class UserSearchRes : public ::google::protobuf::Message {
 public:
  UserSearchRes();
  virtual ~UserSearchRes();

  UserSearchRes(const UserSearchRes& from);

  inline UserSearchRes& operator=(const UserSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserSearchRes& default_instance();

  void Swap(UserSearchRes* other);

  // implements Message ----------------------------------------------

  UserSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string keyword = 1;
  inline bool has_keyword() const;
  inline void clear_keyword();
  static const int kKeywordFieldNumber = 1;
  inline const ::std::string& keyword() const;
  inline void set_keyword(const ::std::string& value);
  inline void set_keyword(const char* value);
  inline void set_keyword(const char* value, size_t size);
  inline ::std::string* mutable_keyword();
  inline ::std::string* release_keyword();
  inline void set_allocated_keyword(::std::string* keyword);

  // optional uint32 totalresults = 2;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 2;
  inline ::google::protobuf::uint32 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint32 value);

  // optional uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // repeated .pp.UserInfo users = 4;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 4;
  inline const ::pp::UserInfo& users(int index) const;
  inline ::pp::UserInfo* mutable_users(int index);
  inline ::pp::UserInfo* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
      mutable_users();

  // optional .pp.SexType sex = 5;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 5;
  inline ::pp::SexType sex() const;
  inline void set_sex(::pp::SexType value);

  // optional .pp.UserSearchBy searchby = 6;
  inline bool has_searchby() const;
  inline void clear_searchby();
  static const int kSearchbyFieldNumber = 6;
  inline ::pp::UserSearchBy searchby() const;
  inline void set_searchby(::pp::UserSearchBy value);

  // optional .pp.UserSearchOrderBy orderby = 7;
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderbyFieldNumber = 7;
  inline ::pp::UserSearchOrderBy orderby() const;
  inline void set_orderby(::pp::UserSearchOrderBy value);

  // optional string location = 8;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 8;
  inline const ::std::string& location() const;
  inline void set_location(const ::std::string& value);
  inline void set_location(const char* value);
  inline void set_location(const char* value, size_t size);
  inline ::std::string* mutable_location();
  inline ::std::string* release_location();
  inline void set_allocated_location(::std::string* location);

  // optional bool online = 9;
  inline bool has_online() const;
  inline void clear_online();
  static const int kOnlineFieldNumber = 9;
  inline bool online() const;
  inline void set_online(bool value);

  // optional bool showing = 10;
  inline bool has_showing() const;
  inline void clear_showing();
  static const int kShowingFieldNumber = 10;
  inline bool showing() const;
  inline void set_showing(bool value);

  // optional uint32 fetchs = 11;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 11;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional int64 sortkey = 12;
  inline bool has_sortkey() const;
  inline void clear_sortkey();
  static const int kSortkeyFieldNumber = 12;
  inline ::google::protobuf::int64 sortkey() const;
  inline void set_sortkey(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserSearchRes)
 private:
  inline void set_has_keyword();
  inline void clear_has_keyword();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_searchby();
  inline void clear_has_searchby();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_location();
  inline void clear_has_location();
  inline void set_has_online();
  inline void clear_has_online();
  inline void set_has_showing();
  inline void clear_has_showing();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_sortkey();
  inline void clear_has_sortkey();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* keyword_;
  ::google::protobuf::uint32 totalresults_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserInfo > users_;
  int sex_;
  int searchby_;
  ::std::string* location_;
  int orderby_;
  bool online_;
  bool showing_;
  ::google::protobuf::int64 sortkey_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class UserImageListReq : public ::google::protobuf::Message {
 public:
  UserImageListReq();
  virtual ~UserImageListReq();

  UserImageListReq(const UserImageListReq& from);

  inline UserImageListReq& operator=(const UserImageListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImageListReq& default_instance();

  void Swap(UserImageListReq* other);

  // implements Message ----------------------------------------------

  UserImageListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.UserImageOrderBy orderBy = 4 [default = UserImageOrderBy_Default];
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 4;
  inline ::pp::UserImageOrderBy orderby() const;
  inline void set_orderby(::pp::UserImageOrderBy value);

  // optional .pp.UserImageType imageType = 5 [default = UserImageType_Default];
  inline bool has_imagetype() const;
  inline void clear_imagetype();
  static const int kImageTypeFieldNumber = 5;
  inline ::pp::UserImageType imagetype() const;
  inline void set_imagetype(::pp::UserImageType value);

  // @@protoc_insertion_point(class_scope:pp.UserImageListReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_imagetype();
  inline void clear_has_imagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  int orderby_;
  int imagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImageListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserImageListRes : public ::google::protobuf::Message {
 public:
  UserImageListRes();
  virtual ~UserImageListRes();

  UserImageListRes(const UserImageListRes& from);

  inline UserImageListRes& operator=(const UserImageListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImageListRes& default_instance();

  void Swap(UserImageListRes* other);

  // implements Message ----------------------------------------------

  UserImageListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.UserImage images = 4;
  inline int images_size() const;
  inline void clear_images();
  static const int kImagesFieldNumber = 4;
  inline const ::pp::UserImage& images(int index) const;
  inline ::pp::UserImage* mutable_images(int index);
  inline ::pp::UserImage* add_images();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserImage >&
      images() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserImage >*
      mutable_images();

  // optional .pp.UserImageOrderBy orderBy = 5 [default = UserImageOrderBy_Default];
  inline bool has_orderby() const;
  inline void clear_orderby();
  static const int kOrderByFieldNumber = 5;
  inline ::pp::UserImageOrderBy orderby() const;
  inline void set_orderby(::pp::UserImageOrderBy value);

  // optional .pp.UserImageType imageType = 6 [default = UserImageType_Default];
  inline bool has_imagetype() const;
  inline void clear_imagetype();
  static const int kImageTypeFieldNumber = 6;
  inline ::pp::UserImageType imagetype() const;
  inline void set_imagetype(::pp::UserImageType value);

  // @@protoc_insertion_point(class_scope:pp.UserImageListRes)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_orderby();
  inline void clear_has_orderby();
  inline void set_has_imagetype();
  inline void clear_has_imagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserImage > images_;
  int orderby_;
  int imagetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImageListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserImage : public ::google::protobuf::Message {
 public:
  UserImage();
  virtual ~UserImage();

  UserImage(const UserImage& from);

  inline UserImage& operator=(const UserImage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImage& default_instance();

  void Swap(UserImage* other);

  // implements Message ----------------------------------------------

  UserImage* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint64 uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string url = 2;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 2;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 likes = 3;
  inline bool has_likes() const;
  inline void clear_likes();
  static const int kLikesFieldNumber = 3;
  inline ::google::protobuf::uint32 likes() const;
  inline void set_likes(::google::protobuf::uint32 value);

  // optional bool mylike = 4;
  inline bool has_mylike() const;
  inline void clear_mylike();
  static const int kMylikeFieldNumber = 4;
  inline bool mylike() const;
  inline void set_mylike(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserImage)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_likes();
  inline void clear_has_likes();
  inline void set_has_mylike();
  inline void clear_has_mylike();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 likes_;
  ::std::string* url_;
  bool mylike_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImage* default_instance_;
};
// -------------------------------------------------------------------

class UserImageOpReq : public ::google::protobuf::Message {
 public:
  UserImageOpReq();
  virtual ~UserImageOpReq();

  UserImageOpReq(const UserImageOpReq& from);

  inline UserImageOpReq& operator=(const UserImageOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImageOpReq& default_instance();

  void Swap(UserImageOpReq* other);

  // implements Message ----------------------------------------------

  UserImageOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef UserImageOpReq_Type Type;
  static const Type Upload = UserImageOpReq_Type_Upload;
  static const Type Delete = UserImageOpReq_Type_Delete;
  static inline bool Type_IsValid(int value) {
    return UserImageOpReq_Type_IsValid(value);
  }
  static const Type Type_MIN =
    UserImageOpReq_Type_Type_MIN;
  static const Type Type_MAX =
    UserImageOpReq_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    UserImageOpReq_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return UserImageOpReq_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return UserImageOpReq_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return UserImageOpReq_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .pp.UserImageOpReq.Type type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::pp::UserImageOpReq_Type type() const;
  inline void set_type(::pp::UserImageOpReq_Type value);

  // repeated uint32 ids = 2;
  inline int ids_size() const;
  inline void clear_ids();
  static const int kIdsFieldNumber = 2;
  inline ::google::protobuf::uint32 ids(int index) const;
  inline void set_ids(int index, ::google::protobuf::uint32 value);
  inline void add_ids(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      ids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_ids();

  // repeated string urls = 3;
  inline int urls_size() const;
  inline void clear_urls();
  static const int kUrlsFieldNumber = 3;
  inline const ::std::string& urls(int index) const;
  inline ::std::string* mutable_urls(int index);
  inline void set_urls(int index, const ::std::string& value);
  inline void set_urls(int index, const char* value);
  inline void set_urls(int index, const char* value, size_t size);
  inline ::std::string* add_urls();
  inline void add_urls(const ::std::string& value);
  inline void add_urls(const char* value);
  inline void add_urls(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& urls() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_urls();

  // optional uint64 uid = 4;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 4;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional .pp.UserImageType imageType = 5 [default = UserImageType_Default];
  inline bool has_imagetype() const;
  inline void clear_imagetype();
  static const int kImageTypeFieldNumber = 5;
  inline ::pp::UserImageType imagetype() const;
  inline void set_imagetype(::pp::UserImageType value);

  // @@protoc_insertion_point(class_scope:pp.UserImageOpReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_imagetype();
  inline void clear_has_imagetype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > ids_;
  ::google::protobuf::RepeatedPtrField< ::std::string> urls_;
  int type_;
  int imagetype_;
  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImageOpReq* default_instance_;
};
// -------------------------------------------------------------------

class UserImageOpRes : public ::google::protobuf::Message {
 public:
  UserImageOpRes();
  virtual ~UserImageOpRes();

  UserImageOpRes(const UserImageOpRes& from);

  inline UserImageOpRes& operator=(const UserImageOpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImageOpRes& default_instance();

  void Swap(UserImageOpRes* other);

  // implements Message ----------------------------------------------

  UserImageOpRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserImageOpRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImageOpRes* default_instance_;
};
// -------------------------------------------------------------------

class UserImageLikeReq : public ::google::protobuf::Message {
 public:
  UserImageLikeReq();
  virtual ~UserImageLikeReq();

  UserImageLikeReq(const UserImageLikeReq& from);

  inline UserImageLikeReq& operator=(const UserImageLikeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImageLikeReq& default_instance();

  void Swap(UserImageLikeReq* other);

  // implements Message ----------------------------------------------

  UserImageLikeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 likeUserId = 1;
  inline bool has_likeuserid() const;
  inline void clear_likeuserid();
  static const int kLikeUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 likeuserid() const;
  inline void set_likeuserid(::google::protobuf::uint64 value);

  // required uint32 imageId = 2;
  inline bool has_imageid() const;
  inline void clear_imageid();
  static const int kImageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 imageid() const;
  inline void set_imageid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserImageLikeReq)
 private:
  inline void set_has_likeuserid();
  inline void clear_has_likeuserid();
  inline void set_has_imageid();
  inline void clear_has_imageid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 likeuserid_;
  ::google::protobuf::uint32 imageid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImageLikeReq* default_instance_;
};
// -------------------------------------------------------------------

class UserImageLikeRes : public ::google::protobuf::Message {
 public:
  UserImageLikeRes();
  virtual ~UserImageLikeRes();

  UserImageLikeRes(const UserImageLikeRes& from);

  inline UserImageLikeRes& operator=(const UserImageLikeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserImageLikeRes& default_instance();

  void Swap(UserImageLikeRes* other);

  // implements Message ----------------------------------------------

  UserImageLikeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 likeUserId = 1;
  inline bool has_likeuserid() const;
  inline void clear_likeuserid();
  static const int kLikeUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 likeuserid() const;
  inline void set_likeuserid(::google::protobuf::uint64 value);

  // required uint32 imageId = 2;
  inline bool has_imageid() const;
  inline void clear_imageid();
  static const int kImageIdFieldNumber = 2;
  inline ::google::protobuf::uint32 imageid() const;
  inline void set_imageid(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserImageLikeRes)
 private:
  inline void set_has_likeuserid();
  inline void clear_has_likeuserid();
  inline void set_has_imageid();
  inline void clear_has_imageid();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 likeuserid_;
  ::google::protobuf::uint32 imageid_;
  ::google::protobuf::uint32 total_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserImageLikeRes* default_instance_;
};
// -------------------------------------------------------------------

class UserShowShareReq : public ::google::protobuf::Message {
 public:
  UserShowShareReq();
  virtual ~UserShowShareReq();

  UserShowShareReq(const UserShowShareReq& from);

  inline UserShowShareReq& operator=(const UserShowShareReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserShowShareReq& default_instance();

  void Swap(UserShowShareReq* other);

  // implements Message ----------------------------------------------

  UserShowShareReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string shareinfo = 1;
  inline bool has_shareinfo() const;
  inline void clear_shareinfo();
  static const int kShareinfoFieldNumber = 1;
  inline const ::std::string& shareinfo() const;
  inline void set_shareinfo(const ::std::string& value);
  inline void set_shareinfo(const char* value);
  inline void set_shareinfo(const char* value, size_t size);
  inline ::std::string* mutable_shareinfo();
  inline ::std::string* release_shareinfo();
  inline void set_allocated_shareinfo(::std::string* shareinfo);

  // @@protoc_insertion_point(class_scope:pp.UserShowShareReq)
 private:
  inline void set_has_shareinfo();
  inline void clear_has_shareinfo();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* shareinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserShowShareReq* default_instance_;
};
// -------------------------------------------------------------------

class UserShowShareRes : public ::google::protobuf::Message {
 public:
  UserShowShareRes();
  virtual ~UserShowShareRes();

  UserShowShareRes(const UserShowShareRes& from);

  inline UserShowShareRes& operator=(const UserShowShareRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserShowShareRes& default_instance();

  void Swap(UserShowShareRes* other);

  // implements Message ----------------------------------------------

  UserShowShareRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserShowShareRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserShowShareRes* default_instance_;
};
// -------------------------------------------------------------------

class UserRecommendRegisterReq : public ::google::protobuf::Message {
 public:
  UserRecommendRegisterReq();
  virtual ~UserRecommendRegisterReq();

  UserRecommendRegisterReq(const UserRecommendRegisterReq& from);

  inline UserRecommendRegisterReq& operator=(const UserRecommendRegisterReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRecommendRegisterReq& default_instance();

  void Swap(UserRecommendRegisterReq* other);

  // implements Message ----------------------------------------------

  UserRecommendRegisterReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ruid = 1;
  inline bool has_ruid() const;
  inline void clear_ruid();
  static const int kRuidFieldNumber = 1;
  inline ::google::protobuf::uint64 ruid() const;
  inline void set_ruid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserRecommendRegisterReq)
 private:
  inline void set_has_ruid();
  inline void clear_has_ruid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 ruid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRecommendRegisterReq* default_instance_;
};
// -------------------------------------------------------------------

class UserRecommendRegisterRes : public ::google::protobuf::Message {
 public:
  UserRecommendRegisterRes();
  virtual ~UserRecommendRegisterRes();

  UserRecommendRegisterRes(const UserRecommendRegisterRes& from);

  inline UserRecommendRegisterRes& operator=(const UserRecommendRegisterRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRecommendRegisterRes& default_instance();

  void Swap(UserRecommendRegisterRes* other);

  // implements Message ----------------------------------------------

  UserRecommendRegisterRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 ruid = 1;
  inline bool has_ruid() const;
  inline void clear_ruid();
  static const int kRuidFieldNumber = 1;
  inline ::google::protobuf::uint64 ruid() const;
  inline void set_ruid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserRecommendRegisterRes)
 private:
  inline void set_has_ruid();
  inline void clear_has_ruid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 ruid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRecommendRegisterRes* default_instance_;
};
// -------------------------------------------------------------------

class UserRefererListReq : public ::google::protobuf::Message {
 public:
  UserRefererListReq();
  virtual ~UserRefererListReq();

  UserRefererListReq(const UserRefererListReq& from);

  inline UserRefererListReq& operator=(const UserRefererListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRefererListReq& default_instance();

  void Swap(UserRefererListReq* other);

  // implements Message ----------------------------------------------

  UserRefererListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserRefererListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRefererListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserRefererListRes : public ::google::protobuf::Message {
 public:
  UserRefererListRes();
  virtual ~UserRefererListRes();

  UserRefererListRes(const UserRefererListRes& from);

  inline UserRefererListRes& operator=(const UserRefererListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserRefererListRes& default_instance();

  void Swap(UserRefererListRes* other);

  // implements Message ----------------------------------------------

  UserRefererListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserInfo users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::pp::UserInfo& users(int index) const;
  inline ::pp::UserInfo* mutable_users(int index);
  inline ::pp::UserInfo* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
      mutable_users();

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 total = 3;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // optional uint32 totalCoins = 4;
  inline bool has_totalcoins() const;
  inline void clear_totalcoins();
  static const int kTotalCoinsFieldNumber = 4;
  inline ::google::protobuf::uint32 totalcoins() const;
  inline void set_totalcoins(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserRefererListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();
  inline void set_has_totalcoins();
  inline void clear_has_totalcoins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserInfo > users_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::uint32 totalcoins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserRefererListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserProductListReq : public ::google::protobuf::Message {
 public:
  UserProductListReq();
  virtual ~UserProductListReq();

  UserProductListReq(const UserProductListReq& from);

  inline UserProductListReq& operator=(const UserProductListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProductListReq& default_instance();

  void Swap(UserProductListReq* other);

  // implements Message ----------------------------------------------

  UserProductListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserProductListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserProductListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserProductListRes : public ::google::protobuf::Message {
 public:
  UserProductListRes();
  virtual ~UserProductListRes();

  UserProductListRes(const UserProductListRes& from);

  inline UserProductListRes& operator=(const UserProductListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProductListRes& default_instance();

  void Swap(UserProductListRes* other);

  // implements Message ----------------------------------------------

  UserProductListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 total = 2;
  inline bool has_total() const;
  inline void clear_total();
  static const int kTotalFieldNumber = 2;
  inline ::google::protobuf::uint32 total() const;
  inline void set_total(::google::protobuf::uint32 value);

  // repeated .pp.UserProduct userProducts = 3;
  inline int userproducts_size() const;
  inline void clear_userproducts();
  static const int kUserProductsFieldNumber = 3;
  inline const ::pp::UserProduct& userproducts(int index) const;
  inline ::pp::UserProduct* mutable_userproducts(int index);
  inline ::pp::UserProduct* add_userproducts();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserProduct >&
      userproducts() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserProduct >*
      mutable_userproducts();

  // @@protoc_insertion_point(class_scope:pp.UserProductListRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_total();
  inline void clear_has_total();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 total_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserProduct > userproducts_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserProductListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserProduct : public ::google::protobuf::Message {
 public:
  UserProduct();
  virtual ~UserProduct();

  UserProduct(const UserProduct& from);

  inline UserProduct& operator=(const UserProduct& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProduct& default_instance();

  void Swap(UserProduct* other);

  // implements Message ----------------------------------------------

  UserProduct* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.ProductInfo product = 1;
  inline bool has_product() const;
  inline void clear_product();
  static const int kProductFieldNumber = 1;
  inline const ::pp::ProductInfo& product() const;
  inline ::pp::ProductInfo* mutable_product();
  inline ::pp::ProductInfo* release_product();
  inline void set_allocated_product(::pp::ProductInfo* product);

  // optional uint32 num = 2;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 2;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional sint64 createTime = 3;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional uint32 money = 4;
  inline bool has_money() const;
  inline void clear_money();
  static const int kMoneyFieldNumber = 4;
  inline ::google::protobuf::uint32 money() const;
  inline void set_money(::google::protobuf::uint32 value);

  // optional .pp.UserTradeRecord.Type type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::pp::UserTradeRecord_Type type() const;
  inline void set_type(::pp::UserTradeRecord_Type value);

  // @@protoc_insertion_point(class_scope:pp.UserProduct)
 private:
  inline void set_has_product();
  inline void clear_has_product();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_money();
  inline void clear_has_money();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::ProductInfo* product_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 money_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserProduct* default_instance_;
};
// -------------------------------------------------------------------

class UserStatDataReq : public ::google::protobuf::Message {
 public:
  UserStatDataReq();
  virtual ~UserStatDataReq();

  UserStatDataReq(const UserStatDataReq& from);

  inline UserStatDataReq& operator=(const UserStatDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStatDataReq& default_instance();

  void Swap(UserStatDataReq* other);

  // implements Message ----------------------------------------------

  UserStatDataReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserStatDataReq)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 userid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserStatDataReq* default_instance_;
};
// -------------------------------------------------------------------

class UserStatDataRes : public ::google::protobuf::Message {
 public:
  UserStatDataRes();
  virtual ~UserStatDataRes();

  UserStatDataRes(const UserStatDataRes& from);

  inline UserStatDataRes& operator=(const UserStatDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserStatDataRes& default_instance();

  void Swap(UserStatDataRes* other);

  // implements Message ----------------------------------------------

  UserStatDataRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 userId = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::uint64 userid() const;
  inline void set_userid(::google::protobuf::uint64 value);

  // optional uint32 fans = 2;
  inline bool has_fans() const;
  inline void clear_fans();
  static const int kFansFieldNumber = 2;
  inline ::google::protobuf::uint32 fans() const;
  inline void set_fans(::google::protobuf::uint32 value);

  // optional uint32 giftTotal = 3;
  inline bool has_gifttotal() const;
  inline void clear_gifttotal();
  static const int kGiftTotalFieldNumber = 3;
  inline ::google::protobuf::uint32 gifttotal() const;
  inline void set_gifttotal(::google::protobuf::uint32 value);

  // optional uint32 imageLikes = 4;
  inline bool has_imagelikes() const;
  inline void clear_imagelikes();
  static const int kImageLikesFieldNumber = 4;
  inline ::google::protobuf::uint32 imagelikes() const;
  inline void set_imagelikes(::google::protobuf::uint32 value);

  // optional uint32 imageTotal = 5;
  inline bool has_imagetotal() const;
  inline void clear_imagetotal();
  static const int kImageTotalFieldNumber = 5;
  inline ::google::protobuf::uint32 imagetotal() const;
  inline void set_imagetotal(::google::protobuf::uint32 value);

  // optional uint32 follows = 6;
  inline bool has_follows() const;
  inline void clear_follows();
  static const int kFollowsFieldNumber = 6;
  inline ::google::protobuf::uint32 follows() const;
  inline void set_follows(::google::protobuf::uint32 value);

  // optional uint32 Songs = 7;
  inline bool has_songs() const;
  inline void clear_songs();
  static const int kSongsFieldNumber = 7;
  inline ::google::protobuf::uint32 songs() const;
  inline void set_songs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserStatDataRes)
 private:
  inline void set_has_userid();
  inline void clear_has_userid();
  inline void set_has_fans();
  inline void clear_has_fans();
  inline void set_has_gifttotal();
  inline void clear_has_gifttotal();
  inline void set_has_imagelikes();
  inline void clear_has_imagelikes();
  inline void set_has_imagetotal();
  inline void clear_has_imagetotal();
  inline void set_has_follows();
  inline void clear_has_follows();
  inline void set_has_songs();
  inline void clear_has_songs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 userid_;
  ::google::protobuf::uint32 fans_;
  ::google::protobuf::uint32 gifttotal_;
  ::google::protobuf::uint32 imagelikes_;
  ::google::protobuf::uint32 imagetotal_;
  ::google::protobuf::uint32 follows_;
  ::google::protobuf::uint32 songs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserStatDataRes* default_instance_;
};
// -------------------------------------------------------------------

class UserProfileViewReq : public ::google::protobuf::Message {
 public:
  UserProfileViewReq();
  virtual ~UserProfileViewReq();

  UserProfileViewReq(const UserProfileViewReq& from);

  inline UserProfileViewReq& operator=(const UserProfileViewReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProfileViewReq& default_instance();

  void Swap(UserProfileViewReq* other);

  // implements Message ----------------------------------------------

  UserProfileViewReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserProfileViewReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserProfileViewReq* default_instance_;
};
// -------------------------------------------------------------------

class UserProfileViewRes : public ::google::protobuf::Message {
 public:
  UserProfileViewRes();
  virtual ~UserProfileViewRes();

  UserProfileViewRes(const UserProfileViewRes& from);

  inline UserProfileViewRes& operator=(const UserProfileViewRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserProfileViewRes& default_instance();

  void Swap(UserProfileViewRes* other);

  // implements Message ----------------------------------------------

  UserProfileViewRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserProfileViewRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserProfileViewRes* default_instance_;
};
// -------------------------------------------------------------------

class AutoTaskUserListReq : public ::google::protobuf::Message {
 public:
  AutoTaskUserListReq();
  virtual ~AutoTaskUserListReq();

  AutoTaskUserListReq(const AutoTaskUserListReq& from);

  inline AutoTaskUserListReq& operator=(const AutoTaskUserListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoTaskUserListReq& default_instance();

  void Swap(AutoTaskUserListReq* other);

  // implements Message ----------------------------------------------

  AutoTaskUserListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.AutoTaskUserListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AutoTaskUserListReq* default_instance_;
};
// -------------------------------------------------------------------

class AutoTaskUserListRes : public ::google::protobuf::Message {
 public:
  AutoTaskUserListRes();
  virtual ~AutoTaskUserListRes();

  AutoTaskUserListRes(const AutoTaskUserListRes& from);

  inline AutoTaskUserListRes& operator=(const AutoTaskUserListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AutoTaskUserListRes& default_instance();

  void Swap(AutoTaskUserListRes* other);

  // implements Message ----------------------------------------------

  AutoTaskUserListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 uids = 1;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 1;
  inline ::google::protobuf::uint64 uids(int index) const;
  inline void set_uids(int index, ::google::protobuf::uint64 value);
  inline void add_uids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uids();

  // @@protoc_insertion_point(class_scope:pp.AutoTaskUserListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static AutoTaskUserListRes* default_instance_;
};
// -------------------------------------------------------------------

class UserAppRateReq : public ::google::protobuf::Message {
 public:
  UserAppRateReq();
  virtual ~UserAppRateReq();

  UserAppRateReq(const UserAppRateReq& from);

  inline UserAppRateReq& operator=(const UserAppRateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAppRateReq& default_instance();

  void Swap(UserAppRateReq* other);

  // implements Message ----------------------------------------------

  UserAppRateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserAppRateReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserAppRateReq* default_instance_;
};
// -------------------------------------------------------------------

class UserAppRateRes : public ::google::protobuf::Message {
 public:
  UserAppRateRes();
  virtual ~UserAppRateRes();

  UserAppRateRes(const UserAppRateRes& from);

  inline UserAppRateRes& operator=(const UserAppRateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAppRateRes& default_instance();

  void Swap(UserAppRateRes* other);

  // implements Message ----------------------------------------------

  UserAppRateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserAppRateRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserAppRateRes* default_instance_;
};
// -------------------------------------------------------------------

class UserExpressAddrOpReq : public ::google::protobuf::Message {
 public:
  UserExpressAddrOpReq();
  virtual ~UserExpressAddrOpReq();

  UserExpressAddrOpReq(const UserExpressAddrOpReq& from);

  inline UserExpressAddrOpReq& operator=(const UserExpressAddrOpReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserExpressAddrOpReq& default_instance();

  void Swap(UserExpressAddrOpReq* other);

  // implements Message ----------------------------------------------

  UserExpressAddrOpReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.EntityOpType opType = 1 [default = EntityOpType_Add];
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOpTypeFieldNumber = 1;
  inline ::pp::EntityOpType optype() const;
  inline void set_optype(::pp::EntityOpType value);

  // optional .pp.ExpressAddr entity = 2;
  inline bool has_entity() const;
  inline void clear_entity();
  static const int kEntityFieldNumber = 2;
  inline const ::pp::ExpressAddr& entity() const;
  inline ::pp::ExpressAddr* mutable_entity();
  inline ::pp::ExpressAddr* release_entity();
  inline void set_allocated_entity(::pp::ExpressAddr* entity);

  // optional uint32 productId = 3;
  inline bool has_productid() const;
  inline void clear_productid();
  static const int kProductIdFieldNumber = 3;
  inline ::google::protobuf::uint32 productid() const;
  inline void set_productid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserExpressAddrOpReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_entity();
  inline void clear_has_entity();
  inline void set_has_productid();
  inline void clear_has_productid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::ExpressAddr* entity_;
  int optype_;
  ::google::protobuf::uint32 productid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserExpressAddrOpReq* default_instance_;
};
// -------------------------------------------------------------------

class ExpressAddr : public ::google::protobuf::Message {
 public:
  ExpressAddr();
  virtual ~ExpressAddr();

  ExpressAddr(const ExpressAddr& from);

  inline ExpressAddr& operator=(const ExpressAddr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ExpressAddr& default_instance();

  void Swap(ExpressAddr* other);

  // implements Message ----------------------------------------------

  ExpressAddr* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string mobile = 3;
  inline bool has_mobile() const;
  inline void clear_mobile();
  static const int kMobileFieldNumber = 3;
  inline const ::std::string& mobile() const;
  inline void set_mobile(const ::std::string& value);
  inline void set_mobile(const char* value);
  inline void set_mobile(const char* value, size_t size);
  inline ::std::string* mutable_mobile();
  inline ::std::string* release_mobile();
  inline void set_allocated_mobile(::std::string* mobile);

  // optional string QQ = 4;
  inline bool has_qq() const;
  inline void clear_qq();
  static const int kQQFieldNumber = 4;
  inline const ::std::string& qq() const;
  inline void set_qq(const ::std::string& value);
  inline void set_qq(const char* value);
  inline void set_qq(const char* value, size_t size);
  inline ::std::string* mutable_qq();
  inline ::std::string* release_qq();
  inline void set_allocated_qq(::std::string* qq);

  // optional string address = 5;
  inline bool has_address() const;
  inline void clear_address();
  static const int kAddressFieldNumber = 5;
  inline const ::std::string& address() const;
  inline void set_address(const ::std::string& value);
  inline void set_address(const char* value);
  inline void set_address(const char* value, size_t size);
  inline ::std::string* mutable_address();
  inline ::std::string* release_address();
  inline void set_allocated_address(::std::string* address);

  // @@protoc_insertion_point(class_scope:pp.ExpressAddr)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_mobile();
  inline void clear_has_mobile();
  inline void set_has_qq();
  inline void clear_has_qq();
  inline void set_has_address();
  inline void clear_has_address();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* mobile_;
  ::std::string* qq_;
  ::std::string* address_;
  ::google::protobuf::uint32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ExpressAddr* default_instance_;
};
// -------------------------------------------------------------------

class UserExpressAddrOpRes : public ::google::protobuf::Message {
 public:
  UserExpressAddrOpRes();
  virtual ~UserExpressAddrOpRes();

  UserExpressAddrOpRes(const UserExpressAddrOpRes& from);

  inline UserExpressAddrOpRes& operator=(const UserExpressAddrOpRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserExpressAddrOpRes& default_instance();

  void Swap(UserExpressAddrOpRes* other);

  // implements Message ----------------------------------------------

  UserExpressAddrOpRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserExpressAddrOpRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserExpressAddrOpRes* default_instance_;
};
// -------------------------------------------------------------------

class UserThirdPartyAccountReq : public ::google::protobuf::Message {
 public:
  UserThirdPartyAccountReq();
  virtual ~UserThirdPartyAccountReq();

  UserThirdPartyAccountReq(const UserThirdPartyAccountReq& from);

  inline UserThirdPartyAccountReq& operator=(const UserThirdPartyAccountReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserThirdPartyAccountReq& default_instance();

  void Swap(UserThirdPartyAccountReq* other);

  // implements Message ----------------------------------------------

  UserThirdPartyAccountReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserThirdPartyAccountReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserThirdPartyAccountReq* default_instance_;
};
// -------------------------------------------------------------------

class UserThirdPartyAccountRes : public ::google::protobuf::Message {
 public:
  UserThirdPartyAccountRes();
  virtual ~UserThirdPartyAccountRes();

  UserThirdPartyAccountRes(const UserThirdPartyAccountRes& from);

  inline UserThirdPartyAccountRes& operator=(const UserThirdPartyAccountRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserThirdPartyAccountRes& default_instance();

  void Swap(UserThirdPartyAccountRes* other);

  // implements Message ----------------------------------------------

  UserThirdPartyAccountRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional .pp.AccountType accountType = 2;
  inline bool has_accounttype() const;
  inline void clear_accounttype();
  static const int kAccountTypeFieldNumber = 2;
  inline ::pp::AccountType accounttype() const;
  inline void set_accounttype(::pp::AccountType value);

  // optional uint64 thridPartyUid = 3;
  inline bool has_thridpartyuid() const;
  inline void clear_thridpartyuid();
  static const int kThridPartyUidFieldNumber = 3;
  inline ::google::protobuf::uint64 thridpartyuid() const;
  inline void set_thridpartyuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserThirdPartyAccountRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_accounttype();
  inline void clear_has_accounttype();
  inline void set_has_thridpartyuid();
  inline void clear_has_thridpartyuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 thridpartyuid_;
  int accounttype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserThirdPartyAccountRes* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgReq : public ::google::protobuf::Message {
 public:
  UserMsgReq();
  virtual ~UserMsgReq();

  UserMsgReq(const UserMsgReq& from);

  inline UserMsgReq& operator=(const UserMsgReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgReq& default_instance();

  void Swap(UserMsgReq* other);

  // implements Message ----------------------------------------------

  UserMsgReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 revision = 2;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 2;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional uint32 topn = 4;
  inline bool has_topn() const;
  inline void clear_topn();
  static const int kTopnFieldNumber = 4;
  inline ::google::protobuf::uint32 topn() const;
  inline void set_topn(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserMsgReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_topn();
  inline void clear_has_topn();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 topn_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgListReq : public ::google::protobuf::Message {
 public:
  UserMsgListReq();
  virtual ~UserMsgListReq();

  UserMsgListReq(const UserMsgListReq& from);

  inline UserMsgListReq& operator=(const UserMsgListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgListReq& default_instance();

  void Swap(UserMsgListReq* other);

  // implements Message ----------------------------------------------

  UserMsgListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserMsgReq users = 1;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 1;
  inline const ::pp::UserMsgReq& users(int index) const;
  inline ::pp::UserMsgReq* mutable_users(int index);
  inline ::pp::UserMsgReq* add_users();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserMsgReq >&
      users() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserMsgReq >*
      mutable_users();

  // optional bool newmsg = 2;
  inline bool has_newmsg() const;
  inline void clear_newmsg();
  static const int kNewmsgFieldNumber = 2;
  inline bool newmsg() const;
  inline void set_newmsg(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserMsgListReq)
 private:
  inline void set_has_newmsg();
  inline void clear_has_newmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserMsgReq > users_;
  bool newmsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgListReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMsg : public ::google::protobuf::Message {
 public:
  UserMsg();
  virtual ~UserMsg();

  UserMsg(const UserMsg& from);

  inline UserMsg& operator=(const UserMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsg& default_instance();

  void Swap(UserMsg* other);

  // implements Message ----------------------------------------------

  UserMsg* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional string message = 2;
  inline bool has_message() const;
  inline void clear_message();
  static const int kMessageFieldNumber = 2;
  inline const ::std::string& message() const;
  inline void set_message(const ::std::string& value);
  inline void set_message(const char* value);
  inline void set_message(const char* value, size_t size);
  inline ::std::string* mutable_message();
  inline ::std::string* release_message();
  inline void set_allocated_message(::std::string* message);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional .pp.UserMsgType msgtype = 5;
  inline bool has_msgtype() const;
  inline void clear_msgtype();
  static const int kMsgtypeFieldNumber = 5;
  inline ::pp::UserMsgType msgtype() const;
  inline void set_msgtype(::pp::UserMsgType value);

  // optional .pp.UserInfo userinfo = 6;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserinfoFieldNumber = 6;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional uint64 gid = 9;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 9;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional .pp.MessageContentType contentType = 10;
  inline bool has_contenttype() const;
  inline void clear_contenttype();
  static const int kContentTypeFieldNumber = 10;
  inline ::pp::MessageContentType contenttype() const;
  inline void set_contenttype(::pp::MessageContentType value);

  // optional int64 storetime = 11;
  inline bool has_storetime() const;
  inline void clear_storetime();
  static const int kStoretimeFieldNumber = 11;
  inline ::google::protobuf::int64 storetime() const;
  inline void set_storetime(::google::protobuf::int64 value);

  // optional uint64 destuid = 12;
  inline bool has_destuid() const;
  inline void clear_destuid();
  static const int kDestuidFieldNumber = 12;
  inline ::google::protobuf::uint64 destuid() const;
  inline void set_destuid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserMsg)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_message();
  inline void clear_has_message();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_msgtype();
  inline void clear_has_msgtype();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_contenttype();
  inline void clear_has_contenttype();
  inline void set_has_storetime();
  inline void clear_has_storetime();
  inline void set_has_destuid();
  inline void clear_has_destuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::std::string* message_;
  ::google::protobuf::int64 timestamp_;
  ::pp::UserInfo* userinfo_;
  int msgtype_;
  int contenttype_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::int64 storetime_;
  ::google::protobuf::uint64 destuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsg* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgList : public ::google::protobuf::Message {
 public:
  UserMsgList();
  virtual ~UserMsgList();

  UserMsgList(const UserMsgList& from);

  inline UserMsgList& operator=(const UserMsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgList& default_instance();

  void Swap(UserMsgList* other);

  // implements Message ----------------------------------------------

  UserMsgList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // repeated .pp.UserMsg msgs = 3;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 3;
  inline const ::pp::UserMsg& msgs(int index) const;
  inline ::pp::UserMsg* mutable_msgs(int index);
  inline ::pp::UserMsg* add_msgs();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserMsg >&
      msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserMsg >*
      mutable_msgs();

  // optional uint64 msgread = 4;
  inline bool has_msgread() const;
  inline void clear_msgread();
  static const int kMsgreadFieldNumber = 4;
  inline ::google::protobuf::uint64 msgread() const;
  inline void set_msgread(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UserMsgList)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_msgread();
  inline void clear_has_msgread();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserMsg > msgs_;
  ::google::protobuf::uint64 msgread_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgList* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgListRes : public ::google::protobuf::Message {
 public:
  UserMsgListRes();
  virtual ~UserMsgListRes();

  UserMsgListRes(const UserMsgListRes& from);

  inline UserMsgListRes& operator=(const UserMsgListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgListRes& default_instance();

  void Swap(UserMsgListRes* other);

  // implements Message ----------------------------------------------

  UserMsgListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.UserMsgList msglists = 1;
  inline int msglists_size() const;
  inline void clear_msglists();
  static const int kMsglistsFieldNumber = 1;
  inline const ::pp::UserMsgList& msglists(int index) const;
  inline ::pp::UserMsgList* mutable_msglists(int index);
  inline ::pp::UserMsgList* add_msglists();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserMsgList >&
      msglists() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserMsgList >*
      mutable_msglists();

  // optional bool newmsg = 2;
  inline bool has_newmsg() const;
  inline void clear_newmsg();
  static const int kNewmsgFieldNumber = 2;
  inline bool newmsg() const;
  inline void set_newmsg(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserMsgListRes)
 private:
  inline void set_has_newmsg();
  inline void clear_has_newmsg();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::UserMsgList > msglists_;
  bool newmsg_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgListRes* default_instance_;
};
// -------------------------------------------------------------------

class UidRange : public ::google::protobuf::Message {
 public:
  UidRange();
  virtual ~UidRange();

  UidRange(const UidRange& from);

  inline UidRange& operator=(const UidRange& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UidRange& default_instance();

  void Swap(UidRange* other);

  // implements Message ----------------------------------------------

  UidRange* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 startValue = 1;
  inline bool has_startvalue() const;
  inline void clear_startvalue();
  static const int kStartValueFieldNumber = 1;
  inline ::google::protobuf::uint64 startvalue() const;
  inline void set_startvalue(::google::protobuf::uint64 value);

  // optional uint64 stopValue = 2;
  inline bool has_stopvalue() const;
  inline void clear_stopvalue();
  static const int kStopValueFieldNumber = 2;
  inline ::google::protobuf::uint64 stopvalue() const;
  inline void set_stopvalue(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.UidRange)
 private:
  inline void set_has_startvalue();
  inline void clear_has_startvalue();
  inline void set_has_stopvalue();
  inline void clear_has_stopvalue();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 startvalue_;
  ::google::protobuf::uint64 stopvalue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UidRange* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgBroadcastReq : public ::google::protobuf::Message {
 public:
  UserMsgBroadcastReq();
  virtual ~UserMsgBroadcastReq();

  UserMsgBroadcastReq(const UserMsgBroadcastReq& from);

  inline UserMsgBroadcastReq& operator=(const UserMsgBroadcastReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgBroadcastReq& default_instance();

  void Swap(UserMsgBroadcastReq* other);

  // implements Message ----------------------------------------------

  UserMsgBroadcastReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserMsg msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::pp::UserMsg& msg() const;
  inline ::pp::UserMsg* mutable_msg();
  inline ::pp::UserMsg* release_msg();
  inline void set_allocated_msg(::pp::UserMsg* msg);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated .pp.UidRange uids = 3;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 3;
  inline const ::pp::UidRange& uids(int index) const;
  inline ::pp::UidRange* mutable_uids(int index);
  inline ::pp::UidRange* add_uids();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UidRange >&
      uids() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UidRange >*
      mutable_uids();

  // optional .pp.BroadcastRange brange = 4;
  inline bool has_brange() const;
  inline void clear_brange();
  static const int kBrangeFieldNumber = 4;
  inline ::pp::BroadcastRange brange() const;
  inline void set_brange(::pp::BroadcastRange value);

  // optional uint64 pushUid = 8;
  inline bool has_pushuid() const;
  inline void clear_pushuid();
  static const int kPushUidFieldNumber = 8;
  inline ::google::protobuf::uint64 pushuid() const;
  inline void set_pushuid(::google::protobuf::uint64 value);

  // optional uint32 event = 9;
  inline bool has_event() const;
  inline void clear_event();
  static const int kEventFieldNumber = 9;
  inline ::google::protobuf::uint32 event() const;
  inline void set_event(::google::protobuf::uint32 value);

  // optional int64 timelimit = 10;
  inline bool has_timelimit() const;
  inline void clear_timelimit();
  static const int kTimelimitFieldNumber = 10;
  inline ::google::protobuf::int64 timelimit() const;
  inline void set_timelimit(::google::protobuf::int64 value);

  // optional uint64 bid = 20;
  inline bool has_bid() const;
  inline void clear_bid();
  static const int kBidFieldNumber = 20;
  inline ::google::protobuf::uint64 bid() const;
  inline void set_bid(::google::protobuf::uint64 value);

  // optional bool realtime = 30;
  inline bool has_realtime() const;
  inline void clear_realtime();
  static const int kRealtimeFieldNumber = 30;
  inline bool realtime() const;
  inline void set_realtime(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserMsgBroadcastReq)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_brange();
  inline void clear_has_brange();
  inline void set_has_pushuid();
  inline void clear_has_pushuid();
  inline void set_has_event();
  inline void clear_has_event();
  inline void set_has_timelimit();
  inline void clear_has_timelimit();
  inline void set_has_bid();
  inline void clear_has_bid();
  inline void set_has_realtime();
  inline void clear_has_realtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserMsg* msg_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedPtrField< ::pp::UidRange > uids_;
  ::google::protobuf::uint64 pushuid_;
  int brange_;
  ::google::protobuf::uint32 event_;
  ::google::protobuf::int64 timelimit_;
  ::google::protobuf::uint64 bid_;
  bool realtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgBroadcastReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgRejectList : public ::google::protobuf::Message {
 public:
  UserMsgRejectList();
  virtual ~UserMsgRejectList();

  UserMsgRejectList(const UserMsgRejectList& from);

  inline UserMsgRejectList& operator=(const UserMsgRejectList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgRejectList& default_instance();

  void Swap(UserMsgRejectList* other);

  // implements Message ----------------------------------------------

  UserMsgRejectList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool all = 1;
  inline bool has_all() const;
  inline void clear_all();
  static const int kAllFieldNumber = 1;
  inline bool all() const;
  inline void set_all(bool value);

  // optional bool stranger = 2;
  inline bool has_stranger() const;
  inline void clear_stranger();
  static const int kStrangerFieldNumber = 2;
  inline bool stranger() const;
  inline void set_stranger(bool value);

  // optional bool newfan = 3;
  inline bool has_newfan() const;
  inline void clear_newfan();
  static const int kNewfanFieldNumber = 3;
  inline bool newfan() const;
  inline void set_newfan(bool value);

  // optional bool newgift = 4;
  inline bool has_newgift() const;
  inline void clear_newgift();
  static const int kNewgiftFieldNumber = 4;
  inline bool newgift() const;
  inline void set_newgift(bool value);

  // @@protoc_insertion_point(class_scope:pp.UserMsgRejectList)
 private:
  inline void set_has_all();
  inline void clear_has_all();
  inline void set_has_stranger();
  inline void clear_has_stranger();
  inline void set_has_newfan();
  inline void clear_has_newfan();
  inline void set_has_newgift();
  inline void clear_has_newgift();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool all_;
  bool stranger_;
  bool newfan_;
  bool newgift_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgRejectList* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgRejectListSetReq : public ::google::protobuf::Message {
 public:
  UserMsgRejectListSetReq();
  virtual ~UserMsgRejectListSetReq();

  UserMsgRejectListSetReq(const UserMsgRejectListSetReq& from);

  inline UserMsgRejectListSetReq& operator=(const UserMsgRejectListSetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgRejectListSetReq& default_instance();

  void Swap(UserMsgRejectListSetReq* other);

  // implements Message ----------------------------------------------

  UserMsgRejectListSetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserMsgRejectList rejectlist = 1;
  inline bool has_rejectlist() const;
  inline void clear_rejectlist();
  static const int kRejectlistFieldNumber = 1;
  inline const ::pp::UserMsgRejectList& rejectlist() const;
  inline ::pp::UserMsgRejectList* mutable_rejectlist();
  inline ::pp::UserMsgRejectList* release_rejectlist();
  inline void set_allocated_rejectlist(::pp::UserMsgRejectList* rejectlist);

  // @@protoc_insertion_point(class_scope:pp.UserMsgRejectListSetReq)
 private:
  inline void set_has_rejectlist();
  inline void clear_has_rejectlist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserMsgRejectList* rejectlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgRejectListSetReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgRejectListSetRes : public ::google::protobuf::Message {
 public:
  UserMsgRejectListSetRes();
  virtual ~UserMsgRejectListSetRes();

  UserMsgRejectListSetRes(const UserMsgRejectListSetRes& from);

  inline UserMsgRejectListSetRes& operator=(const UserMsgRejectListSetRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgRejectListSetRes& default_instance();

  void Swap(UserMsgRejectListSetRes* other);

  // implements Message ----------------------------------------------

  UserMsgRejectListSetRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserMsgRejectList rejectlist = 1;
  inline bool has_rejectlist() const;
  inline void clear_rejectlist();
  static const int kRejectlistFieldNumber = 1;
  inline const ::pp::UserMsgRejectList& rejectlist() const;
  inline ::pp::UserMsgRejectList* mutable_rejectlist();
  inline ::pp::UserMsgRejectList* release_rejectlist();
  inline void set_allocated_rejectlist(::pp::UserMsgRejectList* rejectlist);

  // @@protoc_insertion_point(class_scope:pp.UserMsgRejectListSetRes)
 private:
  inline void set_has_rejectlist();
  inline void clear_has_rejectlist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserMsgRejectList* rejectlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgRejectListSetRes* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgRejectListGetReq : public ::google::protobuf::Message {
 public:
  UserMsgRejectListGetReq();
  virtual ~UserMsgRejectListGetReq();

  UserMsgRejectListGetReq(const UserMsgRejectListGetReq& from);

  inline UserMsgRejectListGetReq& operator=(const UserMsgRejectListGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgRejectListGetReq& default_instance();

  void Swap(UserMsgRejectListGetReq* other);

  // implements Message ----------------------------------------------

  UserMsgRejectListGetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserMsgRejectListGetReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgRejectListGetReq* default_instance_;
};
// -------------------------------------------------------------------

class UserMsgRejectListGetRes : public ::google::protobuf::Message {
 public:
  UserMsgRejectListGetRes();
  virtual ~UserMsgRejectListGetRes();

  UserMsgRejectListGetRes(const UserMsgRejectListGetRes& from);

  inline UserMsgRejectListGetRes& operator=(const UserMsgRejectListGetRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserMsgRejectListGetRes& default_instance();

  void Swap(UserMsgRejectListGetRes* other);

  // implements Message ----------------------------------------------

  UserMsgRejectListGetRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserMsgRejectList rejectlist = 1;
  inline bool has_rejectlist() const;
  inline void clear_rejectlist();
  static const int kRejectlistFieldNumber = 1;
  inline const ::pp::UserMsgRejectList& rejectlist() const;
  inline ::pp::UserMsgRejectList* mutable_rejectlist();
  inline ::pp::UserMsgRejectList* release_rejectlist();
  inline void set_allocated_rejectlist(::pp::UserMsgRejectList* rejectlist);

  // @@protoc_insertion_point(class_scope:pp.UserMsgRejectListGetRes)
 private:
  inline void set_has_rejectlist();
  inline void clear_has_rejectlist();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserMsgRejectList* rejectlist_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserMsgRejectListGetRes* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadItem : public ::google::protobuf::Message {
 public:
  MsgReadItem();
  virtual ~MsgReadItem();

  MsgReadItem(const MsgReadItem& from);

  inline MsgReadItem& operator=(const MsgReadItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReadItem& default_instance();

  void Swap(MsgReadItem* other);

  // implements Message ----------------------------------------------

  MsgReadItem* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint64 revision = 3;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 3;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.MsgReadItem)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_revision();
  inline void clear_has_revision();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 revision_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgReadItem* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadRevisionSetReq : public ::google::protobuf::Message {
 public:
  MsgReadRevisionSetReq();
  virtual ~MsgReadRevisionSetReq();

  MsgReadRevisionSetReq(const MsgReadRevisionSetReq& from);

  inline MsgReadRevisionSetReq& operator=(const MsgReadRevisionSetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReadRevisionSetReq& default_instance();

  void Swap(MsgReadRevisionSetReq* other);

  // implements Message ----------------------------------------------

  MsgReadRevisionSetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.MsgReadItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::MsgReadItem& items(int index) const;
  inline ::pp::MsgReadItem* mutable_items(int index);
  inline ::pp::MsgReadItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.MsgReadRevisionSetReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgReadRevisionSetReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadRevisionSetRes : public ::google::protobuf::Message {
 public:
  MsgReadRevisionSetRes();
  virtual ~MsgReadRevisionSetRes();

  MsgReadRevisionSetRes(const MsgReadRevisionSetRes& from);

  inline MsgReadRevisionSetRes& operator=(const MsgReadRevisionSetRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReadRevisionSetRes& default_instance();

  void Swap(MsgReadRevisionSetRes* other);

  // implements Message ----------------------------------------------

  MsgReadRevisionSetRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.MsgReadItem items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::MsgReadItem& items(int index) const;
  inline ::pp::MsgReadItem* mutable_items(int index);
  inline ::pp::MsgReadItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.MsgReadRevisionSetRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgReadRevisionSetRes* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadRevisionGetReq : public ::google::protobuf::Message {
 public:
  MsgReadRevisionGetReq();
  virtual ~MsgReadRevisionGetReq();

  MsgReadRevisionGetReq(const MsgReadRevisionGetReq& from);

  inline MsgReadRevisionGetReq& operator=(const MsgReadRevisionGetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReadRevisionGetReq& default_instance();

  void Swap(MsgReadRevisionGetReq* other);

  // implements Message ----------------------------------------------

  MsgReadRevisionGetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool contact = 1 [default = true];
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 1;
  inline bool contact() const;
  inline void set_contact(bool value);

  // optional bool group = 2 [default = true];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline bool group() const;
  inline void set_group(bool value);

  // optional bool simple = 4 [default = false];
  inline bool has_simple() const;
  inline void clear_simple();
  static const int kSimpleFieldNumber = 4;
  inline bool simple() const;
  inline void set_simple(bool value);

  // @@protoc_insertion_point(class_scope:pp.MsgReadRevisionGetReq)
 private:
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_simple();
  inline void clear_has_simple();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool contact_;
  bool group_;
  bool simple_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgReadRevisionGetReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgReadRevisionGetRes : public ::google::protobuf::Message {
 public:
  MsgReadRevisionGetRes();
  virtual ~MsgReadRevisionGetRes();

  MsgReadRevisionGetRes(const MsgReadRevisionGetRes& from);

  inline MsgReadRevisionGetRes& operator=(const MsgReadRevisionGetRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgReadRevisionGetRes& default_instance();

  void Swap(MsgReadRevisionGetRes* other);

  // implements Message ----------------------------------------------

  MsgReadRevisionGetRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool contact = 1 [default = true];
  inline bool has_contact() const;
  inline void clear_contact();
  static const int kContactFieldNumber = 1;
  inline bool contact() const;
  inline void set_contact(bool value);

  // optional bool group = 2 [default = true];
  inline bool has_group() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline bool group() const;
  inline void set_group(bool value);

  // repeated .pp.MsgReadItem items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::pp::MsgReadItem& items(int index) const;
  inline ::pp::MsgReadItem* mutable_items(int index);
  inline ::pp::MsgReadItem* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >*
      mutable_items();

  // optional bool simple = 4 [default = false];
  inline bool has_simple() const;
  inline void clear_simple();
  static const int kSimpleFieldNumber = 4;
  inline bool simple() const;
  inline void set_simple(bool value);

  // @@protoc_insertion_point(class_scope:pp.MsgReadRevisionGetRes)
 private:
  inline void set_has_contact();
  inline void clear_has_contact();
  inline void set_has_group();
  inline void clear_has_group();
  inline void set_has_simple();
  inline void clear_has_simple();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem > items_;
  bool contact_;
  bool group_;
  bool simple_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgReadRevisionGetRes* default_instance_;
};
// -------------------------------------------------------------------

class MsgBroadcastQueryReq : public ::google::protobuf::Message {
 public:
  MsgBroadcastQueryReq();
  virtual ~MsgBroadcastQueryReq();

  MsgBroadcastQueryReq(const MsgBroadcastQueryReq& from);

  inline MsgBroadcastQueryReq& operator=(const MsgBroadcastQueryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgBroadcastQueryReq& default_instance();

  void Swap(MsgBroadcastQueryReq* other);

  // implements Message ----------------------------------------------

  MsgBroadcastQueryReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.MsgBroadcastQueryReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgBroadcastQueryReq* default_instance_;
};
// -------------------------------------------------------------------

class MsgBroadcastQuery : public ::google::protobuf::Message {
 public:
  MsgBroadcastQuery();
  virtual ~MsgBroadcastQuery();

  MsgBroadcastQuery(const MsgBroadcastQuery& from);

  inline MsgBroadcastQuery& operator=(const MsgBroadcastQuery& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgBroadcastQuery& default_instance();

  void Swap(MsgBroadcastQuery* other);

  // implements Message ----------------------------------------------

  MsgBroadcastQuery* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.UserMsgBroadcastReq msg = 1;
  inline bool has_msg() const;
  inline void clear_msg();
  static const int kMsgFieldNumber = 1;
  inline const ::pp::UserMsgBroadcastReq& msg() const;
  inline ::pp::UserMsgBroadcastReq* mutable_msg();
  inline ::pp::UserMsgBroadcastReq* release_msg();
  inline void set_allocated_msg(::pp::UserMsgBroadcastReq* msg);

  // required string msgTime = 2;
  inline bool has_msgtime() const;
  inline void clear_msgtime();
  static const int kMsgTimeFieldNumber = 2;
  inline const ::std::string& msgtime() const;
  inline void set_msgtime(const ::std::string& value);
  inline void set_msgtime(const char* value);
  inline void set_msgtime(const char* value, size_t size);
  inline ::std::string* mutable_msgtime();
  inline ::std::string* release_msgtime();
  inline void set_allocated_msgtime(::std::string* msgtime);

  // @@protoc_insertion_point(class_scope:pp.MsgBroadcastQuery)
 private:
  inline void set_has_msg();
  inline void clear_has_msg();
  inline void set_has_msgtime();
  inline void clear_has_msgtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserMsgBroadcastReq* msg_;
  ::std::string* msgtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgBroadcastQuery* default_instance_;
};
// -------------------------------------------------------------------

class MsgBroadcastQueryRes : public ::google::protobuf::Message {
 public:
  MsgBroadcastQueryRes();
  virtual ~MsgBroadcastQueryRes();

  MsgBroadcastQueryRes(const MsgBroadcastQueryRes& from);

  inline MsgBroadcastQueryRes& operator=(const MsgBroadcastQueryRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MsgBroadcastQueryRes& default_instance();

  void Swap(MsgBroadcastQueryRes* other);

  // implements Message ----------------------------------------------

  MsgBroadcastQueryRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // repeated .pp.MsgBroadcastQuery msgs = 3;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 3;
  inline const ::pp::MsgBroadcastQuery& msgs(int index) const;
  inline ::pp::MsgBroadcastQuery* mutable_msgs(int index);
  inline ::pp::MsgBroadcastQuery* add_msgs();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgBroadcastQuery >&
      msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::MsgBroadcastQuery >*
      mutable_msgs();

  // @@protoc_insertion_point(class_scope:pp.MsgBroadcastQueryRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::RepeatedPtrField< ::pp::MsgBroadcastQuery > msgs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static MsgBroadcastQueryRes* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianJoinReq : public ::google::protobuf::Message {
 public:
  WeiLianJoinReq();
  virtual ~WeiLianJoinReq();

  WeiLianJoinReq(const WeiLianJoinReq& from);

  inline WeiLianJoinReq& operator=(const WeiLianJoinReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianJoinReq& default_instance();

  void Swap(WeiLianJoinReq* other);

  // implements Message ----------------------------------------------

  WeiLianJoinReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline ::google::protobuf::uint32 req() const;
  inline void set_req(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianJoinReq)
 private:
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 req_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianJoinReq* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianJoinRes : public ::google::protobuf::Message {
 public:
  WeiLianJoinRes();
  virtual ~WeiLianJoinRes();

  WeiLianJoinRes(const WeiLianJoinRes& from);

  inline WeiLianJoinRes& operator=(const WeiLianJoinRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianJoinRes& default_instance();

  void Swap(WeiLianJoinRes* other);

  // implements Message ----------------------------------------------

  WeiLianJoinRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline ::google::protobuf::uint32 res() const;
  inline void set_res(::google::protobuf::uint32 value);

  // required uint32 resType = 2;
  inline bool has_restype() const;
  inline void clear_restype();
  static const int kResTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 restype() const;
  inline void set_restype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianJoinRes)
 private:
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_restype();
  inline void clear_has_restype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 res_;
  ::google::protobuf::uint32 restype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianJoinRes* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianGoddessRankReq : public ::google::protobuf::Message {
 public:
  WeiLianGoddessRankReq();
  virtual ~WeiLianGoddessRankReq();

  WeiLianGoddessRankReq(const WeiLianGoddessRankReq& from);

  inline WeiLianGoddessRankReq& operator=(const WeiLianGoddessRankReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianGoddessRankReq& default_instance();

  void Swap(WeiLianGoddessRankReq* other);

  // implements Message ----------------------------------------------

  WeiLianGoddessRankReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianGoddessRankReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianGoddessRankReq* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianGoddess : public ::google::protobuf::Message {
 public:
  WeiLianGoddess();
  virtual ~WeiLianGoddess();

  WeiLianGoddess(const WeiLianGoddess& from);

  inline WeiLianGoddess& operator=(const WeiLianGoddess& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianGoddess& default_instance();

  void Swap(WeiLianGoddess* other);

  // implements Message ----------------------------------------------

  WeiLianGoddess* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // required uint32 ticketNum = 4;
  inline bool has_ticketnum() const;
  inline void clear_ticketnum();
  static const int kTicketNumFieldNumber = 4;
  inline ::google::protobuf::uint32 ticketnum() const;
  inline void set_ticketnum(::google::protobuf::uint32 value);

  // required uint32 myVote = 5;
  inline bool has_myvote() const;
  inline void clear_myvote();
  static const int kMyVoteFieldNumber = 5;
  inline ::google::protobuf::uint32 myvote() const;
  inline void set_myvote(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianGoddess)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_ticketnum();
  inline void clear_has_ticketnum();
  inline void set_has_myvote();
  inline void clear_has_myvote();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* name_;
  ::std::string* url_;
  ::google::protobuf::uint32 ticketnum_;
  ::google::protobuf::uint32 myvote_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianGoddess* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianGoddessRankRes : public ::google::protobuf::Message {
 public:
  WeiLianGoddessRankRes();
  virtual ~WeiLianGoddessRankRes();

  WeiLianGoddessRankRes(const WeiLianGoddessRankRes& from);

  inline WeiLianGoddessRankRes& operator=(const WeiLianGoddessRankRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianGoddessRankRes& default_instance();

  void Swap(WeiLianGoddessRankRes* other);

  // implements Message ----------------------------------------------

  WeiLianGoddessRankRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // repeated .pp.WeiLianGoddess res = 3;
  inline int res_size() const;
  inline void clear_res();
  static const int kResFieldNumber = 3;
  inline const ::pp::WeiLianGoddess& res(int index) const;
  inline ::pp::WeiLianGoddess* mutable_res(int index);
  inline ::pp::WeiLianGoddess* add_res();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::WeiLianGoddess >&
      res() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::WeiLianGoddess >*
      mutable_res();

  // @@protoc_insertion_point(class_scope:pp.WeiLianGoddessRankRes)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::RepeatedPtrField< ::pp::WeiLianGoddess > res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianGoddessRankRes* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianSearchReq : public ::google::protobuf::Message {
 public:
  WeiLianSearchReq();
  virtual ~WeiLianSearchReq();

  WeiLianSearchReq(const WeiLianSearchReq& from);

  inline WeiLianSearchReq& operator=(const WeiLianSearchReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianSearchReq& default_instance();

  void Swap(WeiLianSearchReq* other);

  // implements Message ----------------------------------------------

  WeiLianSearchReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianSearchReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianSearchReq* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianSearchRes : public ::google::protobuf::Message {
 public:
  WeiLianSearchRes();
  virtual ~WeiLianSearchRes();

  WeiLianSearchRes(const WeiLianSearchRes& from);

  inline WeiLianSearchRes& operator=(const WeiLianSearchRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianSearchRes& default_instance();

  void Swap(WeiLianSearchRes* other);

  // implements Message ----------------------------------------------

  WeiLianSearchRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .pp.WeiLianGoddess res = 1;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 1;
  inline const ::pp::WeiLianGoddess& res() const;
  inline ::pp::WeiLianGoddess* mutable_res();
  inline ::pp::WeiLianGoddess* release_res();
  inline void set_allocated_res(::pp::WeiLianGoddess* res);

  // @@protoc_insertion_point(class_scope:pp.WeiLianSearchRes)
 private:
  inline void set_has_res();
  inline void clear_has_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::WeiLianGoddess* res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianSearchRes* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianVoteReq : public ::google::protobuf::Message {
 public:
  WeiLianVoteReq();
  virtual ~WeiLianVoteReq();

  WeiLianVoteReq(const WeiLianVoteReq& from);

  inline WeiLianVoteReq& operator=(const WeiLianVoteReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianVoteReq& default_instance();

  void Swap(WeiLianVoteReq* other);

  // implements Message ----------------------------------------------

  WeiLianVoteReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianVoteReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianVoteReq* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianVoteRes : public ::google::protobuf::Message {
 public:
  WeiLianVoteRes();
  virtual ~WeiLianVoteRes();

  WeiLianVoteRes(const WeiLianVoteRes& from);

  inline WeiLianVoteRes& operator=(const WeiLianVoteRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianVoteRes& default_instance();

  void Swap(WeiLianVoteRes* other);

  // implements Message ----------------------------------------------

  WeiLianVoteRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 res = 2;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 2;
  inline ::google::protobuf::uint32 res() const;
  inline void set_res(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianVoteRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_res();
  inline void clear_has_res();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 res_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianVoteRes* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianMyRankReq : public ::google::protobuf::Message {
 public:
  WeiLianMyRankReq();
  virtual ~WeiLianMyRankReq();

  WeiLianMyRankReq(const WeiLianMyRankReq& from);

  inline WeiLianMyRankReq& operator=(const WeiLianMyRankReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianMyRankReq& default_instance();

  void Swap(WeiLianMyRankReq* other);

  // implements Message ----------------------------------------------

  WeiLianMyRankReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 req = 1;
  inline bool has_req() const;
  inline void clear_req();
  static const int kReqFieldNumber = 1;
  inline ::google::protobuf::uint64 req() const;
  inline void set_req(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianMyRankReq)
 private:
  inline void set_has_req();
  inline void clear_has_req();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 req_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianMyRankReq* default_instance_;
};
// -------------------------------------------------------------------

class WeiLianMyRankRes : public ::google::protobuf::Message {
 public:
  WeiLianMyRankRes();
  virtual ~WeiLianMyRankRes();

  WeiLianMyRankRes(const WeiLianMyRankRes& from);

  inline WeiLianMyRankRes& operator=(const WeiLianMyRankRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WeiLianMyRankRes& default_instance();

  void Swap(WeiLianMyRankRes* other);

  // implements Message ----------------------------------------------

  WeiLianMyRankRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string url = 3;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 3;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // required uint32 ticketNum = 4;
  inline bool has_ticketnum() const;
  inline void clear_ticketnum();
  static const int kTicketNumFieldNumber = 4;
  inline ::google::protobuf::uint32 ticketnum() const;
  inline void set_ticketnum(::google::protobuf::uint32 value);

  // required uint32 myRank = 5;
  inline bool has_myrank() const;
  inline void clear_myrank();
  static const int kMyRankFieldNumber = 5;
  inline ::google::protobuf::uint32 myrank() const;
  inline void set_myrank(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.WeiLianMyRankRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_ticketnum();
  inline void clear_has_ticketnum();
  inline void set_has_myrank();
  inline void clear_has_myrank();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* name_;
  ::std::string* url_;
  ::google::protobuf::uint32 ticketnum_;
  ::google::protobuf::uint32 myrank_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WeiLianMyRankRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupOwnerTransferReq : public ::google::protobuf::Message {
 public:
  GroupOwnerTransferReq();
  virtual ~GroupOwnerTransferReq();

  GroupOwnerTransferReq(const GroupOwnerTransferReq& from);

  inline GroupOwnerTransferReq& operator=(const GroupOwnerTransferReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupOwnerTransferReq& default_instance();

  void Swap(GroupOwnerTransferReq* other);

  // implements Message ----------------------------------------------

  GroupOwnerTransferReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 newUid = 2;
  inline bool has_newuid() const;
  inline void clear_newuid();
  static const int kNewUidFieldNumber = 2;
  inline ::google::protobuf::uint64 newuid() const;
  inline void set_newuid(::google::protobuf::uint64 value);

  // optional string newNick = 3;
  inline bool has_newnick() const;
  inline void clear_newnick();
  static const int kNewNickFieldNumber = 3;
  inline const ::std::string& newnick() const;
  inline void set_newnick(const ::std::string& value);
  inline void set_newnick(const char* value);
  inline void set_newnick(const char* value, size_t size);
  inline ::std::string* mutable_newnick();
  inline ::std::string* release_newnick();
  inline void set_allocated_newnick(::std::string* newnick);

  // @@protoc_insertion_point(class_scope:pp.GroupOwnerTransferReq)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_newuid();
  inline void clear_has_newuid();
  inline void set_has_newnick();
  inline void clear_has_newnick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 newuid_;
  ::std::string* newnick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupOwnerTransferReq* default_instance_;
};
// -------------------------------------------------------------------

class TopicListReq : public ::google::protobuf::Message {
 public:
  TopicListReq();
  virtual ~TopicListReq();

  TopicListReq(const TopicListReq& from);

  inline TopicListReq& operator=(const TopicListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicListReq& default_instance();

  void Swap(TopicListReq* other);

  // implements Message ----------------------------------------------

  TopicListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 3;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 3;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // optional .pp.GroupMemberRoler roler = 5;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 5;
  inline ::pp::GroupMemberRoler roler() const;
  inline void set_roler(::pp::GroupMemberRoler value);

  // optional .pp.GroupType grouptype = 6;
  inline bool has_grouptype() const;
  inline void clear_grouptype();
  static const int kGrouptypeFieldNumber = 6;
  inline ::pp::GroupType grouptype() const;
  inline void set_grouptype(::pp::GroupType value);

  // optional bool latest = 7;
  inline bool has_latest() const;
  inline void clear_latest();
  static const int kLatestFieldNumber = 7;
  inline bool latest() const;
  inline void set_latest(bool value);

  // @@protoc_insertion_point(class_scope:pp.TopicListReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_roler();
  inline void clear_has_roler();
  inline void set_has_grouptype();
  inline void clear_has_grouptype();
  inline void set_has_latest();
  inline void clear_has_latest();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  int roler_;
  int grouptype_;
  bool latest_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static TopicListReq* default_instance_;
};
// -------------------------------------------------------------------

class TopicListRes : public ::google::protobuf::Message {
 public:
  TopicListRes();
  virtual ~TopicListRes();

  TopicListRes(const TopicListRes& from);

  inline TopicListRes& operator=(const TopicListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopicListRes& default_instance();

  void Swap(TopicListRes* other);

  // implements Message ----------------------------------------------

  TopicListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 totalresults = 2;
  inline bool has_totalresults() const;
  inline void clear_totalresults();
  static const int kTotalresultsFieldNumber = 2;
  inline ::google::protobuf::uint32 totalresults() const;
  inline void set_totalresults(::google::protobuf::uint32 value);

  // required uint32 index = 3;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 3;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // repeated .pp.GroupInfo groups = 4;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 4;
  inline const ::pp::GroupInfo& groups(int index) const;
  inline ::pp::GroupInfo* mutable_groups(int index);
  inline ::pp::GroupInfo* add_groups();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
      groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
      mutable_groups();

  // optional .pp.GroupMemberRoler roler = 5;
  inline bool has_roler() const;
  inline void clear_roler();
  static const int kRolerFieldNumber = 5;
  inline ::pp::GroupMemberRoler roler() const;
  inline void set_roler(::pp::GroupMemberRoler value);

  // optional .pp.GroupType grouptype = 6;
  inline bool has_grouptype() const;
  inline void clear_grouptype();
  static const int kGrouptypeFieldNumber = 6;
  inline ::pp::GroupType grouptype() const;
  inline void set_grouptype(::pp::GroupType value);

  // optional uint32 latestNum = 8;
  inline bool has_latestnum() const;
  inline void clear_latestnum();
  static const int kLatestNumFieldNumber = 8;
  inline ::google::protobuf::uint32 latestnum() const;
  inline void set_latestnum(::google::protobuf::uint32 value);

  // optional uint32 fetchs = 9;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 9;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.TopicListRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_totalresults();
  inline void clear_has_totalresults();
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_roler();
  inline void clear_has_roler();
  inline void set_has_grouptype();
  inline void clear_has_grouptype();
  inline void set_has_latestnum();
  inline void clear_has_latestnum();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 totalresults_;
  ::google::protobuf::uint32 index_;
  ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo > groups_;
  int roler_;
  int grouptype_;
  ::google::protobuf::uint32 latestnum_;
  ::google::protobuf::uint32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static TopicListRes* default_instance_;
};
// -------------------------------------------------------------------

class WebQRCodeScanReq : public ::google::protobuf::Message {
 public:
  WebQRCodeScanReq();
  virtual ~WebQRCodeScanReq();

  WebQRCodeScanReq(const WebQRCodeScanReq& from);

  inline WebQRCodeScanReq& operator=(const WebQRCodeScanReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebQRCodeScanReq& default_instance();

  void Swap(WebQRCodeScanReq* other);

  // implements Message ----------------------------------------------

  WebQRCodeScanReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // @@protoc_insertion_point(class_scope:pp.WebQRCodeScanReq)
 private:
  inline void set_has_url();
  inline void clear_has_url();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WebQRCodeScanReq* default_instance_;
};
// -------------------------------------------------------------------

class WebTokenVerifyReq : public ::google::protobuf::Message {
 public:
  WebTokenVerifyReq();
  virtual ~WebTokenVerifyReq();

  WebTokenVerifyReq(const WebTokenVerifyReq& from);

  inline WebTokenVerifyReq& operator=(const WebTokenVerifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebTokenVerifyReq& default_instance();

  void Swap(WebTokenVerifyReq* other);

  // implements Message ----------------------------------------------

  WebTokenVerifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string token = 1;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 1;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:pp.WebTokenVerifyReq)
 private:
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WebTokenVerifyReq* default_instance_;
};
// -------------------------------------------------------------------

class SysParamSetReq : public ::google::protobuf::Message {
 public:
  SysParamSetReq();
  virtual ~SysParamSetReq();

  SysParamSetReq(const SysParamSetReq& from);

  inline SysParamSetReq& operator=(const SysParamSetReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SysParamSetReq& default_instance();

  void Swap(SysParamSetReq* other);

  // implements Message ----------------------------------------------

  SysParamSetReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:pp.SysParamSetReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static SysParamSetReq* default_instance_;
};
// -------------------------------------------------------------------

class CoinStatItem : public ::google::protobuf::Message {
 public:
  CoinStatItem();
  virtual ~CoinStatItem();

  CoinStatItem(const CoinStatItem& from);

  inline CoinStatItem& operator=(const CoinStatItem& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinStatItem& default_instance();

  void Swap(CoinStatItem* other);

  // implements Message ----------------------------------------------

  CoinStatItem* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional int64 timestamp = 3;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 3;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // optional string ext = 4;
  inline bool has_ext() const;
  inline void clear_ext();
  static const int kExtFieldNumber = 4;
  inline const ::std::string& ext() const;
  inline void set_ext(const ::std::string& value);
  inline void set_ext(const char* value);
  inline void set_ext(const char* value, size_t size);
  inline ::std::string* mutable_ext();
  inline ::std::string* release_ext();
  inline void set_allocated_ext(::std::string* ext);

  // @@protoc_insertion_point(class_scope:pp.CoinStatItem)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_ext();
  inline void clear_has_ext();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 coins_;
  ::google::protobuf::int64 timestamp_;
  ::std::string* ext_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoinStatItem* default_instance_;
};
// -------------------------------------------------------------------

class UserCoinStatReq : public ::google::protobuf::Message {
 public:
  UserCoinStatReq();
  virtual ~UserCoinStatReq();

  UserCoinStatReq(const UserCoinStatReq& from);

  inline UserCoinStatReq& operator=(const UserCoinStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCoinStatReq& default_instance();

  void Swap(UserCoinStatReq* other);

  // implements Message ----------------------------------------------

  UserCoinStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 seconds = 2;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserCoinStatReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserCoinStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserCoinStatRes : public ::google::protobuf::Message {
 public:
  UserCoinStatRes();
  virtual ~UserCoinStatRes();

  UserCoinStatRes(const UserCoinStatRes& from);

  inline UserCoinStatRes& operator=(const UserCoinStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCoinStatRes& default_instance();

  void Swap(UserCoinStatRes* other);

  // implements Message ----------------------------------------------

  UserCoinStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 seconds = 2;
  inline bool has_seconds() const;
  inline void clear_seconds();
  static const int kSecondsFieldNumber = 2;
  inline ::google::protobuf::uint32 seconds() const;
  inline void set_seconds(::google::protobuf::uint32 value);

  // repeated .pp.CoinStatItem incomeItems = 5;
  inline int incomeitems_size() const;
  inline void clear_incomeitems();
  static const int kIncomeItemsFieldNumber = 5;
  inline const ::pp::CoinStatItem& incomeitems(int index) const;
  inline ::pp::CoinStatItem* mutable_incomeitems(int index);
  inline ::pp::CoinStatItem* add_incomeitems();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >&
      incomeitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >*
      mutable_incomeitems();

  // repeated .pp.CoinStatItem consumeItems = 6;
  inline int consumeitems_size() const;
  inline void clear_consumeitems();
  static const int kConsumeItemsFieldNumber = 6;
  inline const ::pp::CoinStatItem& consumeitems(int index) const;
  inline ::pp::CoinStatItem* mutable_consumeitems(int index);
  inline ::pp::CoinStatItem* add_consumeitems();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >&
      consumeitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >*
      mutable_consumeitems();

  // repeated .pp.CoinStatItem topupItems = 7;
  inline int topupitems_size() const;
  inline void clear_topupitems();
  static const int kTopupItemsFieldNumber = 7;
  inline const ::pp::CoinStatItem& topupitems(int index) const;
  inline ::pp::CoinStatItem* mutable_topupitems(int index);
  inline ::pp::CoinStatItem* add_topupitems();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >&
      topupitems() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >*
      mutable_topupitems();

  // @@protoc_insertion_point(class_scope:pp.UserCoinStatRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_seconds();
  inline void clear_has_seconds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem > incomeitems_;
  ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem > consumeitems_;
  ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem > topupitems_;
  ::google::protobuf::uint32 seconds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserCoinStatRes* default_instance_;
};
// -------------------------------------------------------------------

class UserAllStatReq : public ::google::protobuf::Message {
 public:
  UserAllStatReq();
  virtual ~UserAllStatReq();

  UserAllStatReq(const UserAllStatReq& from);

  inline UserAllStatReq& operator=(const UserAllStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAllStatReq& default_instance();

  void Swap(UserAllStatReq* other);

  // implements Message ----------------------------------------------

  UserAllStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserAllStatReq)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserAllStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserAllStatRes : public ::google::protobuf::Message {
 public:
  UserAllStatRes();
  virtual ~UserAllStatRes();

  UserAllStatRes(const UserAllStatRes& from);

  inline UserAllStatRes& operator=(const UserAllStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserAllStatRes& default_instance();

  void Swap(UserAllStatRes* other);

  // implements Message ----------------------------------------------

  UserAllStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // repeated .pp.FromStoreItems items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::pp::FromStoreItems& items(int index) const;
  inline ::pp::FromStoreItems* mutable_items(int index);
  inline ::pp::FromStoreItems* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserAllStatRes)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserAllStatRes* default_instance_;
};
// -------------------------------------------------------------------

class GroupMembersStat : public ::google::protobuf::Message {
 public:
  GroupMembersStat();
  virtual ~GroupMembersStat();

  GroupMembersStat(const GroupMembersStat& from);

  inline GroupMembersStat& operator=(const GroupMembersStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMembersStat& default_instance();

  void Swap(GroupMembersStat* other);

  // implements Message ----------------------------------------------

  GroupMembersStat* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string statTime = 1;
  inline bool has_stattime() const;
  inline void clear_stattime();
  static const int kStatTimeFieldNumber = 1;
  inline const ::std::string& stattime() const;
  inline void set_stattime(const ::std::string& value);
  inline void set_stattime(const char* value);
  inline void set_stattime(const char* value, size_t size);
  inline ::std::string* mutable_stattime();
  inline ::std::string* release_stattime();
  inline void set_allocated_stattime(::std::string* stattime);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 gid = 3;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 3;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 categoryid = 4;
  inline bool has_categoryid() const;
  inline void clear_categoryid();
  static const int kCategoryidFieldNumber = 4;
  inline ::google::protobuf::uint64 categoryid() const;
  inline void set_categoryid(::google::protobuf::uint64 value);

  // optional uint64 locked = 5;
  inline bool has_locked() const;
  inline void clear_locked();
  static const int kLockedFieldNumber = 5;
  inline ::google::protobuf::uint64 locked() const;
  inline void set_locked(::google::protobuf::uint64 value);

  // optional uint64 sortorder = 6;
  inline bool has_sortorder() const;
  inline void clear_sortorder();
  static const int kSortorderFieldNumber = 6;
  inline ::google::protobuf::uint64 sortorder() const;
  inline void set_sortorder(::google::protobuf::uint64 value);

  // optional string members = 7;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 7;
  inline const ::std::string& members() const;
  inline void set_members(const ::std::string& value);
  inline void set_members(const char* value);
  inline void set_members(const char* value, size_t size);
  inline ::std::string* mutable_members();
  inline ::std::string* release_members();
  inline void set_allocated_members(::std::string* members);

  // @@protoc_insertion_point(class_scope:pp.GroupMembersStat)
 private:
  inline void set_has_stattime();
  inline void clear_has_stattime();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_categoryid();
  inline void clear_has_categoryid();
  inline void set_has_locked();
  inline void clear_has_locked();
  inline void set_has_sortorder();
  inline void clear_has_sortorder();
  inline void set_has_members();
  inline void clear_has_members();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stattime_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 categoryid_;
  ::google::protobuf::uint64 locked_;
  ::google::protobuf::uint64 sortorder_;
  ::std::string* members_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMembersStat* default_instance_;
};
// -------------------------------------------------------------------

class GroupMembersStatReq : public ::google::protobuf::Message {
 public:
  GroupMembersStatReq();
  virtual ~GroupMembersStatReq();

  GroupMembersStatReq(const GroupMembersStatReq& from);

  inline GroupMembersStatReq& operator=(const GroupMembersStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMembersStatReq& default_instance();

  void Swap(GroupMembersStatReq* other);

  // implements Message ----------------------------------------------

  GroupMembersStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional sint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.GroupMembersStatReq)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMembersStatReq* default_instance_;
};
// -------------------------------------------------------------------

class GroupMembersStatRes : public ::google::protobuf::Message {
 public:
  GroupMembersStatRes();
  virtual ~GroupMembersStatRes();

  GroupMembersStatRes(const GroupMembersStatRes& from);

  inline GroupMembersStatRes& operator=(const GroupMembersStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroupMembersStatRes& default_instance();

  void Swap(GroupMembersStatRes* other);

  // implements Message ----------------------------------------------

  GroupMembersStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.GroupMembersStat items = 2;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 2;
  inline const ::pp::GroupMembersStat& items(int index) const;
  inline ::pp::GroupMembersStat* mutable_items(int index);
  inline ::pp::GroupMembersStat* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMembersStat >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMembersStat >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.GroupMembersStatRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::GroupMembersStat > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static GroupMembersStatRes* default_instance_;
};
// -------------------------------------------------------------------

class DailyTaskList : public ::google::protobuf::Message {
 public:
  DailyTaskList();
  virtual ~DailyTaskList();

  DailyTaskList(const DailyTaskList& from);

  inline DailyTaskList& operator=(const DailyTaskList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyTaskList& default_instance();

  void Swap(DailyTaskList* other);

  // implements Message ----------------------------------------------

  DailyTaskList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 countComplete = 2;
  inline bool has_countcomplete() const;
  inline void clear_countcomplete();
  static const int kCountCompleteFieldNumber = 2;
  inline ::google::protobuf::uint32 countcomplete() const;
  inline void set_countcomplete(::google::protobuf::uint32 value);

  // required uint32 countMembers = 3;
  inline bool has_countmembers() const;
  inline void clear_countmembers();
  static const int kCountMembersFieldNumber = 3;
  inline ::google::protobuf::uint32 countmembers() const;
  inline void set_countmembers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.DailyTaskList)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_countcomplete();
  inline void clear_has_countcomplete();
  inline void set_has_countmembers();
  inline void clear_has_countmembers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 countcomplete_;
  ::google::protobuf::uint32 countmembers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static DailyTaskList* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskCompleteStatReq : public ::google::protobuf::Message {
 public:
  UserTaskCompleteStatReq();
  virtual ~UserTaskCompleteStatReq();

  UserTaskCompleteStatReq(const UserTaskCompleteStatReq& from);

  inline UserTaskCompleteStatReq& operator=(const UserTaskCompleteStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskCompleteStatReq& default_instance();

  void Swap(UserTaskCompleteStatReq* other);

  // implements Message ----------------------------------------------

  UserTaskCompleteStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional sint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserTaskCompleteStatReq)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskCompleteStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTaskCompleteStatRes : public ::google::protobuf::Message {
 public:
  UserTaskCompleteStatRes();
  virtual ~UserTaskCompleteStatRes();

  UserTaskCompleteStatRes(const UserTaskCompleteStatRes& from);

  inline UserTaskCompleteStatRes& operator=(const UserTaskCompleteStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTaskCompleteStatRes& default_instance();

  void Swap(UserTaskCompleteStatRes* other);

  // implements Message ----------------------------------------------

  UserTaskCompleteStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startDate = 1;
  inline bool has_startdate() const;
  inline void clear_startdate();
  static const int kStartDateFieldNumber = 1;
  inline const ::std::string& startdate() const;
  inline void set_startdate(const ::std::string& value);
  inline void set_startdate(const char* value);
  inline void set_startdate(const char* value, size_t size);
  inline ::std::string* mutable_startdate();
  inline ::std::string* release_startdate();
  inline void set_allocated_startdate(::std::string* startdate);

  // optional string endDate = 2;
  inline bool has_enddate() const;
  inline void clear_enddate();
  static const int kEndDateFieldNumber = 2;
  inline const ::std::string& enddate() const;
  inline void set_enddate(const ::std::string& value);
  inline void set_enddate(const char* value);
  inline void set_enddate(const char* value, size_t size);
  inline ::std::string* mutable_enddate();
  inline ::std::string* release_enddate();
  inline void set_allocated_enddate(::std::string* enddate);

  // repeated .pp.DailyTaskList items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::pp::DailyTaskList& items(int index) const;
  inline ::pp::DailyTaskList* mutable_items(int index);
  inline ::pp::DailyTaskList* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskList >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskList >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserTaskCompleteStatRes)
 private:
  inline void set_has_startdate();
  inline void clear_has_startdate();
  inline void set_has_enddate();
  inline void clear_has_enddate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* startdate_;
  ::std::string* enddate_;
  ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskList > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTaskCompleteStatRes* default_instance_;
};
// -------------------------------------------------------------------

class FromStoreItems : public ::google::protobuf::Message {
 public:
  FromStoreItems();
  virtual ~FromStoreItems();

  FromStoreItems(const FromStoreItems& from);

  inline FromStoreItems& operator=(const FromStoreItems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FromStoreItems& default_instance();

  void Swap(FromStoreItems* other);

  // implements Message ----------------------------------------------

  FromStoreItems* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string fromStore = 1;
  inline bool has_fromstore() const;
  inline void clear_fromstore();
  static const int kFromStoreFieldNumber = 1;
  inline const ::std::string& fromstore() const;
  inline void set_fromstore(const ::std::string& value);
  inline void set_fromstore(const char* value);
  inline void set_fromstore(const char* value, size_t size);
  inline ::std::string* mutable_fromstore();
  inline ::std::string* release_fromstore();
  inline void set_allocated_fromstore(::std::string* fromstore);

  // required uint32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.FromStoreItems)
 private:
  inline void set_has_fromstore();
  inline void clear_has_fromstore();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* fromstore_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static FromStoreItems* default_instance_;
};
// -------------------------------------------------------------------

class UserNewStatReq : public ::google::protobuf::Message {
 public:
  UserNewStatReq();
  virtual ~UserNewStatReq();

  UserNewStatReq(const UserNewStatReq& from);

  inline UserNewStatReq& operator=(const UserNewStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserNewStatReq& default_instance();

  void Swap(UserNewStatReq* other);

  // implements Message ----------------------------------------------

  UserNewStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional sint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserNewStatReq)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserNewStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserNewStatRes : public ::google::protobuf::Message {
 public:
  UserNewStatRes();
  virtual ~UserNewStatRes();

  UserNewStatRes(const UserNewStatRes& from);

  inline UserNewStatRes& operator=(const UserNewStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserNewStatRes& default_instance();

  void Swap(UserNewStatRes* other);

  // implements Message ----------------------------------------------

  UserNewStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional sint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // repeated .pp.FromStoreItems items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::pp::FromStoreItems& items(int index) const;
  inline ::pp::FromStoreItems* mutable_items(int index);
  inline ::pp::FromStoreItems* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserNewStatRes)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;
  ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserNewStatRes* default_instance_;
};
// -------------------------------------------------------------------

class UserLevelStatReq : public ::google::protobuf::Message {
 public:
  UserLevelStatReq();
  virtual ~UserLevelStatReq();

  UserLevelStatReq(const UserLevelStatReq& from);

  inline UserLevelStatReq& operator=(const UserLevelStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLevelStatReq& default_instance();

  void Swap(UserLevelStatReq* other);

  // implements Message ----------------------------------------------

  UserLevelStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.UserLevelStatReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLevelStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserLevelStatRes : public ::google::protobuf::Message {
 public:
  UserLevelStatRes();
  virtual ~UserLevelStatRes();

  UserLevelStatRes(const UserLevelStatRes& from);

  inline UserLevelStatRes& operator=(const UserLevelStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLevelStatRes& default_instance();

  void Swap(UserLevelStatRes* other);

  // implements Message ----------------------------------------------

  UserLevelStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.LevelNumberItems charmLevel = 1;
  inline int charmlevel_size() const;
  inline void clear_charmlevel();
  static const int kCharmLevelFieldNumber = 1;
  inline const ::pp::LevelNumberItems& charmlevel(int index) const;
  inline ::pp::LevelNumberItems* mutable_charmlevel(int index);
  inline ::pp::LevelNumberItems* add_charmlevel();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >&
      charmlevel() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >*
      mutable_charmlevel();

  // repeated .pp.LevelNumberItems worthLevel = 2;
  inline int worthlevel_size() const;
  inline void clear_worthlevel();
  static const int kWorthLevelFieldNumber = 2;
  inline const ::pp::LevelNumberItems& worthlevel(int index) const;
  inline ::pp::LevelNumberItems* mutable_worthlevel(int index);
  inline ::pp::LevelNumberItems* add_worthlevel();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >&
      worthlevel() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >*
      mutable_worthlevel();

  // repeated .pp.LevelNumberItems passionLevel = 3;
  inline int passionlevel_size() const;
  inline void clear_passionlevel();
  static const int kPassionLevelFieldNumber = 3;
  inline const ::pp::LevelNumberItems& passionlevel(int index) const;
  inline ::pp::LevelNumberItems* mutable_passionlevel(int index);
  inline ::pp::LevelNumberItems* add_passionlevel();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >&
      passionlevel() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >*
      mutable_passionlevel();

  // @@protoc_insertion_point(class_scope:pp.UserLevelStatRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems > charmlevel_;
  ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems > worthlevel_;
  ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems > passionlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLevelStatRes* default_instance_;
};
// -------------------------------------------------------------------

class LevelNumberItems : public ::google::protobuf::Message {
 public:
  LevelNumberItems();
  virtual ~LevelNumberItems();

  LevelNumberItems(const LevelNumberItems& from);

  inline LevelNumberItems& operator=(const LevelNumberItems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LevelNumberItems& default_instance();

  void Swap(LevelNumberItems* other);

  // implements Message ----------------------------------------------

  LevelNumberItems* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 level = 1;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 1;
  inline ::google::protobuf::uint32 level() const;
  inline void set_level(::google::protobuf::uint32 value);

  // required uint32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.LevelNumberItems)
 private:
  inline void set_has_level();
  inline void clear_has_level();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 level_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static LevelNumberItems* default_instance_;
};
// -------------------------------------------------------------------

class UserTradeNumReq : public ::google::protobuf::Message {
 public:
  UserTradeNumReq();
  virtual ~UserTradeNumReq();

  UserTradeNumReq(const UserTradeNumReq& from);

  inline UserTradeNumReq& operator=(const UserTradeNumReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTradeNumReq& default_instance();

  void Swap(UserTradeNumReq* other);

  // implements Message ----------------------------------------------

  UserTradeNumReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.UserTradeNumReq)
 private:
  inline void set_has_time();
  inline void clear_has_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTradeNumReq* default_instance_;
};
// -------------------------------------------------------------------

class UserTradeNumRes : public ::google::protobuf::Message {
 public:
  UserTradeNumRes();
  virtual ~UserTradeNumRes();

  UserTradeNumRes(const UserTradeNumRes& from);

  inline UserTradeNumRes& operator=(const UserTradeNumRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserTradeNumRes& default_instance();

  void Swap(UserTradeNumRes* other);

  // implements Message ----------------------------------------------

  UserTradeNumRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  static const int kTimeFieldNumber = 1;
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);

  // required string trade = 2;
  inline bool has_trade() const;
  inline void clear_trade();
  static const int kTradeFieldNumber = 2;
  inline const ::std::string& trade() const;
  inline void set_trade(const ::std::string& value);
  inline void set_trade(const char* value);
  inline void set_trade(const char* value, size_t size);
  inline ::std::string* mutable_trade();
  inline ::std::string* release_trade();
  inline void set_allocated_trade(::std::string* trade);

  // @@protoc_insertion_point(class_scope:pp.UserTradeNumRes)
 private:
  inline void set_has_time();
  inline void clear_has_time();
  inline void set_has_trade();
  inline void clear_has_trade();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 time_;
  ::std::string* trade_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserTradeNumRes* default_instance_;
};
// -------------------------------------------------------------------

class UserPaymentReq : public ::google::protobuf::Message {
 public:
  UserPaymentReq();
  virtual ~UserPaymentReq();

  UserPaymentReq(const UserPaymentReq& from);

  inline UserPaymentReq& operator=(const UserPaymentReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPaymentReq& default_instance();

  void Swap(UserPaymentReq* other);

  // implements Message ----------------------------------------------

  UserPaymentReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string statDate = 1;
  inline bool has_statdate() const;
  inline void clear_statdate();
  static const int kStatDateFieldNumber = 1;
  inline const ::std::string& statdate() const;
  inline void set_statdate(const ::std::string& value);
  inline void set_statdate(const char* value);
  inline void set_statdate(const char* value, size_t size);
  inline ::std::string* mutable_statdate();
  inline ::std::string* release_statdate();
  inline void set_allocated_statdate(::std::string* statdate);

  // @@protoc_insertion_point(class_scope:pp.UserPaymentReq)
 private:
  inline void set_has_statdate();
  inline void clear_has_statdate();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* statdate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPaymentReq* default_instance_;
};
// -------------------------------------------------------------------

class UserPaymentRes : public ::google::protobuf::Message {
 public:
  UserPaymentRes();
  virtual ~UserPaymentRes();

  UserPaymentRes(const UserPaymentRes& from);

  inline UserPaymentRes& operator=(const UserPaymentRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserPaymentRes& default_instance();

  void Swap(UserPaymentRes* other);

  // implements Message ----------------------------------------------

  UserPaymentRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string statDate = 1;
  inline bool has_statdate() const;
  inline void clear_statdate();
  static const int kStatDateFieldNumber = 1;
  inline const ::std::string& statdate() const;
  inline void set_statdate(const ::std::string& value);
  inline void set_statdate(const char* value);
  inline void set_statdate(const char* value, size_t size);
  inline ::std::string* mutable_statdate();
  inline ::std::string* release_statdate();
  inline void set_allocated_statdate(::std::string* statdate);

  // required string paydata = 2;
  inline bool has_paydata() const;
  inline void clear_paydata();
  static const int kPaydataFieldNumber = 2;
  inline const ::std::string& paydata() const;
  inline void set_paydata(const ::std::string& value);
  inline void set_paydata(const char* value);
  inline void set_paydata(const char* value, size_t size);
  inline ::std::string* mutable_paydata();
  inline ::std::string* release_paydata();
  inline void set_allocated_paydata(::std::string* paydata);

  // @@protoc_insertion_point(class_scope:pp.UserPaymentRes)
 private:
  inline void set_has_statdate();
  inline void clear_has_statdate();
  inline void set_has_paydata();
  inline void clear_has_paydata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* statdate_;
  ::std::string* paydata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserPaymentRes* default_instance_;
};
// -------------------------------------------------------------------

class CreamFamilyReq : public ::google::protobuf::Message {
 public:
  CreamFamilyReq();
  virtual ~CreamFamilyReq();

  CreamFamilyReq(const CreamFamilyReq& from);

  inline CreamFamilyReq& operator=(const CreamFamilyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreamFamilyReq& default_instance();

  void Swap(CreamFamilyReq* other);

  // implements Message ----------------------------------------------

  CreamFamilyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // required sint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // repeated string wsids = 3;
  inline int wsids_size() const;
  inline void clear_wsids();
  static const int kWsidsFieldNumber = 3;
  inline const ::std::string& wsids(int index) const;
  inline ::std::string* mutable_wsids(int index);
  inline void set_wsids(int index, const ::std::string& value);
  inline void set_wsids(int index, const char* value);
  inline void set_wsids(int index, const char* value, size_t size);
  inline ::std::string* add_wsids();
  inline void add_wsids(const ::std::string& value);
  inline void add_wsids(const char* value);
  inline void add_wsids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& wsids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_wsids();

  // @@protoc_insertion_point(class_scope:pp.CreamFamilyReq)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;
  ::google::protobuf::RepeatedPtrField< ::std::string> wsids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CreamFamilyReq* default_instance_;
};
// -------------------------------------------------------------------

class CreamFamilyRes : public ::google::protobuf::Message {
 public:
  CreamFamilyRes();
  virtual ~CreamFamilyRes();

  CreamFamilyRes(const CreamFamilyRes& from);

  inline CreamFamilyRes& operator=(const CreamFamilyRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CreamFamilyRes& default_instance();

  void Swap(CreamFamilyRes* other);

  // implements Message ----------------------------------------------

  CreamFamilyRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint64 startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional sint64 endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // repeated .pp.YYuserList items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::pp::YYuserList& items(int index) const;
  inline ::pp::YYuserList* mutable_items(int index);
  inline ::pp::YYuserList* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::YYuserList >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::YYuserList >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.CreamFamilyRes)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;
  ::google::protobuf::RepeatedPtrField< ::pp::YYuserList > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CreamFamilyRes* default_instance_;
};
// -------------------------------------------------------------------

class YYuserList : public ::google::protobuf::Message {
 public:
  YYuserList();
  virtual ~YYuserList();

  YYuserList(const YYuserList& from);

  inline YYuserList& operator=(const YYuserList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYuserList& default_instance();

  void Swap(YYuserList* other);

  // implements Message ----------------------------------------------

  YYuserList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 wsid = 1;
  inline bool has_wsid() const;
  inline void clear_wsid();
  static const int kWsidFieldNumber = 1;
  inline ::google::protobuf::uint32 wsid() const;
  inline void set_wsid(::google::protobuf::uint32 value);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional sint64 createTime = 3;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 3;
  inline ::google::protobuf::int64 createtime() const;
  inline void set_createtime(::google::protobuf::int64 value);

  // optional uint32 FamilyNumAll = 4;
  inline bool has_familynumall() const;
  inline void clear_familynumall();
  static const int kFamilyNumAllFieldNumber = 4;
  inline ::google::protobuf::uint32 familynumall() const;
  inline void set_familynumall(::google::protobuf::uint32 value);

  // optional uint32 FamilyNumLv2 = 5;
  inline bool has_familynumlv2() const;
  inline void clear_familynumlv2();
  static const int kFamilyNumLv2FieldNumber = 5;
  inline ::google::protobuf::uint32 familynumlv2() const;
  inline void set_familynumlv2(::google::protobuf::uint32 value);

  // optional uint32 FamilyNumNew = 6;
  inline bool has_familynumnew() const;
  inline void clear_familynumnew();
  static const int kFamilyNumNewFieldNumber = 6;
  inline ::google::protobuf::uint32 familynumnew() const;
  inline void set_familynumnew(::google::protobuf::uint32 value);

  // optional uint32 RepeatIp = 7;
  inline bool has_repeatip() const;
  inline void clear_repeatip();
  static const int kRepeatIpFieldNumber = 7;
  inline ::google::protobuf::uint32 repeatip() const;
  inline void set_repeatip(::google::protobuf::uint32 value);

  // optional uint32 RepeatMac = 8;
  inline bool has_repeatmac() const;
  inline void clear_repeatmac();
  static const int kRepeatMacFieldNumber = 8;
  inline ::google::protobuf::uint32 repeatmac() const;
  inline void set_repeatmac(::google::protobuf::uint32 value);

  // optional uint32 FamilyNumNewLv1 = 9;
  inline bool has_familynumnewlv1() const;
  inline void clear_familynumnewlv1();
  static const int kFamilyNumNewLv1FieldNumber = 9;
  inline ::google::protobuf::uint32 familynumnewlv1() const;
  inline void set_familynumnewlv1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.YYuserList)
 private:
  inline void set_has_wsid();
  inline void clear_has_wsid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_createtime();
  inline void clear_has_createtime();
  inline void set_has_familynumall();
  inline void clear_has_familynumall();
  inline void set_has_familynumlv2();
  inline void clear_has_familynumlv2();
  inline void set_has_familynumnew();
  inline void clear_has_familynumnew();
  inline void set_has_repeatip();
  inline void clear_has_repeatip();
  inline void set_has_repeatmac();
  inline void clear_has_repeatmac();
  inline void set_has_familynumnewlv1();
  inline void clear_has_familynumnewlv1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint32 wsid_;
  ::google::protobuf::uint32 familynumall_;
  ::google::protobuf::int64 createtime_;
  ::google::protobuf::uint32 familynumlv2_;
  ::google::protobuf::uint32 familynumnew_;
  ::google::protobuf::uint32 repeatip_;
  ::google::protobuf::uint32 repeatmac_;
  ::google::protobuf::uint32 familynumnewlv1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYuserList* default_instance_;
};
// -------------------------------------------------------------------

class TopCharmReq : public ::google::protobuf::Message {
 public:
  TopCharmReq();
  virtual ~TopCharmReq();

  TopCharmReq(const TopCharmReq& from);

  inline TopCharmReq& operator=(const TopCharmReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopCharmReq& default_instance();

  void Swap(TopCharmReq* other);

  // implements Message ----------------------------------------------

  TopCharmReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.TopCharmReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static TopCharmReq* default_instance_;
};
// -------------------------------------------------------------------

class TopCharmRes : public ::google::protobuf::Message {
 public:
  TopCharmRes();
  virtual ~TopCharmRes();

  TopCharmRes(const TopCharmRes& from);

  inline TopCharmRes& operator=(const TopCharmRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopCharmRes& default_instance();

  void Swap(TopCharmRes* other);

  // implements Message ----------------------------------------------

  TopCharmRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.TopCharm items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::TopCharm& items(int index) const;
  inline ::pp::TopCharm* mutable_items(int index);
  inline ::pp::TopCharm* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::TopCharm >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::TopCharm >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.TopCharmRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::TopCharm > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static TopCharmRes* default_instance_;
};
// -------------------------------------------------------------------

class TopCharm : public ::google::protobuf::Message {
 public:
  TopCharm();
  virtual ~TopCharm();

  TopCharm(const TopCharm& from);

  inline TopCharm& operator=(const TopCharm& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TopCharm& default_instance();

  void Swap(TopCharm* other);

  // implements Message ----------------------------------------------

  TopCharm* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 month = 1;
  inline bool has_month() const;
  inline void clear_month();
  static const int kMonthFieldNumber = 1;
  inline ::google::protobuf::uint32 month() const;
  inline void set_month(::google::protobuf::uint32 value);

  // optional uint32 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // optional uint32 charmLevel = 3;
  inline bool has_charmlevel() const;
  inline void clear_charmlevel();
  static const int kCharmLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 charmlevel() const;
  inline void set_charmlevel(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.TopCharm)
 private:
  inline void set_has_month();
  inline void clear_has_month();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_charmlevel();
  inline void clear_has_charmlevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 month_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 charmlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static TopCharm* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginStatItems : public ::google::protobuf::Message {
 public:
  UserLoginStatItems();
  virtual ~UserLoginStatItems();

  UserLoginStatItems(const UserLoginStatItems& from);

  inline UserLoginStatItems& operator=(const UserLoginStatItems& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginStatItems& default_instance();

  void Swap(UserLoginStatItems* other);

  // implements Message ----------------------------------------------

  UserLoginStatItems* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string date = 1;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 1;
  inline const ::std::string& date() const;
  inline void set_date(const ::std::string& value);
  inline void set_date(const char* value);
  inline void set_date(const char* value, size_t size);
  inline ::std::string* mutable_date();
  inline ::std::string* release_date();
  inline void set_allocated_date(::std::string* date);

  // optional string StatDate = 2;
  inline bool has_statdate() const;
  inline void clear_statdate();
  static const int kStatDateFieldNumber = 2;
  inline const ::std::string& statdate() const;
  inline void set_statdate(const ::std::string& value);
  inline void set_statdate(const char* value);
  inline void set_statdate(const char* value, size_t size);
  inline ::std::string* mutable_statdate();
  inline ::std::string* release_statdate();
  inline void set_allocated_statdate(::std::string* statdate);

  // optional uint32 LoginUsers = 3;
  inline bool has_loginusers() const;
  inline void clear_loginusers();
  static const int kLoginUsersFieldNumber = 3;
  inline ::google::protobuf::uint32 loginusers() const;
  inline void set_loginusers(::google::protobuf::uint32 value);

  // optional uint32 AndroidLoginUsers = 4;
  inline bool has_androidloginusers() const;
  inline void clear_androidloginusers();
  static const int kAndroidLoginUsersFieldNumber = 4;
  inline ::google::protobuf::uint32 androidloginusers() const;
  inline void set_androidloginusers(::google::protobuf::uint32 value);

  // optional uint32 IosLoginUsers = 5;
  inline bool has_iosloginusers() const;
  inline void clear_iosloginusers();
  static const int kIosLoginUsersFieldNumber = 5;
  inline ::google::protobuf::uint32 iosloginusers() const;
  inline void set_iosloginusers(::google::protobuf::uint32 value);

  // optional uint32 YYLoginUsers = 6;
  inline bool has_yyloginusers() const;
  inline void clear_yyloginusers();
  static const int kYYLoginUsersFieldNumber = 6;
  inline ::google::protobuf::uint32 yyloginusers() const;
  inline void set_yyloginusers(::google::protobuf::uint32 value);

  // optional uint32 ShowLikes = 7;
  inline bool has_showlikes() const;
  inline void clear_showlikes();
  static const int kShowLikesFieldNumber = 7;
  inline ::google::protobuf::uint32 showlikes() const;
  inline void set_showlikes(::google::protobuf::uint32 value);

  // optional uint32 ShowLikeUsers = 8;
  inline bool has_showlikeusers() const;
  inline void clear_showlikeusers();
  static const int kShowLikeUsersFieldNumber = 8;
  inline ::google::protobuf::uint32 showlikeusers() const;
  inline void set_showlikeusers(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.UserLoginStatItems)
 private:
  inline void set_has_date();
  inline void clear_has_date();
  inline void set_has_statdate();
  inline void clear_has_statdate();
  inline void set_has_loginusers();
  inline void clear_has_loginusers();
  inline void set_has_androidloginusers();
  inline void clear_has_androidloginusers();
  inline void set_has_iosloginusers();
  inline void clear_has_iosloginusers();
  inline void set_has_yyloginusers();
  inline void clear_has_yyloginusers();
  inline void set_has_showlikes();
  inline void clear_has_showlikes();
  inline void set_has_showlikeusers();
  inline void clear_has_showlikeusers();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* date_;
  ::std::string* statdate_;
  ::google::protobuf::uint32 loginusers_;
  ::google::protobuf::uint32 androidloginusers_;
  ::google::protobuf::uint32 iosloginusers_;
  ::google::protobuf::uint32 yyloginusers_;
  ::google::protobuf::uint32 showlikes_;
  ::google::protobuf::uint32 showlikeusers_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLoginStatItems* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginStatReq : public ::google::protobuf::Message {
 public:
  UserLoginStatReq();
  virtual ~UserLoginStatReq();

  UserLoginStatReq(const UserLoginStatReq& from);

  inline UserLoginStatReq& operator=(const UserLoginStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginStatReq& default_instance();

  void Swap(UserLoginStatReq* other);

  // implements Message ----------------------------------------------

  UserLoginStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:pp.UserLoginStatReq)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::std::string* endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLoginStatReq* default_instance_;
};
// -------------------------------------------------------------------

class UserLoginStatRes : public ::google::protobuf::Message {
 public:
  UserLoginStatRes();
  virtual ~UserLoginStatRes();

  UserLoginStatRes(const UserLoginStatRes& from);

  inline UserLoginStatRes& operator=(const UserLoginStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserLoginStatRes& default_instance();

  void Swap(UserLoginStatRes* other);

  // implements Message ----------------------------------------------

  UserLoginStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // repeated .pp.UserLoginStatItems items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::pp::UserLoginStatItems& items(int index) const;
  inline ::pp::UserLoginStatItems* mutable_items(int index);
  inline ::pp::UserLoginStatItems* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::UserLoginStatItems >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::UserLoginStatItems >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.UserLoginStatRes)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::std::string* endtime_;
  ::google::protobuf::RepeatedPtrField< ::pp::UserLoginStatItems > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserLoginStatRes* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonActData : public ::google::protobuf::Message {
 public:
  ConfigJsonActData();
  virtual ~ConfigJsonActData();

  ConfigJsonActData(const ConfigJsonActData& from);

  inline ConfigJsonActData& operator=(const ConfigJsonActData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonActData& default_instance();

  void Swap(ConfigJsonActData* other);

  // implements Message ----------------------------------------------

  ConfigJsonActData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string jsondata = 2;
  inline bool has_jsondata() const;
  inline void clear_jsondata();
  static const int kJsondataFieldNumber = 2;
  inline const ::std::string& jsondata() const;
  inline void set_jsondata(const ::std::string& value);
  inline void set_jsondata(const char* value);
  inline void set_jsondata(const char* value, size_t size);
  inline ::std::string* mutable_jsondata();
  inline ::std::string* release_jsondata();
  inline void set_allocated_jsondata(::std::string* jsondata);

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonActData)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_jsondata();
  inline void clear_has_jsondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* jsondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonActData* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonActListReq : public ::google::protobuf::Message {
 public:
  ConfigJsonActListReq();
  virtual ~ConfigJsonActListReq();

  ConfigJsonActListReq(const ConfigJsonActListReq& from);

  inline ConfigJsonActListReq& operator=(const ConfigJsonActListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonActListReq& default_instance();

  void Swap(ConfigJsonActListReq* other);

  // implements Message ----------------------------------------------

  ConfigJsonActListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonActListReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonActListReq* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonActListRes : public ::google::protobuf::Message {
 public:
  ConfigJsonActListRes();
  virtual ~ConfigJsonActListRes();

  ConfigJsonActListRes(const ConfigJsonActListRes& from);

  inline ConfigJsonActListRes& operator=(const ConfigJsonActListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonActListRes& default_instance();

  void Swap(ConfigJsonActListRes* other);

  // implements Message ----------------------------------------------

  ConfigJsonActListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.ConfigJsonActData items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::ConfigJsonActData& items(int index) const;
  inline ::pp::ConfigJsonActData* mutable_items(int index);
  inline ::pp::ConfigJsonActData* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonActData >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonActData >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonActListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonActData > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonActListRes* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonActStarReq : public ::google::protobuf::Message {
 public:
  ConfigJsonActStarReq();
  virtual ~ConfigJsonActStarReq();

  ConfigJsonActStarReq(const ConfigJsonActStarReq& from);

  inline ConfigJsonActStarReq& operator=(const ConfigJsonActStarReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonActStarReq& default_instance();

  void Swap(ConfigJsonActStarReq* other);

  // implements Message ----------------------------------------------

  ConfigJsonActStarReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonActStarReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonActStarReq* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonActRes : public ::google::protobuf::Message {
 public:
  ConfigJsonActRes();
  virtual ~ConfigJsonActRes();

  ConfigJsonActRes(const ConfigJsonActRes& from);

  inline ConfigJsonActRes& operator=(const ConfigJsonActRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonActRes& default_instance();

  void Swap(ConfigJsonActRes* other);

  // implements Message ----------------------------------------------

  ConfigJsonActRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string jsondata = 1;
  inline bool has_jsondata() const;
  inline void clear_jsondata();
  static const int kJsondataFieldNumber = 1;
  inline const ::std::string& jsondata() const;
  inline void set_jsondata(const ::std::string& value);
  inline void set_jsondata(const char* value);
  inline void set_jsondata(const char* value, size_t size);
  inline ::std::string* mutable_jsondata();
  inline ::std::string* release_jsondata();
  inline void set_allocated_jsondata(::std::string* jsondata);

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonActRes)
 private:
  inline void set_has_jsondata();
  inline void clear_has_jsondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* jsondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonActRes* default_instance_;
};
// -------------------------------------------------------------------

class ConfigJsonActModifyReq : public ::google::protobuf::Message {
 public:
  ConfigJsonActModifyReq();
  virtual ~ConfigJsonActModifyReq();

  ConfigJsonActModifyReq(const ConfigJsonActModifyReq& from);

  inline ConfigJsonActModifyReq& operator=(const ConfigJsonActModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigJsonActModifyReq& default_instance();

  void Swap(ConfigJsonActModifyReq* other);

  // implements Message ----------------------------------------------

  ConfigJsonActModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string jsondata = 2;
  inline bool has_jsondata() const;
  inline void clear_jsondata();
  static const int kJsondataFieldNumber = 2;
  inline const ::std::string& jsondata() const;
  inline void set_jsondata(const ::std::string& value);
  inline void set_jsondata(const char* value);
  inline void set_jsondata(const char* value, size_t size);
  inline ::std::string* mutable_jsondata();
  inline ::std::string* release_jsondata();
  inline void set_allocated_jsondata(::std::string* jsondata);

  // @@protoc_insertion_point(class_scope:pp.ConfigJsonActModifyReq)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_jsondata();
  inline void clear_has_jsondata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* jsondata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigJsonActModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class ActStarFormReq : public ::google::protobuf::Message {
 public:
  ActStarFormReq();
  virtual ~ActStarFormReq();

  ActStarFormReq(const ActStarFormReq& from);

  inline ActStarFormReq& operator=(const ActStarFormReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActStarFormReq& default_instance();

  void Swap(ActStarFormReq* other);

  // implements Message ----------------------------------------------

  ActStarFormReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 signType = 1;
  inline bool has_signtype() const;
  inline void clear_signtype();
  static const int kSignTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 signtype() const;
  inline void set_signtype(::google::protobuf::uint32 value);

  // required uint32 joinType = 2;
  inline bool has_jointype() const;
  inline void clear_jointype();
  static const int kJoinTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 jointype() const;
  inline void set_jointype(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActStarFormReq)
 private:
  inline void set_has_signtype();
  inline void clear_has_signtype();
  inline void set_has_jointype();
  inline void clear_has_jointype();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 signtype_;
  ::google::protobuf::uint32 jointype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActStarFormReq* default_instance_;
};
// -------------------------------------------------------------------

class ActMsgListReq : public ::google::protobuf::Message {
 public:
  ActMsgListReq();
  virtual ~ActMsgListReq();

  ActMsgListReq(const ActMsgListReq& from);

  inline ActMsgListReq& operator=(const ActMsgListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActMsgListReq& default_instance();

  void Swap(ActMsgListReq* other);

  // implements Message ----------------------------------------------

  ActMsgListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::uint32 fetchs() const;
  inline void set_fetchs(::google::protobuf::uint32 value);

  // required uint32 act = 3;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 3;
  inline ::google::protobuf::uint32 act() const;
  inline void set_act(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActMsgListReq)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();
  inline void set_has_act();
  inline void clear_has_act();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 index_;
  ::google::protobuf::uint32 fetchs_;
  ::google::protobuf::uint32 act_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActMsgListReq* default_instance_;
};
// -------------------------------------------------------------------

class ActMsgListRes : public ::google::protobuf::Message {
 public:
  ActMsgListRes();
  virtual ~ActMsgListRes();

  ActMsgListRes(const ActMsgListRes& from);

  inline ActMsgListRes& operator=(const ActMsgListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActMsgListRes& default_instance();

  void Swap(ActMsgListRes* other);

  // implements Message ----------------------------------------------

  ActMsgListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.ActMsgList items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::ActMsgList& items(int index) const;
  inline ::pp::ActMsgList* mutable_items(int index);
  inline ::pp::ActMsgList* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ActMsgList >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ActMsgList >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.ActMsgListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::ActMsgList > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActMsgListRes* default_instance_;
};
// -------------------------------------------------------------------

class ActMsgList : public ::google::protobuf::Message {
 public:
  ActMsgList();
  virtual ~ActMsgList();

  ActMsgList(const ActMsgList& from);

  inline ActMsgList& operator=(const ActMsgList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActMsgList& default_instance();

  void Swap(ActMsgList* other);

  // implements Message ----------------------------------------------

  ActMsgList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint32 revision() const;
  inline void set_revision(::google::protobuf::uint32 value);

  // optional uint32 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint32 gid() const;
  inline void set_gid(::google::protobuf::uint32 value);

  // optional uint32 uid = 3;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 3;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // optional string url = 4;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 4;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional uint32 type = 5;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string description = 6;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 6;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional uint32 act = 7;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 7;
  inline ::google::protobuf::uint32 act() const;
  inline void set_act(::google::protobuf::uint32 value);

  // optional string createTime = 8;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 8;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const char* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // @@protoc_insertion_point(class_scope:pp.ActMsgList)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 revision_;
  ::google::protobuf::uint32 gid_;
  ::std::string* url_;
  ::google::protobuf::uint32 uid_;
  ::google::protobuf::uint32 type_;
  ::std::string* description_;
  ::std::string* createtime_;
  ::google::protobuf::uint32 act_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActMsgList* default_instance_;
};
// -------------------------------------------------------------------

class ActMsgModifyReq : public ::google::protobuf::Message {
 public:
  ActMsgModifyReq();
  virtual ~ActMsgModifyReq();

  ActMsgModifyReq(const ActMsgModifyReq& from);

  inline ActMsgModifyReq& operator=(const ActMsgModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActMsgModifyReq& default_instance();

  void Swap(ActMsgModifyReq* other);

  // implements Message ----------------------------------------------

  ActMsgModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 revision = 1;
  inline bool has_revision() const;
  inline void clear_revision();
  static const int kRevisionFieldNumber = 1;
  inline ::google::protobuf::uint64 revision() const;
  inline void set_revision(::google::protobuf::uint64 value);

  // optional uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint32 act = 3;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 3;
  inline ::google::protobuf::uint32 act() const;
  inline void set_act(::google::protobuf::uint32 value);

  // optional string description = 4;
  inline bool has_description() const;
  inline void clear_description();
  static const int kDescriptionFieldNumber = 4;
  inline const ::std::string& description() const;
  inline void set_description(const ::std::string& value);
  inline void set_description(const char* value);
  inline void set_description(const char* value, size_t size);
  inline ::std::string* mutable_description();
  inline ::std::string* release_description();
  inline void set_allocated_description(::std::string* description);

  // optional uint32 state = 5;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 5;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActMsgModifyReq)
 private:
  inline void set_has_revision();
  inline void clear_has_revision();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_description();
  inline void clear_has_description();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 revision_;
  ::google::protobuf::uint64 gid_;
  ::std::string* description_;
  ::google::protobuf::uint32 act_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActMsgModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberAddReq : public ::google::protobuf::Message {
 public:
  ActRegMemberAddReq();
  virtual ~ActRegMemberAddReq();

  ActRegMemberAddReq(const ActRegMemberAddReq& from);

  inline ActRegMemberAddReq& operator=(const ActRegMemberAddReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberAddReq& default_instance();

  void Swap(ActRegMemberAddReq* other);

  // implements Message ----------------------------------------------

  ActRegMemberAddReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string act = 1;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 1;
  inline const ::std::string& act() const;
  inline void set_act(const ::std::string& value);
  inline void set_act(const char* value);
  inline void set_act(const char* value, size_t size);
  inline ::std::string* mutable_act();
  inline ::std::string* release_act();
  inline void set_allocated_act(::std::string* act);

  // required uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional bool check = 3;
  inline bool has_check() const;
  inline void clear_check();
  static const int kCheckFieldNumber = 3;
  inline bool check() const;
  inline void set_check(bool value);

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberAddReq)
 private:
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_check();
  inline void clear_has_check();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* act_;
  ::google::protobuf::uint64 uid_;
  bool check_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberAddReq* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberModifyReq : public ::google::protobuf::Message {
 public:
  ActRegMemberModifyReq();
  virtual ~ActRegMemberModifyReq();

  ActRegMemberModifyReq(const ActRegMemberModifyReq& from);

  inline ActRegMemberModifyReq& operator=(const ActRegMemberModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberModifyReq& default_instance();

  void Swap(ActRegMemberModifyReq* other);

  // implements Message ----------------------------------------------

  ActRegMemberModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string act = 1;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 1;
  inline const ::std::string& act() const;
  inline void set_act(const ::std::string& value);
  inline void set_act(const char* value);
  inline void set_act(const char* value, size_t size);
  inline ::std::string* mutable_act();
  inline ::std::string* release_act();
  inline void set_allocated_act(::std::string* act);

  // required uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberModifyReq)
 private:
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* act_;
  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberStateReq : public ::google::protobuf::Message {
 public:
  ActRegMemberStateReq();
  virtual ~ActRegMemberStateReq();

  ActRegMemberStateReq(const ActRegMemberStateReq& from);

  inline ActRegMemberStateReq& operator=(const ActRegMemberStateReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberStateReq& default_instance();

  void Swap(ActRegMemberStateReq* other);

  // implements Message ----------------------------------------------

  ActRegMemberStateReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // required uint64 gid = 2;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 2;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // required string act = 3;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 3;
  inline const ::std::string& act() const;
  inline void set_act(const ::std::string& value);
  inline void set_act(const char* value);
  inline void set_act(const char* value, size_t size);
  inline ::std::string* mutable_act();
  inline ::std::string* release_act();
  inline void set_allocated_act(::std::string* act);

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberStateReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_act();
  inline void clear_has_act();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 gid_;
  ::std::string* act_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberStateReq* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberStateRes : public ::google::protobuf::Message {
 public:
  ActRegMemberStateRes();
  virtual ~ActRegMemberStateRes();

  ActRegMemberStateRes(const ActRegMemberStateRes& from);

  inline ActRegMemberStateRes& operator=(const ActRegMemberStateRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberStateRes& default_instance();

  void Swap(ActRegMemberStateRes* other);

  // implements Message ----------------------------------------------

  ActRegMemberStateRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string act = 2;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 2;
  inline const ::std::string& act() const;
  inline void set_act(const ::std::string& value);
  inline void set_act(const char* value);
  inline void set_act(const char* value, size_t size);
  inline ::std::string* mutable_act();
  inline ::std::string* release_act();
  inline void set_allocated_act(::std::string* act);

  // repeated .pp.ActRegMemberState weekReport = 3;
  inline int weekreport_size() const;
  inline void clear_weekreport();
  static const int kWeekReportFieldNumber = 3;
  inline const ::pp::ActRegMemberState& weekreport(int index) const;
  inline ::pp::ActRegMemberState* mutable_weekreport(int index);
  inline ::pp::ActRegMemberState* add_weekreport();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberState >&
      weekreport() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberState >*
      mutable_weekreport();

  // repeated .pp.ActRegMembers members = 4;
  inline int members_size() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 4;
  inline const ::pp::ActRegMembers& members(int index) const;
  inline ::pp::ActRegMembers* mutable_members(int index);
  inline ::pp::ActRegMembers* add_members();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegMembers >&
      members() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegMembers >*
      mutable_members();

  // repeated .pp.ActRegVoice voice = 5;
  inline int voice_size() const;
  inline void clear_voice();
  static const int kVoiceFieldNumber = 5;
  inline const ::pp::ActRegVoice& voice(int index) const;
  inline ::pp::ActRegVoice* mutable_voice(int index);
  inline ::pp::ActRegVoice* add_voice();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegVoice >&
      voice() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegVoice >*
      mutable_voice();

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberStateRes)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_act();
  inline void clear_has_act();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* act_;
  ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberState > weekreport_;
  ::google::protobuf::RepeatedPtrField< ::pp::ActRegMembers > members_;
  ::google::protobuf::RepeatedPtrField< ::pp::ActRegVoice > voice_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberStateRes* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberListReq : public ::google::protobuf::Message {
 public:
  ActRegMemberListReq();
  virtual ~ActRegMemberListReq();

  ActRegMemberListReq(const ActRegMemberListReq& from);

  inline ActRegMemberListReq& operator=(const ActRegMemberListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberListReq& default_instance();

  void Swap(ActRegMemberListReq* other);

  // implements Message ----------------------------------------------

  ActRegMemberListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string act = 1;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 1;
  inline const ::std::string& act() const;
  inline void set_act(const ::std::string& value);
  inline void set_act(const char* value);
  inline void set_act(const char* value, size_t size);
  inline ::std::string* mutable_act();
  inline ::std::string* release_act();
  inline void set_allocated_act(::std::string* act);

  // required string startTime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // required string endTime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 3;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // required uint32 type1 = 4;
  inline bool has_type1() const;
  inline void clear_type1();
  static const int kType1FieldNumber = 4;
  inline ::google::protobuf::uint32 type1() const;
  inline void set_type1(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberListReq)
 private:
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();
  inline void set_has_type1();
  inline void clear_has_type1();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* act_;
  ::std::string* starttime_;
  ::std::string* endtime_;
  ::google::protobuf::uint32 type1_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberListReq* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberListRes : public ::google::protobuf::Message {
 public:
  ActRegMemberListRes();
  virtual ~ActRegMemberListRes();

  ActRegMemberListRes(const ActRegMemberListRes& from);

  inline ActRegMemberListRes& operator=(const ActRegMemberListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberListRes& default_instance();

  void Swap(ActRegMemberListRes* other);

  // implements Message ----------------------------------------------

  ActRegMemberListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.ActRegMemberList uids = 1;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 1;
  inline const ::pp::ActRegMemberList& uids(int index) const;
  inline ::pp::ActRegMemberList* mutable_uids(int index);
  inline ::pp::ActRegMemberList* add_uids();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberList >&
      uids() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberList >*
      mutable_uids();

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberList > uids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberListRes* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberList : public ::google::protobuf::Message {
 public:
  ActRegMemberList();
  virtual ~ActRegMemberList();

  ActRegMemberList(const ActRegMemberList& from);

  inline ActRegMemberList& operator=(const ActRegMemberList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberList& default_instance();

  void Swap(ActRegMemberList* other);

  // implements Message ----------------------------------------------

  ActRegMemberList* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional string act = 2;
  inline bool has_act() const;
  inline void clear_act();
  static const int kActFieldNumber = 2;
  inline const ::std::string& act() const;
  inline void set_act(const ::std::string& value);
  inline void set_act(const char* value);
  inline void set_act(const char* value, size_t size);
  inline ::std::string* mutable_act();
  inline ::std::string* release_act();
  inline void set_allocated_act(::std::string* act);

  // optional uint32 state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // optional uint32 charmLv = 4;
  inline bool has_charmlv() const;
  inline void clear_charmlv();
  static const int kCharmLvFieldNumber = 4;
  inline ::google::protobuf::uint32 charmlv() const;
  inline void set_charmlv(::google::protobuf::uint32 value);

  // optional string dateTime = 5;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 5;
  inline const ::std::string& datetime() const;
  inline void set_datetime(const ::std::string& value);
  inline void set_datetime(const char* value);
  inline void set_datetime(const char* value, size_t size);
  inline ::std::string* mutable_datetime();
  inline ::std::string* release_datetime();
  inline void set_allocated_datetime(::std::string* datetime);

  // optional string nick = 6;
  inline bool has_nick() const;
  inline void clear_nick();
  static const int kNickFieldNumber = 6;
  inline const ::std::string& nick() const;
  inline void set_nick(const ::std::string& value);
  inline void set_nick(const char* value);
  inline void set_nick(const char* value, size_t size);
  inline ::std::string* mutable_nick();
  inline ::std::string* release_nick();
  inline void set_allocated_nick(::std::string* nick);

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberList)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_act();
  inline void clear_has_act();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_charmlv();
  inline void clear_has_charmlv();
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_nick();
  inline void clear_has_nick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::std::string* act_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 charmlv_;
  ::std::string* datetime_;
  ::std::string* nick_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberList* default_instance_;
};
// -------------------------------------------------------------------

class CoinAwardRecordReq : public ::google::protobuf::Message {
 public:
  CoinAwardRecordReq();
  virtual ~CoinAwardRecordReq();

  CoinAwardRecordReq(const CoinAwardRecordReq& from);

  inline CoinAwardRecordReq& operator=(const CoinAwardRecordReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinAwardRecordReq& default_instance();

  void Swap(CoinAwardRecordReq* other);

  // implements Message ----------------------------------------------

  CoinAwardRecordReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 opuid = 2;
  inline bool has_opuid() const;
  inline void clear_opuid();
  static const int kOpuidFieldNumber = 2;
  inline ::google::protobuf::uint64 opuid() const;
  inline void set_opuid(::google::protobuf::uint64 value);

  // optional string startTime = 3;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 3;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endTime = 4;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 4;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // @@protoc_insertion_point(class_scope:pp.CoinAwardRecordReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_opuid();
  inline void clear_has_opuid();
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 opuid_;
  ::std::string* starttime_;
  ::std::string* endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoinAwardRecordReq* default_instance_;
};
// -------------------------------------------------------------------

class CoinAwardRecordRes : public ::google::protobuf::Message {
 public:
  CoinAwardRecordRes();
  virtual ~CoinAwardRecordRes();

  CoinAwardRecordRes(const CoinAwardRecordRes& from);

  inline CoinAwardRecordRes& operator=(const CoinAwardRecordRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinAwardRecordRes& default_instance();

  void Swap(CoinAwardRecordRes* other);

  // implements Message ----------------------------------------------

  CoinAwardRecordRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string startTime = 1;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 1;
  inline const ::std::string& starttime() const;
  inline void set_starttime(const ::std::string& value);
  inline void set_starttime(const char* value);
  inline void set_starttime(const char* value, size_t size);
  inline ::std::string* mutable_starttime();
  inline ::std::string* release_starttime();
  inline void set_allocated_starttime(::std::string* starttime);

  // optional string endTime = 2;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 2;
  inline const ::std::string& endtime() const;
  inline void set_endtime(const ::std::string& value);
  inline void set_endtime(const char* value);
  inline void set_endtime(const char* value, size_t size);
  inline ::std::string* mutable_endtime();
  inline ::std::string* release_endtime();
  inline void set_allocated_endtime(::std::string* endtime);

  // repeated .pp.CoinAwardRecord items = 3;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 3;
  inline const ::pp::CoinAwardRecord& items(int index) const;
  inline ::pp::CoinAwardRecord* mutable_items(int index);
  inline ::pp::CoinAwardRecord* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinAwardRecord >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::CoinAwardRecord >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.CoinAwardRecordRes)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* starttime_;
  ::std::string* endtime_;
  ::google::protobuf::RepeatedPtrField< ::pp::CoinAwardRecord > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoinAwardRecordRes* default_instance_;
};
// -------------------------------------------------------------------

class CoreUserListReq : public ::google::protobuf::Message {
 public:
  CoreUserListReq();
  virtual ~CoreUserListReq();

  CoreUserListReq(const CoreUserListReq& from);

  inline CoreUserListReq& operator=(const CoreUserListReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoreUserListReq& default_instance();

  void Swap(CoreUserListReq* other);

  // implements Message ----------------------------------------------

  CoreUserListReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.CoreUserListReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoreUserListReq* default_instance_;
};
// -------------------------------------------------------------------

class CoreUserListRes : public ::google::protobuf::Message {
 public:
  CoreUserListRes();
  virtual ~CoreUserListRes();

  CoreUserListRes(const CoreUserListRes& from);

  inline CoreUserListRes& operator=(const CoreUserListRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoreUserListRes& default_instance();

  void Swap(CoreUserListRes* other);

  // implements Message ----------------------------------------------

  CoreUserListRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.CoreUser items = 1;
  inline int items_size() const;
  inline void clear_items();
  static const int kItemsFieldNumber = 1;
  inline const ::pp::CoreUser& items(int index) const;
  inline ::pp::CoreUser* mutable_items(int index);
  inline ::pp::CoreUser* add_items();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::CoreUser >&
      items() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::CoreUser >*
      mutable_items();

  // @@protoc_insertion_point(class_scope:pp.CoreUserListRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::CoreUser > items_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoreUserListRes* default_instance_;
};
// -------------------------------------------------------------------

class CoreUser : public ::google::protobuf::Message {
 public:
  CoreUser();
  virtual ~CoreUser();

  CoreUser(const CoreUser& from);

  inline CoreUser& operator=(const CoreUser& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoreUser& default_instance();

  void Swap(CoreUser* other);

  // implements Message ----------------------------------------------

  CoreUser* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.CoreUser)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoreUser* default_instance_;
};
// -------------------------------------------------------------------

class CoreUserModifyReq : public ::google::protobuf::Message {
 public:
  CoreUserModifyReq();
  virtual ~CoreUserModifyReq();

  CoreUserModifyReq(const CoreUserModifyReq& from);

  inline CoreUserModifyReq& operator=(const CoreUserModifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoreUserModifyReq& default_instance();

  void Swap(CoreUserModifyReq* other);

  // implements Message ----------------------------------------------

  CoreUserModifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 optype = 1;
  inline bool has_optype() const;
  inline void clear_optype();
  static const int kOptypeFieldNumber = 1;
  inline ::google::protobuf::uint32 optype() const;
  inline void set_optype(::google::protobuf::uint32 value);

  // optional uint64 uid = 2;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 2;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint32 type = 3;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 3;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.CoreUserModifyReq)
 private:
  inline void set_has_optype();
  inline void clear_has_optype();
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint32 optype_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoreUserModifyReq* default_instance_;
};
// -------------------------------------------------------------------

class CoinAwardRecord : public ::google::protobuf::Message {
 public:
  CoinAwardRecord();
  virtual ~CoinAwardRecord();

  CoinAwardRecord(const CoinAwardRecord& from);

  inline CoinAwardRecord& operator=(const CoinAwardRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CoinAwardRecord& default_instance();

  void Swap(CoinAwardRecord* other);

  // implements Message ----------------------------------------------

  CoinAwardRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional uint64 opuid = 2;
  inline bool has_opuid() const;
  inline void clear_opuid();
  static const int kOpuidFieldNumber = 2;
  inline ::google::protobuf::uint64 opuid() const;
  inline void set_opuid(::google::protobuf::uint64 value);

  // optional uint64 coins = 3;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 3;
  inline ::google::protobuf::uint64 coins() const;
  inline void set_coins(::google::protobuf::uint64 value);

  // optional string createTime = 4;
  inline bool has_createtime() const;
  inline void clear_createtime();
  static const int kCreateTimeFieldNumber = 4;
  inline const ::std::string& createtime() const;
  inline void set_createtime(const ::std::string& value);
  inline void set_createtime(const char* value);
  inline void set_createtime(const char* value, size_t size);
  inline ::std::string* mutable_createtime();
  inline ::std::string* release_createtime();
  inline void set_allocated_createtime(::std::string* createtime);

  // @@protoc_insertion_point(class_scope:pp.CoinAwardRecord)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_opuid();
  inline void clear_has_opuid();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_createtime();
  inline void clear_has_createtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::uint64 opuid_;
  ::google::protobuf::uint64 coins_;
  ::std::string* createtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static CoinAwardRecord* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMemberState : public ::google::protobuf::Message {
 public:
  ActRegMemberState();
  virtual ~ActRegMemberState();

  ActRegMemberState(const ActRegMemberState& from);

  inline ActRegMemberState& operator=(const ActRegMemberState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMemberState& default_instance();

  void Swap(ActRegMemberState* other);

  // implements Message ----------------------------------------------

  ActRegMemberState* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string dateTime = 1;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDateTimeFieldNumber = 1;
  inline const ::std::string& datetime() const;
  inline void set_datetime(const ::std::string& value);
  inline void set_datetime(const char* value);
  inline void set_datetime(const char* value, size_t size);
  inline ::std::string* mutable_datetime();
  inline ::std::string* release_datetime();
  inline void set_allocated_datetime(::std::string* datetime);

  // optional uint32 state = 2;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 2;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActRegMemberState)
 private:
  inline void set_has_datetime();
  inline void clear_has_datetime();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* datetime_;
  ::google::protobuf::uint32 state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMemberState* default_instance_;
};
// -------------------------------------------------------------------

class ActRegMembers : public ::google::protobuf::Message {
 public:
  ActRegMembers();
  virtual ~ActRegMembers();

  ActRegMembers(const ActRegMembers& from);

  inline ActRegMembers& operator=(const ActRegMembers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegMembers& default_instance();

  void Swap(ActRegMembers* other);

  // implements Message ----------------------------------------------

  ActRegMembers* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string statTime = 1;
  inline bool has_stattime() const;
  inline void clear_stattime();
  static const int kStatTimeFieldNumber = 1;
  inline const ::std::string& stattime() const;
  inline void set_stattime(const ::std::string& value);
  inline void set_stattime(const char* value);
  inline void set_stattime(const char* value, size_t size);
  inline ::std::string* mutable_stattime();
  inline ::std::string* release_stattime();
  inline void set_allocated_stattime(::std::string* stattime);

  // optional uint32 categoryid = 2;
  inline bool has_categoryid() const;
  inline void clear_categoryid();
  static const int kCategoryidFieldNumber = 2;
  inline ::google::protobuf::uint32 categoryid() const;
  inline void set_categoryid(::google::protobuf::uint32 value);

  // optional uint32 password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline ::google::protobuf::uint32 password() const;
  inline void set_password(::google::protobuf::uint32 value);

  // optional uint32 sortOrder = 4;
  inline bool has_sortorder() const;
  inline void clear_sortorder();
  static const int kSortOrderFieldNumber = 4;
  inline ::google::protobuf::uint32 sortorder() const;
  inline void set_sortorder(::google::protobuf::uint32 value);

  // optional string members = 5;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 5;
  inline const ::std::string& members() const;
  inline void set_members(const ::std::string& value);
  inline void set_members(const char* value);
  inline void set_members(const char* value, size_t size);
  inline ::std::string* mutable_members();
  inline ::std::string* release_members();
  inline void set_allocated_members(::std::string* members);

  // @@protoc_insertion_point(class_scope:pp.ActRegMembers)
 private:
  inline void set_has_stattime();
  inline void clear_has_stattime();
  inline void set_has_categoryid();
  inline void clear_has_categoryid();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_sortorder();
  inline void clear_has_sortorder();
  inline void set_has_members();
  inline void clear_has_members();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stattime_;
  ::google::protobuf::uint32 categoryid_;
  ::google::protobuf::uint32 password_;
  ::std::string* members_;
  ::google::protobuf::uint32 sortorder_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegMembers* default_instance_;
};
// -------------------------------------------------------------------

class ActRegVoice : public ::google::protobuf::Message {
 public:
  ActRegVoice();
  virtual ~ActRegVoice();

  ActRegVoice(const ActRegVoice& from);

  inline ActRegVoice& operator=(const ActRegVoice& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRegVoice& default_instance();

  void Swap(ActRegVoice* other);

  // implements Message ----------------------------------------------

  ActRegVoice* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string statTime = 1;
  inline bool has_stattime() const;
  inline void clear_stattime();
  static const int kStatTimeFieldNumber = 1;
  inline const ::std::string& stattime() const;
  inline void set_stattime(const ::std::string& value);
  inline void set_stattime(const char* value);
  inline void set_stattime(const char* value, size_t size);
  inline ::std::string* mutable_stattime();
  inline ::std::string* release_stattime();
  inline void set_allocated_stattime(::std::string* stattime);

  // optional uint32 timeLen = 2;
  inline bool has_timelen() const;
  inline void clear_timelen();
  static const int kTimeLenFieldNumber = 2;
  inline ::google::protobuf::uint32 timelen() const;
  inline void set_timelen(::google::protobuf::uint32 value);

  // optional uint32 Num = 3;
  inline bool has_num() const;
  inline void clear_num();
  static const int kNumFieldNumber = 3;
  inline ::google::protobuf::uint32 num() const;
  inline void set_num(::google::protobuf::uint32 value);

  // optional uint32 gid = 4;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 4;
  inline ::google::protobuf::uint32 gid() const;
  inline void set_gid(::google::protobuf::uint32 value);

  // optional uint32 uid = 5;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 5;
  inline ::google::protobuf::uint32 uid() const;
  inline void set_uid(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.ActRegVoice)
 private:
  inline void set_has_stattime();
  inline void clear_has_stattime();
  inline void set_has_timelen();
  inline void clear_has_timelen();
  inline void set_has_num();
  inline void clear_has_num();
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_uid();
  inline void clear_has_uid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* stattime_;
  ::google::protobuf::uint32 timelen_;
  ::google::protobuf::uint32 num_;
  ::google::protobuf::uint32 gid_;
  ::google::protobuf::uint32 uid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRegVoice* default_instance_;
};
// -------------------------------------------------------------------

class InvitationReq : public ::google::protobuf::Message {
 public:
  InvitationReq();
  virtual ~InvitationReq();

  InvitationReq(const InvitationReq& from);

  inline InvitationReq& operator=(const InvitationReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationReq& default_instance();

  void Swap(InvitationReq* other);

  // implements Message ----------------------------------------------

  InvitationReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required sint64 timeMonthStart = 2;
  inline bool has_timemonthstart() const;
  inline void clear_timemonthstart();
  static const int kTimeMonthStartFieldNumber = 2;
  inline ::google::protobuf::int64 timemonthstart() const;
  inline void set_timemonthstart(::google::protobuf::int64 value);

  // required sint64 timeMonthEnd = 3;
  inline bool has_timemonthend() const;
  inline void clear_timemonthend();
  static const int kTimeMonthEndFieldNumber = 3;
  inline ::google::protobuf::int64 timemonthend() const;
  inline void set_timemonthend(::google::protobuf::int64 value);

  // required sint64 timeWeekStart = 4;
  inline bool has_timeweekstart() const;
  inline void clear_timeweekstart();
  static const int kTimeWeekStartFieldNumber = 4;
  inline ::google::protobuf::int64 timeweekstart() const;
  inline void set_timeweekstart(::google::protobuf::int64 value);

  // required sint64 timeWeekEnd = 5;
  inline bool has_timeweekend() const;
  inline void clear_timeweekend();
  static const int kTimeWeekEndFieldNumber = 5;
  inline ::google::protobuf::int64 timeweekend() const;
  inline void set_timeweekend(::google::protobuf::int64 value);

  // required sint64 timeTodayStart = 6;
  inline bool has_timetodaystart() const;
  inline void clear_timetodaystart();
  static const int kTimeTodayStartFieldNumber = 6;
  inline ::google::protobuf::int64 timetodaystart() const;
  inline void set_timetodaystart(::google::protobuf::int64 value);

  // required sint64 timeTodayEnd = 7;
  inline bool has_timetodayend() const;
  inline void clear_timetodayend();
  static const int kTimeTodayEndFieldNumber = 7;
  inline ::google::protobuf::int64 timetodayend() const;
  inline void set_timetodayend(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.InvitationReq)
 private:
  inline void set_has_timemonthstart();
  inline void clear_has_timemonthstart();
  inline void set_has_timemonthend();
  inline void clear_has_timemonthend();
  inline void set_has_timeweekstart();
  inline void clear_has_timeweekstart();
  inline void set_has_timeweekend();
  inline void clear_has_timeweekend();
  inline void set_has_timetodaystart();
  inline void clear_has_timetodaystart();
  inline void set_has_timetodayend();
  inline void clear_has_timetodayend();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int64 timemonthstart_;
  ::google::protobuf::int64 timemonthend_;
  ::google::protobuf::int64 timeweekstart_;
  ::google::protobuf::int64 timeweekend_;
  ::google::protobuf::int64 timetodaystart_;
  ::google::protobuf::int64 timetodayend_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static InvitationReq* default_instance_;
};
// -------------------------------------------------------------------

class InvitationRes : public ::google::protobuf::Message {
 public:
  InvitationRes();
  virtual ~InvitationRes();

  InvitationRes(const InvitationRes& from);

  inline InvitationRes& operator=(const InvitationRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationRes& default_instance();

  void Swap(InvitationRes* other);

  // implements Message ----------------------------------------------

  InvitationRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 inviteTotal = 1;
  inline bool has_invitetotal() const;
  inline void clear_invitetotal();
  static const int kInviteTotalFieldNumber = 1;
  inline ::google::protobuf::uint32 invitetotal() const;
  inline void set_invitetotal(::google::protobuf::uint32 value);

  // optional uint32 inviteMonth = 2;
  inline bool has_invitemonth() const;
  inline void clear_invitemonth();
  static const int kInviteMonthFieldNumber = 2;
  inline ::google::protobuf::uint32 invitemonth() const;
  inline void set_invitemonth(::google::protobuf::uint32 value);

  // optional uint32 inviteWeek = 3;
  inline bool has_inviteweek() const;
  inline void clear_inviteweek();
  static const int kInviteWeekFieldNumber = 3;
  inline ::google::protobuf::uint32 inviteweek() const;
  inline void set_inviteweek(::google::protobuf::uint32 value);

  // optional uint32 inviteToday = 4;
  inline bool has_invitetoday() const;
  inline void clear_invitetoday();
  static const int kInviteTodayFieldNumber = 4;
  inline ::google::protobuf::uint32 invitetoday() const;
  inline void set_invitetoday(::google::protobuf::uint32 value);

  // repeated .pp.InvitationLv itemsCharm = 5;
  inline int itemscharm_size() const;
  inline void clear_itemscharm();
  static const int kItemsCharmFieldNumber = 5;
  inline const ::pp::InvitationLv& itemscharm(int index) const;
  inline ::pp::InvitationLv* mutable_itemscharm(int index);
  inline ::pp::InvitationLv* add_itemscharm();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >&
      itemscharm() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >*
      mutable_itemscharm();

  // repeated .pp.InvitationLv itemsPassion = 6;
  inline int itemspassion_size() const;
  inline void clear_itemspassion();
  static const int kItemsPassionFieldNumber = 6;
  inline const ::pp::InvitationLv& itemspassion(int index) const;
  inline ::pp::InvitationLv* mutable_itemspassion(int index);
  inline ::pp::InvitationLv* add_itemspassion();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >&
      itemspassion() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >*
      mutable_itemspassion();

  // @@protoc_insertion_point(class_scope:pp.InvitationRes)
 private:
  inline void set_has_invitetotal();
  inline void clear_has_invitetotal();
  inline void set_has_invitemonth();
  inline void clear_has_invitemonth();
  inline void set_has_inviteweek();
  inline void clear_has_inviteweek();
  inline void set_has_invitetoday();
  inline void clear_has_invitetoday();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 invitetotal_;
  ::google::protobuf::uint32 invitemonth_;
  ::google::protobuf::uint32 inviteweek_;
  ::google::protobuf::uint32 invitetoday_;
  ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv > itemscharm_;
  ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv > itemspassion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static InvitationRes* default_instance_;
};
// -------------------------------------------------------------------

class InvitationLv : public ::google::protobuf::Message {
 public:
  InvitationLv();
  virtual ~InvitationLv();

  InvitationLv(const InvitationLv& from);

  inline InvitationLv& operator=(const InvitationLv& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InvitationLv& default_instance();

  void Swap(InvitationLv* other);

  // implements Message ----------------------------------------------

  InvitationLv* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 lv = 1;
  inline bool has_lv() const;
  inline void clear_lv();
  static const int kLvFieldNumber = 1;
  inline ::google::protobuf::uint32 lv() const;
  inline void set_lv(::google::protobuf::uint32 value);

  // optional uint32 number = 2;
  inline bool has_number() const;
  inline void clear_number();
  static const int kNumberFieldNumber = 2;
  inline ::google::protobuf::uint32 number() const;
  inline void set_number(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.InvitationLv)
 private:
  inline void set_has_lv();
  inline void clear_has_lv();
  inline void set_has_number();
  inline void clear_has_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 lv_;
  ::google::protobuf::uint32 number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static InvitationLv* default_instance_;
};
// -------------------------------------------------------------------

class UserDataAdjustReq : public ::google::protobuf::Message {
 public:
  UserDataAdjustReq();
  virtual ~UserDataAdjustReq();

  UserDataAdjustReq(const UserDataAdjustReq& from);

  inline UserDataAdjustReq& operator=(const UserDataAdjustReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserDataAdjustReq& default_instance();

  void Swap(UserDataAdjustReq* other);

  // implements Message ----------------------------------------------

  UserDataAdjustReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 uid = 1;
  inline bool has_uid() const;
  inline void clear_uid();
  static const int kUidFieldNumber = 1;
  inline ::google::protobuf::uint64 uid() const;
  inline void set_uid(::google::protobuf::uint64 value);

  // optional int64 coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline ::google::protobuf::int64 coins() const;
  inline void set_coins(::google::protobuf::int64 value);

  // optional uint32 newCharmLevel = 3;
  inline bool has_newcharmlevel() const;
  inline void clear_newcharmlevel();
  static const int kNewCharmLevelFieldNumber = 3;
  inline ::google::protobuf::uint32 newcharmlevel() const;
  inline void set_newcharmlevel(::google::protobuf::uint32 value);

  // repeated uint64 uids = 4;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 4;
  inline ::google::protobuf::uint64 uids(int index) const;
  inline void set_uids(int index, ::google::protobuf::uint64 value);
  inline void add_uids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uids();

  // @@protoc_insertion_point(class_scope:pp.UserDataAdjustReq)
 private:
  inline void set_has_uid();
  inline void clear_has_uid();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_newcharmlevel();
  inline void clear_has_newcharmlevel();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 uid_;
  ::google::protobuf::int64 coins_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uids_;
  ::google::protobuf::uint32 newcharmlevel_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static UserDataAdjustReq* default_instance_;
};
// -------------------------------------------------------------------

class PCGiftNotifyRecord : public ::google::protobuf::Message {
 public:
  PCGiftNotifyRecord();
  virtual ~PCGiftNotifyRecord();

  PCGiftNotifyRecord(const PCGiftNotifyRecord& from);

  inline PCGiftNotifyRecord& operator=(const PCGiftNotifyRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PCGiftNotifyRecord& default_instance();

  void Swap(PCGiftNotifyRecord* other);

  // implements Message ----------------------------------------------

  PCGiftNotifyRecord* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 yyuid = 1;
  inline bool has_yyuid() const;
  inline void clear_yyuid();
  static const int kYyuidFieldNumber = 1;
  inline ::google::protobuf::uint64 yyuid() const;
  inline void set_yyuid(::google::protobuf::uint64 value);

  // optional string gift_id = 2;
  inline bool has_gift_id() const;
  inline void clear_gift_id();
  static const int kGiftIdFieldNumber = 2;
  inline const ::std::string& gift_id() const;
  inline void set_gift_id(const ::std::string& value);
  inline void set_gift_id(const char* value);
  inline void set_gift_id(const char* value, size_t size);
  inline ::std::string* mutable_gift_id();
  inline ::std::string* release_gift_id();
  inline void set_allocated_gift_id(::std::string* gift_id);

  // optional sint64 datetime = 3;
  inline bool has_datetime() const;
  inline void clear_datetime();
  static const int kDatetimeFieldNumber = 3;
  inline ::google::protobuf::int64 datetime() const;
  inline void set_datetime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.PCGiftNotifyRecord)
 private:
  inline void set_has_yyuid();
  inline void clear_has_yyuid();
  inline void set_has_gift_id();
  inline void clear_has_gift_id();
  inline void set_has_datetime();
  inline void clear_has_datetime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 yyuid_;
  ::std::string* gift_id_;
  ::google::protobuf::int64 datetime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PCGiftNotifyRecord* default_instance_;
};
// -------------------------------------------------------------------

class PCGiftNotifyReq : public ::google::protobuf::Message {
 public:
  PCGiftNotifyReq();
  virtual ~PCGiftNotifyReq();

  PCGiftNotifyReq(const PCGiftNotifyReq& from);

  inline PCGiftNotifyReq& operator=(const PCGiftNotifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PCGiftNotifyReq& default_instance();

  void Swap(PCGiftNotifyReq* other);

  // implements Message ----------------------------------------------

  PCGiftNotifyReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.PCGiftNotifyRecord records = 1;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline const ::pp::PCGiftNotifyRecord& records(int index) const;
  inline ::pp::PCGiftNotifyRecord* mutable_records(int index);
  inline ::pp::PCGiftNotifyRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::PCGiftNotifyRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::PCGiftNotifyRecord >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:pp.PCGiftNotifyReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::PCGiftNotifyRecord > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PCGiftNotifyReq* default_instance_;
};
// -------------------------------------------------------------------

class ConfigDataReq : public ::google::protobuf::Message {
 public:
  ConfigDataReq();
  virtual ~ConfigDataReq();

  ConfigDataReq(const ConfigDataReq& from);

  inline ConfigDataReq& operator=(const ConfigDataReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigDataReq& default_instance();

  void Swap(ConfigDataReq* other);

  // implements Message ----------------------------------------------

  ConfigDataReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.ConfigDataReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigDataReq* default_instance_;
};
// -------------------------------------------------------------------

class TradeConfigData : public ::google::protobuf::Message {
 public:
  TradeConfigData();
  virtual ~TradeConfigData();

  TradeConfigData(const TradeConfigData& from);

  inline TradeConfigData& operator=(const TradeConfigData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TradeConfigData& default_instance();

  void Swap(TradeConfigData* other);

  // implements Message ----------------------------------------------

  TradeConfigData* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string productOpenDays = 1;
  inline int productopendays_size() const;
  inline void clear_productopendays();
  static const int kProductOpenDaysFieldNumber = 1;
  inline const ::std::string& productopendays(int index) const;
  inline ::std::string* mutable_productopendays(int index);
  inline void set_productopendays(int index, const ::std::string& value);
  inline void set_productopendays(int index, const char* value);
  inline void set_productopendays(int index, const char* value, size_t size);
  inline ::std::string* add_productopendays();
  inline void add_productopendays(const ::std::string& value);
  inline void add_productopendays(const char* value);
  inline void add_productopendays(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& productopendays() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_productopendays();

  // optional uint32 tradeRate = 2;
  inline bool has_traderate() const;
  inline void clear_traderate();
  static const int kTradeRateFieldNumber = 2;
  inline ::google::protobuf::uint32 traderate() const;
  inline void set_traderate(::google::protobuf::uint32 value);

  // repeated uint32 tradeOpenDays = 3;
  inline int tradeopendays_size() const;
  inline void clear_tradeopendays();
  static const int kTradeOpenDaysFieldNumber = 3;
  inline ::google::protobuf::uint32 tradeopendays(int index) const;
  inline void set_tradeopendays(int index, ::google::protobuf::uint32 value);
  inline void add_tradeopendays(::google::protobuf::uint32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
      tradeopendays() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
      mutable_tradeopendays();

  // optional uint32 minTradeLevel = 4;
  inline bool has_mintradelevel() const;
  inline void clear_mintradelevel();
  static const int kMinTradeLevelFieldNumber = 4;
  inline ::google::protobuf::uint32 mintradelevel() const;
  inline void set_mintradelevel(::google::protobuf::uint32 value);

  // optional uint32 cashArrivingDay = 5;
  inline bool has_casharrivingday() const;
  inline void clear_casharrivingday();
  static const int kCashArrivingDayFieldNumber = 5;
  inline ::google::protobuf::uint32 casharrivingday() const;
  inline void set_casharrivingday(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.TradeConfigData)
 private:
  inline void set_has_traderate();
  inline void clear_has_traderate();
  inline void set_has_mintradelevel();
  inline void clear_has_mintradelevel();
  inline void set_has_casharrivingday();
  inline void clear_has_casharrivingday();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> productopendays_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint32 > tradeopendays_;
  ::google::protobuf::uint32 traderate_;
  ::google::protobuf::uint32 mintradelevel_;
  ::google::protobuf::uint32 casharrivingday_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static TradeConfigData* default_instance_;
};
// -------------------------------------------------------------------

class ConfigDataRes : public ::google::protobuf::Message {
 public:
  ConfigDataRes();
  virtual ~ConfigDataRes();

  ConfigDataRes(const ConfigDataRes& from);

  inline ConfigDataRes& operator=(const ConfigDataRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConfigDataRes& default_instance();

  void Swap(ConfigDataRes* other);

  // implements Message ----------------------------------------------

  ConfigDataRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.TradeConfigData tradeConfigData = 1;
  inline bool has_tradeconfigdata() const;
  inline void clear_tradeconfigdata();
  static const int kTradeConfigDataFieldNumber = 1;
  inline const ::pp::TradeConfigData& tradeconfigdata() const;
  inline ::pp::TradeConfigData* mutable_tradeconfigdata();
  inline ::pp::TradeConfigData* release_tradeconfigdata();
  inline void set_allocated_tradeconfigdata(::pp::TradeConfigData* tradeconfigdata);

  // @@protoc_insertion_point(class_scope:pp.ConfigDataRes)
 private:
  inline void set_has_tradeconfigdata();
  inline void clear_has_tradeconfigdata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::TradeConfigData* tradeconfigdata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ConfigDataRes* default_instance_;
};
// -------------------------------------------------------------------

class DailyTaskStatReq : public ::google::protobuf::Message {
 public:
  DailyTaskStatReq();
  virtual ~DailyTaskStatReq();

  DailyTaskStatReq(const DailyTaskStatReq& from);

  inline DailyTaskStatReq& operator=(const DailyTaskStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyTaskStatReq& default_instance();

  void Swap(DailyTaskStatReq* other);

  // implements Message ----------------------------------------------

  DailyTaskStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated uint64 uids = 1;
  inline int uids_size() const;
  inline void clear_uids();
  static const int kUidsFieldNumber = 1;
  inline ::google::protobuf::uint64 uids(int index) const;
  inline void set_uids(int index, ::google::protobuf::uint64 value);
  inline void add_uids(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      uids() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_uids();

  // optional sint64 startTime = 2;
  inline bool has_starttime() const;
  inline void clear_starttime();
  static const int kStartTimeFieldNumber = 2;
  inline ::google::protobuf::int64 starttime() const;
  inline void set_starttime(::google::protobuf::int64 value);

  // optional sint64 endTime = 3;
  inline bool has_endtime() const;
  inline void clear_endtime();
  static const int kEndTimeFieldNumber = 3;
  inline ::google::protobuf::int64 endtime() const;
  inline void set_endtime(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.DailyTaskStatReq)
 private:
  inline void set_has_starttime();
  inline void clear_has_starttime();
  inline void set_has_endtime();
  inline void clear_has_endtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > uids_;
  ::google::protobuf::int64 starttime_;
  ::google::protobuf::int64 endtime_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static DailyTaskStatReq* default_instance_;
};
// -------------------------------------------------------------------

class DailyTaskStat : public ::google::protobuf::Message {
 public:
  DailyTaskStat();
  virtual ~DailyTaskStat();

  DailyTaskStat(const DailyTaskStat& from);

  inline DailyTaskStat& operator=(const DailyTaskStat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyTaskStat& default_instance();

  void Swap(DailyTaskStat* other);

  // implements Message ----------------------------------------------

  DailyTaskStat* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pp.UserInfo user = 1;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 1;
  inline const ::pp::UserInfo& user() const;
  inline ::pp::UserInfo* mutable_user();
  inline ::pp::UserInfo* release_user();
  inline void set_allocated_user(::pp::UserInfo* user);

  // optional uint32 coins = 2;
  inline bool has_coins() const;
  inline void clear_coins();
  static const int kCoinsFieldNumber = 2;
  inline ::google::protobuf::uint32 coins() const;
  inline void set_coins(::google::protobuf::uint32 value);

  // optional float achieveRate = 3;
  inline bool has_achieverate() const;
  inline void clear_achieverate();
  static const int kAchieveRateFieldNumber = 3;
  inline float achieverate() const;
  inline void set_achieverate(float value);

  // optional sint64 date = 4;
  inline bool has_date() const;
  inline void clear_date();
  static const int kDateFieldNumber = 4;
  inline ::google::protobuf::int64 date() const;
  inline void set_date(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.DailyTaskStat)
 private:
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_coins();
  inline void clear_has_coins();
  inline void set_has_achieverate();
  inline void clear_has_achieverate();
  inline void set_has_date();
  inline void clear_has_date();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::pp::UserInfo* user_;
  ::google::protobuf::uint32 coins_;
  float achieverate_;
  ::google::protobuf::int64 date_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static DailyTaskStat* default_instance_;
};
// -------------------------------------------------------------------

class DailyTaskStatRes : public ::google::protobuf::Message {
 public:
  DailyTaskStatRes();
  virtual ~DailyTaskStatRes();

  DailyTaskStatRes(const DailyTaskStatRes& from);

  inline DailyTaskStatRes& operator=(const DailyTaskStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DailyTaskStatRes& default_instance();

  void Swap(DailyTaskStatRes* other);

  // implements Message ----------------------------------------------

  DailyTaskStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pp.DailyTaskStat records = 1;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline const ::pp::DailyTaskStat& records(int index) const;
  inline ::pp::DailyTaskStat* mutable_records(int index);
  inline ::pp::DailyTaskStat* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskStat >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskStat >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:pp.DailyTaskStatRes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskStat > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static DailyTaskStatRes* default_instance_;
};
// -------------------------------------------------------------------

class BabyDataStatReq : public ::google::protobuf::Message {
 public:
  BabyDataStatReq();
  virtual ~BabyDataStatReq();

  BabyDataStatReq(const BabyDataStatReq& from);

  inline BabyDataStatReq& operator=(const BabyDataStatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BabyDataStatReq& default_instance();

  void Swap(BabyDataStatReq* other);

  // implements Message ----------------------------------------------

  BabyDataStatReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:pp.BabyDataStatReq)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;


  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[1];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BabyDataStatReq* default_instance_;
};
// -------------------------------------------------------------------

class BabyDataStatRes : public ::google::protobuf::Message {
 public:
  BabyDataStatRes();
  virtual ~BabyDataStatRes();

  BabyDataStatRes(const BabyDataStatRes& from);

  inline BabyDataStatRes& operator=(const BabyDataStatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const BabyDataStatRes& default_instance();

  void Swap(BabyDataStatRes* other);

  // implements Message ----------------------------------------------

  BabyDataStatRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 rmb = 1;
  inline bool has_rmb() const;
  inline void clear_rmb();
  static const int kRmbFieldNumber = 1;
  inline ::google::protobuf::uint32 rmb() const;
  inline void set_rmb(::google::protobuf::uint32 value);

  // optional uint32 yyscore = 2;
  inline bool has_yyscore() const;
  inline void clear_yyscore();
  static const int kYyscoreFieldNumber = 2;
  inline ::google::protobuf::uint32 yyscore() const;
  inline void set_yyscore(::google::protobuf::uint32 value);

  // optional uint32 lolskin = 3;
  inline bool has_lolskin() const;
  inline void clear_lolskin();
  static const int kLolskinFieldNumber = 3;
  inline ::google::protobuf::uint32 lolskin() const;
  inline void set_lolskin(::google::protobuf::uint32 value);

  // optional uint32 movein = 4;
  inline bool has_movein() const;
  inline void clear_movein();
  static const int kMoveinFieldNumber = 4;
  inline ::google::protobuf::uint32 movein() const;
  inline void set_movein(::google::protobuf::uint32 value);

  // optional uint32 showing = 5;
  inline bool has_showing() const;
  inline void clear_showing();
  static const int kShowingFieldNumber = 5;
  inline ::google::protobuf::uint32 showing() const;
  inline void set_showing(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:pp.BabyDataStatRes)
 private:
  inline void set_has_rmb();
  inline void clear_has_rmb();
  inline void set_has_yyscore();
  inline void clear_has_yyscore();
  inline void set_has_lolskin();
  inline void clear_has_lolskin();
  inline void set_has_movein();
  inline void clear_has_movein();
  inline void set_has_showing();
  inline void clear_has_showing();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 rmb_;
  ::google::protobuf::uint32 yyscore_;
  ::google::protobuf::uint32 lolskin_;
  ::google::protobuf::uint32 movein_;
  ::google::protobuf::uint32 showing_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static BabyDataStatRes* default_instance_;
};
// -------------------------------------------------------------------

class PageDataExchangeReq : public ::google::protobuf::Message {
 public:
  PageDataExchangeReq();
  virtual ~PageDataExchangeReq();

  PageDataExchangeReq(const PageDataExchangeReq& from);

  inline PageDataExchangeReq& operator=(const PageDataExchangeReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PageDataExchangeReq& default_instance();

  void Swap(PageDataExchangeReq* other);

  // implements Message ----------------------------------------------

  PageDataExchangeReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:pp.PageDataExchangeReq)
 private:
  inline void set_has_key();
  inline void clear_has_key();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PageDataExchangeReq* default_instance_;
};
// -------------------------------------------------------------------

class PageDataExchangeRes : public ::google::protobuf::Message {
 public:
  PageDataExchangeRes();
  virtual ~PageDataExchangeRes();

  PageDataExchangeRes(const PageDataExchangeRes& from);

  inline PageDataExchangeRes& operator=(const PageDataExchangeRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PageDataExchangeRes& default_instance();

  void Swap(PageDataExchangeRes* other);

  // implements Message ----------------------------------------------

  PageDataExchangeRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string url = 1;
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  inline void set_allocated_url(::std::string* url);

  // optional string param = 2;
  inline bool has_param() const;
  inline void clear_param();
  static const int kParamFieldNumber = 2;
  inline const ::std::string& param() const;
  inline void set_param(const ::std::string& value);
  inline void set_param(const char* value);
  inline void set_param(const char* value, size_t size);
  inline ::std::string* mutable_param();
  inline ::std::string* release_param();
  inline void set_allocated_param(::std::string* param);

  // @@protoc_insertion_point(class_scope:pp.PageDataExchangeRes)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  inline void set_has_param();
  inline void clear_has_param();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* url_;
  ::std::string* param_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static PageDataExchangeRes* default_instance_;
};
// -------------------------------------------------------------------

class ActLuckyTryReq : public ::google::protobuf::Message {
 public:
  ActLuckyTryReq();
  virtual ~ActLuckyTryReq();

  ActLuckyTryReq(const ActLuckyTryReq& from);

  inline ActLuckyTryReq& operator=(const ActLuckyTryReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActLuckyTryReq& default_instance();

  void Swap(ActLuckyTryReq* other);

  // implements Message ----------------------------------------------

  ActLuckyTryReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool try = 1;
  inline bool has_try_() const;
  inline void clear_try_();
  static const int kTryFieldNumber = 1;
  inline bool try_() const;
  inline void set_try_(bool value);

  // optional string actName = 2;
  inline bool has_actname() const;
  inline void clear_actname();
  static const int kActNameFieldNumber = 2;
  inline const ::std::string& actname() const;
  inline void set_actname(const ::std::string& value);
  inline void set_actname(const char* value);
  inline void set_actname(const char* value, size_t size);
  inline ::std::string* mutable_actname();
  inline ::std::string* release_actname();
  inline void set_allocated_actname(::std::string* actname);

  // @@protoc_insertion_point(class_scope:pp.ActLuckyTryReq)
 private:
  inline void set_has_try_();
  inline void clear_has_try_();
  inline void set_has_actname();
  inline void clear_has_actname();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* actname_;
  bool try__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActLuckyTryReq* default_instance_;
};
// -------------------------------------------------------------------

class ActLuckyTryRes : public ::google::protobuf::Message {
 public:
  ActLuckyTryRes();
  virtual ~ActLuckyTryRes();

  ActLuckyTryRes(const ActLuckyTryRes& from);

  inline ActLuckyTryRes& operator=(const ActLuckyTryRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActLuckyTryRes& default_instance();

  void Swap(ActLuckyTryRes* other);

  // implements Message ----------------------------------------------

  ActLuckyTryRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:pp.ActLuckyTryRes)
 private:
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActLuckyTryRes* default_instance_;
};
// -------------------------------------------------------------------

class ActRecvDynamicReq : public ::google::protobuf::Message {
 public:
  ActRecvDynamicReq();
  virtual ~ActRecvDynamicReq();

  ActRecvDynamicReq(const ActRecvDynamicReq& from);

  inline ActRecvDynamicReq& operator=(const ActRecvDynamicReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRecvDynamicReq& default_instance();

  void Swap(ActRecvDynamicReq* other);

  // implements Message ----------------------------------------------

  ActRecvDynamicReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 actId = 1;
  inline bool has_actid() const;
  inline void clear_actid();
  static const int kActIdFieldNumber = 1;
  inline ::google::protobuf::uint32 actid() const;
  inline void set_actid(::google::protobuf::uint32 value);

  // optional int32 fetchs = 2;
  inline bool has_fetchs() const;
  inline void clear_fetchs();
  static const int kFetchsFieldNumber = 2;
  inline ::google::protobuf::int32 fetchs() const;
  inline void set_fetchs(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:pp.ActRecvDynamicReq)
 private:
  inline void set_has_actid();
  inline void clear_has_actid();
  inline void set_has_fetchs();
  inline void clear_has_fetchs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 actid_;
  ::google::protobuf::int32 fetchs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRecvDynamicReq* default_instance_;
};
// -------------------------------------------------------------------

class ActRecvDynamicRes : public ::google::protobuf::Message {
 public:
  ActRecvDynamicRes();
  virtual ~ActRecvDynamicRes();

  ActRecvDynamicRes(const ActRecvDynamicRes& from);

  inline ActRecvDynamicRes& operator=(const ActRecvDynamicRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ActRecvDynamicRes& default_instance();

  void Swap(ActRecvDynamicRes* other);

  // implements Message ----------------------------------------------

  ActRecvDynamicRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 actId = 1;
  inline bool has_actid() const;
  inline void clear_actid();
  static const int kActIdFieldNumber = 1;
  inline ::google::protobuf::uint32 actid() const;
  inline void set_actid(::google::protobuf::uint32 value);

  // repeated string msgs = 2;
  inline int msgs_size() const;
  inline void clear_msgs();
  static const int kMsgsFieldNumber = 2;
  inline const ::std::string& msgs(int index) const;
  inline ::std::string* mutable_msgs(int index);
  inline void set_msgs(int index, const ::std::string& value);
  inline void set_msgs(int index, const char* value);
  inline void set_msgs(int index, const char* value, size_t size);
  inline ::std::string* add_msgs();
  inline void add_msgs(const ::std::string& value);
  inline void add_msgs(const char* value);
  inline void add_msgs(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& msgs() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_msgs();

  // @@protoc_insertion_point(class_scope:pp.ActRecvDynamicRes)
 private:
  inline void set_has_actid();
  inline void clear_has_actid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> msgs_;
  ::google::protobuf::uint32 actid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ActRecvDynamicRes* default_instance_;
};
// -------------------------------------------------------------------

class DevFinger : public ::google::protobuf::Message {
 public:
  DevFinger();
  virtual ~DevFinger();

  DevFinger(const DevFinger& from);

  inline DevFinger& operator=(const DevFinger& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DevFinger& default_instance();

  void Swap(DevFinger* other);

  // implements Message ----------------------------------------------

  DevFinger* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // optional string imei = 2;
  inline bool has_imei() const;
  inline void clear_imei();
  static const int kImeiFieldNumber = 2;
  inline const ::std::string& imei() const;
  inline void set_imei(const ::std::string& value);
  inline void set_imei(const char* value);
  inline void set_imei(const char* value, size_t size);
  inline ::std::string* mutable_imei();
  inline ::std::string* release_imei();
  inline void set_allocated_imei(::std::string* imei);

  // optional string wlan_mac = 3;
  inline bool has_wlan_mac() const;
  inline void clear_wlan_mac();
  static const int kWlanMacFieldNumber = 3;
  inline const ::std::string& wlan_mac() const;
  inline void set_wlan_mac(const ::std::string& value);
  inline void set_wlan_mac(const char* value);
  inline void set_wlan_mac(const char* value, size_t size);
  inline ::std::string* mutable_wlan_mac();
  inline ::std::string* release_wlan_mac();
  inline void set_allocated_wlan_mac(::std::string* wlan_mac);

  // optional string android_id = 4;
  inline bool has_android_id() const;
  inline void clear_android_id();
  static const int kAndroidIdFieldNumber = 4;
  inline const ::std::string& android_id() const;
  inline void set_android_id(const ::std::string& value);
  inline void set_android_id(const char* value);
  inline void set_android_id(const char* value, size_t size);
  inline ::std::string* mutable_android_id();
  inline ::std::string* release_android_id();
  inline void set_allocated_android_id(::std::string* android_id);

  // optional string bt_mac = 5;
  inline bool has_bt_mac() const;
  inline void clear_bt_mac();
  static const int kBtMacFieldNumber = 5;
  inline const ::std::string& bt_mac() const;
  inline void set_bt_mac(const ::std::string& value);
  inline void set_bt_mac(const char* value);
  inline void set_bt_mac(const char* value, size_t size);
  inline ::std::string* mutable_bt_mac();
  inline ::std::string* release_bt_mac();
  inline void set_allocated_bt_mac(::std::string* bt_mac);

  // optional string idfa = 6;
  inline bool has_idfa() const;
  inline void clear_idfa();
  static const int kIdfaFieldNumber = 6;
  inline const ::std::string& idfa() const;
  inline void set_idfa(const ::std::string& value);
  inline void set_idfa(const char* value);
  inline void set_idfa(const char* value, size_t size);
  inline ::std::string* mutable_idfa();
  inline ::std::string* release_idfa();
  inline void set_allocated_idfa(::std::string* idfa);

  // @@protoc_insertion_point(class_scope:pp.DevFinger)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_imei();
  inline void clear_has_imei();
  inline void set_has_wlan_mac();
  inline void clear_has_wlan_mac();
  inline void set_has_android_id();
  inline void clear_has_android_id();
  inline void set_has_bt_mac();
  inline void clear_has_bt_mac();
  inline void set_has_idfa();
  inline void clear_has_idfa();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* imei_;
  ::std::string* wlan_mac_;
  ::std::string* android_id_;
  ::std::string* bt_mac_;
  ::std::string* idfa_;
  ::google::protobuf::uint32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static DevFinger* default_instance_;
};
// -------------------------------------------------------------------

class YYChannelTreeInfoReq : public ::google::protobuf::Message {
 public:
  YYChannelTreeInfoReq();
  virtual ~YYChannelTreeInfoReq();

  YYChannelTreeInfoReq(const YYChannelTreeInfoReq& from);

  inline YYChannelTreeInfoReq& operator=(const YYChannelTreeInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYChannelTreeInfoReq& default_instance();

  void Swap(YYChannelTreeInfoReq* other);

  // implements Message ----------------------------------------------

  YYChannelTreeInfoReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 sid = 1;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 1;
  inline ::google::protobuf::uint64 sid() const;
  inline void set_sid(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:pp.YYChannelTreeInfoReq)
 private:
  inline void set_has_sid();
  inline void clear_has_sid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 sid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYChannelTreeInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class YYChannelBranch : public ::google::protobuf::Message {
 public:
  YYChannelBranch();
  virtual ~YYChannelBranch();

  YYChannelBranch(const YYChannelBranch& from);

  inline YYChannelBranch& operator=(const YYChannelBranch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYChannelBranch& default_instance();

  void Swap(YYChannelBranch* other);

  // implements Message ----------------------------------------------

  YYChannelBranch* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint64 gid = 1;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 1;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // optional uint64 sid = 2;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 2;
  inline ::google::protobuf::uint64 sid() const;
  inline void set_sid(::google::protobuf::uint64 value);

  // optional uint64 pid = 3;
  inline bool has_pid() const;
  inline void clear_pid();
  static const int kPidFieldNumber = 3;
  inline ::google::protobuf::uint64 pid() const;
  inline void set_pid(::google::protobuf::uint64 value);

  // optional uint64 tid = 4;
  inline bool has_tid() const;
  inline void clear_tid();
  static const int kTidFieldNumber = 4;
  inline ::google::protobuf::uint64 tid() const;
  inline void set_tid(::google::protobuf::uint64 value);

  // optional string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool isPassWdSet = 6;
  inline bool has_ispasswdset() const;
  inline void clear_ispasswdset();
  static const int kIsPassWdSetFieldNumber = 6;
  inline bool ispasswdset() const;
  inline void set_ispasswdset(bool value);

  // optional string passwd = 7;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 7;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional bool isGuestAccessLimit = 8;
  inline bool has_isguestaccesslimit() const;
  inline void clear_isguestaccesslimit();
  static const int kIsGuestAccessLimitFieldNumber = 8;
  inline bool isguestaccesslimit() const;
  inline void set_isguestaccesslimit(bool value);

  // optional uint64 members = 9;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 9;
  inline ::google::protobuf::uint64 members() const;
  inline void set_members(::google::protobuf::uint64 value);

  // optional uint32 orderNum = 10;
  inline bool has_ordernum() const;
  inline void clear_ordernum();
  static const int kOrderNumFieldNumber = 10;
  inline ::google::protobuf::uint32 ordernum() const;
  inline void set_ordernum(::google::protobuf::uint32 value);

  // optional string logoUrl = 11;
  inline bool has_logourl() const;
  inline void clear_logourl();
  static const int kLogoUrlFieldNumber = 11;
  inline const ::std::string& logourl() const;
  inline void set_logourl(const ::std::string& value);
  inline void set_logourl(const char* value);
  inline void set_logourl(const char* value, size_t size);
  inline ::std::string* mutable_logourl();
  inline ::std::string* release_logourl();
  inline void set_allocated_logourl(::std::string* logourl);

  // repeated .pp.YYChannelBranch subCh = 12;
  inline int subch_size() const;
  inline void clear_subch();
  static const int kSubChFieldNumber = 12;
  inline const ::pp::YYChannelBranch& subch(int index) const;
  inline ::pp::YYChannelBranch* mutable_subch(int index);
  inline ::pp::YYChannelBranch* add_subch();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >&
      subch() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >*
      mutable_subch();

  // @@protoc_insertion_point(class_scope:pp.YYChannelBranch)
 private:
  inline void set_has_gid();
  inline void clear_has_gid();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_pid();
  inline void clear_has_pid();
  inline void set_has_tid();
  inline void clear_has_tid();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_ispasswdset();
  inline void clear_has_ispasswdset();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_isguestaccesslimit();
  inline void clear_has_isguestaccesslimit();
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_ordernum();
  inline void clear_has_ordernum();
  inline void set_has_logourl();
  inline void clear_has_logourl();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 gid_;
  ::google::protobuf::uint64 sid_;
  ::google::protobuf::uint64 pid_;
  ::google::protobuf::uint64 tid_;
  ::std::string* name_;
  ::std::string* passwd_;
  bool ispasswdset_;
  bool isguestaccesslimit_;
  ::google::protobuf::uint32 ordernum_;
  ::google::protobuf::uint64 members_;
  ::std::string* logourl_;
  ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch > subch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYChannelBranch* default_instance_;
};
// -------------------------------------------------------------------

class YYChannelTreeInfoRes : public ::google::protobuf::Message {
 public:
  YYChannelTreeInfoRes();
  virtual ~YYChannelTreeInfoRes();

  YYChannelTreeInfoRes(const YYChannelTreeInfoRes& from);

  inline YYChannelTreeInfoRes& operator=(const YYChannelTreeInfoRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YYChannelTreeInfoRes& default_instance();

  void Swap(YYChannelTreeInfoRes* other);

  // implements Message ----------------------------------------------

  YYChannelTreeInfoRes* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional uint64 asid = 2;
  inline bool has_asid() const;
  inline void clear_asid();
  static const int kAsidFieldNumber = 2;
  inline ::google::protobuf::uint64 asid() const;
  inline void set_asid(::google::protobuf::uint64 value);

  // optional uint64 sid = 3;
  inline bool has_sid() const;
  inline void clear_sid();
  static const int kSidFieldNumber = 3;
  inline ::google::protobuf::uint64 sid() const;
  inline void set_sid(::google::protobuf::uint64 value);

  // optional uint64 members = 4;
  inline bool has_members() const;
  inline void clear_members();
  static const int kMembersFieldNumber = 4;
  inline ::google::protobuf::uint64 members() const;
  inline void set_members(::google::protobuf::uint64 value);

  // optional string logoUrl = 5;
  inline bool has_logourl() const;
  inline void clear_logourl();
  static const int kLogoUrlFieldNumber = 5;
  inline const ::std::string& logourl() const;
  inline void set_logourl(const ::std::string& value);
  inline void set_logourl(const char* value);
  inline void set_logourl(const char* value, size_t size);
  inline ::std::string* mutable_logourl();
  inline ::std::string* release_logourl();
  inline void set_allocated_logourl(::std::string* logourl);

  // optional uint64 gid = 6;
  inline bool has_gid() const;
  inline void clear_gid();
  static const int kGidFieldNumber = 6;
  inline ::google::protobuf::uint64 gid() const;
  inline void set_gid(::google::protobuf::uint64 value);

  // repeated .pp.YYChannelBranch treeInfo = 7;
  inline int treeinfo_size() const;
  inline void clear_treeinfo();
  static const int kTreeInfoFieldNumber = 7;
  inline const ::pp::YYChannelBranch& treeinfo(int index) const;
  inline ::pp::YYChannelBranch* mutable_treeinfo(int index);
  inline ::pp::YYChannelBranch* add_treeinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >&
      treeinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >*
      mutable_treeinfo();

  // @@protoc_insertion_point(class_scope:pp.YYChannelTreeInfoRes)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_asid();
  inline void clear_has_asid();
  inline void set_has_sid();
  inline void clear_has_sid();
  inline void set_has_members();
  inline void clear_has_members();
  inline void set_has_logourl();
  inline void clear_has_logourl();
  inline void set_has_gid();
  inline void clear_has_gid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::google::protobuf::uint64 asid_;
  ::google::protobuf::uint64 sid_;
  ::google::protobuf::uint64 members_;
  ::std::string* logourl_;
  ::google::protobuf::uint64 gid_;
  ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch > treeinfo_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static YYChannelTreeInfoRes* default_instance_;
};
// -------------------------------------------------------------------

class ProtoBody : public ::google::protobuf::Message {
 public:
  ProtoBody();
  virtual ~ProtoBody();

  ProtoBody(const ProtoBody& from);

  inline ProtoBody& operator=(const ProtoBody& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProtoBody& default_instance();

  void Swap(ProtoBody* other);

  // implements Message ----------------------------------------------

  ProtoBody* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string remoteAddr = 1;
  inline bool has_remoteaddr() const;
  inline void clear_remoteaddr();
  static const int kRemoteAddrFieldNumber = 1;
  inline const ::std::string& remoteaddr() const;
  inline void set_remoteaddr(const ::std::string& value);
  inline void set_remoteaddr(const char* value);
  inline void set_remoteaddr(const char* value, size_t size);
  inline ::std::string* mutable_remoteaddr();
  inline ::std::string* release_remoteaddr();
  inline void set_allocated_remoteaddr(::std::string* remoteaddr);

  // optional uint32 clientVersion = 4;
  inline bool has_clientversion() const;
  inline void clear_clientversion();
  static const int kClientVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 clientversion() const;
  inline void set_clientversion(::google::protobuf::uint32 value);

  // optional .pp.ForceLogoutPush forceLogoutPush = 5;
  inline bool has_forcelogoutpush() const;
  inline void clear_forcelogoutpush();
  static const int kForceLogoutPushFieldNumber = 5;
  inline const ::pp::ForceLogoutPush& forcelogoutpush() const;
  inline ::pp::ForceLogoutPush* mutable_forcelogoutpush();
  inline ::pp::ForceLogoutPush* release_forcelogoutpush();
  inline void set_allocated_forcelogoutpush(::pp::ForceLogoutPush* forcelogoutpush);

  // optional .pp.MsgPush msgPush = 6;
  inline bool has_msgpush() const;
  inline void clear_msgpush();
  static const int kMsgPushFieldNumber = 6;
  inline const ::pp::MsgPush& msgpush() const;
  inline ::pp::MsgPush* mutable_msgpush();
  inline ::pp::MsgPush* release_msgpush();
  inline void set_allocated_msgpush(::pp::MsgPush* msgpush);

  // optional string iosPushMsg = 7;
  inline bool has_iospushmsg() const;
  inline void clear_iospushmsg();
  static const int kIosPushMsgFieldNumber = 7;
  inline const ::std::string& iospushmsg() const;
  inline void set_iospushmsg(const ::std::string& value);
  inline void set_iospushmsg(const char* value);
  inline void set_iospushmsg(const char* value, size_t size);
  inline ::std::string* mutable_iospushmsg();
  inline ::std::string* release_iospushmsg();
  inline void set_allocated_iospushmsg(::std::string* iospushmsg);

  // optional .pp.UserMsg userMsg = 8;
  inline bool has_usermsg() const;
  inline void clear_usermsg();
  static const int kUserMsgFieldNumber = 8;
  inline const ::pp::UserMsg& usermsg() const;
  inline ::pp::UserMsg* mutable_usermsg();
  inline ::pp::UserMsg* release_usermsg();
  inline void set_allocated_usermsg(::pp::UserMsg* usermsg);

  // optional .pp.GroupMsg groupMsg = 9;
  inline bool has_groupmsg() const;
  inline void clear_groupmsg();
  static const int kGroupMsgFieldNumber = 9;
  inline const ::pp::GroupMsg& groupmsg() const;
  inline ::pp::GroupMsg* mutable_groupmsg();
  inline ::pp::GroupMsg* release_groupmsg();
  inline void set_allocated_groupmsg(::pp::GroupMsg* groupmsg);

  // optional .pp.Result result = 16;
  inline bool has_result() const;
  inline void clear_result();
  static const int kResultFieldNumber = 16;
  inline const ::pp::Result& result() const;
  inline ::pp::Result* mutable_result();
  inline ::pp::Result* release_result();
  inline void set_allocated_result(::pp::Result* result);

  // optional .pp.UserInfo userInfo = 32;
  inline bool has_userinfo() const;
  inline void clear_userinfo();
  static const int kUserInfoFieldNumber = 32;
  inline const ::pp::UserInfo& userinfo() const;
  inline ::pp::UserInfo* mutable_userinfo();
  inline ::pp::UserInfo* release_userinfo();
  inline void set_allocated_userinfo(::pp::UserInfo* userinfo);

  // optional .pp.GroupInfo groupInfo = 33;
  inline bool has_groupinfo() const;
  inline void clear_groupinfo();
  static const int kGroupInfoFieldNumber = 33;
  inline const ::pp::GroupInfo& groupinfo() const;
  inline ::pp::GroupInfo* mutable_groupinfo();
  inline ::pp::GroupInfo* release_groupinfo();
  inline void set_allocated_groupinfo(::pp::GroupInfo* groupinfo);

  // optional .pp.GroupIncrement groupIncrement = 48;
  inline bool has_groupincrement() const;
  inline void clear_groupincrement();
  static const int kGroupIncrementFieldNumber = 48;
  inline const ::pp::GroupIncrement& groupincrement() const;
  inline ::pp::GroupIncrement* mutable_groupincrement();
  inline ::pp::GroupIncrement* release_groupincrement();
  inline void set_allocated_groupincrement(::pp::GroupIncrement* groupincrement);

  // optional .pp.ContactIncrement contactIncrement = 64;
  inline bool has_contactincrement() const;
  inline void clear_contactincrement();
  static const int kContactIncrementFieldNumber = 64;
  inline const ::pp::ContactIncrement& contactincrement() const;
  inline ::pp::ContactIncrement* mutable_contactincrement();
  inline ::pp::ContactIncrement* release_contactincrement();
  inline void set_allocated_contactincrement(::pp::ContactIncrement* contactincrement);

  // optional .pp.AdListReq adListReq = 5120;
  inline bool has_adlistreq() const;
  inline void clear_adlistreq();
  static const int kAdListReqFieldNumber = 5120;
  inline const ::pp::AdListReq& adlistreq() const;
  inline ::pp::AdListReq* mutable_adlistreq();
  inline ::pp::AdListReq* release_adlistreq();
  inline void set_allocated_adlistreq(::pp::AdListReq* adlistreq);

  // optional .pp.AdListRes adListRes = 5121;
  inline bool has_adlistres() const;
  inline void clear_adlistres();
  static const int kAdListResFieldNumber = 5121;
  inline const ::pp::AdListRes& adlistres() const;
  inline ::pp::AdListRes* mutable_adlistres();
  inline ::pp::AdListRes* release_adlistres();
  inline void set_allocated_adlistres(::pp::AdListRes* adlistres);

  // optional .pp.AdModifyReq adModifyReq = 5122;
  inline bool has_admodifyreq() const;
  inline void clear_admodifyreq();
  static const int kAdModifyReqFieldNumber = 5122;
  inline const ::pp::AdModifyReq& admodifyreq() const;
  inline ::pp::AdModifyReq* mutable_admodifyreq();
  inline ::pp::AdModifyReq* release_admodifyreq();
  inline void set_allocated_admodifyreq(::pp::AdModifyReq* admodifyreq);

  // optional .pp.AdModifyRes adModifyRes = 5123;
  inline bool has_admodifyres() const;
  inline void clear_admodifyres();
  static const int kAdModifyResFieldNumber = 5123;
  inline const ::pp::AdModifyRes& admodifyres() const;
  inline ::pp::AdModifyRes* mutable_admodifyres();
  inline ::pp::AdModifyRes* release_admodifyres();
  inline void set_allocated_admodifyres(::pp::AdModifyRes* admodifyres);

  // optional .pp.AdRemoveReq adRemoveReq = 5124;
  inline bool has_adremovereq() const;
  inline void clear_adremovereq();
  static const int kAdRemoveReqFieldNumber = 5124;
  inline const ::pp::AdRemoveReq& adremovereq() const;
  inline ::pp::AdRemoveReq* mutable_adremovereq();
  inline ::pp::AdRemoveReq* release_adremovereq();
  inline void set_allocated_adremovereq(::pp::AdRemoveReq* adremovereq);

  // optional .pp.AdRemoveRes adRemoveRes = 5125;
  inline bool has_adremoveres() const;
  inline void clear_adremoveres();
  static const int kAdRemoveResFieldNumber = 5125;
  inline const ::pp::AdRemoveRes& adremoveres() const;
  inline ::pp::AdRemoveRes* mutable_adremoveres();
  inline ::pp::AdRemoveRes* release_adremoveres();
  inline void set_allocated_adremoveres(::pp::AdRemoveRes* adremoveres);

  // optional .pp.IDCodeApplyReq iDCodeApplyReq = 4864;
  inline bool has_idcodeapplyreq() const;
  inline void clear_idcodeapplyreq();
  static const int kIDCodeApplyReqFieldNumber = 4864;
  inline const ::pp::IDCodeApplyReq& idcodeapplyreq() const;
  inline ::pp::IDCodeApplyReq* mutable_idcodeapplyreq();
  inline ::pp::IDCodeApplyReq* release_idcodeapplyreq();
  inline void set_allocated_idcodeapplyreq(::pp::IDCodeApplyReq* idcodeapplyreq);

  // optional .pp.IDCodeApplyRes iDCodeApplyRes = 4865;
  inline bool has_idcodeapplyres() const;
  inline void clear_idcodeapplyres();
  static const int kIDCodeApplyResFieldNumber = 4865;
  inline const ::pp::IDCodeApplyRes& idcodeapplyres() const;
  inline ::pp::IDCodeApplyRes* mutable_idcodeapplyres();
  inline ::pp::IDCodeApplyRes* release_idcodeapplyres();
  inline void set_allocated_idcodeapplyres(::pp::IDCodeApplyRes* idcodeapplyres);

  // optional .pp.IDReplaceReq iDReplaceReq = 4866;
  inline bool has_idreplacereq() const;
  inline void clear_idreplacereq();
  static const int kIDReplaceReqFieldNumber = 4866;
  inline const ::pp::IDReplaceReq& idreplacereq() const;
  inline ::pp::IDReplaceReq* mutable_idreplacereq();
  inline ::pp::IDReplaceReq* release_idreplacereq();
  inline void set_allocated_idreplacereq(::pp::IDReplaceReq* idreplacereq);

  // optional .pp.PublicNumAddReq publicNumAddReq = 4880;
  inline bool has_publicnumaddreq() const;
  inline void clear_publicnumaddreq();
  static const int kPublicNumAddReqFieldNumber = 4880;
  inline const ::pp::PublicNumAddReq& publicnumaddreq() const;
  inline ::pp::PublicNumAddReq* mutable_publicnumaddreq();
  inline ::pp::PublicNumAddReq* release_publicnumaddreq();
  inline void set_allocated_publicnumaddreq(::pp::PublicNumAddReq* publicnumaddreq);

  // optional .pp.UserForbidOpReq userForbidOpReq = 4882;
  inline bool has_userforbidopreq() const;
  inline void clear_userforbidopreq();
  static const int kUserForbidOpReqFieldNumber = 4882;
  inline const ::pp::UserForbidOpReq& userforbidopreq() const;
  inline ::pp::UserForbidOpReq* mutable_userforbidopreq();
  inline ::pp::UserForbidOpReq* release_userforbidopreq();
  inline void set_allocated_userforbidopreq(::pp::UserForbidOpReq* userforbidopreq);

  // optional .pp.UserForbidOpRes userForbidOpRes = 4883;
  inline bool has_userforbidopres() const;
  inline void clear_userforbidopres();
  static const int kUserForbidOpResFieldNumber = 4883;
  inline const ::pp::UserForbidOpRes& userforbidopres() const;
  inline ::pp::UserForbidOpRes* mutable_userforbidopres();
  inline ::pp::UserForbidOpRes* release_userforbidopres();
  inline void set_allocated_userforbidopres(::pp::UserForbidOpRes* userforbidopres);

  // optional .pp.UserForbidSearchReq userForbidSearchReq = 4884;
  inline bool has_userforbidsearchreq() const;
  inline void clear_userforbidsearchreq();
  static const int kUserForbidSearchReqFieldNumber = 4884;
  inline const ::pp::UserForbidSearchReq& userforbidsearchreq() const;
  inline ::pp::UserForbidSearchReq* mutable_userforbidsearchreq();
  inline ::pp::UserForbidSearchReq* release_userforbidsearchreq();
  inline void set_allocated_userforbidsearchreq(::pp::UserForbidSearchReq* userforbidsearchreq);

  // optional .pp.UserForbidSearchRes userForbidSearchRes = 4885;
  inline bool has_userforbidsearchres() const;
  inline void clear_userforbidsearchres();
  static const int kUserForbidSearchResFieldNumber = 4885;
  inline const ::pp::UserForbidSearchRes& userforbidsearchres() const;
  inline ::pp::UserForbidSearchRes* mutable_userforbidsearchres();
  inline ::pp::UserForbidSearchRes* release_userforbidsearchres();
  inline void set_allocated_userforbidsearchres(::pp::UserForbidSearchRes* userforbidsearchres);

  // optional .pp.UserRoleModifyReq userRoleModifyReq = 4890;
  inline bool has_userrolemodifyreq() const;
  inline void clear_userrolemodifyreq();
  static const int kUserRoleModifyReqFieldNumber = 4890;
  inline const ::pp::UserRoleModifyReq& userrolemodifyreq() const;
  inline ::pp::UserRoleModifyReq* mutable_userrolemodifyreq();
  inline ::pp::UserRoleModifyReq* release_userrolemodifyreq();
  inline void set_allocated_userrolemodifyreq(::pp::UserRoleModifyReq* userrolemodifyreq);

  // optional .pp.BackstageGidSidReq backstageGidSidReq = 13569;
  inline bool has_backstagegidsidreq() const;
  inline void clear_backstagegidsidreq();
  static const int kBackstageGidSidReqFieldNumber = 13569;
  inline const ::pp::BackstageGidSidReq& backstagegidsidreq() const;
  inline ::pp::BackstageGidSidReq* mutable_backstagegidsidreq();
  inline ::pp::BackstageGidSidReq* release_backstagegidsidreq();
  inline void set_allocated_backstagegidsidreq(::pp::BackstageGidSidReq* backstagegidsidreq);

  // optional .pp.BackstageGidSidRes backstageGidSidRes = 13570;
  inline bool has_backstagegidsidres() const;
  inline void clear_backstagegidsidres();
  static const int kBackstageGidSidResFieldNumber = 13570;
  inline const ::pp::BackstageGidSidRes& backstagegidsidres() const;
  inline ::pp::BackstageGidSidRes* mutable_backstagegidsidres();
  inline ::pp::BackstageGidSidRes* release_backstagegidsidres();
  inline void set_allocated_backstagegidsidres(::pp::BackstageGidSidRes* backstagegidsidres);

  // optional .pp.ConfigJsonReq configJsonReq = 6401;
  inline bool has_configjsonreq() const;
  inline void clear_configjsonreq();
  static const int kConfigJsonReqFieldNumber = 6401;
  inline const ::pp::ConfigJsonReq& configjsonreq() const;
  inline ::pp::ConfigJsonReq* mutable_configjsonreq();
  inline ::pp::ConfigJsonReq* release_configjsonreq();
  inline void set_allocated_configjsonreq(::pp::ConfigJsonReq* configjsonreq);

  // optional .pp.ConfigJsonRes configJsonRes = 6402;
  inline bool has_configjsonres() const;
  inline void clear_configjsonres();
  static const int kConfigJsonResFieldNumber = 6402;
  inline const ::pp::ConfigJsonRes& configjsonres() const;
  inline ::pp::ConfigJsonRes* mutable_configjsonres();
  inline ::pp::ConfigJsonRes* release_configjsonres();
  inline void set_allocated_configjsonres(::pp::ConfigJsonRes* configjsonres);

  // optional .pp.ConfigJsonListReq configJsonListReq = 6403;
  inline bool has_configjsonlistreq() const;
  inline void clear_configjsonlistreq();
  static const int kConfigJsonListReqFieldNumber = 6403;
  inline const ::pp::ConfigJsonListReq& configjsonlistreq() const;
  inline ::pp::ConfigJsonListReq* mutable_configjsonlistreq();
  inline ::pp::ConfigJsonListReq* release_configjsonlistreq();
  inline void set_allocated_configjsonlistreq(::pp::ConfigJsonListReq* configjsonlistreq);

  // optional .pp.ConfigJsonListRes configJsonListRes = 6404;
  inline bool has_configjsonlistres() const;
  inline void clear_configjsonlistres();
  static const int kConfigJsonListResFieldNumber = 6404;
  inline const ::pp::ConfigJsonListRes& configjsonlistres() const;
  inline ::pp::ConfigJsonListRes* mutable_configjsonlistres();
  inline ::pp::ConfigJsonListRes* release_configjsonlistres();
  inline void set_allocated_configjsonlistres(::pp::ConfigJsonListRes* configjsonlistres);

  // optional .pp.SysConfReq sysConfReq = 6405;
  inline bool has_sysconfreq() const;
  inline void clear_sysconfreq();
  static const int kSysConfReqFieldNumber = 6405;
  inline const ::pp::SysConfReq& sysconfreq() const;
  inline ::pp::SysConfReq* mutable_sysconfreq();
  inline ::pp::SysConfReq* release_sysconfreq();
  inline void set_allocated_sysconfreq(::pp::SysConfReq* sysconfreq);

  // optional .pp.SysConfRes sysConfRes = 6406;
  inline bool has_sysconfres() const;
  inline void clear_sysconfres();
  static const int kSysConfResFieldNumber = 6406;
  inline const ::pp::SysConfRes& sysconfres() const;
  inline ::pp::SysConfRes* mutable_sysconfres();
  inline ::pp::SysConfRes* release_sysconfres();
  inline void set_allocated_sysconfres(::pp::SysConfRes* sysconfres);

  // optional .pp.UserSettingSetReq userSettingSetReq = 6452;
  inline bool has_usersettingsetreq() const;
  inline void clear_usersettingsetreq();
  static const int kUserSettingSetReqFieldNumber = 6452;
  inline const ::pp::UserSettingSetReq& usersettingsetreq() const;
  inline ::pp::UserSettingSetReq* mutable_usersettingsetreq();
  inline ::pp::UserSettingSetReq* release_usersettingsetreq();
  inline void set_allocated_usersettingsetreq(::pp::UserSettingSetReq* usersettingsetreq);

  // optional .pp.UserSettingSetRes userSettingSetRes = 6453;
  inline bool has_usersettingsetres() const;
  inline void clear_usersettingsetres();
  static const int kUserSettingSetResFieldNumber = 6453;
  inline const ::pp::UserSettingSetRes& usersettingsetres() const;
  inline ::pp::UserSettingSetRes* mutable_usersettingsetres();
  inline ::pp::UserSettingSetRes* release_usersettingsetres();
  inline void set_allocated_usersettingsetres(::pp::UserSettingSetRes* usersettingsetres);

  // optional .pp.UserSettingGetReq userSettingGetReq = 6454;
  inline bool has_usersettinggetreq() const;
  inline void clear_usersettinggetreq();
  static const int kUserSettingGetReqFieldNumber = 6454;
  inline const ::pp::UserSettingGetReq& usersettinggetreq() const;
  inline ::pp::UserSettingGetReq* mutable_usersettinggetreq();
  inline ::pp::UserSettingGetReq* release_usersettinggetreq();
  inline void set_allocated_usersettinggetreq(::pp::UserSettingGetReq* usersettinggetreq);

  // optional .pp.UserSettingGetRes userSettingGetRes = 6455;
  inline bool has_usersettinggetres() const;
  inline void clear_usersettinggetres();
  static const int kUserSettingGetResFieldNumber = 6455;
  inline const ::pp::UserSettingGetRes& usersettinggetres() const;
  inline ::pp::UserSettingGetRes* mutable_usersettinggetres();
  inline ::pp::UserSettingGetRes* release_usersettinggetres();
  inline void set_allocated_usersettinggetres(::pp::UserSettingGetRes* usersettinggetres);

  // optional .pp.AppStateCheckReq appStateCheckReq = 6464;
  inline bool has_appstatecheckreq() const;
  inline void clear_appstatecheckreq();
  static const int kAppStateCheckReqFieldNumber = 6464;
  inline const ::pp::AppStateCheckReq& appstatecheckreq() const;
  inline ::pp::AppStateCheckReq* mutable_appstatecheckreq();
  inline ::pp::AppStateCheckReq* release_appstatecheckreq();
  inline void set_allocated_appstatecheckreq(::pp::AppStateCheckReq* appstatecheckreq);

  // optional .pp.AppStateCheckRes appStateCheckRes = 6465;
  inline bool has_appstatecheckres() const;
  inline void clear_appstatecheckres();
  static const int kAppStateCheckResFieldNumber = 6465;
  inline const ::pp::AppStateCheckRes& appstatecheckres() const;
  inline ::pp::AppStateCheckRes* mutable_appstatecheckres();
  inline ::pp::AppStateCheckRes* release_appstatecheckres();
  inline void set_allocated_appstatecheckres(::pp::AppStateCheckRes* appstatecheckres);

  // optional .pp.AppStateUpdateReq appStateUpdateReq = 6466;
  inline bool has_appstateupdatereq() const;
  inline void clear_appstateupdatereq();
  static const int kAppStateUpdateReqFieldNumber = 6466;
  inline const ::pp::AppStateUpdateReq& appstateupdatereq() const;
  inline ::pp::AppStateUpdateReq* mutable_appstateupdatereq();
  inline ::pp::AppStateUpdateReq* release_appstateupdatereq();
  inline void set_allocated_appstateupdatereq(::pp::AppStateUpdateReq* appstateupdatereq);

  // optional .pp.AppStateUpdateRes appStateUpdateRes = 6467;
  inline bool has_appstateupdateres() const;
  inline void clear_appstateupdateres();
  static const int kAppStateUpdateResFieldNumber = 6467;
  inline const ::pp::AppStateUpdateRes& appstateupdateres() const;
  inline ::pp::AppStateUpdateRes* mutable_appstateupdateres();
  inline ::pp::AppStateUpdateRes* release_appstateupdateres();
  inline void set_allocated_appstateupdateres(::pp::AppStateUpdateRes* appstateupdateres);

  // optional .pp.AppActConfigReq appActConfigReq = 6468;
  inline bool has_appactconfigreq() const;
  inline void clear_appactconfigreq();
  static const int kAppActConfigReqFieldNumber = 6468;
  inline const ::pp::AppActConfigReq& appactconfigreq() const;
  inline ::pp::AppActConfigReq* mutable_appactconfigreq();
  inline ::pp::AppActConfigReq* release_appactconfigreq();
  inline void set_allocated_appactconfigreq(::pp::AppActConfigReq* appactconfigreq);

  // optional .pp.AppActConfigRes appActConfigRes = 6469;
  inline bool has_appactconfigres() const;
  inline void clear_appactconfigres();
  static const int kAppActConfigResFieldNumber = 6469;
  inline const ::pp::AppActConfigRes& appactconfigres() const;
  inline ::pp::AppActConfigRes* mutable_appactconfigres();
  inline ::pp::AppActConfigRes* release_appactconfigres();
  inline void set_allocated_appactconfigres(::pp::AppActConfigRes* appactconfigres);

  // optional .pp.AppProtoVersionUpdateReq appProtoVersionUpdateReq = 6470;
  inline bool has_appprotoversionupdatereq() const;
  inline void clear_appprotoversionupdatereq();
  static const int kAppProtoVersionUpdateReqFieldNumber = 6470;
  inline const ::pp::AppProtoVersionUpdateReq& appprotoversionupdatereq() const;
  inline ::pp::AppProtoVersionUpdateReq* mutable_appprotoversionupdatereq();
  inline ::pp::AppProtoVersionUpdateReq* release_appprotoversionupdatereq();
  inline void set_allocated_appprotoversionupdatereq(::pp::AppProtoVersionUpdateReq* appprotoversionupdatereq);

  // optional .pp.AppProtoVersionUpdateRes appProtoVersionUpdateRes = 6471;
  inline bool has_appprotoversionupdateres() const;
  inline void clear_appprotoversionupdateres();
  static const int kAppProtoVersionUpdateResFieldNumber = 6471;
  inline const ::pp::AppProtoVersionUpdateRes& appprotoversionupdateres() const;
  inline ::pp::AppProtoVersionUpdateRes* mutable_appprotoversionupdateres();
  inline ::pp::AppProtoVersionUpdateRes* release_appprotoversionupdateres();
  inline void set_allocated_appprotoversionupdateres(::pp::AppProtoVersionUpdateRes* appprotoversionupdateres);

  // optional .pp.ContactListReq contactListReq = 12801;
  inline bool has_contactlistreq() const;
  inline void clear_contactlistreq();
  static const int kContactListReqFieldNumber = 12801;
  inline const ::pp::ContactListReq& contactlistreq() const;
  inline ::pp::ContactListReq* mutable_contactlistreq();
  inline ::pp::ContactListReq* release_contactlistreq();
  inline void set_allocated_contactlistreq(::pp::ContactListReq* contactlistreq);

  // optional .pp.ContactListRes contactListRes = 12802;
  inline bool has_contactlistres() const;
  inline void clear_contactlistres();
  static const int kContactListResFieldNumber = 12802;
  inline const ::pp::ContactListRes& contactlistres() const;
  inline ::pp::ContactListRes* mutable_contactlistres();
  inline ::pp::ContactListRes* release_contactlistres();
  inline void set_allocated_contactlistres(::pp::ContactListRes* contactlistres);

  // optional .pp.ContactAddReq contactAddReq = 12807;
  inline bool has_contactaddreq() const;
  inline void clear_contactaddreq();
  static const int kContactAddReqFieldNumber = 12807;
  inline const ::pp::ContactAddReq& contactaddreq() const;
  inline ::pp::ContactAddReq* mutable_contactaddreq();
  inline ::pp::ContactAddReq* release_contactaddreq();
  inline void set_allocated_contactaddreq(::pp::ContactAddReq* contactaddreq);

  // optional .pp.ContactAddRes contactAddRes = 12808;
  inline bool has_contactaddres() const;
  inline void clear_contactaddres();
  static const int kContactAddResFieldNumber = 12808;
  inline const ::pp::ContactAddRes& contactaddres() const;
  inline ::pp::ContactAddRes* mutable_contactaddres();
  inline ::pp::ContactAddRes* release_contactaddres();
  inline void set_allocated_contactaddres(::pp::ContactAddRes* contactaddres);

  // optional .pp.ContactApproveReq contactApproveReq = 12809;
  inline bool has_contactapprovereq() const;
  inline void clear_contactapprovereq();
  static const int kContactApproveReqFieldNumber = 12809;
  inline const ::pp::ContactApproveReq& contactapprovereq() const;
  inline ::pp::ContactApproveReq* mutable_contactapprovereq();
  inline ::pp::ContactApproveReq* release_contactapprovereq();
  inline void set_allocated_contactapprovereq(::pp::ContactApproveReq* contactapprovereq);

  // optional .pp.ContactApproveRes contactApproveRes = 12810;
  inline bool has_contactapproveres() const;
  inline void clear_contactapproveres();
  static const int kContactApproveResFieldNumber = 12810;
  inline const ::pp::ContactApproveRes& contactapproveres() const;
  inline ::pp::ContactApproveRes* mutable_contactapproveres();
  inline ::pp::ContactApproveRes* release_contactapproveres();
  inline void set_allocated_contactapproveres(::pp::ContactApproveRes* contactapproveres);

  // optional .pp.ContactModifyReq contactModifyReq = 12811;
  inline bool has_contactmodifyreq() const;
  inline void clear_contactmodifyreq();
  static const int kContactModifyReqFieldNumber = 12811;
  inline const ::pp::ContactModifyReq& contactmodifyreq() const;
  inline ::pp::ContactModifyReq* mutable_contactmodifyreq();
  inline ::pp::ContactModifyReq* release_contactmodifyreq();
  inline void set_allocated_contactmodifyreq(::pp::ContactModifyReq* contactmodifyreq);

  // optional .pp.ContactModifyRes contactModifyRes = 12812;
  inline bool has_contactmodifyres() const;
  inline void clear_contactmodifyres();
  static const int kContactModifyResFieldNumber = 12812;
  inline const ::pp::ContactModifyRes& contactmodifyres() const;
  inline ::pp::ContactModifyRes* mutable_contactmodifyres();
  inline ::pp::ContactModifyRes* release_contactmodifyres();
  inline void set_allocated_contactmodifyres(::pp::ContactModifyRes* contactmodifyres);

  // optional .pp.KeyExchangeReq keyExchangeReq = 65280;
  inline bool has_keyexchangereq() const;
  inline void clear_keyexchangereq();
  static const int kKeyExchangeReqFieldNumber = 65280;
  inline const ::pp::KeyExchangeReq& keyexchangereq() const;
  inline ::pp::KeyExchangeReq* mutable_keyexchangereq();
  inline ::pp::KeyExchangeReq* release_keyexchangereq();
  inline void set_allocated_keyexchangereq(::pp::KeyExchangeReq* keyexchangereq);

  // optional .pp.KeyExchangeRes keyExchangeRes = 65281;
  inline bool has_keyexchangeres() const;
  inline void clear_keyexchangeres();
  static const int kKeyExchangeResFieldNumber = 65281;
  inline const ::pp::KeyExchangeRes& keyexchangeres() const;
  inline ::pp::KeyExchangeRes* mutable_keyexchangeres();
  inline ::pp::KeyExchangeRes* release_keyexchangeres();
  inline void set_allocated_keyexchangeres(::pp::KeyExchangeRes* keyexchangeres);

  // optional .pp.UserGameListReq userGameListReq = 12545;
  inline bool has_usergamelistreq() const;
  inline void clear_usergamelistreq();
  static const int kUserGameListReqFieldNumber = 12545;
  inline const ::pp::UserGameListReq& usergamelistreq() const;
  inline ::pp::UserGameListReq* mutable_usergamelistreq();
  inline ::pp::UserGameListReq* release_usergamelistreq();
  inline void set_allocated_usergamelistreq(::pp::UserGameListReq* usergamelistreq);

  // optional .pp.UserGameListRes userGameListRes = 12546;
  inline bool has_usergamelistres() const;
  inline void clear_usergamelistres();
  static const int kUserGameListResFieldNumber = 12546;
  inline const ::pp::UserGameListRes& usergamelistres() const;
  inline ::pp::UserGameListRes* mutable_usergamelistres();
  inline ::pp::UserGameListRes* release_usergamelistres();
  inline void set_allocated_usergamelistres(::pp::UserGameListRes* usergamelistres);

  // optional .pp.UserGameListReportReq userGameListReportReq = 12547;
  inline bool has_usergamelistreportreq() const;
  inline void clear_usergamelistreportreq();
  static const int kUserGameListReportReqFieldNumber = 12547;
  inline const ::pp::UserGameListReportReq& usergamelistreportreq() const;
  inline ::pp::UserGameListReportReq* mutable_usergamelistreportreq();
  inline ::pp::UserGameListReportReq* release_usergamelistreportreq();
  inline void set_allocated_usergamelistreportreq(::pp::UserGameListReportReq* usergamelistreportreq);

  // optional .pp.UserGameListReportRes userGameListReportRes = 12548;
  inline bool has_usergamelistreportres() const;
  inline void clear_usergamelistreportres();
  static const int kUserGameListReportResFieldNumber = 12548;
  inline const ::pp::UserGameListReportRes& usergamelistreportres() const;
  inline ::pp::UserGameListReportRes* mutable_usergamelistreportres();
  inline ::pp::UserGameListReportRes* release_usergamelistreportres();
  inline void set_allocated_usergamelistreportres(::pp::UserGameListReportRes* usergamelistreportres);

  // optional .pp.UserGameRunReportReq userGameRunReportReq = 12549;
  inline bool has_usergamerunreportreq() const;
  inline void clear_usergamerunreportreq();
  static const int kUserGameRunReportReqFieldNumber = 12549;
  inline const ::pp::UserGameRunReportReq& usergamerunreportreq() const;
  inline ::pp::UserGameRunReportReq* mutable_usergamerunreportreq();
  inline ::pp::UserGameRunReportReq* release_usergamerunreportreq();
  inline void set_allocated_usergamerunreportreq(::pp::UserGameRunReportReq* usergamerunreportreq);

  // optional .pp.UserGameRunReportRes userGameRunReportRes = 12550;
  inline bool has_usergamerunreportres() const;
  inline void clear_usergamerunreportres();
  static const int kUserGameRunReportResFieldNumber = 12550;
  inline const ::pp::UserGameRunReportRes& usergamerunreportres() const;
  inline ::pp::UserGameRunReportRes* mutable_usergamerunreportres();
  inline ::pp::UserGameRunReportRes* release_usergamerunreportres();
  inline void set_allocated_usergamerunreportres(::pp::UserGameRunReportRes* usergamerunreportres);

  // optional .pp.GameAddReq gameAddReq = 12557;
  inline bool has_gameaddreq() const;
  inline void clear_gameaddreq();
  static const int kGameAddReqFieldNumber = 12557;
  inline const ::pp::GameAddReq& gameaddreq() const;
  inline ::pp::GameAddReq* mutable_gameaddreq();
  inline ::pp::GameAddReq* release_gameaddreq();
  inline void set_allocated_gameaddreq(::pp::GameAddReq* gameaddreq);

  // optional .pp.GameAddRes gameAddRes = 12558;
  inline bool has_gameaddres() const;
  inline void clear_gameaddres();
  static const int kGameAddResFieldNumber = 12558;
  inline const ::pp::GameAddRes& gameaddres() const;
  inline ::pp::GameAddRes* mutable_gameaddres();
  inline ::pp::GameAddRes* release_gameaddres();
  inline void set_allocated_gameaddres(::pp::GameAddRes* gameaddres);

  // optional .pp.GameModifyReq gameModifyReq = 12559;
  inline bool has_gamemodifyreq() const;
  inline void clear_gamemodifyreq();
  static const int kGameModifyReqFieldNumber = 12559;
  inline const ::pp::GameModifyReq& gamemodifyreq() const;
  inline ::pp::GameModifyReq* mutable_gamemodifyreq();
  inline ::pp::GameModifyReq* release_gamemodifyreq();
  inline void set_allocated_gamemodifyreq(::pp::GameModifyReq* gamemodifyreq);

  // optional .pp.GameModifyRes gameModifyRes = 12560;
  inline bool has_gamemodifyres() const;
  inline void clear_gamemodifyres();
  static const int kGameModifyResFieldNumber = 12560;
  inline const ::pp::GameModifyRes& gamemodifyres() const;
  inline ::pp::GameModifyRes* mutable_gamemodifyres();
  inline ::pp::GameModifyRes* release_gamemodifyres();
  inline void set_allocated_gamemodifyres(::pp::GameModifyRes* gamemodifyres);

  // optional .pp.GameSearchReq gameSearchReq = 12569;
  inline bool has_gamesearchreq() const;
  inline void clear_gamesearchreq();
  static const int kGameSearchReqFieldNumber = 12569;
  inline const ::pp::GameSearchReq& gamesearchreq() const;
  inline ::pp::GameSearchReq* mutable_gamesearchreq();
  inline ::pp::GameSearchReq* release_gamesearchreq();
  inline void set_allocated_gamesearchreq(::pp::GameSearchReq* gamesearchreq);

  // optional .pp.GameSearchRes gameSearchRes = 12570;
  inline bool has_gamesearchres() const;
  inline void clear_gamesearchres();
  static const int kGameSearchResFieldNumber = 12570;
  inline const ::pp::GameSearchRes& gamesearchres() const;
  inline ::pp::GameSearchRes* mutable_gamesearchres();
  inline ::pp::GameSearchRes* release_gamesearchres();
  inline void set_allocated_gamesearchres(::pp::GameSearchRes* gamesearchres);

  // optional .pp.ModifyGroupGameReq modifyGroupGameReq = 12571;
  inline bool has_modifygroupgamereq() const;
  inline void clear_modifygroupgamereq();
  static const int kModifyGroupGameReqFieldNumber = 12571;
  inline const ::pp::ModifyGroupGameReq& modifygroupgamereq() const;
  inline ::pp::ModifyGroupGameReq* mutable_modifygroupgamereq();
  inline ::pp::ModifyGroupGameReq* release_modifygroupgamereq();
  inline void set_allocated_modifygroupgamereq(::pp::ModifyGroupGameReq* modifygroupgamereq);

  // optional .pp.ModifyGroupGameRes modifyGroupGameRes = 12572;
  inline bool has_modifygroupgameres() const;
  inline void clear_modifygroupgameres();
  static const int kModifyGroupGameResFieldNumber = 12572;
  inline const ::pp::ModifyGroupGameRes& modifygroupgameres() const;
  inline ::pp::ModifyGroupGameRes* mutable_modifygroupgameres();
  inline ::pp::ModifyGroupGameRes* release_modifygroupgameres();
  inline void set_allocated_modifygroupgameres(::pp::ModifyGroupGameRes* modifygroupgameres);

  // optional .pp.GameDiscountListReq gameDiscountListReq = 12576;
  inline bool has_gamediscountlistreq() const;
  inline void clear_gamediscountlistreq();
  static const int kGameDiscountListReqFieldNumber = 12576;
  inline const ::pp::GameDiscountListReq& gamediscountlistreq() const;
  inline ::pp::GameDiscountListReq* mutable_gamediscountlistreq();
  inline ::pp::GameDiscountListReq* release_gamediscountlistreq();
  inline void set_allocated_gamediscountlistreq(::pp::GameDiscountListReq* gamediscountlistreq);

  // optional .pp.GameDiscountListRes gameDiscountListRes = 12577;
  inline bool has_gamediscountlistres() const;
  inline void clear_gamediscountlistres();
  static const int kGameDiscountListResFieldNumber = 12577;
  inline const ::pp::GameDiscountListRes& gamediscountlistres() const;
  inline ::pp::GameDiscountListRes* mutable_gamediscountlistres();
  inline ::pp::GameDiscountListRes* release_gamediscountlistres();
  inline void set_allocated_gamediscountlistres(::pp::GameDiscountListRes* gamediscountlistres);

  // optional .pp.ModifyGroupGameApkurlReq modifyGroupGameApkurlReq = 12578;
  inline bool has_modifygroupgameapkurlreq() const;
  inline void clear_modifygroupgameapkurlreq();
  static const int kModifyGroupGameApkurlReqFieldNumber = 12578;
  inline const ::pp::ModifyGroupGameApkurlReq& modifygroupgameapkurlreq() const;
  inline ::pp::ModifyGroupGameApkurlReq* mutable_modifygroupgameapkurlreq();
  inline ::pp::ModifyGroupGameApkurlReq* release_modifygroupgameapkurlreq();
  inline void set_allocated_modifygroupgameapkurlreq(::pp::ModifyGroupGameApkurlReq* modifygroupgameapkurlreq);

  // optional .pp.ModifyGroupGameApkurlRes modifyGroupGameApkurlRes = 12579;
  inline bool has_modifygroupgameapkurlres() const;
  inline void clear_modifygroupgameapkurlres();
  static const int kModifyGroupGameApkurlResFieldNumber = 12579;
  inline const ::pp::ModifyGroupGameApkurlRes& modifygroupgameapkurlres() const;
  inline ::pp::ModifyGroupGameApkurlRes* mutable_modifygroupgameapkurlres();
  inline ::pp::ModifyGroupGameApkurlRes* release_modifygroupgameapkurlres();
  inline void set_allocated_modifygroupgameapkurlres(::pp::ModifyGroupGameApkurlRes* modifygroupgameapkurlres);

  // optional .pp.SendInstallGameMsgReq sendInstallGameMsgReq = 12592;
  inline bool has_sendinstallgamemsgreq() const;
  inline void clear_sendinstallgamemsgreq();
  static const int kSendInstallGameMsgReqFieldNumber = 12592;
  inline const ::pp::SendInstallGameMsgReq& sendinstallgamemsgreq() const;
  inline ::pp::SendInstallGameMsgReq* mutable_sendinstallgamemsgreq();
  inline ::pp::SendInstallGameMsgReq* release_sendinstallgamemsgreq();
  inline void set_allocated_sendinstallgamemsgreq(::pp::SendInstallGameMsgReq* sendinstallgamemsgreq);

  // optional .pp.SendInstallGameMsgRes sendInstallGameMsgRes = 12593;
  inline bool has_sendinstallgamemsgres() const;
  inline void clear_sendinstallgamemsgres();
  static const int kSendInstallGameMsgResFieldNumber = 12593;
  inline const ::pp::SendInstallGameMsgRes& sendinstallgamemsgres() const;
  inline ::pp::SendInstallGameMsgRes* mutable_sendinstallgamemsgres();
  inline ::pp::SendInstallGameMsgRes* release_sendinstallgamemsgres();
  inline void set_allocated_sendinstallgamemsgres(::pp::SendInstallGameMsgRes* sendinstallgamemsgres);

  // optional .pp.ModifyOurGameStateReq modifyOurGameStateReq = 12608;
  inline bool has_modifyourgamestatereq() const;
  inline void clear_modifyourgamestatereq();
  static const int kModifyOurGameStateReqFieldNumber = 12608;
  inline const ::pp::ModifyOurGameStateReq& modifyourgamestatereq() const;
  inline ::pp::ModifyOurGameStateReq* mutable_modifyourgamestatereq();
  inline ::pp::ModifyOurGameStateReq* release_modifyourgamestatereq();
  inline void set_allocated_modifyourgamestatereq(::pp::ModifyOurGameStateReq* modifyourgamestatereq);

  // optional .pp.ModifyOurGameStateRes modifyOurGameStateRes = 12609;
  inline bool has_modifyourgamestateres() const;
  inline void clear_modifyourgamestateres();
  static const int kModifyOurGameStateResFieldNumber = 12609;
  inline const ::pp::ModifyOurGameStateRes& modifyourgamestateres() const;
  inline ::pp::ModifyOurGameStateRes* mutable_modifyourgamestateres();
  inline ::pp::ModifyOurGameStateRes* release_modifyourgamestateres();
  inline void set_allocated_modifyourgamestateres(::pp::ModifyOurGameStateRes* modifyourgamestateres);

  // optional .pp.SearchGamesListReq searchGamesListReq = 12610;
  inline bool has_searchgameslistreq() const;
  inline void clear_searchgameslistreq();
  static const int kSearchGamesListReqFieldNumber = 12610;
  inline const ::pp::SearchGamesListReq& searchgameslistreq() const;
  inline ::pp::SearchGamesListReq* mutable_searchgameslistreq();
  inline ::pp::SearchGamesListReq* release_searchgameslistreq();
  inline void set_allocated_searchgameslistreq(::pp::SearchGamesListReq* searchgameslistreq);

  // optional .pp.SearchGamesListRes searchGamesListRes = 12611;
  inline bool has_searchgameslistres() const;
  inline void clear_searchgameslistres();
  static const int kSearchGamesListResFieldNumber = 12611;
  inline const ::pp::SearchGamesListRes& searchgameslistres() const;
  inline ::pp::SearchGamesListRes* mutable_searchgameslistres();
  inline ::pp::SearchGamesListRes* release_searchgameslistres();
  inline void set_allocated_searchgameslistres(::pp::SearchGamesListRes* searchgameslistres);

  // optional .pp.GameCountReq gameCountReq = 12624;
  inline bool has_gamecountreq() const;
  inline void clear_gamecountreq();
  static const int kGameCountReqFieldNumber = 12624;
  inline const ::pp::GameCountReq& gamecountreq() const;
  inline ::pp::GameCountReq* mutable_gamecountreq();
  inline ::pp::GameCountReq* release_gamecountreq();
  inline void set_allocated_gamecountreq(::pp::GameCountReq* gamecountreq);

  // optional .pp.GameCountRes gameCountRes = 12625;
  inline bool has_gamecountres() const;
  inline void clear_gamecountres();
  static const int kGameCountResFieldNumber = 12625;
  inline const ::pp::GameCountRes& gamecountres() const;
  inline ::pp::GameCountRes* mutable_gamecountres();
  inline ::pp::GameCountRes* release_gamecountres();
  inline void set_allocated_gamecountres(::pp::GameCountRes* gamecountres);

  // optional .pp.RecommendPackNameReq recommendPackNameReq = 12626;
  inline bool has_recommendpacknamereq() const;
  inline void clear_recommendpacknamereq();
  static const int kRecommendPackNameReqFieldNumber = 12626;
  inline const ::pp::RecommendPackNameReq& recommendpacknamereq() const;
  inline ::pp::RecommendPackNameReq* mutable_recommendpacknamereq();
  inline ::pp::RecommendPackNameReq* release_recommendpacknamereq();
  inline void set_allocated_recommendpacknamereq(::pp::RecommendPackNameReq* recommendpacknamereq);

  // optional .pp.RecommendPackNameRes recommendPackNameRes = 12627;
  inline bool has_recommendpacknameres() const;
  inline void clear_recommendpacknameres();
  static const int kRecommendPackNameResFieldNumber = 12627;
  inline const ::pp::RecommendPackNameRes& recommendpacknameres() const;
  inline ::pp::RecommendPackNameRes* mutable_recommendpacknameres();
  inline ::pp::RecommendPackNameRes* release_recommendpacknameres();
  inline void set_allocated_recommendpacknameres(::pp::RecommendPackNameRes* recommendpacknameres);

  // optional .pp.GameFilterSearchReq gameFilterSearchReq = 12628;
  inline bool has_gamefiltersearchreq() const;
  inline void clear_gamefiltersearchreq();
  static const int kGameFilterSearchReqFieldNumber = 12628;
  inline const ::pp::GameFilterSearchReq& gamefiltersearchreq() const;
  inline ::pp::GameFilterSearchReq* mutable_gamefiltersearchreq();
  inline ::pp::GameFilterSearchReq* release_gamefiltersearchreq();
  inline void set_allocated_gamefiltersearchreq(::pp::GameFilterSearchReq* gamefiltersearchreq);

  // optional .pp.GameFilterSearchRes gameFilterSearchRes = 12629;
  inline bool has_gamefiltersearchres() const;
  inline void clear_gamefiltersearchres();
  static const int kGameFilterSearchResFieldNumber = 12629;
  inline const ::pp::GameFilterSearchRes& gamefiltersearchres() const;
  inline ::pp::GameFilterSearchRes* mutable_gamefiltersearchres();
  inline ::pp::GameFilterSearchRes* release_gamefiltersearchres();
  inline void set_allocated_gamefiltersearchres(::pp::GameFilterSearchRes* gamefiltersearchres);

  // optional .pp.ModifyGameFilterReq modifyGameFilterReq = 12630;
  inline bool has_modifygamefilterreq() const;
  inline void clear_modifygamefilterreq();
  static const int kModifyGameFilterReqFieldNumber = 12630;
  inline const ::pp::ModifyGameFilterReq& modifygamefilterreq() const;
  inline ::pp::ModifyGameFilterReq* mutable_modifygamefilterreq();
  inline ::pp::ModifyGameFilterReq* release_modifygamefilterreq();
  inline void set_allocated_modifygamefilterreq(::pp::ModifyGameFilterReq* modifygamefilterreq);

  // optional .pp.ModifyGameFilterRes modifyGameFilterRes = 12631;
  inline bool has_modifygamefilterres() const;
  inline void clear_modifygamefilterres();
  static const int kModifyGameFilterResFieldNumber = 12631;
  inline const ::pp::ModifyGameFilterRes& modifygamefilterres() const;
  inline ::pp::ModifyGameFilterRes* mutable_modifygamefilterres();
  inline ::pp::ModifyGameFilterRes* release_modifygamefilterres();
  inline void set_allocated_modifygamefilterres(::pp::ModifyGameFilterRes* modifygamefilterres);

  // optional .pp.GameSpiderReq gameSpiderReq = 12632;
  inline bool has_gamespiderreq() const;
  inline void clear_gamespiderreq();
  static const int kGameSpiderReqFieldNumber = 12632;
  inline const ::pp::GameSpiderReq& gamespiderreq() const;
  inline ::pp::GameSpiderReq* mutable_gamespiderreq();
  inline ::pp::GameSpiderReq* release_gamespiderreq();
  inline void set_allocated_gamespiderreq(::pp::GameSpiderReq* gamespiderreq);

  // optional .pp.GameSpiderRes gameSpiderRes = 12633;
  inline bool has_gamespiderres() const;
  inline void clear_gamespiderres();
  static const int kGameSpiderResFieldNumber = 12633;
  inline const ::pp::GameSpiderRes& gamespiderres() const;
  inline ::pp::GameSpiderRes* mutable_gamespiderres();
  inline ::pp::GameSpiderRes* release_gamespiderres();
  inline void set_allocated_gamespiderres(::pp::GameSpiderRes* gamespiderres);

  // optional .pp.ModifyGameDiscountReq modifyGameDiscountReq = 12634;
  inline bool has_modifygamediscountreq() const;
  inline void clear_modifygamediscountreq();
  static const int kModifyGameDiscountReqFieldNumber = 12634;
  inline const ::pp::ModifyGameDiscountReq& modifygamediscountreq() const;
  inline ::pp::ModifyGameDiscountReq* mutable_modifygamediscountreq();
  inline ::pp::ModifyGameDiscountReq* release_modifygamediscountreq();
  inline void set_allocated_modifygamediscountreq(::pp::ModifyGameDiscountReq* modifygamediscountreq);

  // optional .pp.ModifyGameDiscountRes modifyGameDiscountRes = 12635;
  inline bool has_modifygamediscountres() const;
  inline void clear_modifygamediscountres();
  static const int kModifyGameDiscountResFieldNumber = 12635;
  inline const ::pp::ModifyGameDiscountRes& modifygamediscountres() const;
  inline ::pp::ModifyGameDiscountRes* mutable_modifygamediscountres();
  inline ::pp::ModifyGameDiscountRes* release_modifygamediscountres();
  inline void set_allocated_modifygamediscountres(::pp::ModifyGameDiscountRes* modifygamediscountres);

  // optional .pp.ModifyGroupDiscountReq modifyGroupDiscountReq = 12636;
  inline bool has_modifygroupdiscountreq() const;
  inline void clear_modifygroupdiscountreq();
  static const int kModifyGroupDiscountReqFieldNumber = 12636;
  inline const ::pp::ModifyGroupDiscountReq& modifygroupdiscountreq() const;
  inline ::pp::ModifyGroupDiscountReq* mutable_modifygroupdiscountreq();
  inline ::pp::ModifyGroupDiscountReq* release_modifygroupdiscountreq();
  inline void set_allocated_modifygroupdiscountreq(::pp::ModifyGroupDiscountReq* modifygroupdiscountreq);

  // optional .pp.ModifyGroupDiscountRes modifyGroupDiscountRes = 12637;
  inline bool has_modifygroupdiscountres() const;
  inline void clear_modifygroupdiscountres();
  static const int kModifyGroupDiscountResFieldNumber = 12637;
  inline const ::pp::ModifyGroupDiscountRes& modifygroupdiscountres() const;
  inline ::pp::ModifyGroupDiscountRes* mutable_modifygroupdiscountres();
  inline ::pp::ModifyGroupDiscountRes* release_modifygroupdiscountres();
  inline void set_allocated_modifygroupdiscountres(::pp::ModifyGroupDiscountRes* modifygroupdiscountres);

  // optional .pp.GroupDiscountListReq groupDiscountListReq = 12638;
  inline bool has_groupdiscountlistreq() const;
  inline void clear_groupdiscountlistreq();
  static const int kGroupDiscountListReqFieldNumber = 12638;
  inline const ::pp::GroupDiscountListReq& groupdiscountlistreq() const;
  inline ::pp::GroupDiscountListReq* mutable_groupdiscountlistreq();
  inline ::pp::GroupDiscountListReq* release_groupdiscountlistreq();
  inline void set_allocated_groupdiscountlistreq(::pp::GroupDiscountListReq* groupdiscountlistreq);

  // optional .pp.GroupDiscountListRes groupDiscountListRes = 12639;
  inline bool has_groupdiscountlistres() const;
  inline void clear_groupdiscountlistres();
  static const int kGroupDiscountListResFieldNumber = 12639;
  inline const ::pp::GroupDiscountListRes& groupdiscountlistres() const;
  inline ::pp::GroupDiscountListRes* mutable_groupdiscountlistres();
  inline ::pp::GroupDiscountListRes* release_groupdiscountlistres();
  inline void set_allocated_groupdiscountlistres(::pp::GroupDiscountListRes* groupdiscountlistres);

  // optional .pp.UserYYCoinsPayMethodReq userYYCoinsPayMethodReq = 2817;
  inline bool has_useryycoinspaymethodreq() const;
  inline void clear_useryycoinspaymethodreq();
  static const int kUserYYCoinsPayMethodReqFieldNumber = 2817;
  inline const ::pp::UserYYCoinsPayMethodReq& useryycoinspaymethodreq() const;
  inline ::pp::UserYYCoinsPayMethodReq* mutable_useryycoinspaymethodreq();
  inline ::pp::UserYYCoinsPayMethodReq* release_useryycoinspaymethodreq();
  inline void set_allocated_useryycoinspaymethodreq(::pp::UserYYCoinsPayMethodReq* useryycoinspaymethodreq);

  // optional .pp.UserYYCoinsPayMethodRes userYYCoinsPayMethodRes = 2818;
  inline bool has_useryycoinspaymethodres() const;
  inline void clear_useryycoinspaymethodres();
  static const int kUserYYCoinsPayMethodResFieldNumber = 2818;
  inline const ::pp::UserYYCoinsPayMethodRes& useryycoinspaymethodres() const;
  inline ::pp::UserYYCoinsPayMethodRes* mutable_useryycoinspaymethodres();
  inline ::pp::UserYYCoinsPayMethodRes* release_useryycoinspaymethodres();
  inline void set_allocated_useryycoinspaymethodres(::pp::UserYYCoinsPayMethodRes* useryycoinspaymethodres);

  // optional .pp.UserYYCoinsShopListReq userYYCoinsShopListReq = 2821;
  inline bool has_useryycoinsshoplistreq() const;
  inline void clear_useryycoinsshoplistreq();
  static const int kUserYYCoinsShopListReqFieldNumber = 2821;
  inline const ::pp::UserYYCoinsShopListReq& useryycoinsshoplistreq() const;
  inline ::pp::UserYYCoinsShopListReq* mutable_useryycoinsshoplistreq();
  inline ::pp::UserYYCoinsShopListReq* release_useryycoinsshoplistreq();
  inline void set_allocated_useryycoinsshoplistreq(::pp::UserYYCoinsShopListReq* useryycoinsshoplistreq);

  // optional .pp.UserYYCoinsShopListRes userYYCoinsShopListRes = 2822;
  inline bool has_useryycoinsshoplistres() const;
  inline void clear_useryycoinsshoplistres();
  static const int kUserYYCoinsShopListResFieldNumber = 2822;
  inline const ::pp::UserYYCoinsShopListRes& useryycoinsshoplistres() const;
  inline ::pp::UserYYCoinsShopListRes* mutable_useryycoinsshoplistres();
  inline ::pp::UserYYCoinsShopListRes* release_useryycoinsshoplistres();
  inline void set_allocated_useryycoinsshoplistres(::pp::UserYYCoinsShopListRes* useryycoinsshoplistres);

  // optional .pp.UserYYCoinsQueryReq userYYCoinsQueryReq = 2825;
  inline bool has_useryycoinsqueryreq() const;
  inline void clear_useryycoinsqueryreq();
  static const int kUserYYCoinsQueryReqFieldNumber = 2825;
  inline const ::pp::UserYYCoinsQueryReq& useryycoinsqueryreq() const;
  inline ::pp::UserYYCoinsQueryReq* mutable_useryycoinsqueryreq();
  inline ::pp::UserYYCoinsQueryReq* release_useryycoinsqueryreq();
  inline void set_allocated_useryycoinsqueryreq(::pp::UserYYCoinsQueryReq* useryycoinsqueryreq);

  // optional .pp.UserYYCoinsQueryRes userYYCoinsQueryRes = 2826;
  inline bool has_useryycoinsqueryres() const;
  inline void clear_useryycoinsqueryres();
  static const int kUserYYCoinsQueryResFieldNumber = 2826;
  inline const ::pp::UserYYCoinsQueryRes& useryycoinsqueryres() const;
  inline ::pp::UserYYCoinsQueryRes* mutable_useryycoinsqueryres();
  inline ::pp::UserYYCoinsQueryRes* release_useryycoinsqueryres();
  inline void set_allocated_useryycoinsqueryres(::pp::UserYYCoinsQueryRes* useryycoinsqueryres);

  // optional .pp.UserYYCoinsBuyReq userYYCoinsBuyReq = 2833;
  inline bool has_useryycoinsbuyreq() const;
  inline void clear_useryycoinsbuyreq();
  static const int kUserYYCoinsBuyReqFieldNumber = 2833;
  inline const ::pp::UserYYCoinsBuyReq& useryycoinsbuyreq() const;
  inline ::pp::UserYYCoinsBuyReq* mutable_useryycoinsbuyreq();
  inline ::pp::UserYYCoinsBuyReq* release_useryycoinsbuyreq();
  inline void set_allocated_useryycoinsbuyreq(::pp::UserYYCoinsBuyReq* useryycoinsbuyreq);

  // optional .pp.UserYYCoinsBuyRes userYYCoinsBuyRes = 2834;
  inline bool has_useryycoinsbuyres() const;
  inline void clear_useryycoinsbuyres();
  static const int kUserYYCoinsBuyResFieldNumber = 2834;
  inline const ::pp::UserYYCoinsBuyRes& useryycoinsbuyres() const;
  inline ::pp::UserYYCoinsBuyRes* mutable_useryycoinsbuyres();
  inline ::pp::UserYYCoinsBuyRes* release_useryycoinsbuyres();
  inline void set_allocated_useryycoinsbuyres(::pp::UserYYCoinsBuyRes* useryycoinsbuyres);

  // optional .pp.UserYYCoinsBuyFeedbackReq userYYCoinsBuyFeedbackReq = 2835;
  inline bool has_useryycoinsbuyfeedbackreq() const;
  inline void clear_useryycoinsbuyfeedbackreq();
  static const int kUserYYCoinsBuyFeedbackReqFieldNumber = 2835;
  inline const ::pp::UserYYCoinsBuyFeedbackReq& useryycoinsbuyfeedbackreq() const;
  inline ::pp::UserYYCoinsBuyFeedbackReq* mutable_useryycoinsbuyfeedbackreq();
  inline ::pp::UserYYCoinsBuyFeedbackReq* release_useryycoinsbuyfeedbackreq();
  inline void set_allocated_useryycoinsbuyfeedbackreq(::pp::UserYYCoinsBuyFeedbackReq* useryycoinsbuyfeedbackreq);

  // optional .pp.UserYYCoinsBuyFeedbackRes userYYCoinsBuyFeedbackRes = 2836;
  inline bool has_useryycoinsbuyfeedbackres() const;
  inline void clear_useryycoinsbuyfeedbackres();
  static const int kUserYYCoinsBuyFeedbackResFieldNumber = 2836;
  inline const ::pp::UserYYCoinsBuyFeedbackRes& useryycoinsbuyfeedbackres() const;
  inline ::pp::UserYYCoinsBuyFeedbackRes* mutable_useryycoinsbuyfeedbackres();
  inline ::pp::UserYYCoinsBuyFeedbackRes* release_useryycoinsbuyfeedbackres();
  inline void set_allocated_useryycoinsbuyfeedbackres(::pp::UserYYCoinsBuyFeedbackRes* useryycoinsbuyfeedbackres);

  // optional .pp.UserYYCoinsHistoryReq userYYCoinsHistoryReq = 2837;
  inline bool has_useryycoinshistoryreq() const;
  inline void clear_useryycoinshistoryreq();
  static const int kUserYYCoinsHistoryReqFieldNumber = 2837;
  inline const ::pp::UserYYCoinsHistoryReq& useryycoinshistoryreq() const;
  inline ::pp::UserYYCoinsHistoryReq* mutable_useryycoinshistoryreq();
  inline ::pp::UserYYCoinsHistoryReq* release_useryycoinshistoryreq();
  inline void set_allocated_useryycoinshistoryreq(::pp::UserYYCoinsHistoryReq* useryycoinshistoryreq);

  // optional .pp.UserYYCoinsHistoryRes userYYCoinsHistoryRes = 2838;
  inline bool has_useryycoinshistoryres() const;
  inline void clear_useryycoinshistoryres();
  static const int kUserYYCoinsHistoryResFieldNumber = 2838;
  inline const ::pp::UserYYCoinsHistoryRes& useryycoinshistoryres() const;
  inline ::pp::UserYYCoinsHistoryRes* mutable_useryycoinshistoryres();
  inline ::pp::UserYYCoinsHistoryRes* release_useryycoinshistoryres();
  inline void set_allocated_useryycoinshistoryres(::pp::UserYYCoinsHistoryRes* useryycoinshistoryres);

  // optional .pp.UserYYCoinsPayGateCallbackReq userYYCoinsPayGateCallbackReq = 2839;
  inline bool has_useryycoinspaygatecallbackreq() const;
  inline void clear_useryycoinspaygatecallbackreq();
  static const int kUserYYCoinsPayGateCallbackReqFieldNumber = 2839;
  inline const ::pp::UserYYCoinsPayGateCallbackReq& useryycoinspaygatecallbackreq() const;
  inline ::pp::UserYYCoinsPayGateCallbackReq* mutable_useryycoinspaygatecallbackreq();
  inline ::pp::UserYYCoinsPayGateCallbackReq* release_useryycoinspaygatecallbackreq();
  inline void set_allocated_useryycoinspaygatecallbackreq(::pp::UserYYCoinsPayGateCallbackReq* useryycoinspaygatecallbackreq);

  // optional .pp.GroupApplyReq groupApplyReq = 1282;
  inline bool has_groupapplyreq() const;
  inline void clear_groupapplyreq();
  static const int kGroupApplyReqFieldNumber = 1282;
  inline const ::pp::GroupApplyReq& groupapplyreq() const;
  inline ::pp::GroupApplyReq* mutable_groupapplyreq();
  inline ::pp::GroupApplyReq* release_groupapplyreq();
  inline void set_allocated_groupapplyreq(::pp::GroupApplyReq* groupapplyreq);

  // optional .pp.GroupApplyRes groupApplyRes = 1283;
  inline bool has_groupapplyres() const;
  inline void clear_groupapplyres();
  static const int kGroupApplyResFieldNumber = 1283;
  inline const ::pp::GroupApplyRes& groupapplyres() const;
  inline ::pp::GroupApplyRes* mutable_groupapplyres();
  inline ::pp::GroupApplyRes* release_groupapplyres();
  inline void set_allocated_groupapplyres(::pp::GroupApplyRes* groupapplyres);

  // optional .pp.GroupCheckinReq groupCheckinReq = 1284;
  inline bool has_groupcheckinreq() const;
  inline void clear_groupcheckinreq();
  static const int kGroupCheckinReqFieldNumber = 1284;
  inline const ::pp::GroupCheckinReq& groupcheckinreq() const;
  inline ::pp::GroupCheckinReq* mutable_groupcheckinreq();
  inline ::pp::GroupCheckinReq* release_groupcheckinreq();
  inline void set_allocated_groupcheckinreq(::pp::GroupCheckinReq* groupcheckinreq);

  // optional .pp.GroupCheckinRes groupCheckinRes = 1285;
  inline bool has_groupcheckinres() const;
  inline void clear_groupcheckinres();
  static const int kGroupCheckinResFieldNumber = 1285;
  inline const ::pp::GroupCheckinRes& groupcheckinres() const;
  inline ::pp::GroupCheckinRes* mutable_groupcheckinres();
  inline ::pp::GroupCheckinRes* release_groupcheckinres();
  inline void set_allocated_groupcheckinres(::pp::GroupCheckinRes* groupcheckinres);

  // optional .pp.GroupQuitReq groupQuitReq = 1286;
  inline bool has_groupquitreq() const;
  inline void clear_groupquitreq();
  static const int kGroupQuitReqFieldNumber = 1286;
  inline const ::pp::GroupQuitReq& groupquitreq() const;
  inline ::pp::GroupQuitReq* mutable_groupquitreq();
  inline ::pp::GroupQuitReq* release_groupquitreq();
  inline void set_allocated_groupquitreq(::pp::GroupQuitReq* groupquitreq);

  // optional .pp.GroupInfoReq groupInfoReq = 1288;
  inline bool has_groupinforeq() const;
  inline void clear_groupinforeq();
  static const int kGroupInfoReqFieldNumber = 1288;
  inline const ::pp::GroupInfoReq& groupinforeq() const;
  inline ::pp::GroupInfoReq* mutable_groupinforeq();
  inline ::pp::GroupInfoReq* release_groupinforeq();
  inline void set_allocated_groupinforeq(::pp::GroupInfoReq* groupinforeq);

  // optional .pp.GroupSearchReq groupSearchReq = 1292;
  inline bool has_groupsearchreq() const;
  inline void clear_groupsearchreq();
  static const int kGroupSearchReqFieldNumber = 1292;
  inline const ::pp::GroupSearchReq& groupsearchreq() const;
  inline ::pp::GroupSearchReq* mutable_groupsearchreq();
  inline ::pp::GroupSearchReq* release_groupsearchreq();
  inline void set_allocated_groupsearchreq(::pp::GroupSearchReq* groupsearchreq);

  // optional .pp.GroupSearchRes groupSearchRes = 1293;
  inline bool has_groupsearchres() const;
  inline void clear_groupsearchres();
  static const int kGroupSearchResFieldNumber = 1293;
  inline const ::pp::GroupSearchRes& groupsearchres() const;
  inline ::pp::GroupSearchRes* mutable_groupsearchres();
  inline ::pp::GroupSearchRes* release_groupsearchres();
  inline void set_allocated_groupsearchres(::pp::GroupSearchRes* groupsearchres);

  // optional .pp.GroupSearchKeywordsReq groupSearchKeywordsReq = 1294;
  inline bool has_groupsearchkeywordsreq() const;
  inline void clear_groupsearchkeywordsreq();
  static const int kGroupSearchKeywordsReqFieldNumber = 1294;
  inline const ::pp::GroupSearchKeywordsReq& groupsearchkeywordsreq() const;
  inline ::pp::GroupSearchKeywordsReq* mutable_groupsearchkeywordsreq();
  inline ::pp::GroupSearchKeywordsReq* release_groupsearchkeywordsreq();
  inline void set_allocated_groupsearchkeywordsreq(::pp::GroupSearchKeywordsReq* groupsearchkeywordsreq);

  // optional .pp.GroupSearchKeywordsRes groupSearchKeywordsRes = 1295;
  inline bool has_groupsearchkeywordsres() const;
  inline void clear_groupsearchkeywordsres();
  static const int kGroupSearchKeywordsResFieldNumber = 1295;
  inline const ::pp::GroupSearchKeywordsRes& groupsearchkeywordsres() const;
  inline ::pp::GroupSearchKeywordsRes* mutable_groupsearchkeywordsres();
  inline ::pp::GroupSearchKeywordsRes* release_groupsearchkeywordsres();
  inline void set_allocated_groupsearchkeywordsres(::pp::GroupSearchKeywordsRes* groupsearchkeywordsres);

  // optional .pp.GroupListReq groupListReq = 1296;
  inline bool has_grouplistreq() const;
  inline void clear_grouplistreq();
  static const int kGroupListReqFieldNumber = 1296;
  inline const ::pp::GroupListReq& grouplistreq() const;
  inline ::pp::GroupListReq* mutable_grouplistreq();
  inline ::pp::GroupListReq* release_grouplistreq();
  inline void set_allocated_grouplistreq(::pp::GroupListReq* grouplistreq);

  // optional .pp.GroupListRes groupListRes = 1297;
  inline bool has_grouplistres() const;
  inline void clear_grouplistres();
  static const int kGroupListResFieldNumber = 1297;
  inline const ::pp::GroupListRes& grouplistres() const;
  inline ::pp::GroupListRes* mutable_grouplistres();
  inline ::pp::GroupListRes* release_grouplistres();
  inline void set_allocated_grouplistres(::pp::GroupListRes* grouplistres);

  // optional .pp.GroupApproveReq groupApproveReq = 1312;
  inline bool has_groupapprovereq() const;
  inline void clear_groupapprovereq();
  static const int kGroupApproveReqFieldNumber = 1312;
  inline const ::pp::GroupApproveReq& groupapprovereq() const;
  inline ::pp::GroupApproveReq* mutable_groupapprovereq();
  inline ::pp::GroupApproveReq* release_groupapprovereq();
  inline void set_allocated_groupapprovereq(::pp::GroupApproveReq* groupapprovereq);

  // optional .pp.GroupApproveRes groupApproveRes = 1313;
  inline bool has_groupapproveres() const;
  inline void clear_groupapproveres();
  static const int kGroupApproveResFieldNumber = 1313;
  inline const ::pp::GroupApproveRes& groupapproveres() const;
  inline ::pp::GroupApproveRes* mutable_groupapproveres();
  inline ::pp::GroupApproveRes* release_groupapproveres();
  inline void set_allocated_groupapproveres(::pp::GroupApproveRes* groupapproveres);

  // optional .pp.GroupLobbyOrderModifyReq groupLobbyOrderModifyReq = 1334;
  inline bool has_grouplobbyordermodifyreq() const;
  inline void clear_grouplobbyordermodifyreq();
  static const int kGroupLobbyOrderModifyReqFieldNumber = 1334;
  inline const ::pp::GroupLobbyOrderModifyReq& grouplobbyordermodifyreq() const;
  inline ::pp::GroupLobbyOrderModifyReq* mutable_grouplobbyordermodifyreq();
  inline ::pp::GroupLobbyOrderModifyReq* release_grouplobbyordermodifyreq();
  inline void set_allocated_grouplobbyordermodifyreq(::pp::GroupLobbyOrderModifyReq* grouplobbyordermodifyreq);

  // optional .pp.GroupLobbyOrderModifyRes groupLobbyOrderModifyRes = 1335;
  inline bool has_grouplobbyordermodifyres() const;
  inline void clear_grouplobbyordermodifyres();
  static const int kGroupLobbyOrderModifyResFieldNumber = 1335;
  inline const ::pp::GroupLobbyOrderModifyRes& grouplobbyordermodifyres() const;
  inline ::pp::GroupLobbyOrderModifyRes* mutable_grouplobbyordermodifyres();
  inline ::pp::GroupLobbyOrderModifyRes* release_grouplobbyordermodifyres();
  inline void set_allocated_grouplobbyordermodifyres(::pp::GroupLobbyOrderModifyRes* grouplobbyordermodifyres);

  // optional .pp.GroupTeamOpReq groupTeamOpReq = 1383;
  inline bool has_groupteamopreq() const;
  inline void clear_groupteamopreq();
  static const int kGroupTeamOpReqFieldNumber = 1383;
  inline const ::pp::GroupTeamOpReq& groupteamopreq() const;
  inline ::pp::GroupTeamOpReq* mutable_groupteamopreq();
  inline ::pp::GroupTeamOpReq* release_groupteamopreq();
  inline void set_allocated_groupteamopreq(::pp::GroupTeamOpReq* groupteamopreq);

  // optional .pp.GroupLabelOpReq groupLabelOpReq = 1385;
  inline bool has_grouplabelopreq() const;
  inline void clear_grouplabelopreq();
  static const int kGroupLabelOpReqFieldNumber = 1385;
  inline const ::pp::GroupLabelOpReq& grouplabelopreq() const;
  inline ::pp::GroupLabelOpReq* mutable_grouplabelopreq();
  inline ::pp::GroupLabelOpReq* release_grouplabelopreq();
  inline void set_allocated_grouplabelopreq(::pp::GroupLabelOpReq* grouplabelopreq);

  // optional .pp.GroupAppSendReq groupAppSendReq = 2048;
  inline bool has_groupappsendreq() const;
  inline void clear_groupappsendreq();
  static const int kGroupAppSendReqFieldNumber = 2048;
  inline const ::pp::GroupAppSendReq& groupappsendreq() const;
  inline ::pp::GroupAppSendReq* mutable_groupappsendreq();
  inline ::pp::GroupAppSendReq* release_groupappsendreq();
  inline void set_allocated_groupappsendreq(::pp::GroupAppSendReq* groupappsendreq);

  // optional .pp.GroupAppSendRes groupAppSendRes = 2049;
  inline bool has_groupappsendres() const;
  inline void clear_groupappsendres();
  static const int kGroupAppSendResFieldNumber = 2049;
  inline const ::pp::GroupAppSendRes& groupappsendres() const;
  inline ::pp::GroupAppSendRes* mutable_groupappsendres();
  inline ::pp::GroupAppSendRes* release_groupappsendres();
  inline void set_allocated_groupappsendres(::pp::GroupAppSendRes* groupappsendres);

  // optional .pp.GroupAppListReq groupAppListReq = 2050;
  inline bool has_groupapplistreq() const;
  inline void clear_groupapplistreq();
  static const int kGroupAppListReqFieldNumber = 2050;
  inline const ::pp::GroupAppListReq& groupapplistreq() const;
  inline ::pp::GroupAppListReq* mutable_groupapplistreq();
  inline ::pp::GroupAppListReq* release_groupapplistreq();
  inline void set_allocated_groupapplistreq(::pp::GroupAppListReq* groupapplistreq);

  // optional .pp.GroupAppListRes groupAppListRes = 2051;
  inline bool has_groupapplistres() const;
  inline void clear_groupapplistres();
  static const int kGroupAppListResFieldNumber = 2051;
  inline const ::pp::GroupAppListRes& groupapplistres() const;
  inline ::pp::GroupAppListRes* mutable_groupapplistres();
  inline ::pp::GroupAppListRes* release_groupapplistres();
  inline void set_allocated_groupapplistres(::pp::GroupAppListRes* groupapplistres);

  // optional .pp.GroupMsgAppReq groupMsgAppReq = 2052;
  inline bool has_groupmsgappreq() const;
  inline void clear_groupmsgappreq();
  static const int kGroupMsgAppReqFieldNumber = 2052;
  inline const ::pp::GroupMsgAppReq& groupmsgappreq() const;
  inline ::pp::GroupMsgAppReq* mutable_groupmsgappreq();
  inline ::pp::GroupMsgAppReq* release_groupmsgappreq();
  inline void set_allocated_groupmsgappreq(::pp::GroupMsgAppReq* groupmsgappreq);

  // optional .pp.GroupMsgAppRes groupMsgAppRes = 2053;
  inline bool has_groupmsgappres() const;
  inline void clear_groupmsgappres();
  static const int kGroupMsgAppResFieldNumber = 2053;
  inline const ::pp::GroupMsgAppRes& groupmsgappres() const;
  inline ::pp::GroupMsgAppRes* mutable_groupmsgappres();
  inline ::pp::GroupMsgAppRes* release_groupmsgappres();
  inline void set_allocated_groupmsgappres(::pp::GroupMsgAppRes* groupmsgappres);

  // optional .pp.GroupMemberKickReq groupMemberKickReq = 2320;
  inline bool has_groupmemberkickreq() const;
  inline void clear_groupmemberkickreq();
  static const int kGroupMemberKickReqFieldNumber = 2320;
  inline const ::pp::GroupMemberKickReq& groupmemberkickreq() const;
  inline ::pp::GroupMemberKickReq* mutable_groupmemberkickreq();
  inline ::pp::GroupMemberKickReq* release_groupmemberkickreq();
  inline void set_allocated_groupmemberkickreq(::pp::GroupMemberKickReq* groupmemberkickreq);

  // optional .pp.GroupMemberListReq groupMemberListReq = 2336;
  inline bool has_groupmemberlistreq() const;
  inline void clear_groupmemberlistreq();
  static const int kGroupMemberListReqFieldNumber = 2336;
  inline const ::pp::GroupMemberListReq& groupmemberlistreq() const;
  inline ::pp::GroupMemberListReq* mutable_groupmemberlistreq();
  inline ::pp::GroupMemberListReq* release_groupmemberlistreq();
  inline void set_allocated_groupmemberlistreq(::pp::GroupMemberListReq* groupmemberlistreq);

  // optional .pp.GroupMemberListRes groupMemberListRes = 2337;
  inline bool has_groupmemberlistres() const;
  inline void clear_groupmemberlistres();
  static const int kGroupMemberListResFieldNumber = 2337;
  inline const ::pp::GroupMemberListRes& groupmemberlistres() const;
  inline ::pp::GroupMemberListRes* mutable_groupmemberlistres();
  inline ::pp::GroupMemberListRes* release_groupmemberlistres();
  inline void set_allocated_groupmemberlistres(::pp::GroupMemberListRes* groupmemberlistres);

  // optional .pp.GroupMemberReq groupMemberReq = 2338;
  inline bool has_groupmemberreq() const;
  inline void clear_groupmemberreq();
  static const int kGroupMemberReqFieldNumber = 2338;
  inline const ::pp::GroupMemberReq& groupmemberreq() const;
  inline ::pp::GroupMemberReq* mutable_groupmemberreq();
  inline ::pp::GroupMemberReq* release_groupmemberreq();
  inline void set_allocated_groupmemberreq(::pp::GroupMemberReq* groupmemberreq);

  // optional .pp.GroupMemberRes groupMemberRes = 2339;
  inline bool has_groupmemberres() const;
  inline void clear_groupmemberres();
  static const int kGroupMemberResFieldNumber = 2339;
  inline const ::pp::GroupMemberRes& groupmemberres() const;
  inline ::pp::GroupMemberRes* mutable_groupmemberres();
  inline ::pp::GroupMemberRes* release_groupmemberres();
  inline void set_allocated_groupmemberres(::pp::GroupMemberRes* groupmemberres);

  // optional .pp.GroupMemberModifyReq groupMemberModifyReq = 2340;
  inline bool has_groupmembermodifyreq() const;
  inline void clear_groupmembermodifyreq();
  static const int kGroupMemberModifyReqFieldNumber = 2340;
  inline const ::pp::GroupMemberModifyReq& groupmembermodifyreq() const;
  inline ::pp::GroupMemberModifyReq* mutable_groupmembermodifyreq();
  inline ::pp::GroupMemberModifyReq* release_groupmembermodifyreq();
  inline void set_allocated_groupmembermodifyreq(::pp::GroupMemberModifyReq* groupmembermodifyreq);

  // optional .pp.GroupMemberSearchReq groupMemberSearchReq = 2342;
  inline bool has_groupmembersearchreq() const;
  inline void clear_groupmembersearchreq();
  static const int kGroupMemberSearchReqFieldNumber = 2342;
  inline const ::pp::GroupMemberSearchReq& groupmembersearchreq() const;
  inline ::pp::GroupMemberSearchReq* mutable_groupmembersearchreq();
  inline ::pp::GroupMemberSearchReq* release_groupmembersearchreq();
  inline void set_allocated_groupmembersearchreq(::pp::GroupMemberSearchReq* groupmembersearchreq);

  // optional .pp.GroupMemberSearchRes groupMemberSearchRes = 2343;
  inline bool has_groupmembersearchres() const;
  inline void clear_groupmembersearchres();
  static const int kGroupMemberSearchResFieldNumber = 2343;
  inline const ::pp::GroupMemberSearchRes& groupmembersearchres() const;
  inline ::pp::GroupMemberSearchRes* mutable_groupmembersearchres();
  inline ::pp::GroupMemberSearchRes* release_groupmembersearchres();
  inline void set_allocated_groupmembersearchres(::pp::GroupMemberSearchRes* groupmembersearchres);

  // optional .pp.GroupMemberCountReq groupMemberCountReq = 2344;
  inline bool has_groupmembercountreq() const;
  inline void clear_groupmembercountreq();
  static const int kGroupMemberCountReqFieldNumber = 2344;
  inline const ::pp::GroupMemberCountReq& groupmembercountreq() const;
  inline ::pp::GroupMemberCountReq* mutable_groupmembercountreq();
  inline ::pp::GroupMemberCountReq* release_groupmembercountreq();
  inline void set_allocated_groupmembercountreq(::pp::GroupMemberCountReq* groupmembercountreq);

  // optional .pp.GroupMemberCountRes groupMemberCountRes = 2345;
  inline bool has_groupmembercountres() const;
  inline void clear_groupmembercountres();
  static const int kGroupMemberCountResFieldNumber = 2345;
  inline const ::pp::GroupMemberCountRes& groupmembercountres() const;
  inline ::pp::GroupMemberCountRes* mutable_groupmembercountres();
  inline ::pp::GroupMemberCountRes* release_groupmembercountres();
  inline void set_allocated_groupmembercountres(::pp::GroupMemberCountRes* groupmembercountres);

  // optional .pp.GroupMemberRolerListReq groupMemberRolerListReq = 2401;
  inline bool has_groupmemberrolerlistreq() const;
  inline void clear_groupmemberrolerlistreq();
  static const int kGroupMemberRolerListReqFieldNumber = 2401;
  inline const ::pp::GroupMemberRolerListReq& groupmemberrolerlistreq() const;
  inline ::pp::GroupMemberRolerListReq* mutable_groupmemberrolerlistreq();
  inline ::pp::GroupMemberRolerListReq* release_groupmemberrolerlistreq();
  inline void set_allocated_groupmemberrolerlistreq(::pp::GroupMemberRolerListReq* groupmemberrolerlistreq);

  // optional .pp.GroupMemberRolerListRes groupMemberRolerListRes = 2402;
  inline bool has_groupmemberrolerlistres() const;
  inline void clear_groupmemberrolerlistres();
  static const int kGroupMemberRolerListResFieldNumber = 2402;
  inline const ::pp::GroupMemberRolerListRes& groupmemberrolerlistres() const;
  inline ::pp::GroupMemberRolerListRes* mutable_groupmemberrolerlistres();
  inline ::pp::GroupMemberRolerListRes* release_groupmemberrolerlistres();
  inline void set_allocated_groupmemberrolerlistres(::pp::GroupMemberRolerListRes* groupmemberrolerlistres);

  // optional .pp.GroupMemberRolerSetReq groupMemberRolerSetReq = 2403;
  inline bool has_groupmemberrolersetreq() const;
  inline void clear_groupmemberrolersetreq();
  static const int kGroupMemberRolerSetReqFieldNumber = 2403;
  inline const ::pp::GroupMemberRolerSetReq& groupmemberrolersetreq() const;
  inline ::pp::GroupMemberRolerSetReq* mutable_groupmemberrolersetreq();
  inline ::pp::GroupMemberRolerSetReq* release_groupmemberrolersetreq();
  inline void set_allocated_groupmemberrolersetreq(::pp::GroupMemberRolerSetReq* groupmemberrolersetreq);

  // optional .pp.GroupMsgListReq groupMsgListReq = 1536;
  inline bool has_groupmsglistreq() const;
  inline void clear_groupmsglistreq();
  static const int kGroupMsgListReqFieldNumber = 1536;
  inline const ::pp::GroupMsgListReq& groupmsglistreq() const;
  inline ::pp::GroupMsgListReq* mutable_groupmsglistreq();
  inline ::pp::GroupMsgListReq* release_groupmsglistreq();
  inline void set_allocated_groupmsglistreq(::pp::GroupMsgListReq* groupmsglistreq);

  // optional .pp.GroupMsgListRes groupMsgListRes = 1537;
  inline bool has_groupmsglistres() const;
  inline void clear_groupmsglistres();
  static const int kGroupMsgListResFieldNumber = 1537;
  inline const ::pp::GroupMsgListRes& groupmsglistres() const;
  inline ::pp::GroupMsgListRes* mutable_groupmsglistres();
  inline ::pp::GroupMsgListRes* release_groupmsglistres();
  inline void set_allocated_groupmsglistres(::pp::GroupMsgListRes* groupmsglistres);

  // optional .pp.GroupMsgVoiceReq groupMsgVoiceReq = 1542;
  inline bool has_groupmsgvoicereq() const;
  inline void clear_groupmsgvoicereq();
  static const int kGroupMsgVoiceReqFieldNumber = 1542;
  inline const ::pp::GroupMsgVoiceReq& groupmsgvoicereq() const;
  inline ::pp::GroupMsgVoiceReq* mutable_groupmsgvoicereq();
  inline ::pp::GroupMsgVoiceReq* release_groupmsgvoicereq();
  inline void set_allocated_groupmsgvoicereq(::pp::GroupMsgVoiceReq* groupmsgvoicereq);

  // optional .pp.GroupMsgVoiceRes groupMsgVoiceRes = 1543;
  inline bool has_groupmsgvoiceres() const;
  inline void clear_groupmsgvoiceres();
  static const int kGroupMsgVoiceResFieldNumber = 1543;
  inline const ::pp::GroupMsgVoiceRes& groupmsgvoiceres() const;
  inline ::pp::GroupMsgVoiceRes* mutable_groupmsgvoiceres();
  inline ::pp::GroupMsgVoiceRes* release_groupmsgvoiceres();
  inline void set_allocated_groupmsgvoiceres(::pp::GroupMsgVoiceRes* groupmsgvoiceres);

  // optional .pp.GroupMsgSendReq groupMsgSendReq = 1552;
  inline bool has_groupmsgsendreq() const;
  inline void clear_groupmsgsendreq();
  static const int kGroupMsgSendReqFieldNumber = 1552;
  inline const ::pp::GroupMsgSendReq& groupmsgsendreq() const;
  inline ::pp::GroupMsgSendReq* mutable_groupmsgsendreq();
  inline ::pp::GroupMsgSendReq* release_groupmsgsendreq();
  inline void set_allocated_groupmsgsendreq(::pp::GroupMsgSendReq* groupmsgsendreq);

  // optional .pp.GroupMsgSearchReq groupMsgSearchReq = 1554;
  inline bool has_groupmsgsearchreq() const;
  inline void clear_groupmsgsearchreq();
  static const int kGroupMsgSearchReqFieldNumber = 1554;
  inline const ::pp::GroupMsgSearchReq& groupmsgsearchreq() const;
  inline ::pp::GroupMsgSearchReq* mutable_groupmsgsearchreq();
  inline ::pp::GroupMsgSearchReq* release_groupmsgsearchreq();
  inline void set_allocated_groupmsgsearchreq(::pp::GroupMsgSearchReq* groupmsgsearchreq);

  // optional .pp.GroupMsgSearchRes groupMsgSearchRes = 1555;
  inline bool has_groupmsgsearchres() const;
  inline void clear_groupmsgsearchres();
  static const int kGroupMsgSearchResFieldNumber = 1555;
  inline const ::pp::GroupMsgSearchRes& groupmsgsearchres() const;
  inline ::pp::GroupMsgSearchRes* mutable_groupmsgsearchres();
  inline ::pp::GroupMsgSearchRes* release_groupmsgsearchres();
  inline void set_allocated_groupmsgsearchres(::pp::GroupMsgSearchRes* groupmsgsearchres);

  // optional .pp.UserLoginReq userLoginReq = 256;
  inline bool has_userloginreq() const;
  inline void clear_userloginreq();
  static const int kUserLoginReqFieldNumber = 256;
  inline const ::pp::UserLoginReq& userloginreq() const;
  inline ::pp::UserLoginReq* mutable_userloginreq();
  inline ::pp::UserLoginReq* release_userloginreq();
  inline void set_allocated_userloginreq(::pp::UserLoginReq* userloginreq);

  // optional .pp.UserLoginRes userLoginRes = 257;
  inline bool has_userloginres() const;
  inline void clear_userloginres();
  static const int kUserLoginResFieldNumber = 257;
  inline const ::pp::UserLoginRes& userloginres() const;
  inline ::pp::UserLoginRes* mutable_userloginres();
  inline ::pp::UserLoginRes* release_userloginres();
  inline void set_allocated_userloginres(::pp::UserLoginRes* userloginres);

  // optional .pp.UserActivateReq userActivateReq = 258;
  inline bool has_useractivatereq() const;
  inline void clear_useractivatereq();
  static const int kUserActivateReqFieldNumber = 258;
  inline const ::pp::UserActivateReq& useractivatereq() const;
  inline ::pp::UserActivateReq* mutable_useractivatereq();
  inline ::pp::UserActivateReq* release_useractivatereq();
  inline void set_allocated_useractivatereq(::pp::UserActivateReq* useractivatereq);

  // optional .pp.UserActivateRes userActivateRes = 259;
  inline bool has_useractivateres() const;
  inline void clear_useractivateres();
  static const int kUserActivateResFieldNumber = 259;
  inline const ::pp::UserActivateRes& useractivateres() const;
  inline ::pp::UserActivateRes* mutable_useractivateres();
  inline ::pp::UserActivateRes* release_useractivateres();
  inline void set_allocated_useractivateres(::pp::UserActivateRes* useractivateres);

  // optional .pp.UserHeartBeatReq userHeartBeatReq = 260;
  inline bool has_userheartbeatreq() const;
  inline void clear_userheartbeatreq();
  static const int kUserHeartBeatReqFieldNumber = 260;
  inline const ::pp::UserHeartBeatReq& userheartbeatreq() const;
  inline ::pp::UserHeartBeatReq* mutable_userheartbeatreq();
  inline ::pp::UserHeartBeatReq* release_userheartbeatreq();
  inline void set_allocated_userheartbeatreq(::pp::UserHeartBeatReq* userheartbeatreq);

  // optional .pp.UserHeartBeatRes userHeartBeatRes = 261;
  inline bool has_userheartbeatres() const;
  inline void clear_userheartbeatres();
  static const int kUserHeartBeatResFieldNumber = 261;
  inline const ::pp::UserHeartBeatRes& userheartbeatres() const;
  inline ::pp::UserHeartBeatRes* mutable_userheartbeatres();
  inline ::pp::UserHeartBeatRes* release_userheartbeatres();
  inline void set_allocated_userheartbeatres(::pp::UserHeartBeatRes* userheartbeatres);

  // optional .pp.AccountBindReq accountBindReq = 262;
  inline bool has_accountbindreq() const;
  inline void clear_accountbindreq();
  static const int kAccountBindReqFieldNumber = 262;
  inline const ::pp::AccountBindReq& accountbindreq() const;
  inline ::pp::AccountBindReq* mutable_accountbindreq();
  inline ::pp::AccountBindReq* release_accountbindreq();
  inline void set_allocated_accountbindreq(::pp::AccountBindReq* accountbindreq);

  // optional .pp.AccountBindRes accountBindRes = 263;
  inline bool has_accountbindres() const;
  inline void clear_accountbindres();
  static const int kAccountBindResFieldNumber = 263;
  inline const ::pp::AccountBindRes& accountbindres() const;
  inline ::pp::AccountBindRes* mutable_accountbindres();
  inline ::pp::AccountBindRes* release_accountbindres();
  inline void set_allocated_accountbindres(::pp::AccountBindRes* accountbindres);

  // optional .pp.UserWebLoginReq userWebLoginReq = 264;
  inline bool has_userwebloginreq() const;
  inline void clear_userwebloginreq();
  static const int kUserWebLoginReqFieldNumber = 264;
  inline const ::pp::UserWebLoginReq& userwebloginreq() const;
  inline ::pp::UserWebLoginReq* mutable_userwebloginreq();
  inline ::pp::UserWebLoginReq* release_userwebloginreq();
  inline void set_allocated_userwebloginreq(::pp::UserWebLoginReq* userwebloginreq);

  // optional .pp.UserWebLoginRes userWebLoginRes = 265;
  inline bool has_userwebloginres() const;
  inline void clear_userwebloginres();
  static const int kUserWebLoginResFieldNumber = 265;
  inline const ::pp::UserWebLoginRes& userwebloginres() const;
  inline ::pp::UserWebLoginRes* mutable_userwebloginres();
  inline ::pp::UserWebLoginRes* release_userwebloginres();
  inline void set_allocated_userwebloginres(::pp::UserWebLoginRes* userwebloginres);

  // optional .pp.SessionResumeReq sessionResumeReq = 272;
  inline bool has_sessionresumereq() const;
  inline void clear_sessionresumereq();
  static const int kSessionResumeReqFieldNumber = 272;
  inline const ::pp::SessionResumeReq& sessionresumereq() const;
  inline ::pp::SessionResumeReq* mutable_sessionresumereq();
  inline ::pp::SessionResumeReq* release_sessionresumereq();
  inline void set_allocated_sessionresumereq(::pp::SessionResumeReq* sessionresumereq);

  // optional .pp.SessionResumeRes sessionResumeRes = 273;
  inline bool has_sessionresumeres() const;
  inline void clear_sessionresumeres();
  static const int kSessionResumeResFieldNumber = 273;
  inline const ::pp::SessionResumeRes& sessionresumeres() const;
  inline ::pp::SessionResumeRes* mutable_sessionresumeres();
  inline ::pp::SessionResumeRes* release_sessionresumeres();
  inline void set_allocated_sessionresumeres(::pp::SessionResumeRes* sessionresumeres);

  // optional .pp.SessionSuspendReq sessionSuspendReq = 274;
  inline bool has_sessionsuspendreq() const;
  inline void clear_sessionsuspendreq();
  static const int kSessionSuspendReqFieldNumber = 274;
  inline const ::pp::SessionSuspendReq& sessionsuspendreq() const;
  inline ::pp::SessionSuspendReq* mutable_sessionsuspendreq();
  inline ::pp::SessionSuspendReq* release_sessionsuspendreq();
  inline void set_allocated_sessionsuspendreq(::pp::SessionSuspendReq* sessionsuspendreq);

  // optional .pp.UserTokenReq userTokenReq = 290;
  inline bool has_usertokenreq() const;
  inline void clear_usertokenreq();
  static const int kUserTokenReqFieldNumber = 290;
  inline const ::pp::UserTokenReq& usertokenreq() const;
  inline ::pp::UserTokenReq* mutable_usertokenreq();
  inline ::pp::UserTokenReq* release_usertokenreq();
  inline void set_allocated_usertokenreq(::pp::UserTokenReq* usertokenreq);

  // optional .pp.UserTokenRes userTokenRes = 291;
  inline bool has_usertokenres() const;
  inline void clear_usertokenres();
  static const int kUserTokenResFieldNumber = 291;
  inline const ::pp::UserTokenRes& usertokenres() const;
  inline ::pp::UserTokenRes* mutable_usertokenres();
  inline ::pp::UserTokenRes* release_usertokenres();
  inline void set_allocated_usertokenres(::pp::UserTokenRes* usertokenres);

  // optional .pp.UptokenReq uptokenReq = 304;
  inline bool has_uptokenreq() const;
  inline void clear_uptokenreq();
  static const int kUptokenReqFieldNumber = 304;
  inline const ::pp::UptokenReq& uptokenreq() const;
  inline ::pp::UptokenReq* mutable_uptokenreq();
  inline ::pp::UptokenReq* release_uptokenreq();
  inline void set_allocated_uptokenreq(::pp::UptokenReq* uptokenreq);

  // optional .pp.UptokenRes uptokenRes = 305;
  inline bool has_uptokenres() const;
  inline void clear_uptokenres();
  static const int kUptokenResFieldNumber = 305;
  inline const ::pp::UptokenRes& uptokenres() const;
  inline ::pp::UptokenRes* mutable_uptokenres();
  inline ::pp::UptokenRes* release_uptokenres();
  inline void set_allocated_uptokenres(::pp::UptokenRes* uptokenres);

  // optional .pp.UserPushTokenRegisterReq userPushTokenRegisterReq = 306;
  inline bool has_userpushtokenregisterreq() const;
  inline void clear_userpushtokenregisterreq();
  static const int kUserPushTokenRegisterReqFieldNumber = 306;
  inline const ::pp::UserPushTokenRegisterReq& userpushtokenregisterreq() const;
  inline ::pp::UserPushTokenRegisterReq* mutable_userpushtokenregisterreq();
  inline ::pp::UserPushTokenRegisterReq* release_userpushtokenregisterreq();
  inline void set_allocated_userpushtokenregisterreq(::pp::UserPushTokenRegisterReq* userpushtokenregisterreq);

  // optional .pp.UserPushTokenRegisterRes userPushTokenRegisterRes = 307;
  inline bool has_userpushtokenregisterres() const;
  inline void clear_userpushtokenregisterres();
  static const int kUserPushTokenRegisterResFieldNumber = 307;
  inline const ::pp::UserPushTokenRegisterRes& userpushtokenregisterres() const;
  inline ::pp::UserPushTokenRegisterRes* mutable_userpushtokenregisterres();
  inline ::pp::UserPushTokenRegisterRes* release_userpushtokenregisterres();
  inline void set_allocated_userpushtokenregisterres(::pp::UserPushTokenRegisterRes* userpushtokenregisterres);

  // optional .pp.UserLogoutReq userLogoutReq = 308;
  inline bool has_userlogoutreq() const;
  inline void clear_userlogoutreq();
  static const int kUserLogoutReqFieldNumber = 308;
  inline const ::pp::UserLogoutReq& userlogoutreq() const;
  inline ::pp::UserLogoutReq* mutable_userlogoutreq();
  inline ::pp::UserLogoutReq* release_userlogoutreq();
  inline void set_allocated_userlogoutreq(::pp::UserLogoutReq* userlogoutreq);

  // optional .pp.UserLogoutRes userLogoutRes = 309;
  inline bool has_userlogoutres() const;
  inline void clear_userlogoutres();
  static const int kUserLogoutResFieldNumber = 309;
  inline const ::pp::UserLogoutRes& userlogoutres() const;
  inline ::pp::UserLogoutRes* mutable_userlogoutres();
  inline ::pp::UserLogoutRes* release_userlogoutres();
  inline void set_allocated_userlogoutres(::pp::UserLogoutRes* userlogoutres);

  // optional .pp.CpsWebLoginReq cpsWebLoginReq = 320;
  inline bool has_cpswebloginreq() const;
  inline void clear_cpswebloginreq();
  static const int kCpsWebLoginReqFieldNumber = 320;
  inline const ::pp::CpsWebLoginReq& cpswebloginreq() const;
  inline ::pp::CpsWebLoginReq* mutable_cpswebloginreq();
  inline ::pp::CpsWebLoginReq* release_cpswebloginreq();
  inline void set_allocated_cpswebloginreq(::pp::CpsWebLoginReq* cpswebloginreq);

  // optional .pp.CpsWebLoginRes cpsWebLoginRes = 321;
  inline bool has_cpswebloginres() const;
  inline void clear_cpswebloginres();
  static const int kCpsWebLoginResFieldNumber = 321;
  inline const ::pp::CpsWebLoginRes& cpswebloginres() const;
  inline ::pp::CpsWebLoginRes* mutable_cpswebloginres();
  inline ::pp::CpsWebLoginRes* release_cpswebloginres();
  inline void set_allocated_cpswebloginres(::pp::CpsWebLoginRes* cpswebloginres);

  // optional .pp.CpsAccountBindReq cpsAccountBindReq = 322;
  inline bool has_cpsaccountbindreq() const;
  inline void clear_cpsaccountbindreq();
  static const int kCpsAccountBindReqFieldNumber = 322;
  inline const ::pp::CpsAccountBindReq& cpsaccountbindreq() const;
  inline ::pp::CpsAccountBindReq* mutable_cpsaccountbindreq();
  inline ::pp::CpsAccountBindReq* release_cpsaccountbindreq();
  inline void set_allocated_cpsaccountbindreq(::pp::CpsAccountBindReq* cpsaccountbindreq);

  // optional .pp.CpsAccountBindRes cpsAccountBindRes = 323;
  inline bool has_cpsaccountbindres() const;
  inline void clear_cpsaccountbindres();
  static const int kCpsAccountBindResFieldNumber = 323;
  inline const ::pp::CpsAccountBindRes& cpsaccountbindres() const;
  inline ::pp::CpsAccountBindRes* mutable_cpsaccountbindres();
  inline ::pp::CpsAccountBindRes* release_cpsaccountbindres();
  inline void set_allocated_cpsaccountbindres(::pp::CpsAccountBindRes* cpsaccountbindres);

  // optional .pp.PresentInfoReq presentInfoReq = 13057;
  inline bool has_presentinforeq() const;
  inline void clear_presentinforeq();
  static const int kPresentInfoReqFieldNumber = 13057;
  inline const ::pp::PresentInfoReq& presentinforeq() const;
  inline ::pp::PresentInfoReq* mutable_presentinforeq();
  inline ::pp::PresentInfoReq* release_presentinforeq();
  inline void set_allocated_presentinforeq(::pp::PresentInfoReq* presentinforeq);

  // optional .pp.PresentInfoRes presentInfoRes = 13058;
  inline bool has_presentinfores() const;
  inline void clear_presentinfores();
  static const int kPresentInfoResFieldNumber = 13058;
  inline const ::pp::PresentInfoRes& presentinfores() const;
  inline ::pp::PresentInfoRes* mutable_presentinfores();
  inline ::pp::PresentInfoRes* release_presentinfores();
  inline void set_allocated_presentinfores(::pp::PresentInfoRes* presentinfores);

  // optional .pp.PresentAddReq presentAddReq = 13059;
  inline bool has_presentaddreq() const;
  inline void clear_presentaddreq();
  static const int kPresentAddReqFieldNumber = 13059;
  inline const ::pp::PresentAddReq& presentaddreq() const;
  inline ::pp::PresentAddReq* mutable_presentaddreq();
  inline ::pp::PresentAddReq* release_presentaddreq();
  inline void set_allocated_presentaddreq(::pp::PresentAddReq* presentaddreq);

  // optional .pp.GetPresentsByGameIdReq getPresentsByGameIdReq = 13061;
  inline bool has_getpresentsbygameidreq() const;
  inline void clear_getpresentsbygameidreq();
  static const int kGetPresentsByGameIdReqFieldNumber = 13061;
  inline const ::pp::GetPresentsByGameIdReq& getpresentsbygameidreq() const;
  inline ::pp::GetPresentsByGameIdReq* mutable_getpresentsbygameidreq();
  inline ::pp::GetPresentsByGameIdReq* release_getpresentsbygameidreq();
  inline void set_allocated_getpresentsbygameidreq(::pp::GetPresentsByGameIdReq* getpresentsbygameidreq);

  // optional .pp.GetPresentsByGameIdRes getPresentsByGameIdRes = 13062;
  inline bool has_getpresentsbygameidres() const;
  inline void clear_getpresentsbygameidres();
  static const int kGetPresentsByGameIdResFieldNumber = 13062;
  inline const ::pp::GetPresentsByGameIdRes& getpresentsbygameidres() const;
  inline ::pp::GetPresentsByGameIdRes* mutable_getpresentsbygameidres();
  inline ::pp::GetPresentsByGameIdRes* release_getpresentsbygameidres();
  inline void set_allocated_getpresentsbygameidres(::pp::GetPresentsByGameIdRes* getpresentsbygameidres);

  // optional .pp.PresentListReq presentListReq = 13063;
  inline bool has_presentlistreq() const;
  inline void clear_presentlistreq();
  static const int kPresentListReqFieldNumber = 13063;
  inline const ::pp::PresentListReq& presentlistreq() const;
  inline ::pp::PresentListReq* mutable_presentlistreq();
  inline ::pp::PresentListReq* release_presentlistreq();
  inline void set_allocated_presentlistreq(::pp::PresentListReq* presentlistreq);

  // optional .pp.PresentListRes presentListRes = 13064;
  inline bool has_presentlistres() const;
  inline void clear_presentlistres();
  static const int kPresentListResFieldNumber = 13064;
  inline const ::pp::PresentListRes& presentlistres() const;
  inline ::pp::PresentListRes* mutable_presentlistres();
  inline ::pp::PresentListRes* release_presentlistres();
  inline void set_allocated_presentlistres(::pp::PresentListRes* presentlistres);

  // optional .pp.PresentCountReq presentCountReq = 13065;
  inline bool has_presentcountreq() const;
  inline void clear_presentcountreq();
  static const int kPresentCountReqFieldNumber = 13065;
  inline const ::pp::PresentCountReq& presentcountreq() const;
  inline ::pp::PresentCountReq* mutable_presentcountreq();
  inline ::pp::PresentCountReq* release_presentcountreq();
  inline void set_allocated_presentcountreq(::pp::PresentCountReq* presentcountreq);

  // optional .pp.PresentCountRes presentCountRes = 13066;
  inline bool has_presentcountres() const;
  inline void clear_presentcountres();
  static const int kPresentCountResFieldNumber = 13066;
  inline const ::pp::PresentCountRes& presentcountres() const;
  inline ::pp::PresentCountRes* mutable_presentcountres();
  inline ::pp::PresentCountRes* release_presentcountres();
  inline void set_allocated_presentcountres(::pp::PresentCountRes* presentcountres);

  // optional .pp.PresentGroupListReq presentGroupListReq = 13067;
  inline bool has_presentgrouplistreq() const;
  inline void clear_presentgrouplistreq();
  static const int kPresentGroupListReqFieldNumber = 13067;
  inline const ::pp::PresentGroupListReq& presentgrouplistreq() const;
  inline ::pp::PresentGroupListReq* mutable_presentgrouplistreq();
  inline ::pp::PresentGroupListReq* release_presentgrouplistreq();
  inline void set_allocated_presentgrouplistreq(::pp::PresentGroupListReq* presentgrouplistreq);

  // optional .pp.PresentGroupListRes presentGroupListRes = 13068;
  inline bool has_presentgrouplistres() const;
  inline void clear_presentgrouplistres();
  static const int kPresentGroupListResFieldNumber = 13068;
  inline const ::pp::PresentGroupListRes& presentgrouplistres() const;
  inline ::pp::PresentGroupListRes* mutable_presentgrouplistres();
  inline ::pp::PresentGroupListRes* release_presentgrouplistres();
  inline void set_allocated_presentgrouplistres(::pp::PresentGroupListRes* presentgrouplistres);

  // optional .pp.PresentUserTakeReq presentUserTakeReq = 13069;
  inline bool has_presentusertakereq() const;
  inline void clear_presentusertakereq();
  static const int kPresentUserTakeReqFieldNumber = 13069;
  inline const ::pp::PresentUserTakeReq& presentusertakereq() const;
  inline ::pp::PresentUserTakeReq* mutable_presentusertakereq();
  inline ::pp::PresentUserTakeReq* release_presentusertakereq();
  inline void set_allocated_presentusertakereq(::pp::PresentUserTakeReq* presentusertakereq);

  // optional .pp.PresentUserTakeRes presentUserTakeRes = 13070;
  inline bool has_presentusertakeres() const;
  inline void clear_presentusertakeres();
  static const int kPresentUserTakeResFieldNumber = 13070;
  inline const ::pp::PresentUserTakeRes& presentusertakeres() const;
  inline ::pp::PresentUserTakeRes* mutable_presentusertakeres();
  inline ::pp::PresentUserTakeRes* release_presentusertakeres();
  inline void set_allocated_presentusertakeres(::pp::PresentUserTakeRes* presentusertakeres);

  // optional .pp.PresentModifyReq presentModifyReq = 13073;
  inline bool has_presentmodifyreq() const;
  inline void clear_presentmodifyreq();
  static const int kPresentModifyReqFieldNumber = 13073;
  inline const ::pp::PresentModifyReq& presentmodifyreq() const;
  inline ::pp::PresentModifyReq* mutable_presentmodifyreq();
  inline ::pp::PresentModifyReq* release_presentmodifyreq();
  inline void set_allocated_presentmodifyreq(::pp::PresentModifyReq* presentmodifyreq);

  // optional .pp.UserPresentReq userPresentReq = 13088;
  inline bool has_userpresentreq() const;
  inline void clear_userpresentreq();
  static const int kUserPresentReqFieldNumber = 13088;
  inline const ::pp::UserPresentReq& userpresentreq() const;
  inline ::pp::UserPresentReq* mutable_userpresentreq();
  inline ::pp::UserPresentReq* release_userpresentreq();
  inline void set_allocated_userpresentreq(::pp::UserPresentReq* userpresentreq);

  // optional .pp.UserPresentRes userPresentRes = 13089;
  inline bool has_userpresentres() const;
  inline void clear_userpresentres();
  static const int kUserPresentResFieldNumber = 13089;
  inline const ::pp::UserPresentRes& userpresentres() const;
  inline ::pp::UserPresentRes* mutable_userpresentres();
  inline ::pp::UserPresentRes* release_userpresentres();
  inline void set_allocated_userpresentres(::pp::UserPresentRes* userpresentres);

  // optional .pp.UserPresentListReq userPresentListReq = 13090;
  inline bool has_userpresentlistreq() const;
  inline void clear_userpresentlistreq();
  static const int kUserPresentListReqFieldNumber = 13090;
  inline const ::pp::UserPresentListReq& userpresentlistreq() const;
  inline ::pp::UserPresentListReq* mutable_userpresentlistreq();
  inline ::pp::UserPresentListReq* release_userpresentlistreq();
  inline void set_allocated_userpresentlistreq(::pp::UserPresentListReq* userpresentlistreq);

  // optional .pp.UserPresentListRes userPresentListRes = 13091;
  inline bool has_userpresentlistres() const;
  inline void clear_userpresentlistres();
  static const int kUserPresentListResFieldNumber = 13091;
  inline const ::pp::UserPresentListRes& userpresentlistres() const;
  inline ::pp::UserPresentListRes* mutable_userpresentlistres();
  inline ::pp::UserPresentListRes* release_userpresentlistres();
  inline void set_allocated_userpresentlistres(::pp::UserPresentListRes* userpresentlistres);

  // optional .pp.GroupPresentOpReq groupPresentOpReq = 13092;
  inline bool has_grouppresentopreq() const;
  inline void clear_grouppresentopreq();
  static const int kGroupPresentOpReqFieldNumber = 13092;
  inline const ::pp::GroupPresentOpReq& grouppresentopreq() const;
  inline ::pp::GroupPresentOpReq* mutable_grouppresentopreq();
  inline ::pp::GroupPresentOpReq* release_grouppresentopreq();
  inline void set_allocated_grouppresentopreq(::pp::GroupPresentOpReq* grouppresentopreq);

  // optional .pp.GroupPresentOpRes groupPresentOpRes = 13093;
  inline bool has_grouppresentopres() const;
  inline void clear_grouppresentopres();
  static const int kGroupPresentOpResFieldNumber = 13093;
  inline const ::pp::GroupPresentOpRes& grouppresentopres() const;
  inline ::pp::GroupPresentOpRes* mutable_grouppresentopres();
  inline ::pp::GroupPresentOpRes* release_grouppresentopres();
  inline void set_allocated_grouppresentopres(::pp::GroupPresentOpRes* grouppresentopres);

  // optional .pp.GroupPresentListReq groupPresentListReq = 13094;
  inline bool has_grouppresentlistreq() const;
  inline void clear_grouppresentlistreq();
  static const int kGroupPresentListReqFieldNumber = 13094;
  inline const ::pp::GroupPresentListReq& grouppresentlistreq() const;
  inline ::pp::GroupPresentListReq* mutable_grouppresentlistreq();
  inline ::pp::GroupPresentListReq* release_grouppresentlistreq();
  inline void set_allocated_grouppresentlistreq(::pp::GroupPresentListReq* grouppresentlistreq);

  // optional .pp.GroupPresentListRes groupPresentListRes = 13095;
  inline bool has_grouppresentlistres() const;
  inline void clear_grouppresentlistres();
  static const int kGroupPresentListResFieldNumber = 13095;
  inline const ::pp::GroupPresentListRes& grouppresentlistres() const;
  inline ::pp::GroupPresentListRes* mutable_grouppresentlistres();
  inline ::pp::GroupPresentListRes* release_grouppresentlistres();
  inline void set_allocated_grouppresentlistres(::pp::GroupPresentListRes* grouppresentlistres);

  // optional .pp.PresentUserListReq presentUserListReq = 13096;
  inline bool has_presentuserlistreq() const;
  inline void clear_presentuserlistreq();
  static const int kPresentUserListReqFieldNumber = 13096;
  inline const ::pp::PresentUserListReq& presentuserlistreq() const;
  inline ::pp::PresentUserListReq* mutable_presentuserlistreq();
  inline ::pp::PresentUserListReq* release_presentuserlistreq();
  inline void set_allocated_presentuserlistreq(::pp::PresentUserListReq* presentuserlistreq);

  // optional .pp.PresentUserListRes presentUserListRes = 13097;
  inline bool has_presentuserlistres() const;
  inline void clear_presentuserlistres();
  static const int kPresentUserListResFieldNumber = 13097;
  inline const ::pp::PresentUserListRes& presentuserlistres() const;
  inline ::pp::PresentUserListRes* mutable_presentuserlistres();
  inline ::pp::PresentUserListRes* release_presentuserlistres();
  inline void set_allocated_presentuserlistres(::pp::PresentUserListRes* presentuserlistres);

  // optional .pp.ReportViolatorReq reportViolatorReq = 2561;
  inline bool has_reportviolatorreq() const;
  inline void clear_reportviolatorreq();
  static const int kReportViolatorReqFieldNumber = 2561;
  inline const ::pp::ReportViolatorReq& reportviolatorreq() const;
  inline ::pp::ReportViolatorReq* mutable_reportviolatorreq();
  inline ::pp::ReportViolatorReq* release_reportviolatorreq();
  inline void set_allocated_reportviolatorreq(::pp::ReportViolatorReq* reportviolatorreq);

  // optional .pp.ReportLogReq reportLogReq = 2563;
  inline bool has_reportlogreq() const;
  inline void clear_reportlogreq();
  static const int kReportLogReqFieldNumber = 2563;
  inline const ::pp::ReportLogReq& reportlogreq() const;
  inline ::pp::ReportLogReq* mutable_reportlogreq();
  inline ::pp::ReportLogReq* release_reportlogreq();
  inline void set_allocated_reportlogreq(::pp::ReportLogReq* reportlogreq);

  // optional .pp.YYGiftListReq yYGiftListReq = 4352;
  inline bool has_yygiftlistreq() const;
  inline void clear_yygiftlistreq();
  static const int kYYGiftListReqFieldNumber = 4352;
  inline const ::pp::YYGiftListReq& yygiftlistreq() const;
  inline ::pp::YYGiftListReq* mutable_yygiftlistreq();
  inline ::pp::YYGiftListReq* release_yygiftlistreq();
  inline void set_allocated_yygiftlistreq(::pp::YYGiftListReq* yygiftlistreq);

  // optional .pp.YYGiftListRes yYGiftListRes = 4353;
  inline bool has_yygiftlistres() const;
  inline void clear_yygiftlistres();
  static const int kYYGiftListResFieldNumber = 4353;
  inline const ::pp::YYGiftListRes& yygiftlistres() const;
  inline ::pp::YYGiftListRes* mutable_yygiftlistres();
  inline ::pp::YYGiftListRes* release_yygiftlistres();
  inline void set_allocated_yygiftlistres(::pp::YYGiftListRes* yygiftlistres);

  // optional .pp.YYGiftDonateReq yYGiftDonateReq = 4354;
  inline bool has_yygiftdonatereq() const;
  inline void clear_yygiftdonatereq();
  static const int kYYGiftDonateReqFieldNumber = 4354;
  inline const ::pp::YYGiftDonateReq& yygiftdonatereq() const;
  inline ::pp::YYGiftDonateReq* mutable_yygiftdonatereq();
  inline ::pp::YYGiftDonateReq* release_yygiftdonatereq();
  inline void set_allocated_yygiftdonatereq(::pp::YYGiftDonateReq* yygiftdonatereq);

  // optional .pp.YYGiftDonateRes yYGiftDonateRes = 4355;
  inline bool has_yygiftdonateres() const;
  inline void clear_yygiftdonateres();
  static const int kYYGiftDonateResFieldNumber = 4355;
  inline const ::pp::YYGiftDonateRes& yygiftdonateres() const;
  inline ::pp::YYGiftDonateRes* mutable_yygiftdonateres();
  inline ::pp::YYGiftDonateRes* release_yygiftdonateres();
  inline void set_allocated_yygiftdonateres(::pp::YYGiftDonateRes* yygiftdonateres);

  // optional .pp.YYGiftPayConfirmReq yYGiftPayConfirmReq = 4356;
  inline bool has_yygiftpayconfirmreq() const;
  inline void clear_yygiftpayconfirmreq();
  static const int kYYGiftPayConfirmReqFieldNumber = 4356;
  inline const ::pp::YYGiftPayConfirmReq& yygiftpayconfirmreq() const;
  inline ::pp::YYGiftPayConfirmReq* mutable_yygiftpayconfirmreq();
  inline ::pp::YYGiftPayConfirmReq* release_yygiftpayconfirmreq();
  inline void set_allocated_yygiftpayconfirmreq(::pp::YYGiftPayConfirmReq* yygiftpayconfirmreq);

  // optional .pp.YYGiftPayConfirmRes yYGiftPayConfirmRes = 4357;
  inline bool has_yygiftpayconfirmres() const;
  inline void clear_yygiftpayconfirmres();
  static const int kYYGiftPayConfirmResFieldNumber = 4357;
  inline const ::pp::YYGiftPayConfirmRes& yygiftpayconfirmres() const;
  inline ::pp::YYGiftPayConfirmRes* mutable_yygiftpayconfirmres();
  inline ::pp::YYGiftPayConfirmRes* release_yygiftpayconfirmres();
  inline void set_allocated_yygiftpayconfirmres(::pp::YYGiftPayConfirmRes* yygiftpayconfirmres);

  // optional .pp.ProductListReq productListReq = 4369;
  inline bool has_productlistreq() const;
  inline void clear_productlistreq();
  static const int kProductListReqFieldNumber = 4369;
  inline const ::pp::ProductListReq& productlistreq() const;
  inline ::pp::ProductListReq* mutable_productlistreq();
  inline ::pp::ProductListReq* release_productlistreq();
  inline void set_allocated_productlistreq(::pp::ProductListReq* productlistreq);

  // optional .pp.ProductListRes productListRes = 4370;
  inline bool has_productlistres() const;
  inline void clear_productlistres();
  static const int kProductListResFieldNumber = 4370;
  inline const ::pp::ProductListRes& productlistres() const;
  inline ::pp::ProductListRes* mutable_productlistres();
  inline ::pp::ProductListRes* release_productlistres();
  inline void set_allocated_productlistres(::pp::ProductListRes* productlistres);

  // optional .pp.ProductOpReq productOpReq = 4371;
  inline bool has_productopreq() const;
  inline void clear_productopreq();
  static const int kProductOpReqFieldNumber = 4371;
  inline const ::pp::ProductOpReq& productopreq() const;
  inline ::pp::ProductOpReq* mutable_productopreq();
  inline ::pp::ProductOpReq* release_productopreq();
  inline void set_allocated_productopreq(::pp::ProductOpReq* productopreq);

  // optional .pp.ProductBuyReq productBuyReq = 4373;
  inline bool has_productbuyreq() const;
  inline void clear_productbuyreq();
  static const int kProductBuyReqFieldNumber = 4373;
  inline const ::pp::ProductBuyReq& productbuyreq() const;
  inline ::pp::ProductBuyReq* mutable_productbuyreq();
  inline ::pp::ProductBuyReq* release_productbuyreq();
  inline void set_allocated_productbuyreq(::pp::ProductBuyReq* productbuyreq);

  // optional .pp.UserWithdrawReq userWithdrawReq = 4377;
  inline bool has_userwithdrawreq() const;
  inline void clear_userwithdrawreq();
  static const int kUserWithdrawReqFieldNumber = 4377;
  inline const ::pp::UserWithdrawReq& userwithdrawreq() const;
  inline ::pp::UserWithdrawReq* mutable_userwithdrawreq();
  inline ::pp::UserWithdrawReq* release_userwithdrawreq();
  inline void set_allocated_userwithdrawreq(::pp::UserWithdrawReq* userwithdrawreq);

  // optional .pp.UserMoneyStatReq userMoneyStatReq = 4384;
  inline bool has_usermoneystatreq() const;
  inline void clear_usermoneystatreq();
  static const int kUserMoneyStatReqFieldNumber = 4384;
  inline const ::pp::UserMoneyStatReq& usermoneystatreq() const;
  inline ::pp::UserMoneyStatReq* mutable_usermoneystatreq();
  inline ::pp::UserMoneyStatReq* release_usermoneystatreq();
  inline void set_allocated_usermoneystatreq(::pp::UserMoneyStatReq* usermoneystatreq);

  // optional .pp.UserMoneyStatRes userMoneyStatRes = 4385;
  inline bool has_usermoneystatres() const;
  inline void clear_usermoneystatres();
  static const int kUserMoneyStatResFieldNumber = 4385;
  inline const ::pp::UserMoneyStatRes& usermoneystatres() const;
  inline ::pp::UserMoneyStatRes* mutable_usermoneystatres();
  inline ::pp::UserMoneyStatRes* release_usermoneystatres();
  inline void set_allocated_usermoneystatres(::pp::UserMoneyStatRes* usermoneystatres);

  // optional .pp.UserBankInfoOpReq userBankInfoOpReq = 4386;
  inline bool has_userbankinfoopreq() const;
  inline void clear_userbankinfoopreq();
  static const int kUserBankInfoOpReqFieldNumber = 4386;
  inline const ::pp::UserBankInfoOpReq& userbankinfoopreq() const;
  inline ::pp::UserBankInfoOpReq* mutable_userbankinfoopreq();
  inline ::pp::UserBankInfoOpReq* release_userbankinfoopreq();
  inline void set_allocated_userbankinfoopreq(::pp::UserBankInfoOpReq* userbankinfoopreq);

  // optional .pp.UserBankInfoOpRes userBankInfoOpRes = 4387;
  inline bool has_userbankinfoopres() const;
  inline void clear_userbankinfoopres();
  static const int kUserBankInfoOpResFieldNumber = 4387;
  inline const ::pp::UserBankInfoOpRes& userbankinfoopres() const;
  inline ::pp::UserBankInfoOpRes* mutable_userbankinfoopres();
  inline ::pp::UserBankInfoOpRes* release_userbankinfoopres();
  inline void set_allocated_userbankinfoopres(::pp::UserBankInfoOpRes* userbankinfoopres);

  // optional .pp.BankListReq bankListReq = 4388;
  inline bool has_banklistreq() const;
  inline void clear_banklistreq();
  static const int kBankListReqFieldNumber = 4388;
  inline const ::pp::BankListReq& banklistreq() const;
  inline ::pp::BankListReq* mutable_banklistreq();
  inline ::pp::BankListReq* release_banklistreq();
  inline void set_allocated_banklistreq(::pp::BankListReq* banklistreq);

  // optional .pp.BankListRes bankListRes = 4389;
  inline bool has_banklistres() const;
  inline void clear_banklistres();
  static const int kBankListResFieldNumber = 4389;
  inline const ::pp::BankListRes& banklistres() const;
  inline ::pp::BankListRes* mutable_banklistres();
  inline ::pp::BankListRes* release_banklistres();
  inline void set_allocated_banklistres(::pp::BankListRes* banklistres);

  // optional .pp.UserTaskStateReq userTaskStateReq = 1025;
  inline bool has_usertaskstatereq() const;
  inline void clear_usertaskstatereq();
  static const int kUserTaskStateReqFieldNumber = 1025;
  inline const ::pp::UserTaskStateReq& usertaskstatereq() const;
  inline ::pp::UserTaskStateReq* mutable_usertaskstatereq();
  inline ::pp::UserTaskStateReq* release_usertaskstatereq();
  inline void set_allocated_usertaskstatereq(::pp::UserTaskStateReq* usertaskstatereq);

  // optional .pp.UserTaskStateRes userTaskStateRes = 1026;
  inline bool has_usertaskstateres() const;
  inline void clear_usertaskstateres();
  static const int kUserTaskStateResFieldNumber = 1026;
  inline const ::pp::UserTaskStateRes& usertaskstateres() const;
  inline ::pp::UserTaskStateRes* mutable_usertaskstateres();
  inline ::pp::UserTaskStateRes* release_usertaskstateres();
  inline void set_allocated_usertaskstateres(::pp::UserTaskStateRes* usertaskstateres);

  // optional .pp.UserTaskTakeAwardReq userTaskTakeAwardReq = 1027;
  inline bool has_usertasktakeawardreq() const;
  inline void clear_usertasktakeawardreq();
  static const int kUserTaskTakeAwardReqFieldNumber = 1027;
  inline const ::pp::UserTaskTakeAwardReq& usertasktakeawardreq() const;
  inline ::pp::UserTaskTakeAwardReq* mutable_usertasktakeawardreq();
  inline ::pp::UserTaskTakeAwardReq* release_usertasktakeawardreq();
  inline void set_allocated_usertasktakeawardreq(::pp::UserTaskTakeAwardReq* usertasktakeawardreq);

  // optional .pp.UserTaskTakeAwardRes userTaskTakeAwardRes = 1028;
  inline bool has_usertasktakeawardres() const;
  inline void clear_usertasktakeawardres();
  static const int kUserTaskTakeAwardResFieldNumber = 1028;
  inline const ::pp::UserTaskTakeAwardRes& usertasktakeawardres() const;
  inline ::pp::UserTaskTakeAwardRes* mutable_usertasktakeawardres();
  inline ::pp::UserTaskTakeAwardRes* release_usertasktakeawardres();
  inline void set_allocated_usertasktakeawardres(::pp::UserTaskTakeAwardRes* usertasktakeawardres);

  // optional .pp.UserTaskCheckReq userTaskCheckReq = 1029;
  inline bool has_usertaskcheckreq() const;
  inline void clear_usertaskcheckreq();
  static const int kUserTaskCheckReqFieldNumber = 1029;
  inline const ::pp::UserTaskCheckReq& usertaskcheckreq() const;
  inline ::pp::UserTaskCheckReq* mutable_usertaskcheckreq();
  inline ::pp::UserTaskCheckReq* release_usertaskcheckreq();
  inline void set_allocated_usertaskcheckreq(::pp::UserTaskCheckReq* usertaskcheckreq);

  // optional .pp.UserTaskCheckRes userTaskCheckRes = 1030;
  inline bool has_usertaskcheckres() const;
  inline void clear_usertaskcheckres();
  static const int kUserTaskCheckResFieldNumber = 1030;
  inline const ::pp::UserTaskCheckRes& usertaskcheckres() const;
  inline ::pp::UserTaskCheckRes* mutable_usertaskcheckres();
  inline ::pp::UserTaskCheckRes* release_usertaskcheckres();
  inline void set_allocated_usertaskcheckres(::pp::UserTaskCheckRes* usertaskcheckres);

  // optional .pp.UserInfoReq userInfoReq = 512;
  inline bool has_userinforeq() const;
  inline void clear_userinforeq();
  static const int kUserInfoReqFieldNumber = 512;
  inline const ::pp::UserInfoReq& userinforeq() const;
  inline ::pp::UserInfoReq* mutable_userinforeq();
  inline ::pp::UserInfoReq* release_userinforeq();
  inline void set_allocated_userinforeq(::pp::UserInfoReq* userinforeq);

  // optional .pp.UserInfoRes userInfoRes = 513;
  inline bool has_userinfores() const;
  inline void clear_userinfores();
  static const int kUserInfoResFieldNumber = 513;
  inline const ::pp::UserInfoRes& userinfores() const;
  inline ::pp::UserInfoRes* mutable_userinfores();
  inline ::pp::UserInfoRes* release_userinfores();
  inline void set_allocated_userinfores(::pp::UserInfoRes* userinfores);

  // optional .pp.UserInfoModifyReq userInfoModifyReq = 514;
  inline bool has_userinfomodifyreq() const;
  inline void clear_userinfomodifyreq();
  static const int kUserInfoModifyReqFieldNumber = 514;
  inline const ::pp::UserInfoModifyReq& userinfomodifyreq() const;
  inline ::pp::UserInfoModifyReq* mutable_userinfomodifyreq();
  inline ::pp::UserInfoModifyReq* release_userinfomodifyreq();
  inline void set_allocated_userinfomodifyreq(::pp::UserInfoModifyReq* userinfomodifyreq);

  // optional .pp.UserInfoModifyRes userInfoModifyRes = 515;
  inline bool has_userinfomodifyres() const;
  inline void clear_userinfomodifyres();
  static const int kUserInfoModifyResFieldNumber = 515;
  inline const ::pp::UserInfoModifyRes& userinfomodifyres() const;
  inline ::pp::UserInfoModifyRes* mutable_userinfomodifyres();
  inline ::pp::UserInfoModifyRes* release_userinfomodifyres();
  inline void set_allocated_userinfomodifyres(::pp::UserInfoModifyRes* userinfomodifyres);

  // optional .pp.UserInfoListReq userInfoListReq = 518;
  inline bool has_userinfolistreq() const;
  inline void clear_userinfolistreq();
  static const int kUserInfoListReqFieldNumber = 518;
  inline const ::pp::UserInfoListReq& userinfolistreq() const;
  inline ::pp::UserInfoListReq* mutable_userinfolistreq();
  inline ::pp::UserInfoListReq* release_userinfolistreq();
  inline void set_allocated_userinfolistreq(::pp::UserInfoListReq* userinfolistreq);

  // optional .pp.UserInfoListRes userInfoListRes = 519;
  inline bool has_userinfolistres() const;
  inline void clear_userinfolistres();
  static const int kUserInfoListResFieldNumber = 519;
  inline const ::pp::UserInfoListRes& userinfolistres() const;
  inline ::pp::UserInfoListRes* mutable_userinfolistres();
  inline ::pp::UserInfoListRes* release_userinfolistres();
  inline void set_allocated_userinfolistres(::pp::UserInfoListRes* userinfolistres);

  // optional .pp.UserPasswordModifyReq userPasswordModifyReq = 522;
  inline bool has_userpasswordmodifyreq() const;
  inline void clear_userpasswordmodifyreq();
  static const int kUserPasswordModifyReqFieldNumber = 522;
  inline const ::pp::UserPasswordModifyReq& userpasswordmodifyreq() const;
  inline ::pp::UserPasswordModifyReq* mutable_userpasswordmodifyreq();
  inline ::pp::UserPasswordModifyReq* release_userpasswordmodifyreq();
  inline void set_allocated_userpasswordmodifyreq(::pp::UserPasswordModifyReq* userpasswordmodifyreq);

  // optional .pp.UserPasswordModifyRes userPasswordModifyRes = 523;
  inline bool has_userpasswordmodifyres() const;
  inline void clear_userpasswordmodifyres();
  static const int kUserPasswordModifyResFieldNumber = 523;
  inline const ::pp::UserPasswordModifyRes& userpasswordmodifyres() const;
  inline ::pp::UserPasswordModifyRes* mutable_userpasswordmodifyres();
  inline ::pp::UserPasswordModifyRes* release_userpasswordmodifyres();
  inline void set_allocated_userpasswordmodifyres(::pp::UserPasswordModifyRes* userpasswordmodifyres);

  // optional .pp.UserSearchReq userSearchReq = 528;
  inline bool has_usersearchreq() const;
  inline void clear_usersearchreq();
  static const int kUserSearchReqFieldNumber = 528;
  inline const ::pp::UserSearchReq& usersearchreq() const;
  inline ::pp::UserSearchReq* mutable_usersearchreq();
  inline ::pp::UserSearchReq* release_usersearchreq();
  inline void set_allocated_usersearchreq(::pp::UserSearchReq* usersearchreq);

  // optional .pp.UserSearchRes userSearchRes = 529;
  inline bool has_usersearchres() const;
  inline void clear_usersearchres();
  static const int kUserSearchResFieldNumber = 529;
  inline const ::pp::UserSearchRes& usersearchres() const;
  inline ::pp::UserSearchRes* mutable_usersearchres();
  inline ::pp::UserSearchRes* release_usersearchres();
  inline void set_allocated_usersearchres(::pp::UserSearchRes* usersearchres);

  // optional .pp.UserImageListReq userImageListReq = 562;
  inline bool has_userimagelistreq() const;
  inline void clear_userimagelistreq();
  static const int kUserImageListReqFieldNumber = 562;
  inline const ::pp::UserImageListReq& userimagelistreq() const;
  inline ::pp::UserImageListReq* mutable_userimagelistreq();
  inline ::pp::UserImageListReq* release_userimagelistreq();
  inline void set_allocated_userimagelistreq(::pp::UserImageListReq* userimagelistreq);

  // optional .pp.UserImageListRes userImageListRes = 563;
  inline bool has_userimagelistres() const;
  inline void clear_userimagelistres();
  static const int kUserImageListResFieldNumber = 563;
  inline const ::pp::UserImageListRes& userimagelistres() const;
  inline ::pp::UserImageListRes* mutable_userimagelistres();
  inline ::pp::UserImageListRes* release_userimagelistres();
  inline void set_allocated_userimagelistres(::pp::UserImageListRes* userimagelistres);

  // optional .pp.UserImageOpReq userImageOpReq = 564;
  inline bool has_userimageopreq() const;
  inline void clear_userimageopreq();
  static const int kUserImageOpReqFieldNumber = 564;
  inline const ::pp::UserImageOpReq& userimageopreq() const;
  inline ::pp::UserImageOpReq* mutable_userimageopreq();
  inline ::pp::UserImageOpReq* release_userimageopreq();
  inline void set_allocated_userimageopreq(::pp::UserImageOpReq* userimageopreq);

  // optional .pp.UserImageOpRes userImageOpRes = 565;
  inline bool has_userimageopres() const;
  inline void clear_userimageopres();
  static const int kUserImageOpResFieldNumber = 565;
  inline const ::pp::UserImageOpRes& userimageopres() const;
  inline ::pp::UserImageOpRes* mutable_userimageopres();
  inline ::pp::UserImageOpRes* release_userimageopres();
  inline void set_allocated_userimageopres(::pp::UserImageOpRes* userimageopres);

  // optional .pp.UserImageLikeReq userImageLikeReq = 566;
  inline bool has_userimagelikereq() const;
  inline void clear_userimagelikereq();
  static const int kUserImageLikeReqFieldNumber = 566;
  inline const ::pp::UserImageLikeReq& userimagelikereq() const;
  inline ::pp::UserImageLikeReq* mutable_userimagelikereq();
  inline ::pp::UserImageLikeReq* release_userimagelikereq();
  inline void set_allocated_userimagelikereq(::pp::UserImageLikeReq* userimagelikereq);

  // optional .pp.UserImageLikeRes userImageLikeRes = 567;
  inline bool has_userimagelikeres() const;
  inline void clear_userimagelikeres();
  static const int kUserImageLikeResFieldNumber = 567;
  inline const ::pp::UserImageLikeRes& userimagelikeres() const;
  inline ::pp::UserImageLikeRes* mutable_userimagelikeres();
  inline ::pp::UserImageLikeRes* release_userimagelikeres();
  inline void set_allocated_userimagelikeres(::pp::UserImageLikeRes* userimagelikeres);

  // optional .pp.UserRecommendRegisterReq userRecommendRegisterReq = 608;
  inline bool has_userrecommendregisterreq() const;
  inline void clear_userrecommendregisterreq();
  static const int kUserRecommendRegisterReqFieldNumber = 608;
  inline const ::pp::UserRecommendRegisterReq& userrecommendregisterreq() const;
  inline ::pp::UserRecommendRegisterReq* mutable_userrecommendregisterreq();
  inline ::pp::UserRecommendRegisterReq* release_userrecommendregisterreq();
  inline void set_allocated_userrecommendregisterreq(::pp::UserRecommendRegisterReq* userrecommendregisterreq);

  // optional .pp.UserRecommendRegisterRes userRecommendRegisterRes = 609;
  inline bool has_userrecommendregisterres() const;
  inline void clear_userrecommendregisterres();
  static const int kUserRecommendRegisterResFieldNumber = 609;
  inline const ::pp::UserRecommendRegisterRes& userrecommendregisterres() const;
  inline ::pp::UserRecommendRegisterRes* mutable_userrecommendregisterres();
  inline ::pp::UserRecommendRegisterRes* release_userrecommendregisterres();
  inline void set_allocated_userrecommendregisterres(::pp::UserRecommendRegisterRes* userrecommendregisterres);

  // optional .pp.UserRefererListReq userRefererListReq = 610;
  inline bool has_userrefererlistreq() const;
  inline void clear_userrefererlistreq();
  static const int kUserRefererListReqFieldNumber = 610;
  inline const ::pp::UserRefererListReq& userrefererlistreq() const;
  inline ::pp::UserRefererListReq* mutable_userrefererlistreq();
  inline ::pp::UserRefererListReq* release_userrefererlistreq();
  inline void set_allocated_userrefererlistreq(::pp::UserRefererListReq* userrefererlistreq);

  // optional .pp.UserRefererListRes userRefererListRes = 611;
  inline bool has_userrefererlistres() const;
  inline void clear_userrefererlistres();
  static const int kUserRefererListResFieldNumber = 611;
  inline const ::pp::UserRefererListRes& userrefererlistres() const;
  inline ::pp::UserRefererListRes* mutable_userrefererlistres();
  inline ::pp::UserRefererListRes* release_userrefererlistres();
  inline void set_allocated_userrefererlistres(::pp::UserRefererListRes* userrefererlistres);

  // optional .pp.UserProductListReq userProductListReq = 626;
  inline bool has_userproductlistreq() const;
  inline void clear_userproductlistreq();
  static const int kUserProductListReqFieldNumber = 626;
  inline const ::pp::UserProductListReq& userproductlistreq() const;
  inline ::pp::UserProductListReq* mutable_userproductlistreq();
  inline ::pp::UserProductListReq* release_userproductlistreq();
  inline void set_allocated_userproductlistreq(::pp::UserProductListReq* userproductlistreq);

  // optional .pp.UserProductListRes userProductListRes = 627;
  inline bool has_userproductlistres() const;
  inline void clear_userproductlistres();
  static const int kUserProductListResFieldNumber = 627;
  inline const ::pp::UserProductListRes& userproductlistres() const;
  inline ::pp::UserProductListRes* mutable_userproductlistres();
  inline ::pp::UserProductListRes* release_userproductlistres();
  inline void set_allocated_userproductlistres(::pp::UserProductListRes* userproductlistres);

  // optional .pp.UserActiveDataReq userActiveDataReq = 628;
  inline bool has_useractivedatareq() const;
  inline void clear_useractivedatareq();
  static const int kUserActiveDataReqFieldNumber = 628;
  inline const ::pp::UserActiveDataReq& useractivedatareq() const;
  inline ::pp::UserActiveDataReq* mutable_useractivedatareq();
  inline ::pp::UserActiveDataReq* release_useractivedatareq();
  inline void set_allocated_useractivedatareq(::pp::UserActiveDataReq* useractivedatareq);

  // optional .pp.UserActiveDataRes userActiveDataRes = 629;
  inline bool has_useractivedatares() const;
  inline void clear_useractivedatares();
  static const int kUserActiveDataResFieldNumber = 629;
  inline const ::pp::UserActiveDataRes& useractivedatares() const;
  inline ::pp::UserActiveDataRes* mutable_useractivedatares();
  inline ::pp::UserActiveDataRes* release_useractivedatares();
  inline void set_allocated_useractivedatares(::pp::UserActiveDataRes* useractivedatares);

  // optional .pp.UserStatDataReq userStatDataReq = 636;
  inline bool has_userstatdatareq() const;
  inline void clear_userstatdatareq();
  static const int kUserStatDataReqFieldNumber = 636;
  inline const ::pp::UserStatDataReq& userstatdatareq() const;
  inline ::pp::UserStatDataReq* mutable_userstatdatareq();
  inline ::pp::UserStatDataReq* release_userstatdatareq();
  inline void set_allocated_userstatdatareq(::pp::UserStatDataReq* userstatdatareq);

  // optional .pp.UserStatDataRes userStatDataRes = 637;
  inline bool has_userstatdatares() const;
  inline void clear_userstatdatares();
  static const int kUserStatDataResFieldNumber = 637;
  inline const ::pp::UserStatDataRes& userstatdatares() const;
  inline ::pp::UserStatDataRes* mutable_userstatdatares();
  inline ::pp::UserStatDataRes* release_userstatdatares();
  inline void set_allocated_userstatdatares(::pp::UserStatDataRes* userstatdatares);

  // optional .pp.UserActiveDataListReq userActiveDataListReq = 638;
  inline bool has_useractivedatalistreq() const;
  inline void clear_useractivedatalistreq();
  static const int kUserActiveDataListReqFieldNumber = 638;
  inline const ::pp::UserActiveDataListReq& useractivedatalistreq() const;
  inline ::pp::UserActiveDataListReq* mutable_useractivedatalistreq();
  inline ::pp::UserActiveDataListReq* release_useractivedatalistreq();
  inline void set_allocated_useractivedatalistreq(::pp::UserActiveDataListReq* useractivedatalistreq);

  // optional .pp.UserActiveDataListRes userActiveDataListRes = 639;
  inline bool has_useractivedatalistres() const;
  inline void clear_useractivedatalistres();
  static const int kUserActiveDataListResFieldNumber = 639;
  inline const ::pp::UserActiveDataListRes& useractivedatalistres() const;
  inline ::pp::UserActiveDataListRes* mutable_useractivedatalistres();
  inline ::pp::UserActiveDataListRes* release_useractivedatalistres();
  inline void set_allocated_useractivedatalistres(::pp::UserActiveDataListRes* useractivedatalistres);

  // optional .pp.UserProfileViewReq userProfileViewReq = 642;
  inline bool has_userprofileviewreq() const;
  inline void clear_userprofileviewreq();
  static const int kUserProfileViewReqFieldNumber = 642;
  inline const ::pp::UserProfileViewReq& userprofileviewreq() const;
  inline ::pp::UserProfileViewReq* mutable_userprofileviewreq();
  inline ::pp::UserProfileViewReq* release_userprofileviewreq();
  inline void set_allocated_userprofileviewreq(::pp::UserProfileViewReq* userprofileviewreq);

  // optional .pp.UserProfileViewRes userProfileViewRes = 643;
  inline bool has_userprofileviewres() const;
  inline void clear_userprofileviewres();
  static const int kUserProfileViewResFieldNumber = 643;
  inline const ::pp::UserProfileViewRes& userprofileviewres() const;
  inline ::pp::UserProfileViewRes* mutable_userprofileviewres();
  inline ::pp::UserProfileViewRes* release_userprofileviewres();
  inline void set_allocated_userprofileviewres(::pp::UserProfileViewRes* userprofileviewres);

  // optional .pp.UserAppRateReq userAppRateReq = 644;
  inline bool has_userappratereq() const;
  inline void clear_userappratereq();
  static const int kUserAppRateReqFieldNumber = 644;
  inline const ::pp::UserAppRateReq& userappratereq() const;
  inline ::pp::UserAppRateReq* mutable_userappratereq();
  inline ::pp::UserAppRateReq* release_userappratereq();
  inline void set_allocated_userappratereq(::pp::UserAppRateReq* userappratereq);

  // optional .pp.UserAppRateRes userAppRateRes = 645;
  inline bool has_userapprateres() const;
  inline void clear_userapprateres();
  static const int kUserAppRateResFieldNumber = 645;
  inline const ::pp::UserAppRateRes& userapprateres() const;
  inline ::pp::UserAppRateRes* mutable_userapprateres();
  inline ::pp::UserAppRateRes* release_userapprateres();
  inline void set_allocated_userapprateres(::pp::UserAppRateRes* userapprateres);

  // optional .pp.UserExpressAddrOpReq userExpressAddrOpReq = 646;
  inline bool has_userexpressaddropreq() const;
  inline void clear_userexpressaddropreq();
  static const int kUserExpressAddrOpReqFieldNumber = 646;
  inline const ::pp::UserExpressAddrOpReq& userexpressaddropreq() const;
  inline ::pp::UserExpressAddrOpReq* mutable_userexpressaddropreq();
  inline ::pp::UserExpressAddrOpReq* release_userexpressaddropreq();
  inline void set_allocated_userexpressaddropreq(::pp::UserExpressAddrOpReq* userexpressaddropreq);

  // optional .pp.UserExpressAddrOpRes userExpressAddrOpRes = 647;
  inline bool has_userexpressaddropres() const;
  inline void clear_userexpressaddropres();
  static const int kUserExpressAddrOpResFieldNumber = 647;
  inline const ::pp::UserExpressAddrOpRes& userexpressaddropres() const;
  inline ::pp::UserExpressAddrOpRes* mutable_userexpressaddropres();
  inline ::pp::UserExpressAddrOpRes* release_userexpressaddropres();
  inline void set_allocated_userexpressaddropres(::pp::UserExpressAddrOpRes* userexpressaddropres);

  // optional .pp.AutoTaskUserListReq autoTaskUserListReq = 648;
  inline bool has_autotaskuserlistreq() const;
  inline void clear_autotaskuserlistreq();
  static const int kAutoTaskUserListReqFieldNumber = 648;
  inline const ::pp::AutoTaskUserListReq& autotaskuserlistreq() const;
  inline ::pp::AutoTaskUserListReq* mutable_autotaskuserlistreq();
  inline ::pp::AutoTaskUserListReq* release_autotaskuserlistreq();
  inline void set_allocated_autotaskuserlistreq(::pp::AutoTaskUserListReq* autotaskuserlistreq);

  // optional .pp.AutoTaskUserListRes autoTaskUserListRes = 649;
  inline bool has_autotaskuserlistres() const;
  inline void clear_autotaskuserlistres();
  static const int kAutoTaskUserListResFieldNumber = 649;
  inline const ::pp::AutoTaskUserListRes& autotaskuserlistres() const;
  inline ::pp::AutoTaskUserListRes* mutable_autotaskuserlistres();
  inline ::pp::AutoTaskUserListRes* release_autotaskuserlistres();
  inline void set_allocated_autotaskuserlistres(::pp::AutoTaskUserListRes* autotaskuserlistres);

  // optional .pp.UserShowShareReq userShowShareReq = 650;
  inline bool has_usershowsharereq() const;
  inline void clear_usershowsharereq();
  static const int kUserShowShareReqFieldNumber = 650;
  inline const ::pp::UserShowShareReq& usershowsharereq() const;
  inline ::pp::UserShowShareReq* mutable_usershowsharereq();
  inline ::pp::UserShowShareReq* release_usershowsharereq();
  inline void set_allocated_usershowsharereq(::pp::UserShowShareReq* usershowsharereq);

  // optional .pp.UserShowShareRes userShowShareRes = 651;
  inline bool has_usershowshareres() const;
  inline void clear_usershowshareres();
  static const int kUserShowShareResFieldNumber = 651;
  inline const ::pp::UserShowShareRes& usershowshareres() const;
  inline ::pp::UserShowShareRes* mutable_usershowshareres();
  inline ::pp::UserShowShareRes* release_usershowshareres();
  inline void set_allocated_usershowshareres(::pp::UserShowShareRes* usershowshareres);

  // optional .pp.UserThirdPartyAccountReq userThirdPartyAccountReq = 652;
  inline bool has_userthirdpartyaccountreq() const;
  inline void clear_userthirdpartyaccountreq();
  static const int kUserThirdPartyAccountReqFieldNumber = 652;
  inline const ::pp::UserThirdPartyAccountReq& userthirdpartyaccountreq() const;
  inline ::pp::UserThirdPartyAccountReq* mutable_userthirdpartyaccountreq();
  inline ::pp::UserThirdPartyAccountReq* release_userthirdpartyaccountreq();
  inline void set_allocated_userthirdpartyaccountreq(::pp::UserThirdPartyAccountReq* userthirdpartyaccountreq);

  // optional .pp.UserThirdPartyAccountRes userThirdPartyAccountRes = 653;
  inline bool has_userthirdpartyaccountres() const;
  inline void clear_userthirdpartyaccountres();
  static const int kUserThirdPartyAccountResFieldNumber = 653;
  inline const ::pp::UserThirdPartyAccountRes& userthirdpartyaccountres() const;
  inline ::pp::UserThirdPartyAccountRes* mutable_userthirdpartyaccountres();
  inline ::pp::UserThirdPartyAccountRes* release_userthirdpartyaccountres();
  inline void set_allocated_userthirdpartyaccountres(::pp::UserThirdPartyAccountRes* userthirdpartyaccountres);

  // optional .pp.UserMsgListReq userMsgListReq = 768;
  inline bool has_usermsglistreq() const;
  inline void clear_usermsglistreq();
  static const int kUserMsgListReqFieldNumber = 768;
  inline const ::pp::UserMsgListReq& usermsglistreq() const;
  inline ::pp::UserMsgListReq* mutable_usermsglistreq();
  inline ::pp::UserMsgListReq* release_usermsglistreq();
  inline void set_allocated_usermsglistreq(::pp::UserMsgListReq* usermsglistreq);

  // optional .pp.UserMsgListRes userMsgListRes = 769;
  inline bool has_usermsglistres() const;
  inline void clear_usermsglistres();
  static const int kUserMsgListResFieldNumber = 769;
  inline const ::pp::UserMsgListRes& usermsglistres() const;
  inline ::pp::UserMsgListRes* mutable_usermsglistres();
  inline ::pp::UserMsgListRes* release_usermsglistres();
  inline void set_allocated_usermsglistres(::pp::UserMsgListRes* usermsglistres);

  // optional .pp.UserMsgBroadcastReq userMsgBroadcastReq = 786;
  inline bool has_usermsgbroadcastreq() const;
  inline void clear_usermsgbroadcastreq();
  static const int kUserMsgBroadcastReqFieldNumber = 786;
  inline const ::pp::UserMsgBroadcastReq& usermsgbroadcastreq() const;
  inline ::pp::UserMsgBroadcastReq* mutable_usermsgbroadcastreq();
  inline ::pp::UserMsgBroadcastReq* release_usermsgbroadcastreq();
  inline void set_allocated_usermsgbroadcastreq(::pp::UserMsgBroadcastReq* usermsgbroadcastreq);

  // optional .pp.UserMsgRejectListSetReq userMsgRejectListSetReq = 800;
  inline bool has_usermsgrejectlistsetreq() const;
  inline void clear_usermsgrejectlistsetreq();
  static const int kUserMsgRejectListSetReqFieldNumber = 800;
  inline const ::pp::UserMsgRejectListSetReq& usermsgrejectlistsetreq() const;
  inline ::pp::UserMsgRejectListSetReq* mutable_usermsgrejectlistsetreq();
  inline ::pp::UserMsgRejectListSetReq* release_usermsgrejectlistsetreq();
  inline void set_allocated_usermsgrejectlistsetreq(::pp::UserMsgRejectListSetReq* usermsgrejectlistsetreq);

  // optional .pp.UserMsgRejectListSetRes userMsgRejectListSetRes = 801;
  inline bool has_usermsgrejectlistsetres() const;
  inline void clear_usermsgrejectlistsetres();
  static const int kUserMsgRejectListSetResFieldNumber = 801;
  inline const ::pp::UserMsgRejectListSetRes& usermsgrejectlistsetres() const;
  inline ::pp::UserMsgRejectListSetRes* mutable_usermsgrejectlistsetres();
  inline ::pp::UserMsgRejectListSetRes* release_usermsgrejectlistsetres();
  inline void set_allocated_usermsgrejectlistsetres(::pp::UserMsgRejectListSetRes* usermsgrejectlistsetres);

  // optional .pp.UserMsgRejectListGetReq userMsgRejectListGetReq = 802;
  inline bool has_usermsgrejectlistgetreq() const;
  inline void clear_usermsgrejectlistgetreq();
  static const int kUserMsgRejectListGetReqFieldNumber = 802;
  inline const ::pp::UserMsgRejectListGetReq& usermsgrejectlistgetreq() const;
  inline ::pp::UserMsgRejectListGetReq* mutable_usermsgrejectlistgetreq();
  inline ::pp::UserMsgRejectListGetReq* release_usermsgrejectlistgetreq();
  inline void set_allocated_usermsgrejectlistgetreq(::pp::UserMsgRejectListGetReq* usermsgrejectlistgetreq);

  // optional .pp.UserMsgRejectListGetRes userMsgRejectListGetRes = 803;
  inline bool has_usermsgrejectlistgetres() const;
  inline void clear_usermsgrejectlistgetres();
  static const int kUserMsgRejectListGetResFieldNumber = 803;
  inline const ::pp::UserMsgRejectListGetRes& usermsgrejectlistgetres() const;
  inline ::pp::UserMsgRejectListGetRes* mutable_usermsgrejectlistgetres();
  inline ::pp::UserMsgRejectListGetRes* release_usermsgrejectlistgetres();
  inline void set_allocated_usermsgrejectlistgetres(::pp::UserMsgRejectListGetRes* usermsgrejectlistgetres);

  // optional .pp.MsgReadRevisionSetReq msgReadRevisionSetReq = 816;
  inline bool has_msgreadrevisionsetreq() const;
  inline void clear_msgreadrevisionsetreq();
  static const int kMsgReadRevisionSetReqFieldNumber = 816;
  inline const ::pp::MsgReadRevisionSetReq& msgreadrevisionsetreq() const;
  inline ::pp::MsgReadRevisionSetReq* mutable_msgreadrevisionsetreq();
  inline ::pp::MsgReadRevisionSetReq* release_msgreadrevisionsetreq();
  inline void set_allocated_msgreadrevisionsetreq(::pp::MsgReadRevisionSetReq* msgreadrevisionsetreq);

  // optional .pp.MsgReadRevisionSetRes msgReadRevisionSetRes = 817;
  inline bool has_msgreadrevisionsetres() const;
  inline void clear_msgreadrevisionsetres();
  static const int kMsgReadRevisionSetResFieldNumber = 817;
  inline const ::pp::MsgReadRevisionSetRes& msgreadrevisionsetres() const;
  inline ::pp::MsgReadRevisionSetRes* mutable_msgreadrevisionsetres();
  inline ::pp::MsgReadRevisionSetRes* release_msgreadrevisionsetres();
  inline void set_allocated_msgreadrevisionsetres(::pp::MsgReadRevisionSetRes* msgreadrevisionsetres);

  // optional .pp.MsgReadRevisionGetReq msgReadRevisionGetReq = 818;
  inline bool has_msgreadrevisiongetreq() const;
  inline void clear_msgreadrevisiongetreq();
  static const int kMsgReadRevisionGetReqFieldNumber = 818;
  inline const ::pp::MsgReadRevisionGetReq& msgreadrevisiongetreq() const;
  inline ::pp::MsgReadRevisionGetReq* mutable_msgreadrevisiongetreq();
  inline ::pp::MsgReadRevisionGetReq* release_msgreadrevisiongetreq();
  inline void set_allocated_msgreadrevisiongetreq(::pp::MsgReadRevisionGetReq* msgreadrevisiongetreq);

  // optional .pp.MsgReadRevisionGetRes msgReadRevisionGetRes = 819;
  inline bool has_msgreadrevisiongetres() const;
  inline void clear_msgreadrevisiongetres();
  static const int kMsgReadRevisionGetResFieldNumber = 819;
  inline const ::pp::MsgReadRevisionGetRes& msgreadrevisiongetres() const;
  inline ::pp::MsgReadRevisionGetRes* mutable_msgreadrevisiongetres();
  inline ::pp::MsgReadRevisionGetRes* release_msgreadrevisiongetres();
  inline void set_allocated_msgreadrevisiongetres(::pp::MsgReadRevisionGetRes* msgreadrevisiongetres);

  // optional .pp.MsgBroadcastQueryReq msgBroadcastQueryReq = 820;
  inline bool has_msgbroadcastqueryreq() const;
  inline void clear_msgbroadcastqueryreq();
  static const int kMsgBroadcastQueryReqFieldNumber = 820;
  inline const ::pp::MsgBroadcastQueryReq& msgbroadcastqueryreq() const;
  inline ::pp::MsgBroadcastQueryReq* mutable_msgbroadcastqueryreq();
  inline ::pp::MsgBroadcastQueryReq* release_msgbroadcastqueryreq();
  inline void set_allocated_msgbroadcastqueryreq(::pp::MsgBroadcastQueryReq* msgbroadcastqueryreq);

  // optional .pp.MsgBroadcastQueryRes msgBroadcastQueryRes = 821;
  inline bool has_msgbroadcastqueryres() const;
  inline void clear_msgbroadcastqueryres();
  static const int kMsgBroadcastQueryResFieldNumber = 821;
  inline const ::pp::MsgBroadcastQueryRes& msgbroadcastqueryres() const;
  inline ::pp::MsgBroadcastQueryRes* mutable_msgbroadcastqueryres();
  inline ::pp::MsgBroadcastQueryRes* release_msgbroadcastqueryres();
  inline void set_allocated_msgbroadcastqueryres(::pp::MsgBroadcastQueryRes* msgbroadcastqueryres);

  // optional .pp.WeiLianJoinReq weiLianJoinReq = 13313;
  inline bool has_weilianjoinreq() const;
  inline void clear_weilianjoinreq();
  static const int kWeiLianJoinReqFieldNumber = 13313;
  inline const ::pp::WeiLianJoinReq& weilianjoinreq() const;
  inline ::pp::WeiLianJoinReq* mutable_weilianjoinreq();
  inline ::pp::WeiLianJoinReq* release_weilianjoinreq();
  inline void set_allocated_weilianjoinreq(::pp::WeiLianJoinReq* weilianjoinreq);

  // optional .pp.WeiLianJoinRes weiLianJoinRes = 13314;
  inline bool has_weilianjoinres() const;
  inline void clear_weilianjoinres();
  static const int kWeiLianJoinResFieldNumber = 13314;
  inline const ::pp::WeiLianJoinRes& weilianjoinres() const;
  inline ::pp::WeiLianJoinRes* mutable_weilianjoinres();
  inline ::pp::WeiLianJoinRes* release_weilianjoinres();
  inline void set_allocated_weilianjoinres(::pp::WeiLianJoinRes* weilianjoinres);

  // optional .pp.WeiLianGoddessRankReq weiLianGoddessRankReq = 13315;
  inline bool has_weiliangoddessrankreq() const;
  inline void clear_weiliangoddessrankreq();
  static const int kWeiLianGoddessRankReqFieldNumber = 13315;
  inline const ::pp::WeiLianGoddessRankReq& weiliangoddessrankreq() const;
  inline ::pp::WeiLianGoddessRankReq* mutable_weiliangoddessrankreq();
  inline ::pp::WeiLianGoddessRankReq* release_weiliangoddessrankreq();
  inline void set_allocated_weiliangoddessrankreq(::pp::WeiLianGoddessRankReq* weiliangoddessrankreq);

  // optional .pp.WeiLianGoddessRankRes weiLianGoddessRankRes = 13316;
  inline bool has_weiliangoddessrankres() const;
  inline void clear_weiliangoddessrankres();
  static const int kWeiLianGoddessRankResFieldNumber = 13316;
  inline const ::pp::WeiLianGoddessRankRes& weiliangoddessrankres() const;
  inline ::pp::WeiLianGoddessRankRes* mutable_weiliangoddessrankres();
  inline ::pp::WeiLianGoddessRankRes* release_weiliangoddessrankres();
  inline void set_allocated_weiliangoddessrankres(::pp::WeiLianGoddessRankRes* weiliangoddessrankres);

  // optional .pp.WeiLianSearchReq weiLianSearchReq = 13317;
  inline bool has_weiliansearchreq() const;
  inline void clear_weiliansearchreq();
  static const int kWeiLianSearchReqFieldNumber = 13317;
  inline const ::pp::WeiLianSearchReq& weiliansearchreq() const;
  inline ::pp::WeiLianSearchReq* mutable_weiliansearchreq();
  inline ::pp::WeiLianSearchReq* release_weiliansearchreq();
  inline void set_allocated_weiliansearchreq(::pp::WeiLianSearchReq* weiliansearchreq);

  // optional .pp.WeiLianSearchRes weiLianSearchRes = 13318;
  inline bool has_weiliansearchres() const;
  inline void clear_weiliansearchres();
  static const int kWeiLianSearchResFieldNumber = 13318;
  inline const ::pp::WeiLianSearchRes& weiliansearchres() const;
  inline ::pp::WeiLianSearchRes* mutable_weiliansearchres();
  inline ::pp::WeiLianSearchRes* release_weiliansearchres();
  inline void set_allocated_weiliansearchres(::pp::WeiLianSearchRes* weiliansearchres);

  // optional .pp.WeiLianVoteReq weiLianVoteReq = 13319;
  inline bool has_weilianvotereq() const;
  inline void clear_weilianvotereq();
  static const int kWeiLianVoteReqFieldNumber = 13319;
  inline const ::pp::WeiLianVoteReq& weilianvotereq() const;
  inline ::pp::WeiLianVoteReq* mutable_weilianvotereq();
  inline ::pp::WeiLianVoteReq* release_weilianvotereq();
  inline void set_allocated_weilianvotereq(::pp::WeiLianVoteReq* weilianvotereq);

  // optional .pp.WeiLianVoteRes weiLianVoteRes = 13320;
  inline bool has_weilianvoteres() const;
  inline void clear_weilianvoteres();
  static const int kWeiLianVoteResFieldNumber = 13320;
  inline const ::pp::WeiLianVoteRes& weilianvoteres() const;
  inline ::pp::WeiLianVoteRes* mutable_weilianvoteres();
  inline ::pp::WeiLianVoteRes* release_weilianvoteres();
  inline void set_allocated_weilianvoteres(::pp::WeiLianVoteRes* weilianvoteres);

  // optional .pp.WeiLianMyRankReq weiLianMyRankReq = 13321;
  inline bool has_weilianmyrankreq() const;
  inline void clear_weilianmyrankreq();
  static const int kWeiLianMyRankReqFieldNumber = 13321;
  inline const ::pp::WeiLianMyRankReq& weilianmyrankreq() const;
  inline ::pp::WeiLianMyRankReq* mutable_weilianmyrankreq();
  inline ::pp::WeiLianMyRankReq* release_weilianmyrankreq();
  inline void set_allocated_weilianmyrankreq(::pp::WeiLianMyRankReq* weilianmyrankreq);

  // optional .pp.WeiLianMyRankRes weiLianMyRankRes = 13322;
  inline bool has_weilianmyrankres() const;
  inline void clear_weilianmyrankres();
  static const int kWeiLianMyRankResFieldNumber = 13322;
  inline const ::pp::WeiLianMyRankRes& weilianmyrankres() const;
  inline ::pp::WeiLianMyRankRes* mutable_weilianmyrankres();
  inline ::pp::WeiLianMyRankRes* release_weilianmyrankres();
  inline void set_allocated_weilianmyrankres(::pp::WeiLianMyRankRes* weilianmyrankres);

  // optional .pp.WebQRCodeScanReq webQRCodeScanReq = 4609;
  inline bool has_webqrcodescanreq() const;
  inline void clear_webqrcodescanreq();
  static const int kWebQRCodeScanReqFieldNumber = 4609;
  inline const ::pp::WebQRCodeScanReq& webqrcodescanreq() const;
  inline ::pp::WebQRCodeScanReq* mutable_webqrcodescanreq();
  inline ::pp::WebQRCodeScanReq* release_webqrcodescanreq();
  inline void set_allocated_webqrcodescanreq(::pp::WebQRCodeScanReq* webqrcodescanreq);

  // optional .pp.WebTokenVerifyReq webTokenVerifyReq = 4672;
  inline bool has_webtokenverifyreq() const;
  inline void clear_webtokenverifyreq();
  static const int kWebTokenVerifyReqFieldNumber = 4672;
  inline const ::pp::WebTokenVerifyReq& webtokenverifyreq() const;
  inline ::pp::WebTokenVerifyReq* mutable_webtokenverifyreq();
  inline ::pp::WebTokenVerifyReq* release_webtokenverifyreq();
  inline void set_allocated_webtokenverifyreq(::pp::WebTokenVerifyReq* webtokenverifyreq);

  // optional .pp.UserDataAdjustReq userDataAdjustReq = 4705;
  inline bool has_userdataadjustreq() const;
  inline void clear_userdataadjustreq();
  static const int kUserDataAdjustReqFieldNumber = 4705;
  inline const ::pp::UserDataAdjustReq& userdataadjustreq() const;
  inline ::pp::UserDataAdjustReq* mutable_userdataadjustreq();
  inline ::pp::UserDataAdjustReq* release_userdataadjustreq();
  inline void set_allocated_userdataadjustreq(::pp::UserDataAdjustReq* userdataadjustreq);

  // optional .pp.ConfigDataReq configDataReq = 4709;
  inline bool has_configdatareq() const;
  inline void clear_configdatareq();
  static const int kConfigDataReqFieldNumber = 4709;
  inline const ::pp::ConfigDataReq& configdatareq() const;
  inline ::pp::ConfigDataReq* mutable_configdatareq();
  inline ::pp::ConfigDataReq* release_configdatareq();
  inline void set_allocated_configdatareq(::pp::ConfigDataReq* configdatareq);

  // optional .pp.ConfigDataRes configDataRes = 4710;
  inline bool has_configdatares() const;
  inline void clear_configdatares();
  static const int kConfigDataResFieldNumber = 4710;
  inline const ::pp::ConfigDataRes& configdatares() const;
  inline ::pp::ConfigDataRes* mutable_configdatares();
  inline ::pp::ConfigDataRes* release_configdatares();
  inline void set_allocated_configdatares(::pp::ConfigDataRes* configdatares);

  // optional .pp.PageDataExchangeReq pageDataExchangeReq = 4726;
  inline bool has_pagedataexchangereq() const;
  inline void clear_pagedataexchangereq();
  static const int kPageDataExchangeReqFieldNumber = 4726;
  inline const ::pp::PageDataExchangeReq& pagedataexchangereq() const;
  inline ::pp::PageDataExchangeReq* mutable_pagedataexchangereq();
  inline ::pp::PageDataExchangeReq* release_pagedataexchangereq();
  inline void set_allocated_pagedataexchangereq(::pp::PageDataExchangeReq* pagedataexchangereq);

  // optional .pp.PageDataExchangeRes pageDataExchangeRes = 4727;
  inline bool has_pagedataexchangeres() const;
  inline void clear_pagedataexchangeres();
  static const int kPageDataExchangeResFieldNumber = 4727;
  inline const ::pp::PageDataExchangeRes& pagedataexchangeres() const;
  inline ::pp::PageDataExchangeRes* mutable_pagedataexchangeres();
  inline ::pp::PageDataExchangeRes* release_pagedataexchangeres();
  inline void set_allocated_pagedataexchangeres(::pp::PageDataExchangeRes* pagedataexchangeres);

  // optional .pp.ActLuckyTryReq actLuckyTryReq = 4736;
  inline bool has_actluckytryreq() const;
  inline void clear_actluckytryreq();
  static const int kActLuckyTryReqFieldNumber = 4736;
  inline const ::pp::ActLuckyTryReq& actluckytryreq() const;
  inline ::pp::ActLuckyTryReq* mutable_actluckytryreq();
  inline ::pp::ActLuckyTryReq* release_actluckytryreq();
  inline void set_allocated_actluckytryreq(::pp::ActLuckyTryReq* actluckytryreq);

  // optional .pp.ActLuckyTryRes actLuckyTryRes = 4737;
  inline bool has_actluckytryres() const;
  inline void clear_actluckytryres();
  static const int kActLuckyTryResFieldNumber = 4737;
  inline const ::pp::ActLuckyTryRes& actluckytryres() const;
  inline ::pp::ActLuckyTryRes* mutable_actluckytryres();
  inline ::pp::ActLuckyTryRes* release_actluckytryres();
  inline void set_allocated_actluckytryres(::pp::ActLuckyTryRes* actluckytryres);

  // optional .pp.ActRecvDynamicReq actRecvDynamicReq = 4738;
  inline bool has_actrecvdynamicreq() const;
  inline void clear_actrecvdynamicreq();
  static const int kActRecvDynamicReqFieldNumber = 4738;
  inline const ::pp::ActRecvDynamicReq& actrecvdynamicreq() const;
  inline ::pp::ActRecvDynamicReq* mutable_actrecvdynamicreq();
  inline ::pp::ActRecvDynamicReq* release_actrecvdynamicreq();
  inline void set_allocated_actrecvdynamicreq(::pp::ActRecvDynamicReq* actrecvdynamicreq);

  // optional .pp.ActRecvDynamicRes actRecvDynamicRes = 4739;
  inline bool has_actrecvdynamicres() const;
  inline void clear_actrecvdynamicres();
  static const int kActRecvDynamicResFieldNumber = 4739;
  inline const ::pp::ActRecvDynamicRes& actrecvdynamicres() const;
  inline ::pp::ActRecvDynamicRes* mutable_actrecvdynamicres();
  inline ::pp::ActRecvDynamicRes* release_actrecvdynamicres();
  inline void set_allocated_actrecvdynamicres(::pp::ActRecvDynamicRes* actrecvdynamicres);

  // optional .pp.ConfigJsonActListReq configJsonActListReq = 4740;
  inline bool has_configjsonactlistreq() const;
  inline void clear_configjsonactlistreq();
  static const int kConfigJsonActListReqFieldNumber = 4740;
  inline const ::pp::ConfigJsonActListReq& configjsonactlistreq() const;
  inline ::pp::ConfigJsonActListReq* mutable_configjsonactlistreq();
  inline ::pp::ConfigJsonActListReq* release_configjsonactlistreq();
  inline void set_allocated_configjsonactlistreq(::pp::ConfigJsonActListReq* configjsonactlistreq);

  // optional .pp.ConfigJsonActListRes configJsonActListRes = 4741;
  inline bool has_configjsonactlistres() const;
  inline void clear_configjsonactlistres();
  static const int kConfigJsonActListResFieldNumber = 4741;
  inline const ::pp::ConfigJsonActListRes& configjsonactlistres() const;
  inline ::pp::ConfigJsonActListRes* mutable_configjsonactlistres();
  inline ::pp::ConfigJsonActListRes* release_configjsonactlistres();
  inline void set_allocated_configjsonactlistres(::pp::ConfigJsonActListRes* configjsonactlistres);

  // optional .pp.ConfigJsonActModifyReq configJsonActModifyReq = 4742;
  inline bool has_configjsonactmodifyreq() const;
  inline void clear_configjsonactmodifyreq();
  static const int kConfigJsonActModifyReqFieldNumber = 4742;
  inline const ::pp::ConfigJsonActModifyReq& configjsonactmodifyreq() const;
  inline ::pp::ConfigJsonActModifyReq* mutable_configjsonactmodifyreq();
  inline ::pp::ConfigJsonActModifyReq* release_configjsonactmodifyreq();
  inline void set_allocated_configjsonactmodifyreq(::pp::ConfigJsonActModifyReq* configjsonactmodifyreq);

  // optional .pp.ActStarFormReq actStarFormReq = 4743;
  inline bool has_actstarformreq() const;
  inline void clear_actstarformreq();
  static const int kActStarFormReqFieldNumber = 4743;
  inline const ::pp::ActStarFormReq& actstarformreq() const;
  inline ::pp::ActStarFormReq* mutable_actstarformreq();
  inline ::pp::ActStarFormReq* release_actstarformreq();
  inline void set_allocated_actstarformreq(::pp::ActStarFormReq* actstarformreq);

  // optional .pp.ConfigJsonActStarReq configJsonActStarReq = 4744;
  inline bool has_configjsonactstarreq() const;
  inline void clear_configjsonactstarreq();
  static const int kConfigJsonActStarReqFieldNumber = 4744;
  inline const ::pp::ConfigJsonActStarReq& configjsonactstarreq() const;
  inline ::pp::ConfigJsonActStarReq* mutable_configjsonactstarreq();
  inline ::pp::ConfigJsonActStarReq* release_configjsonactstarreq();
  inline void set_allocated_configjsonactstarreq(::pp::ConfigJsonActStarReq* configjsonactstarreq);

  // optional .pp.ConfigJsonActRes configJsonActRes = 4745;
  inline bool has_configjsonactres() const;
  inline void clear_configjsonactres();
  static const int kConfigJsonActResFieldNumber = 4745;
  inline const ::pp::ConfigJsonActRes& configjsonactres() const;
  inline ::pp::ConfigJsonActRes* mutable_configjsonactres();
  inline ::pp::ConfigJsonActRes* release_configjsonactres();
  inline void set_allocated_configjsonactres(::pp::ConfigJsonActRes* configjsonactres);

  // optional .pp.ActMsgListReq actMsgListReq = 4752;
  inline bool has_actmsglistreq() const;
  inline void clear_actmsglistreq();
  static const int kActMsgListReqFieldNumber = 4752;
  inline const ::pp::ActMsgListReq& actmsglistreq() const;
  inline ::pp::ActMsgListReq* mutable_actmsglistreq();
  inline ::pp::ActMsgListReq* release_actmsglistreq();
  inline void set_allocated_actmsglistreq(::pp::ActMsgListReq* actmsglistreq);

  // optional .pp.ActMsgListRes actMsgListRes = 4753;
  inline bool has_actmsglistres() const;
  inline void clear_actmsglistres();
  static const int kActMsgListResFieldNumber = 4753;
  inline const ::pp::ActMsgListRes& actmsglistres() const;
  inline ::pp::ActMsgListRes* mutable_actmsglistres();
  inline ::pp::ActMsgListRes* release_actmsglistres();
  inline void set_allocated_actmsglistres(::pp::ActMsgListRes* actmsglistres);

  // optional .pp.ActMsgModifyReq actMsgModifyReq = 4754;
  inline bool has_actmsgmodifyreq() const;
  inline void clear_actmsgmodifyreq();
  static const int kActMsgModifyReqFieldNumber = 4754;
  inline const ::pp::ActMsgModifyReq& actmsgmodifyreq() const;
  inline ::pp::ActMsgModifyReq* mutable_actmsgmodifyreq();
  inline ::pp::ActMsgModifyReq* release_actmsgmodifyreq();
  inline void set_allocated_actmsgmodifyreq(::pp::ActMsgModifyReq* actmsgmodifyreq);

  // optional .pp.CoinAwardRecordReq coinAwardRecordReq = 4761;
  inline bool has_coinawardrecordreq() const;
  inline void clear_coinawardrecordreq();
  static const int kCoinAwardRecordReqFieldNumber = 4761;
  inline const ::pp::CoinAwardRecordReq& coinawardrecordreq() const;
  inline ::pp::CoinAwardRecordReq* mutable_coinawardrecordreq();
  inline ::pp::CoinAwardRecordReq* release_coinawardrecordreq();
  inline void set_allocated_coinawardrecordreq(::pp::CoinAwardRecordReq* coinawardrecordreq);

  // optional .pp.CoinAwardRecordRes coinAwardRecordRes = 4762;
  inline bool has_coinawardrecordres() const;
  inline void clear_coinawardrecordres();
  static const int kCoinAwardRecordResFieldNumber = 4762;
  inline const ::pp::CoinAwardRecordRes& coinawardrecordres() const;
  inline ::pp::CoinAwardRecordRes* mutable_coinawardrecordres();
  inline ::pp::CoinAwardRecordRes* release_coinawardrecordres();
  inline void set_allocated_coinawardrecordres(::pp::CoinAwardRecordRes* coinawardrecordres);

  // optional .pp.CoreUserListReq coreUserListReq = 4763;
  inline bool has_coreuserlistreq() const;
  inline void clear_coreuserlistreq();
  static const int kCoreUserListReqFieldNumber = 4763;
  inline const ::pp::CoreUserListReq& coreuserlistreq() const;
  inline ::pp::CoreUserListReq* mutable_coreuserlistreq();
  inline ::pp::CoreUserListReq* release_coreuserlistreq();
  inline void set_allocated_coreuserlistreq(::pp::CoreUserListReq* coreuserlistreq);

  // optional .pp.CoreUserListRes coreUserListRes = 4764;
  inline bool has_coreuserlistres() const;
  inline void clear_coreuserlistres();
  static const int kCoreUserListResFieldNumber = 4764;
  inline const ::pp::CoreUserListRes& coreuserlistres() const;
  inline ::pp::CoreUserListRes* mutable_coreuserlistres();
  inline ::pp::CoreUserListRes* release_coreuserlistres();
  inline void set_allocated_coreuserlistres(::pp::CoreUserListRes* coreuserlistres);

  // optional .pp.CoreUserModifyReq coreUserModifyReq = 4765;
  inline bool has_coreusermodifyreq() const;
  inline void clear_coreusermodifyreq();
  static const int kCoreUserModifyReqFieldNumber = 4765;
  inline const ::pp::CoreUserModifyReq& coreusermodifyreq() const;
  inline ::pp::CoreUserModifyReq* mutable_coreusermodifyreq();
  inline ::pp::CoreUserModifyReq* release_coreusermodifyreq();
  inline void set_allocated_coreusermodifyreq(::pp::CoreUserModifyReq* coreusermodifyreq);

  // optional .pp.YYChannelTreeInfoReq yYChannelTreeInfoReq = 13824;
  inline bool has_yychanneltreeinforeq() const;
  inline void clear_yychanneltreeinforeq();
  static const int kYYChannelTreeInfoReqFieldNumber = 13824;
  inline const ::pp::YYChannelTreeInfoReq& yychanneltreeinforeq() const;
  inline ::pp::YYChannelTreeInfoReq* mutable_yychanneltreeinforeq();
  inline ::pp::YYChannelTreeInfoReq* release_yychanneltreeinforeq();
  inline void set_allocated_yychanneltreeinforeq(::pp::YYChannelTreeInfoReq* yychanneltreeinforeq);

  // optional .pp.YYChannelTreeInfoRes yYChannelTreeInfoRes = 13825;
  inline bool has_yychanneltreeinfores() const;
  inline void clear_yychanneltreeinfores();
  static const int kYYChannelTreeInfoResFieldNumber = 13825;
  inline const ::pp::YYChannelTreeInfoRes& yychanneltreeinfores() const;
  inline ::pp::YYChannelTreeInfoRes* mutable_yychanneltreeinfores();
  inline ::pp::YYChannelTreeInfoRes* release_yychanneltreeinfores();
  inline void set_allocated_yychanneltreeinfores(::pp::YYChannelTreeInfoRes* yychanneltreeinfores);

  // @@protoc_insertion_point(class_scope:pp.ProtoBody)
 private:
  inline void set_has_remoteaddr();
  inline void clear_has_remoteaddr();
  inline void set_has_clientversion();
  inline void clear_has_clientversion();
  inline void set_has_forcelogoutpush();
  inline void clear_has_forcelogoutpush();
  inline void set_has_msgpush();
  inline void clear_has_msgpush();
  inline void set_has_iospushmsg();
  inline void clear_has_iospushmsg();
  inline void set_has_usermsg();
  inline void clear_has_usermsg();
  inline void set_has_groupmsg();
  inline void clear_has_groupmsg();
  inline void set_has_result();
  inline void clear_has_result();
  inline void set_has_userinfo();
  inline void clear_has_userinfo();
  inline void set_has_groupinfo();
  inline void clear_has_groupinfo();
  inline void set_has_groupincrement();
  inline void clear_has_groupincrement();
  inline void set_has_contactincrement();
  inline void clear_has_contactincrement();
  inline void set_has_adlistreq();
  inline void clear_has_adlistreq();
  inline void set_has_adlistres();
  inline void clear_has_adlistres();
  inline void set_has_admodifyreq();
  inline void clear_has_admodifyreq();
  inline void set_has_admodifyres();
  inline void clear_has_admodifyres();
  inline void set_has_adremovereq();
  inline void clear_has_adremovereq();
  inline void set_has_adremoveres();
  inline void clear_has_adremoveres();
  inline void set_has_idcodeapplyreq();
  inline void clear_has_idcodeapplyreq();
  inline void set_has_idcodeapplyres();
  inline void clear_has_idcodeapplyres();
  inline void set_has_idreplacereq();
  inline void clear_has_idreplacereq();
  inline void set_has_publicnumaddreq();
  inline void clear_has_publicnumaddreq();
  inline void set_has_userforbidopreq();
  inline void clear_has_userforbidopreq();
  inline void set_has_userforbidopres();
  inline void clear_has_userforbidopres();
  inline void set_has_userforbidsearchreq();
  inline void clear_has_userforbidsearchreq();
  inline void set_has_userforbidsearchres();
  inline void clear_has_userforbidsearchres();
  inline void set_has_userrolemodifyreq();
  inline void clear_has_userrolemodifyreq();
  inline void set_has_backstagegidsidreq();
  inline void clear_has_backstagegidsidreq();
  inline void set_has_backstagegidsidres();
  inline void clear_has_backstagegidsidres();
  inline void set_has_configjsonreq();
  inline void clear_has_configjsonreq();
  inline void set_has_configjsonres();
  inline void clear_has_configjsonres();
  inline void set_has_configjsonlistreq();
  inline void clear_has_configjsonlistreq();
  inline void set_has_configjsonlistres();
  inline void clear_has_configjsonlistres();
  inline void set_has_sysconfreq();
  inline void clear_has_sysconfreq();
  inline void set_has_sysconfres();
  inline void clear_has_sysconfres();
  inline void set_has_usersettingsetreq();
  inline void clear_has_usersettingsetreq();
  inline void set_has_usersettingsetres();
  inline void clear_has_usersettingsetres();
  inline void set_has_usersettinggetreq();
  inline void clear_has_usersettinggetreq();
  inline void set_has_usersettinggetres();
  inline void clear_has_usersettinggetres();
  inline void set_has_appstatecheckreq();
  inline void clear_has_appstatecheckreq();
  inline void set_has_appstatecheckres();
  inline void clear_has_appstatecheckres();
  inline void set_has_appstateupdatereq();
  inline void clear_has_appstateupdatereq();
  inline void set_has_appstateupdateres();
  inline void clear_has_appstateupdateres();
  inline void set_has_appactconfigreq();
  inline void clear_has_appactconfigreq();
  inline void set_has_appactconfigres();
  inline void clear_has_appactconfigres();
  inline void set_has_appprotoversionupdatereq();
  inline void clear_has_appprotoversionupdatereq();
  inline void set_has_appprotoversionupdateres();
  inline void clear_has_appprotoversionupdateres();
  inline void set_has_contactlistreq();
  inline void clear_has_contactlistreq();
  inline void set_has_contactlistres();
  inline void clear_has_contactlistres();
  inline void set_has_contactaddreq();
  inline void clear_has_contactaddreq();
  inline void set_has_contactaddres();
  inline void clear_has_contactaddres();
  inline void set_has_contactapprovereq();
  inline void clear_has_contactapprovereq();
  inline void set_has_contactapproveres();
  inline void clear_has_contactapproveres();
  inline void set_has_contactmodifyreq();
  inline void clear_has_contactmodifyreq();
  inline void set_has_contactmodifyres();
  inline void clear_has_contactmodifyres();
  inline void set_has_keyexchangereq();
  inline void clear_has_keyexchangereq();
  inline void set_has_keyexchangeres();
  inline void clear_has_keyexchangeres();
  inline void set_has_usergamelistreq();
  inline void clear_has_usergamelistreq();
  inline void set_has_usergamelistres();
  inline void clear_has_usergamelistres();
  inline void set_has_usergamelistreportreq();
  inline void clear_has_usergamelistreportreq();
  inline void set_has_usergamelistreportres();
  inline void clear_has_usergamelistreportres();
  inline void set_has_usergamerunreportreq();
  inline void clear_has_usergamerunreportreq();
  inline void set_has_usergamerunreportres();
  inline void clear_has_usergamerunreportres();
  inline void set_has_gameaddreq();
  inline void clear_has_gameaddreq();
  inline void set_has_gameaddres();
  inline void clear_has_gameaddres();
  inline void set_has_gamemodifyreq();
  inline void clear_has_gamemodifyreq();
  inline void set_has_gamemodifyres();
  inline void clear_has_gamemodifyres();
  inline void set_has_gamesearchreq();
  inline void clear_has_gamesearchreq();
  inline void set_has_gamesearchres();
  inline void clear_has_gamesearchres();
  inline void set_has_modifygroupgamereq();
  inline void clear_has_modifygroupgamereq();
  inline void set_has_modifygroupgameres();
  inline void clear_has_modifygroupgameres();
  inline void set_has_gamediscountlistreq();
  inline void clear_has_gamediscountlistreq();
  inline void set_has_gamediscountlistres();
  inline void clear_has_gamediscountlistres();
  inline void set_has_modifygroupgameapkurlreq();
  inline void clear_has_modifygroupgameapkurlreq();
  inline void set_has_modifygroupgameapkurlres();
  inline void clear_has_modifygroupgameapkurlres();
  inline void set_has_sendinstallgamemsgreq();
  inline void clear_has_sendinstallgamemsgreq();
  inline void set_has_sendinstallgamemsgres();
  inline void clear_has_sendinstallgamemsgres();
  inline void set_has_modifyourgamestatereq();
  inline void clear_has_modifyourgamestatereq();
  inline void set_has_modifyourgamestateres();
  inline void clear_has_modifyourgamestateres();
  inline void set_has_searchgameslistreq();
  inline void clear_has_searchgameslistreq();
  inline void set_has_searchgameslistres();
  inline void clear_has_searchgameslistres();
  inline void set_has_gamecountreq();
  inline void clear_has_gamecountreq();
  inline void set_has_gamecountres();
  inline void clear_has_gamecountres();
  inline void set_has_recommendpacknamereq();
  inline void clear_has_recommendpacknamereq();
  inline void set_has_recommendpacknameres();
  inline void clear_has_recommendpacknameres();
  inline void set_has_gamefiltersearchreq();
  inline void clear_has_gamefiltersearchreq();
  inline void set_has_gamefiltersearchres();
  inline void clear_has_gamefiltersearchres();
  inline void set_has_modifygamefilterreq();
  inline void clear_has_modifygamefilterreq();
  inline void set_has_modifygamefilterres();
  inline void clear_has_modifygamefilterres();
  inline void set_has_gamespiderreq();
  inline void clear_has_gamespiderreq();
  inline void set_has_gamespiderres();
  inline void clear_has_gamespiderres();
  inline void set_has_modifygamediscountreq();
  inline void clear_has_modifygamediscountreq();
  inline void set_has_modifygamediscountres();
  inline void clear_has_modifygamediscountres();
  inline void set_has_modifygroupdiscountreq();
  inline void clear_has_modifygroupdiscountreq();
  inline void set_has_modifygroupdiscountres();
  inline void clear_has_modifygroupdiscountres();
  inline void set_has_groupdiscountlistreq();
  inline void clear_has_groupdiscountlistreq();
  inline void set_has_groupdiscountlistres();
  inline void clear_has_groupdiscountlistres();
  inline void set_has_useryycoinspaymethodreq();
  inline void clear_has_useryycoinspaymethodreq();
  inline void set_has_useryycoinspaymethodres();
  inline void clear_has_useryycoinspaymethodres();
  inline void set_has_useryycoinsshoplistreq();
  inline void clear_has_useryycoinsshoplistreq();
  inline void set_has_useryycoinsshoplistres();
  inline void clear_has_useryycoinsshoplistres();
  inline void set_has_useryycoinsqueryreq();
  inline void clear_has_useryycoinsqueryreq();
  inline void set_has_useryycoinsqueryres();
  inline void clear_has_useryycoinsqueryres();
  inline void set_has_useryycoinsbuyreq();
  inline void clear_has_useryycoinsbuyreq();
  inline void set_has_useryycoinsbuyres();
  inline void clear_has_useryycoinsbuyres();
  inline void set_has_useryycoinsbuyfeedbackreq();
  inline void clear_has_useryycoinsbuyfeedbackreq();
  inline void set_has_useryycoinsbuyfeedbackres();
  inline void clear_has_useryycoinsbuyfeedbackres();
  inline void set_has_useryycoinshistoryreq();
  inline void clear_has_useryycoinshistoryreq();
  inline void set_has_useryycoinshistoryres();
  inline void clear_has_useryycoinshistoryres();
  inline void set_has_useryycoinspaygatecallbackreq();
  inline void clear_has_useryycoinspaygatecallbackreq();
  inline void set_has_groupapplyreq();
  inline void clear_has_groupapplyreq();
  inline void set_has_groupapplyres();
  inline void clear_has_groupapplyres();
  inline void set_has_groupcheckinreq();
  inline void clear_has_groupcheckinreq();
  inline void set_has_groupcheckinres();
  inline void clear_has_groupcheckinres();
  inline void set_has_groupquitreq();
  inline void clear_has_groupquitreq();
  inline void set_has_groupinforeq();
  inline void clear_has_groupinforeq();
  inline void set_has_groupsearchreq();
  inline void clear_has_groupsearchreq();
  inline void set_has_groupsearchres();
  inline void clear_has_groupsearchres();
  inline void set_has_groupsearchkeywordsreq();
  inline void clear_has_groupsearchkeywordsreq();
  inline void set_has_groupsearchkeywordsres();
  inline void clear_has_groupsearchkeywordsres();
  inline void set_has_grouplistreq();
  inline void clear_has_grouplistreq();
  inline void set_has_grouplistres();
  inline void clear_has_grouplistres();
  inline void set_has_groupapprovereq();
  inline void clear_has_groupapprovereq();
  inline void set_has_groupapproveres();
  inline void clear_has_groupapproveres();
  inline void set_has_grouplobbyordermodifyreq();
  inline void clear_has_grouplobbyordermodifyreq();
  inline void set_has_grouplobbyordermodifyres();
  inline void clear_has_grouplobbyordermodifyres();
  inline void set_has_groupteamopreq();
  inline void clear_has_groupteamopreq();
  inline void set_has_grouplabelopreq();
  inline void clear_has_grouplabelopreq();
  inline void set_has_groupappsendreq();
  inline void clear_has_groupappsendreq();
  inline void set_has_groupappsendres();
  inline void clear_has_groupappsendres();
  inline void set_has_groupapplistreq();
  inline void clear_has_groupapplistreq();
  inline void set_has_groupapplistres();
  inline void clear_has_groupapplistres();
  inline void set_has_groupmsgappreq();
  inline void clear_has_groupmsgappreq();
  inline void set_has_groupmsgappres();
  inline void clear_has_groupmsgappres();
  inline void set_has_groupmemberkickreq();
  inline void clear_has_groupmemberkickreq();
  inline void set_has_groupmemberlistreq();
  inline void clear_has_groupmemberlistreq();
  inline void set_has_groupmemberlistres();
  inline void clear_has_groupmemberlistres();
  inline void set_has_groupmemberreq();
  inline void clear_has_groupmemberreq();
  inline void set_has_groupmemberres();
  inline void clear_has_groupmemberres();
  inline void set_has_groupmembermodifyreq();
  inline void clear_has_groupmembermodifyreq();
  inline void set_has_groupmembersearchreq();
  inline void clear_has_groupmembersearchreq();
  inline void set_has_groupmembersearchres();
  inline void clear_has_groupmembersearchres();
  inline void set_has_groupmembercountreq();
  inline void clear_has_groupmembercountreq();
  inline void set_has_groupmembercountres();
  inline void clear_has_groupmembercountres();
  inline void set_has_groupmemberrolerlistreq();
  inline void clear_has_groupmemberrolerlistreq();
  inline void set_has_groupmemberrolerlistres();
  inline void clear_has_groupmemberrolerlistres();
  inline void set_has_groupmemberrolersetreq();
  inline void clear_has_groupmemberrolersetreq();
  inline void set_has_groupmsglistreq();
  inline void clear_has_groupmsglistreq();
  inline void set_has_groupmsglistres();
  inline void clear_has_groupmsglistres();
  inline void set_has_groupmsgvoicereq();
  inline void clear_has_groupmsgvoicereq();
  inline void set_has_groupmsgvoiceres();
  inline void clear_has_groupmsgvoiceres();
  inline void set_has_groupmsgsendreq();
  inline void clear_has_groupmsgsendreq();
  inline void set_has_groupmsgsearchreq();
  inline void clear_has_groupmsgsearchreq();
  inline void set_has_groupmsgsearchres();
  inline void clear_has_groupmsgsearchres();
  inline void set_has_userloginreq();
  inline void clear_has_userloginreq();
  inline void set_has_userloginres();
  inline void clear_has_userloginres();
  inline void set_has_useractivatereq();
  inline void clear_has_useractivatereq();
  inline void set_has_useractivateres();
  inline void clear_has_useractivateres();
  inline void set_has_userheartbeatreq();
  inline void clear_has_userheartbeatreq();
  inline void set_has_userheartbeatres();
  inline void clear_has_userheartbeatres();
  inline void set_has_accountbindreq();
  inline void clear_has_accountbindreq();
  inline void set_has_accountbindres();
  inline void clear_has_accountbindres();
  inline void set_has_userwebloginreq();
  inline void clear_has_userwebloginreq();
  inline void set_has_userwebloginres();
  inline void clear_has_userwebloginres();
  inline void set_has_sessionresumereq();
  inline void clear_has_sessionresumereq();
  inline void set_has_sessionresumeres();
  inline void clear_has_sessionresumeres();
  inline void set_has_sessionsuspendreq();
  inline void clear_has_sessionsuspendreq();
  inline void set_has_usertokenreq();
  inline void clear_has_usertokenreq();
  inline void set_has_usertokenres();
  inline void clear_has_usertokenres();
  inline void set_has_uptokenreq();
  inline void clear_has_uptokenreq();
  inline void set_has_uptokenres();
  inline void clear_has_uptokenres();
  inline void set_has_userpushtokenregisterreq();
  inline void clear_has_userpushtokenregisterreq();
  inline void set_has_userpushtokenregisterres();
  inline void clear_has_userpushtokenregisterres();
  inline void set_has_userlogoutreq();
  inline void clear_has_userlogoutreq();
  inline void set_has_userlogoutres();
  inline void clear_has_userlogoutres();
  inline void set_has_cpswebloginreq();
  inline void clear_has_cpswebloginreq();
  inline void set_has_cpswebloginres();
  inline void clear_has_cpswebloginres();
  inline void set_has_cpsaccountbindreq();
  inline void clear_has_cpsaccountbindreq();
  inline void set_has_cpsaccountbindres();
  inline void clear_has_cpsaccountbindres();
  inline void set_has_presentinforeq();
  inline void clear_has_presentinforeq();
  inline void set_has_presentinfores();
  inline void clear_has_presentinfores();
  inline void set_has_presentaddreq();
  inline void clear_has_presentaddreq();
  inline void set_has_getpresentsbygameidreq();
  inline void clear_has_getpresentsbygameidreq();
  inline void set_has_getpresentsbygameidres();
  inline void clear_has_getpresentsbygameidres();
  inline void set_has_presentlistreq();
  inline void clear_has_presentlistreq();
  inline void set_has_presentlistres();
  inline void clear_has_presentlistres();
  inline void set_has_presentcountreq();
  inline void clear_has_presentcountreq();
  inline void set_has_presentcountres();
  inline void clear_has_presentcountres();
  inline void set_has_presentgrouplistreq();
  inline void clear_has_presentgrouplistreq();
  inline void set_has_presentgrouplistres();
  inline void clear_has_presentgrouplistres();
  inline void set_has_presentusertakereq();
  inline void clear_has_presentusertakereq();
  inline void set_has_presentusertakeres();
  inline void clear_has_presentusertakeres();
  inline void set_has_presentmodifyreq();
  inline void clear_has_presentmodifyreq();
  inline void set_has_userpresentreq();
  inline void clear_has_userpresentreq();
  inline void set_has_userpresentres();
  inline void clear_has_userpresentres();
  inline void set_has_userpresentlistreq();
  inline void clear_has_userpresentlistreq();
  inline void set_has_userpresentlistres();
  inline void clear_has_userpresentlistres();
  inline void set_has_grouppresentopreq();
  inline void clear_has_grouppresentopreq();
  inline void set_has_grouppresentopres();
  inline void clear_has_grouppresentopres();
  inline void set_has_grouppresentlistreq();
  inline void clear_has_grouppresentlistreq();
  inline void set_has_grouppresentlistres();
  inline void clear_has_grouppresentlistres();
  inline void set_has_presentuserlistreq();
  inline void clear_has_presentuserlistreq();
  inline void set_has_presentuserlistres();
  inline void clear_has_presentuserlistres();
  inline void set_has_reportviolatorreq();
  inline void clear_has_reportviolatorreq();
  inline void set_has_reportlogreq();
  inline void clear_has_reportlogreq();
  inline void set_has_yygiftlistreq();
  inline void clear_has_yygiftlistreq();
  inline void set_has_yygiftlistres();
  inline void clear_has_yygiftlistres();
  inline void set_has_yygiftdonatereq();
  inline void clear_has_yygiftdonatereq();
  inline void set_has_yygiftdonateres();
  inline void clear_has_yygiftdonateres();
  inline void set_has_yygiftpayconfirmreq();
  inline void clear_has_yygiftpayconfirmreq();
  inline void set_has_yygiftpayconfirmres();
  inline void clear_has_yygiftpayconfirmres();
  inline void set_has_productlistreq();
  inline void clear_has_productlistreq();
  inline void set_has_productlistres();
  inline void clear_has_productlistres();
  inline void set_has_productopreq();
  inline void clear_has_productopreq();
  inline void set_has_productbuyreq();
  inline void clear_has_productbuyreq();
  inline void set_has_userwithdrawreq();
  inline void clear_has_userwithdrawreq();
  inline void set_has_usermoneystatreq();
  inline void clear_has_usermoneystatreq();
  inline void set_has_usermoneystatres();
  inline void clear_has_usermoneystatres();
  inline void set_has_userbankinfoopreq();
  inline void clear_has_userbankinfoopreq();
  inline void set_has_userbankinfoopres();
  inline void clear_has_userbankinfoopres();
  inline void set_has_banklistreq();
  inline void clear_has_banklistreq();
  inline void set_has_banklistres();
  inline void clear_has_banklistres();
  inline void set_has_usertaskstatereq();
  inline void clear_has_usertaskstatereq();
  inline void set_has_usertaskstateres();
  inline void clear_has_usertaskstateres();
  inline void set_has_usertasktakeawardreq();
  inline void clear_has_usertasktakeawardreq();
  inline void set_has_usertasktakeawardres();
  inline void clear_has_usertasktakeawardres();
  inline void set_has_usertaskcheckreq();
  inline void clear_has_usertaskcheckreq();
  inline void set_has_usertaskcheckres();
  inline void clear_has_usertaskcheckres();
  inline void set_has_userinforeq();
  inline void clear_has_userinforeq();
  inline void set_has_userinfores();
  inline void clear_has_userinfores();
  inline void set_has_userinfomodifyreq();
  inline void clear_has_userinfomodifyreq();
  inline void set_has_userinfomodifyres();
  inline void clear_has_userinfomodifyres();
  inline void set_has_userinfolistreq();
  inline void clear_has_userinfolistreq();
  inline void set_has_userinfolistres();
  inline void clear_has_userinfolistres();
  inline void set_has_userpasswordmodifyreq();
  inline void clear_has_userpasswordmodifyreq();
  inline void set_has_userpasswordmodifyres();
  inline void clear_has_userpasswordmodifyres();
  inline void set_has_usersearchreq();
  inline void clear_has_usersearchreq();
  inline void set_has_usersearchres();
  inline void clear_has_usersearchres();
  inline void set_has_userimagelistreq();
  inline void clear_has_userimagelistreq();
  inline void set_has_userimagelistres();
  inline void clear_has_userimagelistres();
  inline void set_has_userimageopreq();
  inline void clear_has_userimageopreq();
  inline void set_has_userimageopres();
  inline void clear_has_userimageopres();
  inline void set_has_userimagelikereq();
  inline void clear_has_userimagelikereq();
  inline void set_has_userimagelikeres();
  inline void clear_has_userimagelikeres();
  inline void set_has_userrecommendregisterreq();
  inline void clear_has_userrecommendregisterreq();
  inline void set_has_userrecommendregisterres();
  inline void clear_has_userrecommendregisterres();
  inline void set_has_userrefererlistreq();
  inline void clear_has_userrefererlistreq();
  inline void set_has_userrefererlistres();
  inline void clear_has_userrefererlistres();
  inline void set_has_userproductlistreq();
  inline void clear_has_userproductlistreq();
  inline void set_has_userproductlistres();
  inline void clear_has_userproductlistres();
  inline void set_has_useractivedatareq();
  inline void clear_has_useractivedatareq();
  inline void set_has_useractivedatares();
  inline void clear_has_useractivedatares();
  inline void set_has_userstatdatareq();
  inline void clear_has_userstatdatareq();
  inline void set_has_userstatdatares();
  inline void clear_has_userstatdatares();
  inline void set_has_useractivedatalistreq();
  inline void clear_has_useractivedatalistreq();
  inline void set_has_useractivedatalistres();
  inline void clear_has_useractivedatalistres();
  inline void set_has_userprofileviewreq();
  inline void clear_has_userprofileviewreq();
  inline void set_has_userprofileviewres();
  inline void clear_has_userprofileviewres();
  inline void set_has_userappratereq();
  inline void clear_has_userappratereq();
  inline void set_has_userapprateres();
  inline void clear_has_userapprateres();
  inline void set_has_userexpressaddropreq();
  inline void clear_has_userexpressaddropreq();
  inline void set_has_userexpressaddropres();
  inline void clear_has_userexpressaddropres();
  inline void set_has_autotaskuserlistreq();
  inline void clear_has_autotaskuserlistreq();
  inline void set_has_autotaskuserlistres();
  inline void clear_has_autotaskuserlistres();
  inline void set_has_usershowsharereq();
  inline void clear_has_usershowsharereq();
  inline void set_has_usershowshareres();
  inline void clear_has_usershowshareres();
  inline void set_has_userthirdpartyaccountreq();
  inline void clear_has_userthirdpartyaccountreq();
  inline void set_has_userthirdpartyaccountres();
  inline void clear_has_userthirdpartyaccountres();
  inline void set_has_usermsglistreq();
  inline void clear_has_usermsglistreq();
  inline void set_has_usermsglistres();
  inline void clear_has_usermsglistres();
  inline void set_has_usermsgbroadcastreq();
  inline void clear_has_usermsgbroadcastreq();
  inline void set_has_usermsgrejectlistsetreq();
  inline void clear_has_usermsgrejectlistsetreq();
  inline void set_has_usermsgrejectlistsetres();
  inline void clear_has_usermsgrejectlistsetres();
  inline void set_has_usermsgrejectlistgetreq();
  inline void clear_has_usermsgrejectlistgetreq();
  inline void set_has_usermsgrejectlistgetres();
  inline void clear_has_usermsgrejectlistgetres();
  inline void set_has_msgreadrevisionsetreq();
  inline void clear_has_msgreadrevisionsetreq();
  inline void set_has_msgreadrevisionsetres();
  inline void clear_has_msgreadrevisionsetres();
  inline void set_has_msgreadrevisiongetreq();
  inline void clear_has_msgreadrevisiongetreq();
  inline void set_has_msgreadrevisiongetres();
  inline void clear_has_msgreadrevisiongetres();
  inline void set_has_msgbroadcastqueryreq();
  inline void clear_has_msgbroadcastqueryreq();
  inline void set_has_msgbroadcastqueryres();
  inline void clear_has_msgbroadcastqueryres();
  inline void set_has_weilianjoinreq();
  inline void clear_has_weilianjoinreq();
  inline void set_has_weilianjoinres();
  inline void clear_has_weilianjoinres();
  inline void set_has_weiliangoddessrankreq();
  inline void clear_has_weiliangoddessrankreq();
  inline void set_has_weiliangoddessrankres();
  inline void clear_has_weiliangoddessrankres();
  inline void set_has_weiliansearchreq();
  inline void clear_has_weiliansearchreq();
  inline void set_has_weiliansearchres();
  inline void clear_has_weiliansearchres();
  inline void set_has_weilianvotereq();
  inline void clear_has_weilianvotereq();
  inline void set_has_weilianvoteres();
  inline void clear_has_weilianvoteres();
  inline void set_has_weilianmyrankreq();
  inline void clear_has_weilianmyrankreq();
  inline void set_has_weilianmyrankres();
  inline void clear_has_weilianmyrankres();
  inline void set_has_webqrcodescanreq();
  inline void clear_has_webqrcodescanreq();
  inline void set_has_webtokenverifyreq();
  inline void clear_has_webtokenverifyreq();
  inline void set_has_userdataadjustreq();
  inline void clear_has_userdataadjustreq();
  inline void set_has_configdatareq();
  inline void clear_has_configdatareq();
  inline void set_has_configdatares();
  inline void clear_has_configdatares();
  inline void set_has_pagedataexchangereq();
  inline void clear_has_pagedataexchangereq();
  inline void set_has_pagedataexchangeres();
  inline void clear_has_pagedataexchangeres();
  inline void set_has_actluckytryreq();
  inline void clear_has_actluckytryreq();
  inline void set_has_actluckytryres();
  inline void clear_has_actluckytryres();
  inline void set_has_actrecvdynamicreq();
  inline void clear_has_actrecvdynamicreq();
  inline void set_has_actrecvdynamicres();
  inline void clear_has_actrecvdynamicres();
  inline void set_has_configjsonactlistreq();
  inline void clear_has_configjsonactlistreq();
  inline void set_has_configjsonactlistres();
  inline void clear_has_configjsonactlistres();
  inline void set_has_configjsonactmodifyreq();
  inline void clear_has_configjsonactmodifyreq();
  inline void set_has_actstarformreq();
  inline void clear_has_actstarformreq();
  inline void set_has_configjsonactstarreq();
  inline void clear_has_configjsonactstarreq();
  inline void set_has_configjsonactres();
  inline void clear_has_configjsonactres();
  inline void set_has_actmsglistreq();
  inline void clear_has_actmsglistreq();
  inline void set_has_actmsglistres();
  inline void clear_has_actmsglistres();
  inline void set_has_actmsgmodifyreq();
  inline void clear_has_actmsgmodifyreq();
  inline void set_has_coinawardrecordreq();
  inline void clear_has_coinawardrecordreq();
  inline void set_has_coinawardrecordres();
  inline void clear_has_coinawardrecordres();
  inline void set_has_coreuserlistreq();
  inline void clear_has_coreuserlistreq();
  inline void set_has_coreuserlistres();
  inline void clear_has_coreuserlistres();
  inline void set_has_coreusermodifyreq();
  inline void clear_has_coreusermodifyreq();
  inline void set_has_yychanneltreeinforeq();
  inline void clear_has_yychanneltreeinforeq();
  inline void set_has_yychanneltreeinfores();
  inline void clear_has_yychanneltreeinfores();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* remoteaddr_;
  ::pp::ForceLogoutPush* forcelogoutpush_;
  ::pp::MsgPush* msgpush_;
  ::std::string* iospushmsg_;
  ::pp::UserMsg* usermsg_;
  ::pp::GroupMsg* groupmsg_;
  ::pp::Result* result_;
  ::pp::UserInfo* userinfo_;
  ::pp::GroupInfo* groupinfo_;
  ::pp::GroupIncrement* groupincrement_;
  ::pp::ContactIncrement* contactincrement_;
  ::pp::AdListReq* adlistreq_;
  ::pp::AdListRes* adlistres_;
  ::pp::AdModifyReq* admodifyreq_;
  ::pp::AdModifyRes* admodifyres_;
  ::pp::AdRemoveReq* adremovereq_;
  ::pp::AdRemoveRes* adremoveres_;
  ::pp::IDCodeApplyReq* idcodeapplyreq_;
  ::pp::IDCodeApplyRes* idcodeapplyres_;
  ::pp::IDReplaceReq* idreplacereq_;
  ::pp::PublicNumAddReq* publicnumaddreq_;
  ::pp::UserForbidOpReq* userforbidopreq_;
  ::pp::UserForbidOpRes* userforbidopres_;
  ::pp::UserForbidSearchReq* userforbidsearchreq_;
  ::pp::UserForbidSearchRes* userforbidsearchres_;
  ::pp::UserRoleModifyReq* userrolemodifyreq_;
  ::pp::BackstageGidSidReq* backstagegidsidreq_;
  ::pp::BackstageGidSidRes* backstagegidsidres_;
  ::pp::ConfigJsonReq* configjsonreq_;
  ::pp::ConfigJsonRes* configjsonres_;
  ::pp::ConfigJsonListReq* configjsonlistreq_;
  ::pp::ConfigJsonListRes* configjsonlistres_;
  ::pp::SysConfReq* sysconfreq_;
  ::pp::SysConfRes* sysconfres_;
  ::pp::UserSettingSetReq* usersettingsetreq_;
  ::pp::UserSettingSetRes* usersettingsetres_;
  ::pp::UserSettingGetReq* usersettinggetreq_;
  ::pp::UserSettingGetRes* usersettinggetres_;
  ::pp::AppStateCheckReq* appstatecheckreq_;
  ::pp::AppStateCheckRes* appstatecheckres_;
  ::pp::AppStateUpdateReq* appstateupdatereq_;
  ::pp::AppStateUpdateRes* appstateupdateres_;
  ::pp::AppActConfigReq* appactconfigreq_;
  ::pp::AppActConfigRes* appactconfigres_;
  ::pp::AppProtoVersionUpdateReq* appprotoversionupdatereq_;
  ::pp::AppProtoVersionUpdateRes* appprotoversionupdateres_;
  ::pp::ContactListReq* contactlistreq_;
  ::pp::ContactListRes* contactlistres_;
  ::pp::ContactAddReq* contactaddreq_;
  ::pp::ContactAddRes* contactaddres_;
  ::pp::ContactApproveReq* contactapprovereq_;
  ::pp::ContactApproveRes* contactapproveres_;
  ::pp::ContactModifyReq* contactmodifyreq_;
  ::pp::ContactModifyRes* contactmodifyres_;
  ::pp::KeyExchangeReq* keyexchangereq_;
  ::pp::KeyExchangeRes* keyexchangeres_;
  ::pp::UserGameListReq* usergamelistreq_;
  ::pp::UserGameListRes* usergamelistres_;
  ::pp::UserGameListReportReq* usergamelistreportreq_;
  ::pp::UserGameListReportRes* usergamelistreportres_;
  ::pp::UserGameRunReportReq* usergamerunreportreq_;
  ::pp::UserGameRunReportRes* usergamerunreportres_;
  ::pp::GameAddReq* gameaddreq_;
  ::pp::GameAddRes* gameaddres_;
  ::pp::GameModifyReq* gamemodifyreq_;
  ::pp::GameModifyRes* gamemodifyres_;
  ::pp::GameSearchReq* gamesearchreq_;
  ::pp::GameSearchRes* gamesearchres_;
  ::pp::ModifyGroupGameReq* modifygroupgamereq_;
  ::pp::ModifyGroupGameRes* modifygroupgameres_;
  ::pp::GameDiscountListReq* gamediscountlistreq_;
  ::pp::GameDiscountListRes* gamediscountlistres_;
  ::pp::ModifyGroupGameApkurlReq* modifygroupgameapkurlreq_;
  ::pp::ModifyGroupGameApkurlRes* modifygroupgameapkurlres_;
  ::pp::SendInstallGameMsgReq* sendinstallgamemsgreq_;
  ::pp::SendInstallGameMsgRes* sendinstallgamemsgres_;
  ::pp::ModifyOurGameStateReq* modifyourgamestatereq_;
  ::pp::ModifyOurGameStateRes* modifyourgamestateres_;
  ::pp::SearchGamesListReq* searchgameslistreq_;
  ::pp::SearchGamesListRes* searchgameslistres_;
  ::pp::GameCountReq* gamecountreq_;
  ::pp::GameCountRes* gamecountres_;
  ::pp::RecommendPackNameReq* recommendpacknamereq_;
  ::pp::RecommendPackNameRes* recommendpacknameres_;
  ::pp::GameFilterSearchReq* gamefiltersearchreq_;
  ::pp::GameFilterSearchRes* gamefiltersearchres_;
  ::pp::ModifyGameFilterReq* modifygamefilterreq_;
  ::pp::ModifyGameFilterRes* modifygamefilterres_;
  ::pp::GameSpiderReq* gamespiderreq_;
  ::pp::GameSpiderRes* gamespiderres_;
  ::pp::ModifyGameDiscountReq* modifygamediscountreq_;
  ::pp::ModifyGameDiscountRes* modifygamediscountres_;
  ::pp::ModifyGroupDiscountReq* modifygroupdiscountreq_;
  ::pp::ModifyGroupDiscountRes* modifygroupdiscountres_;
  ::pp::GroupDiscountListReq* groupdiscountlistreq_;
  ::pp::GroupDiscountListRes* groupdiscountlistres_;
  ::pp::UserYYCoinsPayMethodReq* useryycoinspaymethodreq_;
  ::pp::UserYYCoinsPayMethodRes* useryycoinspaymethodres_;
  ::pp::UserYYCoinsShopListReq* useryycoinsshoplistreq_;
  ::pp::UserYYCoinsShopListRes* useryycoinsshoplistres_;
  ::pp::UserYYCoinsQueryReq* useryycoinsqueryreq_;
  ::pp::UserYYCoinsQueryRes* useryycoinsqueryres_;
  ::pp::UserYYCoinsBuyReq* useryycoinsbuyreq_;
  ::pp::UserYYCoinsBuyRes* useryycoinsbuyres_;
  ::pp::UserYYCoinsBuyFeedbackReq* useryycoinsbuyfeedbackreq_;
  ::pp::UserYYCoinsBuyFeedbackRes* useryycoinsbuyfeedbackres_;
  ::pp::UserYYCoinsHistoryReq* useryycoinshistoryreq_;
  ::pp::UserYYCoinsHistoryRes* useryycoinshistoryres_;
  ::pp::UserYYCoinsPayGateCallbackReq* useryycoinspaygatecallbackreq_;
  ::pp::GroupApplyReq* groupapplyreq_;
  ::pp::GroupApplyRes* groupapplyres_;
  ::pp::GroupCheckinReq* groupcheckinreq_;
  ::pp::GroupCheckinRes* groupcheckinres_;
  ::pp::GroupQuitReq* groupquitreq_;
  ::pp::GroupInfoReq* groupinforeq_;
  ::pp::GroupSearchReq* groupsearchreq_;
  ::pp::GroupSearchRes* groupsearchres_;
  ::pp::GroupSearchKeywordsReq* groupsearchkeywordsreq_;
  ::pp::GroupSearchKeywordsRes* groupsearchkeywordsres_;
  ::pp::GroupListReq* grouplistreq_;
  ::pp::GroupListRes* grouplistres_;
  ::pp::GroupApproveReq* groupapprovereq_;
  ::pp::GroupApproveRes* groupapproveres_;
  ::pp::GroupLobbyOrderModifyReq* grouplobbyordermodifyreq_;
  ::pp::GroupLobbyOrderModifyRes* grouplobbyordermodifyres_;
  ::pp::GroupTeamOpReq* groupteamopreq_;
  ::pp::GroupLabelOpReq* grouplabelopreq_;
  ::pp::GroupAppSendReq* groupappsendreq_;
  ::pp::GroupAppSendRes* groupappsendres_;
  ::pp::GroupAppListReq* groupapplistreq_;
  ::pp::GroupAppListRes* groupapplistres_;
  ::pp::GroupMsgAppReq* groupmsgappreq_;
  ::pp::GroupMsgAppRes* groupmsgappres_;
  ::pp::GroupMemberKickReq* groupmemberkickreq_;
  ::pp::GroupMemberListReq* groupmemberlistreq_;
  ::pp::GroupMemberListRes* groupmemberlistres_;
  ::pp::GroupMemberReq* groupmemberreq_;
  ::pp::GroupMemberRes* groupmemberres_;
  ::pp::GroupMemberModifyReq* groupmembermodifyreq_;
  ::pp::GroupMemberSearchReq* groupmembersearchreq_;
  ::pp::GroupMemberSearchRes* groupmembersearchres_;
  ::pp::GroupMemberCountReq* groupmembercountreq_;
  ::pp::GroupMemberCountRes* groupmembercountres_;
  ::pp::GroupMemberRolerListReq* groupmemberrolerlistreq_;
  ::pp::GroupMemberRolerListRes* groupmemberrolerlistres_;
  ::pp::GroupMemberRolerSetReq* groupmemberrolersetreq_;
  ::pp::GroupMsgListReq* groupmsglistreq_;
  ::pp::GroupMsgListRes* groupmsglistres_;
  ::pp::GroupMsgVoiceReq* groupmsgvoicereq_;
  ::pp::GroupMsgVoiceRes* groupmsgvoiceres_;
  ::pp::GroupMsgSendReq* groupmsgsendreq_;
  ::pp::GroupMsgSearchReq* groupmsgsearchreq_;
  ::pp::GroupMsgSearchRes* groupmsgsearchres_;
  ::pp::UserLoginReq* userloginreq_;
  ::pp::UserLoginRes* userloginres_;
  ::pp::UserActivateReq* useractivatereq_;
  ::pp::UserActivateRes* useractivateres_;
  ::pp::UserHeartBeatReq* userheartbeatreq_;
  ::pp::UserHeartBeatRes* userheartbeatres_;
  ::pp::AccountBindReq* accountbindreq_;
  ::pp::AccountBindRes* accountbindres_;
  ::pp::UserWebLoginReq* userwebloginreq_;
  ::pp::UserWebLoginRes* userwebloginres_;
  ::pp::SessionResumeReq* sessionresumereq_;
  ::pp::SessionResumeRes* sessionresumeres_;
  ::pp::SessionSuspendReq* sessionsuspendreq_;
  ::pp::UserTokenReq* usertokenreq_;
  ::pp::UserTokenRes* usertokenres_;
  ::pp::UptokenReq* uptokenreq_;
  ::pp::UptokenRes* uptokenres_;
  ::pp::UserPushTokenRegisterReq* userpushtokenregisterreq_;
  ::pp::UserPushTokenRegisterRes* userpushtokenregisterres_;
  ::pp::UserLogoutReq* userlogoutreq_;
  ::pp::UserLogoutRes* userlogoutres_;
  ::pp::CpsWebLoginReq* cpswebloginreq_;
  ::pp::CpsWebLoginRes* cpswebloginres_;
  ::pp::CpsAccountBindReq* cpsaccountbindreq_;
  ::pp::CpsAccountBindRes* cpsaccountbindres_;
  ::pp::PresentInfoReq* presentinforeq_;
  ::pp::PresentInfoRes* presentinfores_;
  ::pp::PresentAddReq* presentaddreq_;
  ::pp::GetPresentsByGameIdReq* getpresentsbygameidreq_;
  ::pp::GetPresentsByGameIdRes* getpresentsbygameidres_;
  ::pp::PresentListReq* presentlistreq_;
  ::pp::PresentListRes* presentlistres_;
  ::pp::PresentCountReq* presentcountreq_;
  ::pp::PresentCountRes* presentcountres_;
  ::pp::PresentGroupListReq* presentgrouplistreq_;
  ::pp::PresentGroupListRes* presentgrouplistres_;
  ::pp::PresentUserTakeReq* presentusertakereq_;
  ::pp::PresentUserTakeRes* presentusertakeres_;
  ::pp::PresentModifyReq* presentmodifyreq_;
  ::pp::UserPresentReq* userpresentreq_;
  ::pp::UserPresentRes* userpresentres_;
  ::pp::UserPresentListReq* userpresentlistreq_;
  ::pp::UserPresentListRes* userpresentlistres_;
  ::pp::GroupPresentOpReq* grouppresentopreq_;
  ::pp::GroupPresentOpRes* grouppresentopres_;
  ::pp::GroupPresentListReq* grouppresentlistreq_;
  ::pp::GroupPresentListRes* grouppresentlistres_;
  ::pp::PresentUserListReq* presentuserlistreq_;
  ::pp::PresentUserListRes* presentuserlistres_;
  ::pp::ReportViolatorReq* reportviolatorreq_;
  ::pp::ReportLogReq* reportlogreq_;
  ::pp::YYGiftListReq* yygiftlistreq_;
  ::pp::YYGiftListRes* yygiftlistres_;
  ::pp::YYGiftDonateReq* yygiftdonatereq_;
  ::pp::YYGiftDonateRes* yygiftdonateres_;
  ::pp::YYGiftPayConfirmReq* yygiftpayconfirmreq_;
  ::pp::YYGiftPayConfirmRes* yygiftpayconfirmres_;
  ::pp::ProductListReq* productlistreq_;
  ::pp::ProductListRes* productlistres_;
  ::pp::ProductOpReq* productopreq_;
  ::pp::ProductBuyReq* productbuyreq_;
  ::pp::UserWithdrawReq* userwithdrawreq_;
  ::pp::UserMoneyStatReq* usermoneystatreq_;
  ::pp::UserMoneyStatRes* usermoneystatres_;
  ::pp::UserBankInfoOpReq* userbankinfoopreq_;
  ::pp::UserBankInfoOpRes* userbankinfoopres_;
  ::pp::BankListReq* banklistreq_;
  ::pp::BankListRes* banklistres_;
  ::pp::UserTaskStateReq* usertaskstatereq_;
  ::pp::UserTaskStateRes* usertaskstateres_;
  ::pp::UserTaskTakeAwardReq* usertasktakeawardreq_;
  ::pp::UserTaskTakeAwardRes* usertasktakeawardres_;
  ::pp::UserTaskCheckReq* usertaskcheckreq_;
  ::pp::UserTaskCheckRes* usertaskcheckres_;
  ::pp::UserInfoReq* userinforeq_;
  ::pp::UserInfoRes* userinfores_;
  ::pp::UserInfoModifyReq* userinfomodifyreq_;
  ::pp::UserInfoModifyRes* userinfomodifyres_;
  ::pp::UserInfoListReq* userinfolistreq_;
  ::pp::UserInfoListRes* userinfolistres_;
  ::pp::UserPasswordModifyReq* userpasswordmodifyreq_;
  ::pp::UserPasswordModifyRes* userpasswordmodifyres_;
  ::pp::UserSearchReq* usersearchreq_;
  ::pp::UserSearchRes* usersearchres_;
  ::pp::UserImageListReq* userimagelistreq_;
  ::pp::UserImageListRes* userimagelistres_;
  ::pp::UserImageOpReq* userimageopreq_;
  ::pp::UserImageOpRes* userimageopres_;
  ::pp::UserImageLikeReq* userimagelikereq_;
  ::pp::UserImageLikeRes* userimagelikeres_;
  ::pp::UserRecommendRegisterReq* userrecommendregisterreq_;
  ::pp::UserRecommendRegisterRes* userrecommendregisterres_;
  ::pp::UserRefererListReq* userrefererlistreq_;
  ::pp::UserRefererListRes* userrefererlistres_;
  ::pp::UserProductListReq* userproductlistreq_;
  ::pp::UserProductListRes* userproductlistres_;
  ::pp::UserActiveDataReq* useractivedatareq_;
  ::pp::UserActiveDataRes* useractivedatares_;
  ::pp::UserStatDataReq* userstatdatareq_;
  ::pp::UserStatDataRes* userstatdatares_;
  ::pp::UserActiveDataListReq* useractivedatalistreq_;
  ::pp::UserActiveDataListRes* useractivedatalistres_;
  ::pp::UserProfileViewReq* userprofileviewreq_;
  ::pp::UserProfileViewRes* userprofileviewres_;
  ::pp::UserAppRateReq* userappratereq_;
  ::pp::UserAppRateRes* userapprateres_;
  ::pp::UserExpressAddrOpReq* userexpressaddropreq_;
  ::pp::UserExpressAddrOpRes* userexpressaddropres_;
  ::pp::AutoTaskUserListReq* autotaskuserlistreq_;
  ::pp::AutoTaskUserListRes* autotaskuserlistres_;
  ::pp::UserShowShareReq* usershowsharereq_;
  ::pp::UserShowShareRes* usershowshareres_;
  ::pp::UserThirdPartyAccountReq* userthirdpartyaccountreq_;
  ::pp::UserThirdPartyAccountRes* userthirdpartyaccountres_;
  ::pp::UserMsgListReq* usermsglistreq_;
  ::pp::UserMsgListRes* usermsglistres_;
  ::pp::UserMsgBroadcastReq* usermsgbroadcastreq_;
  ::pp::UserMsgRejectListSetReq* usermsgrejectlistsetreq_;
  ::pp::UserMsgRejectListSetRes* usermsgrejectlistsetres_;
  ::pp::UserMsgRejectListGetReq* usermsgrejectlistgetreq_;
  ::pp::UserMsgRejectListGetRes* usermsgrejectlistgetres_;
  ::pp::MsgReadRevisionSetReq* msgreadrevisionsetreq_;
  ::pp::MsgReadRevisionSetRes* msgreadrevisionsetres_;
  ::pp::MsgReadRevisionGetReq* msgreadrevisiongetreq_;
  ::pp::MsgReadRevisionGetRes* msgreadrevisiongetres_;
  ::pp::MsgBroadcastQueryReq* msgbroadcastqueryreq_;
  ::pp::MsgBroadcastQueryRes* msgbroadcastqueryres_;
  ::pp::WeiLianJoinReq* weilianjoinreq_;
  ::pp::WeiLianJoinRes* weilianjoinres_;
  ::pp::WeiLianGoddessRankReq* weiliangoddessrankreq_;
  ::pp::WeiLianGoddessRankRes* weiliangoddessrankres_;
  ::pp::WeiLianSearchReq* weiliansearchreq_;
  ::pp::WeiLianSearchRes* weiliansearchres_;
  ::pp::WeiLianVoteReq* weilianvotereq_;
  ::pp::WeiLianVoteRes* weilianvoteres_;
  ::pp::WeiLianMyRankReq* weilianmyrankreq_;
  ::pp::WeiLianMyRankRes* weilianmyrankres_;
  ::pp::WebQRCodeScanReq* webqrcodescanreq_;
  ::pp::WebTokenVerifyReq* webtokenverifyreq_;
  ::pp::UserDataAdjustReq* userdataadjustreq_;
  ::pp::ConfigDataReq* configdatareq_;
  ::pp::ConfigDataRes* configdatares_;
  ::pp::PageDataExchangeReq* pagedataexchangereq_;
  ::pp::PageDataExchangeRes* pagedataexchangeres_;
  ::pp::ActLuckyTryReq* actluckytryreq_;
  ::pp::ActLuckyTryRes* actluckytryres_;
  ::pp::ActRecvDynamicReq* actrecvdynamicreq_;
  ::pp::ActRecvDynamicRes* actrecvdynamicres_;
  ::pp::ConfigJsonActListReq* configjsonactlistreq_;
  ::pp::ConfigJsonActListRes* configjsonactlistres_;
  ::pp::ConfigJsonActModifyReq* configjsonactmodifyreq_;
  ::pp::ActStarFormReq* actstarformreq_;
  ::pp::ConfigJsonActStarReq* configjsonactstarreq_;
  ::pp::ConfigJsonActRes* configjsonactres_;
  ::pp::ActMsgListReq* actmsglistreq_;
  ::pp::ActMsgListRes* actmsglistres_;
  ::pp::ActMsgModifyReq* actmsgmodifyreq_;
  ::pp::CoinAwardRecordReq* coinawardrecordreq_;
  ::pp::CoinAwardRecordRes* coinawardrecordres_;
  ::pp::CoreUserListReq* coreuserlistreq_;
  ::pp::CoreUserListRes* coreuserlistres_;
  ::pp::CoreUserModifyReq* coreusermodifyreq_;
  ::pp::YYChannelTreeInfoReq* yychanneltreeinforeq_;
  ::pp::YYChannelTreeInfoRes* yychanneltreeinfores_;
  ::google::protobuf::uint32 clientversion_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(318 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static ProtoBody* default_instance_;
};
// -------------------------------------------------------------------

class WebReq : public ::google::protobuf::Message {
 public:
  WebReq();
  virtual ~WebReq();

  WebReq(const WebReq& from);

  inline WebReq& operator=(const WebReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WebReq& default_instance();

  void Swap(WebReq* other);

  // implements Message ----------------------------------------------

  WebReq* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional sint32 mt = 1;
  inline bool has_mt() const;
  inline void clear_mt();
  static const int kMtFieldNumber = 1;
  inline ::google::protobuf::int32 mt() const;
  inline void set_mt(::google::protobuf::int32 value);

  // optional sint32 st = 2;
  inline bool has_st() const;
  inline void clear_st();
  static const int kStFieldNumber = 2;
  inline ::google::protobuf::int32 st() const;
  inline void set_st(::google::protobuf::int32 value);

  // optional .pp.ProtoBody body = 7;
  inline bool has_body() const;
  inline void clear_body();
  static const int kBodyFieldNumber = 7;
  inline const ::pp::ProtoBody& body() const;
  inline ::pp::ProtoBody* mutable_body();
  inline ::pp::ProtoBody* release_body();
  inline void set_allocated_body(::pp::ProtoBody* body);

  // optional int64 timestamp = 10;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 10;
  inline ::google::protobuf::int64 timestamp() const;
  inline void set_timestamp(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pp.WebReq)
 private:
  inline void set_has_mt();
  inline void clear_has_mt();
  inline void set_has_st();
  inline void clear_has_st();
  inline void set_has_body();
  inline void clear_has_body();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 mt_;
  ::google::protobuf::int32 st_;
  ::pp::ProtoBody* body_;
  ::google::protobuf::int64 timestamp_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xgame_2eproto();
  friend void protobuf_AssignDesc_xgame_2eproto();
  friend void protobuf_ShutdownFile_xgame_2eproto();

  void InitAsDefaultInstance();
  static WebReq* default_instance_;
};
// ===================================================================


// ===================================================================

// AdListReq

// required uint32 page = 1;
inline bool AdListReq::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdListReq::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdListReq::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdListReq::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 AdListReq::page() const {
  return page_;
}
inline void AdListReq::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// optional bool web = 2;
inline bool AdListReq::has_web() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdListReq::set_has_web() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdListReq::clear_has_web() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdListReq::clear_web() {
  web_ = false;
  clear_has_web();
}
inline bool AdListReq::web() const {
  return web_;
}
inline void AdListReq::set_web(bool value) {
  set_has_web();
  web_ = value;
}

// -------------------------------------------------------------------

// AdListRes

// required uint32 page = 1;
inline bool AdListRes::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdListRes::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdListRes::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdListRes::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 AdListRes::page() const {
  return page_;
}
inline void AdListRes::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// optional .pp.MessageBody adbody = 2;
inline bool AdListRes::has_adbody() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdListRes::set_has_adbody() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdListRes::clear_has_adbody() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdListRes::clear_adbody() {
  if (adbody_ != NULL) adbody_->::pp::MessageBody::Clear();
  clear_has_adbody();
}
inline const ::pp::MessageBody& AdListRes::adbody() const {
  return adbody_ != NULL ? *adbody_ : *default_instance_->adbody_;
}
inline ::pp::MessageBody* AdListRes::mutable_adbody() {
  set_has_adbody();
  if (adbody_ == NULL) adbody_ = new ::pp::MessageBody;
  return adbody_;
}
inline ::pp::MessageBody* AdListRes::release_adbody() {
  clear_has_adbody();
  ::pp::MessageBody* temp = adbody_;
  adbody_ = NULL;
  return temp;
}
inline void AdListRes::set_allocated_adbody(::pp::MessageBody* adbody) {
  delete adbody_;
  adbody_ = adbody;
  if (adbody) {
    set_has_adbody();
  } else {
    clear_has_adbody();
  }
}

// repeated .pp.AdEntity entities = 3;
inline int AdListRes::entities_size() const {
  return entities_.size();
}
inline void AdListRes::clear_entities() {
  entities_.Clear();
}
inline const ::pp::AdEntity& AdListRes::entities(int index) const {
  return entities_.Get(index);
}
inline ::pp::AdEntity* AdListRes::mutable_entities(int index) {
  return entities_.Mutable(index);
}
inline ::pp::AdEntity* AdListRes::add_entities() {
  return entities_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::AdEntity >&
AdListRes::entities() const {
  return entities_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::AdEntity >*
AdListRes::mutable_entities() {
  return &entities_;
}

// -------------------------------------------------------------------

// AdEntity

// optional uint32 page = 1;
inline bool AdEntity::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdEntity::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdEntity::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdEntity::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 AdEntity::page() const {
  return page_;
}
inline void AdEntity::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// optional uint32 id = 2;
inline bool AdEntity::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdEntity::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdEntity::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdEntity::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AdEntity::id() const {
  return id_;
}
inline void AdEntity::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string url = 3;
inline bool AdEntity::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdEntity::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdEntity::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdEntity::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AdEntity::url() const {
  return *url_;
}
inline void AdEntity::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AdEntity::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AdEntity::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdEntity::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* AdEntity::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdEntity::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 4;
inline bool AdEntity::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdEntity::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdEntity::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdEntity::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& AdEntity::image() const {
  return *image_;
}
inline void AdEntity::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void AdEntity::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void AdEntity::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdEntity::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* AdEntity::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdEntity::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string FromStore = 5;
inline bool AdEntity::has_fromstore() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdEntity::set_has_fromstore() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdEntity::clear_has_fromstore() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdEntity::clear_fromstore() {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    fromstore_->clear();
  }
  clear_has_fromstore();
}
inline const ::std::string& AdEntity::fromstore() const {
  return *fromstore_;
}
inline void AdEntity::set_fromstore(const ::std::string& value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void AdEntity::set_fromstore(const char* value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void AdEntity::set_fromstore(const char* value, size_t size) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdEntity::mutable_fromstore() {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  return fromstore_;
}
inline ::std::string* AdEntity::release_fromstore() {
  clear_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromstore_;
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdEntity::set_allocated_fromstore(::std::string* fromstore) {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    delete fromstore_;
  }
  if (fromstore) {
    set_has_fromstore();
    fromstore_ = fromstore;
  } else {
    clear_has_fromstore();
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AdModifyReq

// required uint32 page = 1;
inline bool AdModifyReq::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdModifyReq::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdModifyReq::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdModifyReq::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 AdModifyReq::page() const {
  return page_;
}
inline void AdModifyReq::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// optional uint32 id = 2;
inline bool AdModifyReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdModifyReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdModifyReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdModifyReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AdModifyReq::id() const {
  return id_;
}
inline void AdModifyReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string url = 3;
inline bool AdModifyReq::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdModifyReq::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdModifyReq::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdModifyReq::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AdModifyReq::url() const {
  return *url_;
}
inline void AdModifyReq::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AdModifyReq::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AdModifyReq::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdModifyReq::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* AdModifyReq::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdModifyReq::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 4;
inline bool AdModifyReq::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdModifyReq::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdModifyReq::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdModifyReq::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& AdModifyReq::image() const {
  return *image_;
}
inline void AdModifyReq::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void AdModifyReq::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void AdModifyReq::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdModifyReq::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* AdModifyReq::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdModifyReq::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string FromStore = 5;
inline bool AdModifyReq::has_fromstore() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdModifyReq::set_has_fromstore() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdModifyReq::clear_has_fromstore() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdModifyReq::clear_fromstore() {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    fromstore_->clear();
  }
  clear_has_fromstore();
}
inline const ::std::string& AdModifyReq::fromstore() const {
  return *fromstore_;
}
inline void AdModifyReq::set_fromstore(const ::std::string& value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void AdModifyReq::set_fromstore(const char* value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void AdModifyReq::set_fromstore(const char* value, size_t size) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AdModifyReq::mutable_fromstore() {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  return fromstore_;
}
inline ::std::string* AdModifyReq::release_fromstore() {
  clear_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromstore_;
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AdModifyReq::set_allocated_fromstore(::std::string* fromstore) {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    delete fromstore_;
  }
  if (fromstore) {
    set_has_fromstore();
    fromstore_ = fromstore;
  } else {
    clear_has_fromstore();
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AdModifyRes

// -------------------------------------------------------------------

// AdRemoveReq

// required uint32 page = 1;
inline bool AdRemoveReq::has_page() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdRemoveReq::set_has_page() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdRemoveReq::clear_has_page() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdRemoveReq::clear_page() {
  page_ = 0u;
  clear_has_page();
}
inline ::google::protobuf::uint32 AdRemoveReq::page() const {
  return page_;
}
inline void AdRemoveReq::set_page(::google::protobuf::uint32 value) {
  set_has_page();
  page_ = value;
}

// optional uint32 id = 2;
inline bool AdRemoveReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdRemoveReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdRemoveReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdRemoveReq::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 AdRemoveReq::id() const {
  return id_;
}
inline void AdRemoveReq::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// AdRemoveRes

// -------------------------------------------------------------------

// UserForbidInfo

// optional string dev = 1;
inline bool UserForbidInfo::has_dev() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserForbidInfo::set_has_dev() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserForbidInfo::clear_has_dev() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserForbidInfo::clear_dev() {
  if (dev_ != &::google::protobuf::internal::kEmptyString) {
    dev_->clear();
  }
  clear_has_dev();
}
inline const ::std::string& UserForbidInfo::dev() const {
  return *dev_;
}
inline void UserForbidInfo::set_dev(const ::std::string& value) {
  set_has_dev();
  if (dev_ == &::google::protobuf::internal::kEmptyString) {
    dev_ = new ::std::string;
  }
  dev_->assign(value);
}
inline void UserForbidInfo::set_dev(const char* value) {
  set_has_dev();
  if (dev_ == &::google::protobuf::internal::kEmptyString) {
    dev_ = new ::std::string;
  }
  dev_->assign(value);
}
inline void UserForbidInfo::set_dev(const char* value, size_t size) {
  set_has_dev();
  if (dev_ == &::google::protobuf::internal::kEmptyString) {
    dev_ = new ::std::string;
  }
  dev_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserForbidInfo::mutable_dev() {
  set_has_dev();
  if (dev_ == &::google::protobuf::internal::kEmptyString) {
    dev_ = new ::std::string;
  }
  return dev_;
}
inline ::std::string* UserForbidInfo::release_dev() {
  clear_has_dev();
  if (dev_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dev_;
    dev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserForbidInfo::set_allocated_dev(::std::string* dev) {
  if (dev_ != &::google::protobuf::internal::kEmptyString) {
    delete dev_;
  }
  if (dev) {
    set_has_dev();
    dev_ = dev;
  } else {
    clear_has_dev();
    dev_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.ForbidDevType devType = 2;
inline bool UserForbidInfo::has_devtype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserForbidInfo::set_has_devtype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserForbidInfo::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserForbidInfo::clear_devtype() {
  devtype_ = 0;
  clear_has_devtype();
}
inline ::pp::ForbidDevType UserForbidInfo::devtype() const {
  return static_cast< ::pp::ForbidDevType >(devtype_);
}
inline void UserForbidInfo::set_devtype(::pp::ForbidDevType value) {
  assert(::pp::ForbidDevType_IsValid(value));
  set_has_devtype();
  devtype_ = value;
}

// optional .pp.ForbidStateType state = 3;
inline bool UserForbidInfo::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserForbidInfo::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserForbidInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserForbidInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::ForbidStateType UserForbidInfo::state() const {
  return static_cast< ::pp::ForbidStateType >(state_);
}
inline void UserForbidInfo::set_state(::pp::ForbidStateType value) {
  assert(::pp::ForbidStateType_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional int64 forbidtime = 4;
inline bool UserForbidInfo::has_forbidtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserForbidInfo::set_has_forbidtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserForbidInfo::clear_has_forbidtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserForbidInfo::clear_forbidtime() {
  forbidtime_ = GOOGLE_LONGLONG(0);
  clear_has_forbidtime();
}
inline ::google::protobuf::int64 UserForbidInfo::forbidtime() const {
  return forbidtime_;
}
inline void UserForbidInfo::set_forbidtime(::google::protobuf::int64 value) {
  set_has_forbidtime();
  forbidtime_ = value;
}

// optional int64 forbidsecond = 5;
inline bool UserForbidInfo::has_forbidsecond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserForbidInfo::set_has_forbidsecond() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserForbidInfo::clear_has_forbidsecond() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserForbidInfo::clear_forbidsecond() {
  forbidsecond_ = GOOGLE_LONGLONG(0);
  clear_has_forbidsecond();
}
inline ::google::protobuf::int64 UserForbidInfo::forbidsecond() const {
  return forbidsecond_;
}
inline void UserForbidInfo::set_forbidsecond(::google::protobuf::int64 value) {
  set_has_forbidsecond();
  forbidsecond_ = value;
}

// optional .pp.ForbidReasonType reasontype = 6;
inline bool UserForbidInfo::has_reasontype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserForbidInfo::set_has_reasontype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserForbidInfo::clear_has_reasontype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserForbidInfo::clear_reasontype() {
  reasontype_ = 0;
  clear_has_reasontype();
}
inline ::pp::ForbidReasonType UserForbidInfo::reasontype() const {
  return static_cast< ::pp::ForbidReasonType >(reasontype_);
}
inline void UserForbidInfo::set_reasontype(::pp::ForbidReasonType value) {
  assert(::pp::ForbidReasonType_IsValid(value));
  set_has_reasontype();
  reasontype_ = value;
}

// optional string reason = 7;
inline bool UserForbidInfo::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserForbidInfo::set_has_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserForbidInfo::clear_has_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserForbidInfo::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& UserForbidInfo::reason() const {
  return *reason_;
}
inline void UserForbidInfo::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void UserForbidInfo::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void UserForbidInfo::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserForbidInfo::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* UserForbidInfo::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserForbidInfo::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 opuid = 8;
inline bool UserForbidInfo::has_opuid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserForbidInfo::set_has_opuid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserForbidInfo::clear_has_opuid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserForbidInfo::clear_opuid() {
  opuid_ = GOOGLE_ULONGLONG(0);
  clear_has_opuid();
}
inline ::google::protobuf::uint64 UserForbidInfo::opuid() const {
  return opuid_;
}
inline void UserForbidInfo::set_opuid(::google::protobuf::uint64 value) {
  set_has_opuid();
  opuid_ = value;
}

// optional uint64 uid = 9;
inline bool UserForbidInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserForbidInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserForbidInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserForbidInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserForbidInfo::uid() const {
  return uid_;
}
inline void UserForbidInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// UserForbidOpReq

// optional .pp.UserForbidInfo forbidInfo = 1;
inline bool UserForbidOpReq::has_forbidinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserForbidOpReq::set_has_forbidinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserForbidOpReq::clear_has_forbidinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserForbidOpReq::clear_forbidinfo() {
  if (forbidinfo_ != NULL) forbidinfo_->::pp::UserForbidInfo::Clear();
  clear_has_forbidinfo();
}
inline const ::pp::UserForbidInfo& UserForbidOpReq::forbidinfo() const {
  return forbidinfo_ != NULL ? *forbidinfo_ : *default_instance_->forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidOpReq::mutable_forbidinfo() {
  set_has_forbidinfo();
  if (forbidinfo_ == NULL) forbidinfo_ = new ::pp::UserForbidInfo;
  return forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidOpReq::release_forbidinfo() {
  clear_has_forbidinfo();
  ::pp::UserForbidInfo* temp = forbidinfo_;
  forbidinfo_ = NULL;
  return temp;
}
inline void UserForbidOpReq::set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo) {
  delete forbidinfo_;
  forbidinfo_ = forbidinfo;
  if (forbidinfo) {
    set_has_forbidinfo();
  } else {
    clear_has_forbidinfo();
  }
}

// optional .pp.EntityOpType opType = 2;
inline bool UserForbidOpReq::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserForbidOpReq::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserForbidOpReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserForbidOpReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::EntityOpType UserForbidOpReq::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void UserForbidOpReq::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// UserForbidOpRes

// optional .pp.UserForbidInfo forbidInfo = 1;
inline bool UserForbidOpRes::has_forbidinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserForbidOpRes::set_has_forbidinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserForbidOpRes::clear_has_forbidinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserForbidOpRes::clear_forbidinfo() {
  if (forbidinfo_ != NULL) forbidinfo_->::pp::UserForbidInfo::Clear();
  clear_has_forbidinfo();
}
inline const ::pp::UserForbidInfo& UserForbidOpRes::forbidinfo() const {
  return forbidinfo_ != NULL ? *forbidinfo_ : *default_instance_->forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidOpRes::mutable_forbidinfo() {
  set_has_forbidinfo();
  if (forbidinfo_ == NULL) forbidinfo_ = new ::pp::UserForbidInfo;
  return forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidOpRes::release_forbidinfo() {
  clear_has_forbidinfo();
  ::pp::UserForbidInfo* temp = forbidinfo_;
  forbidinfo_ = NULL;
  return temp;
}
inline void UserForbidOpRes::set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo) {
  delete forbidinfo_;
  forbidinfo_ = forbidinfo;
  if (forbidinfo) {
    set_has_forbidinfo();
  } else {
    clear_has_forbidinfo();
  }
}

// optional .pp.EntityOpType opType = 2;
inline bool UserForbidOpRes::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserForbidOpRes::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserForbidOpRes::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserForbidOpRes::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::EntityOpType UserForbidOpRes::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void UserForbidOpRes::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// UserForbidSearchReq

// optional .pp.UserForbidInfo forbidInfo = 1;
inline bool UserForbidSearchReq::has_forbidinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserForbidSearchReq::set_has_forbidinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserForbidSearchReq::clear_has_forbidinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserForbidSearchReq::clear_forbidinfo() {
  if (forbidinfo_ != NULL) forbidinfo_->::pp::UserForbidInfo::Clear();
  clear_has_forbidinfo();
}
inline const ::pp::UserForbidInfo& UserForbidSearchReq::forbidinfo() const {
  return forbidinfo_ != NULL ? *forbidinfo_ : *default_instance_->forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidSearchReq::mutable_forbidinfo() {
  set_has_forbidinfo();
  if (forbidinfo_ == NULL) forbidinfo_ = new ::pp::UserForbidInfo;
  return forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidSearchReq::release_forbidinfo() {
  clear_has_forbidinfo();
  ::pp::UserForbidInfo* temp = forbidinfo_;
  forbidinfo_ = NULL;
  return temp;
}
inline void UserForbidSearchReq::set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo) {
  delete forbidinfo_;
  forbidinfo_ = forbidinfo;
  if (forbidinfo) {
    set_has_forbidinfo();
  } else {
    clear_has_forbidinfo();
  }
}

// optional .pp.ForbidSearchBy searchBy = 2;
inline bool UserForbidSearchReq::has_searchby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserForbidSearchReq::set_has_searchby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserForbidSearchReq::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserForbidSearchReq::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::ForbidSearchBy UserForbidSearchReq::searchby() const {
  return static_cast< ::pp::ForbidSearchBy >(searchby_);
}
inline void UserForbidSearchReq::set_searchby(::pp::ForbidSearchBy value) {
  assert(::pp::ForbidSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional uint32 index = 3;
inline bool UserForbidSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserForbidSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserForbidSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserForbidSearchReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserForbidSearchReq::index() const {
  return index_;
}
inline void UserForbidSearchReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 4;
inline bool UserForbidSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserForbidSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserForbidSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserForbidSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserForbidSearchReq::fetchs() const {
  return fetchs_;
}
inline void UserForbidSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// UserForbidSearchRes

// optional .pp.UserForbidInfo forbidInfo = 1;
inline bool UserForbidSearchRes::has_forbidinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserForbidSearchRes::set_has_forbidinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserForbidSearchRes::clear_has_forbidinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserForbidSearchRes::clear_forbidinfo() {
  if (forbidinfo_ != NULL) forbidinfo_->::pp::UserForbidInfo::Clear();
  clear_has_forbidinfo();
}
inline const ::pp::UserForbidInfo& UserForbidSearchRes::forbidinfo() const {
  return forbidinfo_ != NULL ? *forbidinfo_ : *default_instance_->forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidSearchRes::mutable_forbidinfo() {
  set_has_forbidinfo();
  if (forbidinfo_ == NULL) forbidinfo_ = new ::pp::UserForbidInfo;
  return forbidinfo_;
}
inline ::pp::UserForbidInfo* UserForbidSearchRes::release_forbidinfo() {
  clear_has_forbidinfo();
  ::pp::UserForbidInfo* temp = forbidinfo_;
  forbidinfo_ = NULL;
  return temp;
}
inline void UserForbidSearchRes::set_allocated_forbidinfo(::pp::UserForbidInfo* forbidinfo) {
  delete forbidinfo_;
  forbidinfo_ = forbidinfo;
  if (forbidinfo) {
    set_has_forbidinfo();
  } else {
    clear_has_forbidinfo();
  }
}

// optional .pp.ForbidSearchBy searchBy = 2;
inline bool UserForbidSearchRes::has_searchby() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserForbidSearchRes::set_has_searchby() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserForbidSearchRes::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserForbidSearchRes::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::ForbidSearchBy UserForbidSearchRes::searchby() const {
  return static_cast< ::pp::ForbidSearchBy >(searchby_);
}
inline void UserForbidSearchRes::set_searchby(::pp::ForbidSearchBy value) {
  assert(::pp::ForbidSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional uint32 index = 3;
inline bool UserForbidSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserForbidSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserForbidSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserForbidSearchRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserForbidSearchRes::index() const {
  return index_;
}
inline void UserForbidSearchRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 4;
inline bool UserForbidSearchRes::has_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserForbidSearchRes::set_has_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserForbidSearchRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserForbidSearchRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserForbidSearchRes::total() const {
  return total_;
}
inline void UserForbidSearchRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.UserForbidInfo forbids = 5;
inline int UserForbidSearchRes::forbids_size() const {
  return forbids_.size();
}
inline void UserForbidSearchRes::clear_forbids() {
  forbids_.Clear();
}
inline const ::pp::UserForbidInfo& UserForbidSearchRes::forbids(int index) const {
  return forbids_.Get(index);
}
inline ::pp::UserForbidInfo* UserForbidSearchRes::mutable_forbids(int index) {
  return forbids_.Mutable(index);
}
inline ::pp::UserForbidInfo* UserForbidSearchRes::add_forbids() {
  return forbids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserForbidInfo >&
UserForbidSearchRes::forbids() const {
  return forbids_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserForbidInfo >*
UserForbidSearchRes::mutable_forbids() {
  return &forbids_;
}

// -------------------------------------------------------------------

// PublicNumAddReq

// required uint64 uid = 1;
inline bool PublicNumAddReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PublicNumAddReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PublicNumAddReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PublicNumAddReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 PublicNumAddReq::uid() const {
  return uid_;
}
inline void PublicNumAddReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required .pp.UidRange uidRange = 2;
inline bool PublicNumAddReq::has_uidrange() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PublicNumAddReq::set_has_uidrange() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PublicNumAddReq::clear_has_uidrange() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PublicNumAddReq::clear_uidrange() {
  if (uidrange_ != NULL) uidrange_->::pp::UidRange::Clear();
  clear_has_uidrange();
}
inline const ::pp::UidRange& PublicNumAddReq::uidrange() const {
  return uidrange_ != NULL ? *uidrange_ : *default_instance_->uidrange_;
}
inline ::pp::UidRange* PublicNumAddReq::mutable_uidrange() {
  set_has_uidrange();
  if (uidrange_ == NULL) uidrange_ = new ::pp::UidRange;
  return uidrange_;
}
inline ::pp::UidRange* PublicNumAddReq::release_uidrange() {
  clear_has_uidrange();
  ::pp::UidRange* temp = uidrange_;
  uidrange_ = NULL;
  return temp;
}
inline void PublicNumAddReq::set_allocated_uidrange(::pp::UidRange* uidrange) {
  delete uidrange_;
  uidrange_ = uidrange;
  if (uidrange) {
    set_has_uidrange();
  } else {
    clear_has_uidrange();
  }
}

// optional uint32 remove = 3;
inline bool PublicNumAddReq::has_remove() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PublicNumAddReq::set_has_remove() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PublicNumAddReq::clear_has_remove() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PublicNumAddReq::clear_remove() {
  remove_ = 0u;
  clear_has_remove();
}
inline ::google::protobuf::uint32 PublicNumAddReq::remove() const {
  return remove_;
}
inline void PublicNumAddReq::set_remove(::google::protobuf::uint32 value) {
  set_has_remove();
  remove_ = value;
}

// -------------------------------------------------------------------

// IDCodeApplyReq

// optional uint64 id = 1;
inline bool IDCodeApplyReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IDCodeApplyReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IDCodeApplyReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IDCodeApplyReq::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 IDCodeApplyReq::id() const {
  return id_;
}
inline void IDCodeApplyReq::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// IDCodeApplyRes

// optional string code = 1;
inline bool IDCodeApplyRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IDCodeApplyRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IDCodeApplyRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IDCodeApplyRes::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& IDCodeApplyRes::code() const {
  return *code_;
}
inline void IDCodeApplyRes::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void IDCodeApplyRes::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void IDCodeApplyRes::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDCodeApplyRes::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* IDCodeApplyRes::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IDCodeApplyRes::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// IDReplaceReq

// optional uint64 old = 1;
inline bool IDReplaceReq::has_old() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IDReplaceReq::set_has_old() {
  _has_bits_[0] |= 0x00000001u;
}
inline void IDReplaceReq::clear_has_old() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void IDReplaceReq::clear_old() {
  old_ = GOOGLE_ULONGLONG(0);
  clear_has_old();
}
inline ::google::protobuf::uint64 IDReplaceReq::old() const {
  return old_;
}
inline void IDReplaceReq::set_old(::google::protobuf::uint64 value) {
  set_has_old();
  old_ = value;
}

// optional string code = 2;
inline bool IDReplaceReq::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IDReplaceReq::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void IDReplaceReq::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void IDReplaceReq::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& IDReplaceReq::code() const {
  return *code_;
}
inline void IDReplaceReq::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void IDReplaceReq::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void IDReplaceReq::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* IDReplaceReq::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* IDReplaceReq::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void IDReplaceReq::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserRoleModifyReq

// required uint64 uid = 1;
inline bool UserRoleModifyReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRoleModifyReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRoleModifyReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRoleModifyReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserRoleModifyReq::uid() const {
  return uid_;
}
inline void UserRoleModifyReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 roletype = 2;
inline bool UserRoleModifyReq::has_roletype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRoleModifyReq::set_has_roletype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRoleModifyReq::clear_has_roletype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRoleModifyReq::clear_roletype() {
  roletype_ = 0u;
  clear_has_roletype();
}
inline ::google::protobuf::uint32 UserRoleModifyReq::roletype() const {
  return roletype_;
}
inline void UserRoleModifyReq::set_roletype(::google::protobuf::uint32 value) {
  set_has_roletype();
  roletype_ = value;
}

// -------------------------------------------------------------------

// BackstageGidSidReq

// required uint32 index = 1;
inline bool BackstageGidSidReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackstageGidSidReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackstageGidSidReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackstageGidSidReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BackstageGidSidReq::index() const {
  return index_;
}
inline void BackstageGidSidReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool BackstageGidSidReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BackstageGidSidReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BackstageGidSidReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BackstageGidSidReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 BackstageGidSidReq::fetchs() const {
  return fetchs_;
}
inline void BackstageGidSidReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// BackstageGidSid

// required uint64 gid = 1;
inline bool BackstageGidSid::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackstageGidSid::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackstageGidSid::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackstageGidSid::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 BackstageGidSid::gid() const {
  return gid_;
}
inline void BackstageGidSid::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// required string name = 2;
inline bool BackstageGidSid::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BackstageGidSid::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BackstageGidSid::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BackstageGidSid::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BackstageGidSid::name() const {
  return *name_;
}
inline void BackstageGidSid::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BackstageGidSid::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BackstageGidSid::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackstageGidSid::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BackstageGidSid::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackstageGidSid::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 ownerId = 3;
inline bool BackstageGidSid::has_ownerid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BackstageGidSid::set_has_ownerid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BackstageGidSid::clear_has_ownerid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BackstageGidSid::clear_ownerid() {
  ownerid_ = GOOGLE_ULONGLONG(0);
  clear_has_ownerid();
}
inline ::google::protobuf::uint64 BackstageGidSid::ownerid() const {
  return ownerid_;
}
inline void BackstageGidSid::set_ownerid(::google::protobuf::uint64 value) {
  set_has_ownerid();
  ownerid_ = value;
}

// required string ownerName = 4;
inline bool BackstageGidSid::has_ownername() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BackstageGidSid::set_has_ownername() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BackstageGidSid::clear_has_ownername() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BackstageGidSid::clear_ownername() {
  if (ownername_ != &::google::protobuf::internal::kEmptyString) {
    ownername_->clear();
  }
  clear_has_ownername();
}
inline const ::std::string& BackstageGidSid::ownername() const {
  return *ownername_;
}
inline void BackstageGidSid::set_ownername(const ::std::string& value) {
  set_has_ownername();
  if (ownername_ == &::google::protobuf::internal::kEmptyString) {
    ownername_ = new ::std::string;
  }
  ownername_->assign(value);
}
inline void BackstageGidSid::set_ownername(const char* value) {
  set_has_ownername();
  if (ownername_ == &::google::protobuf::internal::kEmptyString) {
    ownername_ = new ::std::string;
  }
  ownername_->assign(value);
}
inline void BackstageGidSid::set_ownername(const char* value, size_t size) {
  set_has_ownername();
  if (ownername_ == &::google::protobuf::internal::kEmptyString) {
    ownername_ = new ::std::string;
  }
  ownername_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BackstageGidSid::mutable_ownername() {
  set_has_ownername();
  if (ownername_ == &::google::protobuf::internal::kEmptyString) {
    ownername_ = new ::std::string;
  }
  return ownername_;
}
inline ::std::string* BackstageGidSid::release_ownername() {
  clear_has_ownername();
  if (ownername_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ownername_;
    ownername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BackstageGidSid::set_allocated_ownername(::std::string* ownername) {
  if (ownername_ != &::google::protobuf::internal::kEmptyString) {
    delete ownername_;
  }
  if (ownername) {
    set_has_ownername();
    ownername_ = ownername;
  } else {
    clear_has_ownername();
    ownername_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 sid = 5;
inline bool BackstageGidSid::has_sid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BackstageGidSid::set_has_sid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BackstageGidSid::clear_has_sid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BackstageGidSid::clear_sid() {
  sid_ = GOOGLE_ULONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::uint64 BackstageGidSid::sid() const {
  return sid_;
}
inline void BackstageGidSid::set_sid(::google::protobuf::uint64 value) {
  set_has_sid();
  sid_ = value;
}

// -------------------------------------------------------------------

// BackstageGidSidRes

// required uint32 index = 1;
inline bool BackstageGidSidRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BackstageGidSidRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BackstageGidSidRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BackstageGidSidRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BackstageGidSidRes::index() const {
  return index_;
}
inline void BackstageGidSidRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool BackstageGidSidRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BackstageGidSidRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BackstageGidSidRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BackstageGidSidRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 BackstageGidSidRes::fetchs() const {
  return fetchs_;
}
inline void BackstageGidSidRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// repeated .pp.BackstageGidSid gidSidList = 3;
inline int BackstageGidSidRes::gidsidlist_size() const {
  return gidsidlist_.size();
}
inline void BackstageGidSidRes::clear_gidsidlist() {
  gidsidlist_.Clear();
}
inline const ::pp::BackstageGidSid& BackstageGidSidRes::gidsidlist(int index) const {
  return gidsidlist_.Get(index);
}
inline ::pp::BackstageGidSid* BackstageGidSidRes::mutable_gidsidlist(int index) {
  return gidsidlist_.Mutable(index);
}
inline ::pp::BackstageGidSid* BackstageGidSidRes::add_gidsidlist() {
  return gidsidlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::BackstageGidSid >&
BackstageGidSidRes::gidsidlist() const {
  return gidsidlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::BackstageGidSid >*
BackstageGidSidRes::mutable_gidsidlist() {
  return &gidsidlist_;
}

// -------------------------------------------------------------------

// GroupStatInfo

// optional uint32 msgcount = 1;
inline bool GroupStatInfo::has_msgcount() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupStatInfo::set_has_msgcount() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupStatInfo::clear_has_msgcount() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupStatInfo::clear_msgcount() {
  msgcount_ = 0u;
  clear_has_msgcount();
}
inline ::google::protobuf::uint32 GroupStatInfo::msgcount() const {
  return msgcount_;
}
inline void GroupStatInfo::set_msgcount(::google::protobuf::uint32 value) {
  set_has_msgcount();
  msgcount_ = value;
}

// optional uint32 loginusers = 2;
inline bool GroupStatInfo::has_loginusers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupStatInfo::set_has_loginusers() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupStatInfo::clear_has_loginusers() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupStatInfo::clear_loginusers() {
  loginusers_ = 0u;
  clear_has_loginusers();
}
inline ::google::protobuf::uint32 GroupStatInfo::loginusers() const {
  return loginusers_;
}
inline void GroupStatInfo::set_loginusers(::google::protobuf::uint32 value) {
  set_has_loginusers();
  loginusers_ = value;
}

// optional uint32 loginmacids = 3;
inline bool GroupStatInfo::has_loginmacids() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupStatInfo::set_has_loginmacids() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupStatInfo::clear_has_loginmacids() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupStatInfo::clear_loginmacids() {
  loginmacids_ = 0u;
  clear_has_loginmacids();
}
inline ::google::protobuf::uint32 GroupStatInfo::loginmacids() const {
  return loginmacids_;
}
inline void GroupStatInfo::set_loginmacids(::google::protobuf::uint32 value) {
  set_has_loginmacids();
  loginmacids_ = value;
}

// optional uint32 signcount = 4;
inline bool GroupStatInfo::has_signcount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupStatInfo::set_has_signcount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupStatInfo::clear_has_signcount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupStatInfo::clear_signcount() {
  signcount_ = 0u;
  clear_has_signcount();
}
inline ::google::protobuf::uint32 GroupStatInfo::signcount() const {
  return signcount_;
}
inline void GroupStatInfo::set_signcount(::google::protobuf::uint32 value) {
  set_has_signcount();
  signcount_ = value;
}

// optional uint64 coins = 5;
inline bool GroupStatInfo::has_coins() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupStatInfo::set_has_coins() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupStatInfo::clear_has_coins() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupStatInfo::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 GroupStatInfo::coins() const {
  return coins_;
}
inline void GroupStatInfo::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint64 inccoins = 6;
inline bool GroupStatInfo::has_inccoins() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupStatInfo::set_has_inccoins() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupStatInfo::clear_has_inccoins() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupStatInfo::clear_inccoins() {
  inccoins_ = GOOGLE_ULONGLONG(0);
  clear_has_inccoins();
}
inline ::google::protobuf::uint64 GroupStatInfo::inccoins() const {
  return inccoins_;
}
inline void GroupStatInfo::set_inccoins(::google::protobuf::uint64 value) {
  set_has_inccoins();
  inccoins_ = value;
}

// optional uint32 hot = 9;
inline bool GroupStatInfo::has_hot() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupStatInfo::set_has_hot() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupStatInfo::clear_has_hot() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupStatInfo::clear_hot() {
  hot_ = 0u;
  clear_has_hot();
}
inline ::google::protobuf::uint32 GroupStatInfo::hot() const {
  return hot_;
}
inline void GroupStatInfo::set_hot(::google::protobuf::uint32 value) {
  set_has_hot();
  hot_ = value;
}

// -------------------------------------------------------------------

// GroupTag

// optional uint32 id = 1;
inline bool GroupTag::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupTag::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupTag::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupTag::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 GroupTag::id() const {
  return id_;
}
inline void GroupTag::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string title = 2;
inline bool GroupTag::has_title() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupTag::set_has_title() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupTag::clear_has_title() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupTag::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& GroupTag::title() const {
  return *title_;
}
inline void GroupTag::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void GroupTag::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void GroupTag::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupTag::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* GroupTag::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupTag::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 3;
inline bool GroupTag::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupTag::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupTag::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupTag::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& GroupTag::desc() const {
  return *desc_;
}
inline void GroupTag::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GroupTag::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void GroupTag::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupTag::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* GroupTag::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupTag::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 color = 4;
inline bool GroupTag::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupTag::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupTag::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupTag::clear_color() {
  color_ = 0u;
  clear_has_color();
}
inline ::google::protobuf::uint32 GroupTag::color() const {
  return color_;
}
inline void GroupTag::set_color(::google::protobuf::uint32 value) {
  set_has_color();
  color_ = value;
}

// -------------------------------------------------------------------

// GroupTags

// repeated .pp.GroupTag items = 1;
inline int GroupTags::items_size() const {
  return items_.size();
}
inline void GroupTags::clear_items() {
  items_.Clear();
}
inline const ::pp::GroupTag& GroupTags::items(int index) const {
  return items_.Get(index);
}
inline ::pp::GroupTag* GroupTags::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::GroupTag* GroupTags::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupTag >&
GroupTags::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupTag >*
GroupTags::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// UserInfoBrief

// optional uint64 uid = 1;
inline bool UserInfoBrief::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoBrief::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoBrief::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoBrief::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserInfoBrief::uid() const {
  return uid_;
}
inline void UserInfoBrief::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string nick = 2;
inline bool UserInfoBrief::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoBrief::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoBrief::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoBrief::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UserInfoBrief::nick() const {
  return *nick_;
}
inline void UserInfoBrief::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfoBrief::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfoBrief::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBrief::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* UserInfoBrief::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBrief::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signature = 3;
inline bool UserInfoBrief::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoBrief::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoBrief::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoBrief::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& UserInfoBrief::signature() const {
  return *signature_;
}
inline void UserInfoBrief::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void UserInfoBrief::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void UserInfoBrief::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBrief::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* UserInfoBrief::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBrief::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string logourl = 4;
inline bool UserInfoBrief::has_logourl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoBrief::set_has_logourl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoBrief::clear_has_logourl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoBrief::clear_logourl() {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    logourl_->clear();
  }
  clear_has_logourl();
}
inline const ::std::string& UserInfoBrief::logourl() const {
  return *logourl_;
}
inline void UserInfoBrief::set_logourl(const ::std::string& value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void UserInfoBrief::set_logourl(const char* value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void UserInfoBrief::set_logourl(const char* value, size_t size) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBrief::mutable_logourl() {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  return logourl_;
}
inline ::std::string* UserInfoBrief::release_logourl() {
  clear_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logourl_;
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBrief::set_allocated_logourl(::std::string* logourl) {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    delete logourl_;
  }
  if (logourl) {
    set_has_logourl();
    logourl_ = logourl;
  } else {
    clear_has_logourl();
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.SexType sex = 5;
inline bool UserInfoBrief::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfoBrief::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfoBrief::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfoBrief::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::pp::SexType UserInfoBrief::sex() const {
  return static_cast< ::pp::SexType >(sex_);
}
inline void UserInfoBrief::set_sex(::pp::SexType value) {
  assert(::pp::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// optional string location = 8;
inline bool UserInfoBrief::has_location() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfoBrief::set_has_location() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfoBrief::clear_has_location() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfoBrief::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& UserInfoBrief::location() const {
  return *location_;
}
inline void UserInfoBrief::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserInfoBrief::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserInfoBrief::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBrief::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* UserInfoBrief::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBrief::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 9;
inline bool UserInfoBrief::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfoBrief::set_has_address() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfoBrief::clear_has_address() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfoBrief::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserInfoBrief::address() const {
  return *address_;
}
inline void UserInfoBrief::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserInfoBrief::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserInfoBrief::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoBrief::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserInfoBrief::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoBrief::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserFamily family = 11;
inline bool UserInfoBrief::has_family() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfoBrief::set_has_family() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfoBrief::clear_has_family() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfoBrief::clear_family() {
  if (family_ != NULL) family_->::pp::UserFamily::Clear();
  clear_has_family();
}
inline const ::pp::UserFamily& UserInfoBrief::family() const {
  return family_ != NULL ? *family_ : *default_instance_->family_;
}
inline ::pp::UserFamily* UserInfoBrief::mutable_family() {
  set_has_family();
  if (family_ == NULL) family_ = new ::pp::UserFamily;
  return family_;
}
inline ::pp::UserFamily* UserInfoBrief::release_family() {
  clear_has_family();
  ::pp::UserFamily* temp = family_;
  family_ = NULL;
  return temp;
}
inline void UserInfoBrief::set_allocated_family(::pp::UserFamily* family) {
  delete family_;
  family_ = family;
  if (family) {
    set_has_family();
  } else {
    clear_has_family();
  }
}

// optional .pp.ContactState contactState = 12;
inline bool UserInfoBrief::has_contactstate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfoBrief::set_has_contactstate() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfoBrief::clear_has_contactstate() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfoBrief::clear_contactstate() {
  contactstate_ = 0;
  clear_has_contactstate();
}
inline ::pp::ContactState UserInfoBrief::contactstate() const {
  return static_cast< ::pp::ContactState >(contactstate_);
}
inline void UserInfoBrief::set_contactstate(::pp::ContactState value) {
  assert(::pp::ContactState_IsValid(value));
  set_has_contactstate();
  contactstate_ = value;
}

// -------------------------------------------------------------------

// ExtComment

// required uint64 uid = 1;
inline bool ExtComment::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtComment::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtComment::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtComment::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ExtComment::uid() const {
  return uid_;
}
inline void ExtComment::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string message = 2;
inline bool ExtComment::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtComment::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtComment::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtComment::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& ExtComment::message() const {
  return *message_;
}
inline void ExtComment::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ExtComment::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void ExtComment::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExtComment::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* ExtComment::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExtComment::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 timestamp = 3;
inline bool ExtComment::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtComment::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtComment::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtComment::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ExtComment::timestamp() const {
  return timestamp_;
}
inline void ExtComment::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// ExtProps

// optional uint64 revision = 1;
inline bool ExtProps::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtProps::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExtProps::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExtProps::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 ExtProps::revision() const {
  return revision_;
}
inline void ExtProps::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional bool deleted = 2;
inline bool ExtProps::has_deleted() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtProps::set_has_deleted() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExtProps::clear_has_deleted() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExtProps::clear_deleted() {
  deleted_ = false;
  clear_has_deleted();
}
inline bool ExtProps::deleted() const {
  return deleted_;
}
inline void ExtProps::set_deleted(bool value) {
  set_has_deleted();
  deleted_ = value;
}

// optional uint32 consentCount = 3;
inline bool ExtProps::has_consentcount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtProps::set_has_consentcount() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExtProps::clear_has_consentcount() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExtProps::clear_consentcount() {
  consentcount_ = 0u;
  clear_has_consentcount();
}
inline ::google::protobuf::uint32 ExtProps::consentcount() const {
  return consentcount_;
}
inline void ExtProps::set_consentcount(::google::protobuf::uint32 value) {
  set_has_consentcount();
  consentcount_ = value;
}

// repeated uint64 consentUids = 4;
inline int ExtProps::consentuids_size() const {
  return consentuids_.size();
}
inline void ExtProps::clear_consentuids() {
  consentuids_.Clear();
}
inline ::google::protobuf::uint64 ExtProps::consentuids(int index) const {
  return consentuids_.Get(index);
}
inline void ExtProps::set_consentuids(int index, ::google::protobuf::uint64 value) {
  consentuids_.Set(index, value);
}
inline void ExtProps::add_consentuids(::google::protobuf::uint64 value) {
  consentuids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ExtProps::consentuids() const {
  return consentuids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ExtProps::mutable_consentuids() {
  return &consentuids_;
}

// optional uint32 dissentCount = 5;
inline bool ExtProps::has_dissentcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtProps::set_has_dissentcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExtProps::clear_has_dissentcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExtProps::clear_dissentcount() {
  dissentcount_ = 0u;
  clear_has_dissentcount();
}
inline ::google::protobuf::uint32 ExtProps::dissentcount() const {
  return dissentcount_;
}
inline void ExtProps::set_dissentcount(::google::protobuf::uint32 value) {
  set_has_dissentcount();
  dissentcount_ = value;
}

// repeated uint64 dissentUids = 6;
inline int ExtProps::dissentuids_size() const {
  return dissentuids_.size();
}
inline void ExtProps::clear_dissentuids() {
  dissentuids_.Clear();
}
inline ::google::protobuf::uint64 ExtProps::dissentuids(int index) const {
  return dissentuids_.Get(index);
}
inline void ExtProps::set_dissentuids(int index, ::google::protobuf::uint64 value) {
  dissentuids_.Set(index, value);
}
inline void ExtProps::add_dissentuids(::google::protobuf::uint64 value) {
  dissentuids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ExtProps::dissentuids() const {
  return dissentuids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ExtProps::mutable_dissentuids() {
  return &dissentuids_;
}

// optional uint32 commentCount = 7;
inline bool ExtProps::has_commentcount() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtProps::set_has_commentcount() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ExtProps::clear_has_commentcount() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ExtProps::clear_commentcount() {
  commentcount_ = 0u;
  clear_has_commentcount();
}
inline ::google::protobuf::uint32 ExtProps::commentcount() const {
  return commentcount_;
}
inline void ExtProps::set_commentcount(::google::protobuf::uint32 value) {
  set_has_commentcount();
  commentcount_ = value;
}

// repeated .pp.ExtComment comments = 8;
inline int ExtProps::comments_size() const {
  return comments_.size();
}
inline void ExtProps::clear_comments() {
  comments_.Clear();
}
inline const ::pp::ExtComment& ExtProps::comments(int index) const {
  return comments_.Get(index);
}
inline ::pp::ExtComment* ExtProps::mutable_comments(int index) {
  return comments_.Mutable(index);
}
inline ::pp::ExtComment* ExtProps::add_comments() {
  return comments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ExtComment >&
ExtProps::comments() const {
  return comments_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ExtComment >*
ExtProps::mutable_comments() {
  return &comments_;
}

// optional uint32 hitCount = 9;
inline bool ExtProps::has_hitcount() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ExtProps::set_has_hitcount() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ExtProps::clear_has_hitcount() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ExtProps::clear_hitcount() {
  hitcount_ = 0u;
  clear_has_hitcount();
}
inline ::google::protobuf::uint32 ExtProps::hitcount() const {
  return hitcount_;
}
inline void ExtProps::set_hitcount(::google::protobuf::uint32 value) {
  set_has_hitcount();
  hitcount_ = value;
}

// -------------------------------------------------------------------

// UserFamily

// repeated .pp.GroupInfo families = 1;
inline int UserFamily::families_size() const {
  return families_.size();
}
inline void UserFamily::clear_families() {
  families_.Clear();
}
inline const ::pp::GroupInfo& UserFamily::families(int index) const {
  return families_.Get(index);
}
inline ::pp::GroupInfo* UserFamily::mutable_families(int index) {
  return families_.Mutable(index);
}
inline ::pp::GroupInfo* UserFamily::add_families() {
  return families_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
UserFamily::families() const {
  return families_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
UserFamily::mutable_families() {
  return &families_;
}

// -------------------------------------------------------------------

// UserStamp

// optional uint64 fromUid = 1;
inline bool UserStamp::has_fromuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStamp::set_has_fromuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStamp::clear_has_fromuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStamp::clear_fromuid() {
  fromuid_ = GOOGLE_ULONGLONG(0);
  clear_has_fromuid();
}
inline ::google::protobuf::uint64 UserStamp::fromuid() const {
  return fromuid_;
}
inline void UserStamp::set_fromuid(::google::protobuf::uint64 value) {
  set_has_fromuid();
  fromuid_ = value;
}

// optional uint32 itemId = 2;
inline bool UserStamp::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStamp::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStamp::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStamp::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 UserStamp::itemid() const {
  return itemid_;
}
inline void UserStamp::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional sint64 updated = 3;
inline bool UserStamp::has_updated() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStamp::set_has_updated() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStamp::clear_has_updated() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStamp::clear_updated() {
  updated_ = GOOGLE_LONGLONG(0);
  clear_has_updated();
}
inline ::google::protobuf::int64 UserStamp::updated() const {
  return updated_;
}
inline void UserStamp::set_updated(::google::protobuf::int64 value) {
  set_has_updated();
  updated_ = value;
}

// -------------------------------------------------------------------

// UserInfoProp

// optional string hometown = 10;
inline bool UserInfoProp::has_hometown() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoProp::set_has_hometown() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoProp::clear_has_hometown() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoProp::clear_hometown() {
  if (hometown_ != &::google::protobuf::internal::kEmptyString) {
    hometown_->clear();
  }
  clear_has_hometown();
}
inline const ::std::string& UserInfoProp::hometown() const {
  return *hometown_;
}
inline void UserInfoProp::set_hometown(const ::std::string& value) {
  set_has_hometown();
  if (hometown_ == &::google::protobuf::internal::kEmptyString) {
    hometown_ = new ::std::string;
  }
  hometown_->assign(value);
}
inline void UserInfoProp::set_hometown(const char* value) {
  set_has_hometown();
  if (hometown_ == &::google::protobuf::internal::kEmptyString) {
    hometown_ = new ::std::string;
  }
  hometown_->assign(value);
}
inline void UserInfoProp::set_hometown(const char* value, size_t size) {
  set_has_hometown();
  if (hometown_ == &::google::protobuf::internal::kEmptyString) {
    hometown_ = new ::std::string;
  }
  hometown_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoProp::mutable_hometown() {
  set_has_hometown();
  if (hometown_ == &::google::protobuf::internal::kEmptyString) {
    hometown_ = new ::std::string;
  }
  return hometown_;
}
inline ::std::string* UserInfoProp::release_hometown() {
  clear_has_hometown();
  if (hometown_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hometown_;
    hometown_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoProp::set_allocated_hometown(::std::string* hometown) {
  if (hometown_ != &::google::protobuf::internal::kEmptyString) {
    delete hometown_;
  }
  if (hometown) {
    set_has_hometown();
    hometown_ = hometown;
  } else {
    clear_has_hometown();
    hometown_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string interest = 11;
inline bool UserInfoProp::has_interest() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoProp::set_has_interest() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoProp::clear_has_interest() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoProp::clear_interest() {
  if (interest_ != &::google::protobuf::internal::kEmptyString) {
    interest_->clear();
  }
  clear_has_interest();
}
inline const ::std::string& UserInfoProp::interest() const {
  return *interest_;
}
inline void UserInfoProp::set_interest(const ::std::string& value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
}
inline void UserInfoProp::set_interest(const char* value) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  interest_->assign(value);
}
inline void UserInfoProp::set_interest(const char* value, size_t size) {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  interest_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoProp::mutable_interest() {
  set_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    interest_ = new ::std::string;
  }
  return interest_;
}
inline ::std::string* UserInfoProp::release_interest() {
  clear_has_interest();
  if (interest_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = interest_;
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoProp::set_allocated_interest(::std::string* interest) {
  if (interest_ != &::google::protobuf::internal::kEmptyString) {
    delete interest_;
  }
  if (interest) {
    set_has_interest();
    interest_ = interest;
  } else {
    clear_has_interest();
    interest_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string games = 12;
inline bool UserInfoProp::has_games() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoProp::set_has_games() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoProp::clear_has_games() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoProp::clear_games() {
  if (games_ != &::google::protobuf::internal::kEmptyString) {
    games_->clear();
  }
  clear_has_games();
}
inline const ::std::string& UserInfoProp::games() const {
  return *games_;
}
inline void UserInfoProp::set_games(const ::std::string& value) {
  set_has_games();
  if (games_ == &::google::protobuf::internal::kEmptyString) {
    games_ = new ::std::string;
  }
  games_->assign(value);
}
inline void UserInfoProp::set_games(const char* value) {
  set_has_games();
  if (games_ == &::google::protobuf::internal::kEmptyString) {
    games_ = new ::std::string;
  }
  games_->assign(value);
}
inline void UserInfoProp::set_games(const char* value, size_t size) {
  set_has_games();
  if (games_ == &::google::protobuf::internal::kEmptyString) {
    games_ = new ::std::string;
  }
  games_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoProp::mutable_games() {
  set_has_games();
  if (games_ == &::google::protobuf::internal::kEmptyString) {
    games_ = new ::std::string;
  }
  return games_;
}
inline ::std::string* UserInfoProp::release_games() {
  clear_has_games();
  if (games_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = games_;
    games_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoProp::set_allocated_games(::std::string* games) {
  if (games_ != &::google::protobuf::internal::kEmptyString) {
    delete games_;
  }
  if (games) {
    set_has_games();
    games_ = games;
  } else {
    clear_has_games();
    games_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserStamp stamp = 13;
inline bool UserInfoProp::has_stamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoProp::set_has_stamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoProp::clear_has_stamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoProp::clear_stamp() {
  if (stamp_ != NULL) stamp_->::pp::UserStamp::Clear();
  clear_has_stamp();
}
inline const ::pp::UserStamp& UserInfoProp::stamp() const {
  return stamp_ != NULL ? *stamp_ : *default_instance_->stamp_;
}
inline ::pp::UserStamp* UserInfoProp::mutable_stamp() {
  set_has_stamp();
  if (stamp_ == NULL) stamp_ = new ::pp::UserStamp;
  return stamp_;
}
inline ::pp::UserStamp* UserInfoProp::release_stamp() {
  clear_has_stamp();
  ::pp::UserStamp* temp = stamp_;
  stamp_ = NULL;
  return temp;
}
inline void UserInfoProp::set_allocated_stamp(::pp::UserStamp* stamp) {
  delete stamp_;
  stamp_ = stamp;
  if (stamp) {
    set_has_stamp();
  } else {
    clear_has_stamp();
  }
}

// -------------------------------------------------------------------

// UserActiveData

// optional uint64 uid = 1;
inline bool UserActiveData::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserActiveData::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserActiveData::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserActiveData::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserActiveData::uid() const {
  return uid_;
}
inline void UserActiveData::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 coins = 2;
inline bool UserActiveData::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserActiveData::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserActiveData::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserActiveData::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 UserActiveData::coins() const {
  return coins_;
}
inline void UserActiveData::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint32 passion = 3;
inline bool UserActiveData::has_passion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserActiveData::set_has_passion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserActiveData::clear_has_passion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserActiveData::clear_passion() {
  passion_ = 0u;
  clear_has_passion();
}
inline ::google::protobuf::uint32 UserActiveData::passion() const {
  return passion_;
}
inline void UserActiveData::set_passion(::google::protobuf::uint32 value) {
  set_has_passion();
  passion_ = value;
}

// optional uint32 level = 4;
inline bool UserActiveData::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserActiveData::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserActiveData::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserActiveData::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 UserActiveData::level() const {
  return level_;
}
inline void UserActiveData::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional uint32 nextPassion = 10;
inline bool UserActiveData::has_nextpassion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserActiveData::set_has_nextpassion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserActiveData::clear_has_nextpassion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserActiveData::clear_nextpassion() {
  nextpassion_ = 0u;
  clear_has_nextpassion();
}
inline ::google::protobuf::uint32 UserActiveData::nextpassion() const {
  return nextpassion_;
}
inline void UserActiveData::set_nextpassion(::google::protobuf::uint32 value) {
  set_has_nextpassion();
  nextpassion_ = value;
}

// optional uint32 broadcastTimes = 11;
inline bool UserActiveData::has_broadcasttimes() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserActiveData::set_has_broadcasttimes() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserActiveData::clear_has_broadcasttimes() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserActiveData::clear_broadcasttimes() {
  broadcasttimes_ = 0u;
  clear_has_broadcasttimes();
}
inline ::google::protobuf::uint32 UserActiveData::broadcasttimes() const {
  return broadcasttimes_;
}
inline void UserActiveData::set_broadcasttimes(::google::protobuf::uint32 value) {
  set_has_broadcasttimes();
  broadcasttimes_ = value;
}

// optional uint32 broadcastMaxTimes = 12;
inline bool UserActiveData::has_broadcastmaxtimes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserActiveData::set_has_broadcastmaxtimes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserActiveData::clear_has_broadcastmaxtimes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserActiveData::clear_broadcastmaxtimes() {
  broadcastmaxtimes_ = 0u;
  clear_has_broadcastmaxtimes();
}
inline ::google::protobuf::uint32 UserActiveData::broadcastmaxtimes() const {
  return broadcastmaxtimes_;
}
inline void UserActiveData::set_broadcastmaxtimes(::google::protobuf::uint32 value) {
  set_has_broadcastmaxtimes();
  broadcastmaxtimes_ = value;
}

// -------------------------------------------------------------------

// GameInfo

// required uint32 gameid = 1;
inline bool GameInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameInfo::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameInfo::gameid() const {
  return gameid_;
}
inline void GameInfo::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional string name = 2;
inline bool GameInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GameInfo::name() const {
  return *name_;
}
inline void GameInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GameInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GameInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GameInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string icon = 3;
inline bool GameInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& GameInfo::icon() const {
  return *icon_;
}
inline void GameInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void GameInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void GameInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* GameInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string intro = 4;
inline bool GameInfo::has_intro() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameInfo::set_has_intro() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameInfo::clear_has_intro() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameInfo::clear_intro() {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    intro_->clear();
  }
  clear_has_intro();
}
inline const ::std::string& GameInfo::intro() const {
  return *intro_;
}
inline void GameInfo::set_intro(const ::std::string& value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void GameInfo::set_intro(const char* value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void GameInfo::set_intro(const char* value, size_t size) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_intro() {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  return intro_;
}
inline ::std::string* GameInfo::release_intro() {
  clear_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intro_;
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_intro(::std::string* intro) {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    delete intro_;
  }
  if (intro) {
    set_has_intro();
    intro_ = intro;
  } else {
    clear_has_intro();
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string packname = 5;
inline bool GameInfo::has_packname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameInfo::set_has_packname() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameInfo::clear_has_packname() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameInfo::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& GameInfo::packname() const {
  return *packname_;
}
inline void GameInfo::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void GameInfo::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void GameInfo::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* GameInfo::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extjson = 6;
inline bool GameInfo::has_extjson() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameInfo::set_has_extjson() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameInfo::clear_has_extjson() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameInfo::clear_extjson() {
  if (extjson_ != &::google::protobuf::internal::kEmptyString) {
    extjson_->clear();
  }
  clear_has_extjson();
}
inline const ::std::string& GameInfo::extjson() const {
  return *extjson_;
}
inline void GameInfo::set_extjson(const ::std::string& value) {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  extjson_->assign(value);
}
inline void GameInfo::set_extjson(const char* value) {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  extjson_->assign(value);
}
inline void GameInfo::set_extjson(const char* value, size_t size) {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  extjson_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_extjson() {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  return extjson_;
}
inline ::std::string* GameInfo::release_extjson() {
  clear_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extjson_;
    extjson_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_extjson(::std::string* extjson) {
  if (extjson_ != &::google::protobuf::internal::kEmptyString) {
    delete extjson_;
  }
  if (extjson) {
    set_has_extjson();
    extjson_ = extjson;
  } else {
    clear_has_extjson();
    extjson_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string component = 7;
inline bool GameInfo::has_component() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameInfo::set_has_component() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameInfo::clear_has_component() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameInfo::clear_component() {
  if (component_ != &::google::protobuf::internal::kEmptyString) {
    component_->clear();
  }
  clear_has_component();
}
inline const ::std::string& GameInfo::component() const {
  return *component_;
}
inline void GameInfo::set_component(const ::std::string& value) {
  set_has_component();
  if (component_ == &::google::protobuf::internal::kEmptyString) {
    component_ = new ::std::string;
  }
  component_->assign(value);
}
inline void GameInfo::set_component(const char* value) {
  set_has_component();
  if (component_ == &::google::protobuf::internal::kEmptyString) {
    component_ = new ::std::string;
  }
  component_->assign(value);
}
inline void GameInfo::set_component(const char* value, size_t size) {
  set_has_component();
  if (component_ == &::google::protobuf::internal::kEmptyString) {
    component_ = new ::std::string;
  }
  component_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_component() {
  set_has_component();
  if (component_ == &::google::protobuf::internal::kEmptyString) {
    component_ = new ::std::string;
  }
  return component_;
}
inline ::std::string* GameInfo::release_component() {
  clear_has_component();
  if (component_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = component_;
    component_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_component(::std::string* component) {
  if (component_ != &::google::protobuf::internal::kEmptyString) {
    delete component_;
  }
  if (component) {
    set_has_component();
    component_ = component;
  } else {
    clear_has_component();
    component_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 usercount = 8;
inline bool GameInfo::has_usercount() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameInfo::set_has_usercount() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameInfo::clear_has_usercount() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameInfo::clear_usercount() {
  usercount_ = 0u;
  clear_has_usercount();
}
inline ::google::protobuf::uint32 GameInfo::usercount() const {
  return usercount_;
}
inline void GameInfo::set_usercount(::google::protobuf::uint32 value) {
  set_has_usercount();
  usercount_ = value;
}

// optional uint32 giftLeftNum = 9;
inline bool GameInfo::has_giftleftnum() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GameInfo::set_has_giftleftnum() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GameInfo::clear_has_giftleftnum() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GameInfo::clear_giftleftnum() {
  giftleftnum_ = 0u;
  clear_has_giftleftnum();
}
inline ::google::protobuf::uint32 GameInfo::giftleftnum() const {
  return giftleftnum_;
}
inline void GameInfo::set_giftleftnum(::google::protobuf::uint32 value) {
  set_has_giftleftnum();
  giftleftnum_ = value;
}

// optional uint32 groupCount = 10;
inline bool GameInfo::has_groupcount() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GameInfo::set_has_groupcount() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GameInfo::clear_has_groupcount() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GameInfo::clear_groupcount() {
  groupcount_ = 0u;
  clear_has_groupcount();
}
inline ::google::protobuf::uint32 GameInfo::groupcount() const {
  return groupcount_;
}
inline void GameInfo::set_groupcount(::google::protobuf::uint32 value) {
  set_has_groupcount();
  groupcount_ = value;
}

// optional uint64 apkSize = 11;
inline bool GameInfo::has_apksize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GameInfo::set_has_apksize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GameInfo::clear_has_apksize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GameInfo::clear_apksize() {
  apksize_ = GOOGLE_ULONGLONG(0);
  clear_has_apksize();
}
inline ::google::protobuf::uint64 GameInfo::apksize() const {
  return apksize_;
}
inline void GameInfo::set_apksize(::google::protobuf::uint64 value) {
  set_has_apksize();
  apksize_ = value;
}

// optional string apkUrl = 12;
inline bool GameInfo::has_apkurl() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GameInfo::set_has_apkurl() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GameInfo::clear_has_apkurl() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GameInfo::clear_apkurl() {
  if (apkurl_ != &::google::protobuf::internal::kEmptyString) {
    apkurl_->clear();
  }
  clear_has_apkurl();
}
inline const ::std::string& GameInfo::apkurl() const {
  return *apkurl_;
}
inline void GameInfo::set_apkurl(const ::std::string& value) {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  apkurl_->assign(value);
}
inline void GameInfo::set_apkurl(const char* value) {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  apkurl_->assign(value);
}
inline void GameInfo::set_apkurl(const char* value, size_t size) {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  apkurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_apkurl() {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  return apkurl_;
}
inline ::std::string* GameInfo::release_apkurl() {
  clear_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apkurl_;
    apkurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_apkurl(::std::string* apkurl) {
  if (apkurl_ != &::google::protobuf::internal::kEmptyString) {
    delete apkurl_;
  }
  if (apkurl) {
    set_has_apkurl();
    apkurl_ = apkurl;
  } else {
    clear_has_apkurl();
    apkurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string downloadUrl = 13;
inline bool GameInfo::has_downloadurl() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GameInfo::set_has_downloadurl() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GameInfo::clear_has_downloadurl() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GameInfo::clear_downloadurl() {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    downloadurl_->clear();
  }
  clear_has_downloadurl();
}
inline const ::std::string& GameInfo::downloadurl() const {
  return *downloadurl_;
}
inline void GameInfo::set_downloadurl(const ::std::string& value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void GameInfo::set_downloadurl(const char* value) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(value);
}
inline void GameInfo::set_downloadurl(const char* value, size_t size) {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  downloadurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_downloadurl() {
  set_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    downloadurl_ = new ::std::string;
  }
  return downloadurl_;
}
inline ::std::string* GameInfo::release_downloadurl() {
  clear_has_downloadurl();
  if (downloadurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = downloadurl_;
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_downloadurl(::std::string* downloadurl) {
  if (downloadurl_ != &::google::protobuf::internal::kEmptyString) {
    delete downloadurl_;
  }
  if (downloadurl) {
    set_has_downloadurl();
    downloadurl_ = downloadurl;
  } else {
    clear_has_downloadurl();
    downloadurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string apkSrc = 14;
inline bool GameInfo::has_apksrc() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GameInfo::set_has_apksrc() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GameInfo::clear_has_apksrc() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GameInfo::clear_apksrc() {
  if (apksrc_ != &::google::protobuf::internal::kEmptyString) {
    apksrc_->clear();
  }
  clear_has_apksrc();
}
inline const ::std::string& GameInfo::apksrc() const {
  return *apksrc_;
}
inline void GameInfo::set_apksrc(const ::std::string& value) {
  set_has_apksrc();
  if (apksrc_ == &::google::protobuf::internal::kEmptyString) {
    apksrc_ = new ::std::string;
  }
  apksrc_->assign(value);
}
inline void GameInfo::set_apksrc(const char* value) {
  set_has_apksrc();
  if (apksrc_ == &::google::protobuf::internal::kEmptyString) {
    apksrc_ = new ::std::string;
  }
  apksrc_->assign(value);
}
inline void GameInfo::set_apksrc(const char* value, size_t size) {
  set_has_apksrc();
  if (apksrc_ == &::google::protobuf::internal::kEmptyString) {
    apksrc_ = new ::std::string;
  }
  apksrc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_apksrc() {
  set_has_apksrc();
  if (apksrc_ == &::google::protobuf::internal::kEmptyString) {
    apksrc_ = new ::std::string;
  }
  return apksrc_;
}
inline ::std::string* GameInfo::release_apksrc() {
  clear_has_apksrc();
  if (apksrc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apksrc_;
    apksrc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_apksrc(::std::string* apksrc) {
  if (apksrc_ != &::google::protobuf::internal::kEmptyString) {
    delete apksrc_;
  }
  if (apksrc) {
    set_has_apksrc();
    apksrc_ = apksrc;
  } else {
    clear_has_apksrc();
    apksrc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 giftStyleCount = 15;
inline bool GameInfo::has_giftstylecount() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GameInfo::set_has_giftstylecount() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GameInfo::clear_has_giftstylecount() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GameInfo::clear_giftstylecount() {
  giftstylecount_ = 0u;
  clear_has_giftstylecount();
}
inline ::google::protobuf::uint32 GameInfo::giftstylecount() const {
  return giftstylecount_;
}
inline void GameInfo::set_giftstylecount(::google::protobuf::uint32 value) {
  set_has_giftstylecount();
  giftstylecount_ = value;
}

// optional string activityTitle = 16;
inline bool GameInfo::has_activitytitle() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GameInfo::set_has_activitytitle() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GameInfo::clear_has_activitytitle() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GameInfo::clear_activitytitle() {
  if (activitytitle_ != &::google::protobuf::internal::kEmptyString) {
    activitytitle_->clear();
  }
  clear_has_activitytitle();
}
inline const ::std::string& GameInfo::activitytitle() const {
  return *activitytitle_;
}
inline void GameInfo::set_activitytitle(const ::std::string& value) {
  set_has_activitytitle();
  if (activitytitle_ == &::google::protobuf::internal::kEmptyString) {
    activitytitle_ = new ::std::string;
  }
  activitytitle_->assign(value);
}
inline void GameInfo::set_activitytitle(const char* value) {
  set_has_activitytitle();
  if (activitytitle_ == &::google::protobuf::internal::kEmptyString) {
    activitytitle_ = new ::std::string;
  }
  activitytitle_->assign(value);
}
inline void GameInfo::set_activitytitle(const char* value, size_t size) {
  set_has_activitytitle();
  if (activitytitle_ == &::google::protobuf::internal::kEmptyString) {
    activitytitle_ = new ::std::string;
  }
  activitytitle_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_activitytitle() {
  set_has_activitytitle();
  if (activitytitle_ == &::google::protobuf::internal::kEmptyString) {
    activitytitle_ = new ::std::string;
  }
  return activitytitle_;
}
inline ::std::string* GameInfo::release_activitytitle() {
  clear_has_activitytitle();
  if (activitytitle_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = activitytitle_;
    activitytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_activitytitle(::std::string* activitytitle) {
  if (activitytitle_ != &::google::protobuf::internal::kEmptyString) {
    delete activitytitle_;
  }
  if (activitytitle) {
    set_has_activitytitle();
    activitytitle_ = activitytitle;
  } else {
    clear_has_activitytitle();
    activitytitle_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string activityLink = 17;
inline bool GameInfo::has_activitylink() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GameInfo::set_has_activitylink() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GameInfo::clear_has_activitylink() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GameInfo::clear_activitylink() {
  if (activitylink_ != &::google::protobuf::internal::kEmptyString) {
    activitylink_->clear();
  }
  clear_has_activitylink();
}
inline const ::std::string& GameInfo::activitylink() const {
  return *activitylink_;
}
inline void GameInfo::set_activitylink(const ::std::string& value) {
  set_has_activitylink();
  if (activitylink_ == &::google::protobuf::internal::kEmptyString) {
    activitylink_ = new ::std::string;
  }
  activitylink_->assign(value);
}
inline void GameInfo::set_activitylink(const char* value) {
  set_has_activitylink();
  if (activitylink_ == &::google::protobuf::internal::kEmptyString) {
    activitylink_ = new ::std::string;
  }
  activitylink_->assign(value);
}
inline void GameInfo::set_activitylink(const char* value, size_t size) {
  set_has_activitylink();
  if (activitylink_ == &::google::protobuf::internal::kEmptyString) {
    activitylink_ = new ::std::string;
  }
  activitylink_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_activitylink() {
  set_has_activitylink();
  if (activitylink_ == &::google::protobuf::internal::kEmptyString) {
    activitylink_ = new ::std::string;
  }
  return activitylink_;
}
inline ::std::string* GameInfo::release_activitylink() {
  clear_has_activitylink();
  if (activitylink_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = activitylink_;
    activitylink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_activitylink(::std::string* activitylink) {
  if (activitylink_ != &::google::protobuf::internal::kEmptyString) {
    delete activitylink_;
  }
  if (activitylink) {
    set_has_activitylink();
    activitylink_ = activitylink;
  } else {
    clear_has_activitylink();
    activitylink_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string discountIntro = 18;
inline bool GameInfo::has_discountintro() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GameInfo::set_has_discountintro() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GameInfo::clear_has_discountintro() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GameInfo::clear_discountintro() {
  if (discountintro_ != &::google::protobuf::internal::kEmptyString) {
    discountintro_->clear();
  }
  clear_has_discountintro();
}
inline const ::std::string& GameInfo::discountintro() const {
  return *discountintro_;
}
inline void GameInfo::set_discountintro(const ::std::string& value) {
  set_has_discountintro();
  if (discountintro_ == &::google::protobuf::internal::kEmptyString) {
    discountintro_ = new ::std::string;
  }
  discountintro_->assign(value);
}
inline void GameInfo::set_discountintro(const char* value) {
  set_has_discountintro();
  if (discountintro_ == &::google::protobuf::internal::kEmptyString) {
    discountintro_ = new ::std::string;
  }
  discountintro_->assign(value);
}
inline void GameInfo::set_discountintro(const char* value, size_t size) {
  set_has_discountintro();
  if (discountintro_ == &::google::protobuf::internal::kEmptyString) {
    discountintro_ = new ::std::string;
  }
  discountintro_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_discountintro() {
  set_has_discountintro();
  if (discountintro_ == &::google::protobuf::internal::kEmptyString) {
    discountintro_ = new ::std::string;
  }
  return discountintro_;
}
inline ::std::string* GameInfo::release_discountintro() {
  clear_has_discountintro();
  if (discountintro_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = discountintro_;
    discountintro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_discountintro(::std::string* discountintro) {
  if (discountintro_ != &::google::protobuf::internal::kEmptyString) {
    delete discountintro_;
  }
  if (discountintro) {
    set_has_discountintro();
    discountintro_ = discountintro;
  } else {
    clear_has_discountintro();
    discountintro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 playerCount = 19;
inline bool GameInfo::has_playercount() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void GameInfo::set_has_playercount() {
  _has_bits_[0] |= 0x00040000u;
}
inline void GameInfo::clear_has_playercount() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void GameInfo::clear_playercount() {
  playercount_ = 0u;
  clear_has_playercount();
}
inline ::google::protobuf::uint32 GameInfo::playercount() const {
  return playercount_;
}
inline void GameInfo::set_playercount(::google::protobuf::uint32 value) {
  set_has_playercount();
  playercount_ = value;
}

// optional string categories = 20;
inline bool GameInfo::has_categories() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GameInfo::set_has_categories() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GameInfo::clear_has_categories() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GameInfo::clear_categories() {
  if (categories_ != &::google::protobuf::internal::kEmptyString) {
    categories_->clear();
  }
  clear_has_categories();
}
inline const ::std::string& GameInfo::categories() const {
  return *categories_;
}
inline void GameInfo::set_categories(const ::std::string& value) {
  set_has_categories();
  if (categories_ == &::google::protobuf::internal::kEmptyString) {
    categories_ = new ::std::string;
  }
  categories_->assign(value);
}
inline void GameInfo::set_categories(const char* value) {
  set_has_categories();
  if (categories_ == &::google::protobuf::internal::kEmptyString) {
    categories_ = new ::std::string;
  }
  categories_->assign(value);
}
inline void GameInfo::set_categories(const char* value, size_t size) {
  set_has_categories();
  if (categories_ == &::google::protobuf::internal::kEmptyString) {
    categories_ = new ::std::string;
  }
  categories_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_categories() {
  set_has_categories();
  if (categories_ == &::google::protobuf::internal::kEmptyString) {
    categories_ = new ::std::string;
  }
  return categories_;
}
inline ::std::string* GameInfo::release_categories() {
  clear_has_categories();
  if (categories_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = categories_;
    categories_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_categories(::std::string* categories) {
  if (categories_ != &::google::protobuf::internal::kEmptyString) {
    delete categories_;
  }
  if (categories) {
    set_has_categories();
    categories_ = categories;
  } else {
    clear_has_categories();
    categories_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 21;
inline bool GameInfo::has_version() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GameInfo::set_has_version() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GameInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GameInfo::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GameInfo::version() const {
  return *version_;
}
inline void GameInfo::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GameInfo::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GameInfo::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GameInfo::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string reportPackname = 22;
inline bool GameInfo::has_reportpackname() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GameInfo::set_has_reportpackname() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GameInfo::clear_has_reportpackname() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GameInfo::clear_reportpackname() {
  if (reportpackname_ != &::google::protobuf::internal::kEmptyString) {
    reportpackname_->clear();
  }
  clear_has_reportpackname();
}
inline const ::std::string& GameInfo::reportpackname() const {
  return *reportpackname_;
}
inline void GameInfo::set_reportpackname(const ::std::string& value) {
  set_has_reportpackname();
  if (reportpackname_ == &::google::protobuf::internal::kEmptyString) {
    reportpackname_ = new ::std::string;
  }
  reportpackname_->assign(value);
}
inline void GameInfo::set_reportpackname(const char* value) {
  set_has_reportpackname();
  if (reportpackname_ == &::google::protobuf::internal::kEmptyString) {
    reportpackname_ = new ::std::string;
  }
  reportpackname_->assign(value);
}
inline void GameInfo::set_reportpackname(const char* value, size_t size) {
  set_has_reportpackname();
  if (reportpackname_ == &::google::protobuf::internal::kEmptyString) {
    reportpackname_ = new ::std::string;
  }
  reportpackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_reportpackname() {
  set_has_reportpackname();
  if (reportpackname_ == &::google::protobuf::internal::kEmptyString) {
    reportpackname_ = new ::std::string;
  }
  return reportpackname_;
}
inline ::std::string* GameInfo::release_reportpackname() {
  clear_has_reportpackname();
  if (reportpackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reportpackname_;
    reportpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_reportpackname(::std::string* reportpackname) {
  if (reportpackname_ != &::google::protobuf::internal::kEmptyString) {
    delete reportpackname_;
  }
  if (reportpackname) {
    set_has_reportpackname();
    reportpackname_ = reportpackname;
  } else {
    clear_has_reportpackname();
    reportpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string groupApkUrl = 23;
inline bool GameInfo::has_groupapkurl() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GameInfo::set_has_groupapkurl() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GameInfo::clear_has_groupapkurl() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GameInfo::clear_groupapkurl() {
  if (groupapkurl_ != &::google::protobuf::internal::kEmptyString) {
    groupapkurl_->clear();
  }
  clear_has_groupapkurl();
}
inline const ::std::string& GameInfo::groupapkurl() const {
  return *groupapkurl_;
}
inline void GameInfo::set_groupapkurl(const ::std::string& value) {
  set_has_groupapkurl();
  if (groupapkurl_ == &::google::protobuf::internal::kEmptyString) {
    groupapkurl_ = new ::std::string;
  }
  groupapkurl_->assign(value);
}
inline void GameInfo::set_groupapkurl(const char* value) {
  set_has_groupapkurl();
  if (groupapkurl_ == &::google::protobuf::internal::kEmptyString) {
    groupapkurl_ = new ::std::string;
  }
  groupapkurl_->assign(value);
}
inline void GameInfo::set_groupapkurl(const char* value, size_t size) {
  set_has_groupapkurl();
  if (groupapkurl_ == &::google::protobuf::internal::kEmptyString) {
    groupapkurl_ = new ::std::string;
  }
  groupapkurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_groupapkurl() {
  set_has_groupapkurl();
  if (groupapkurl_ == &::google::protobuf::internal::kEmptyString) {
    groupapkurl_ = new ::std::string;
  }
  return groupapkurl_;
}
inline ::std::string* GameInfo::release_groupapkurl() {
  clear_has_groupapkurl();
  if (groupapkurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = groupapkurl_;
    groupapkurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_groupapkurl(::std::string* groupapkurl) {
  if (groupapkurl_ != &::google::protobuf::internal::kEmptyString) {
    delete groupapkurl_;
  }
  if (groupapkurl) {
    set_has_groupapkurl();
    groupapkurl_ = groupapkurl;
  } else {
    clear_has_groupapkurl();
    groupapkurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 sortOrder = 24;
inline bool GameInfo::has_sortorder() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GameInfo::set_has_sortorder() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GameInfo::clear_has_sortorder() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GameInfo::clear_sortorder() {
  sortorder_ = 0u;
  clear_has_sortorder();
}
inline ::google::protobuf::uint32 GameInfo::sortorder() const {
  return sortorder_;
}
inline void GameInfo::set_sortorder(::google::protobuf::uint32 value) {
  set_has_sortorder();
  sortorder_ = value;
}

// optional string yyPackname = 25;
inline bool GameInfo::has_yypackname() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GameInfo::set_has_yypackname() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GameInfo::clear_has_yypackname() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GameInfo::clear_yypackname() {
  if (yypackname_ != &::google::protobuf::internal::kEmptyString) {
    yypackname_->clear();
  }
  clear_has_yypackname();
}
inline const ::std::string& GameInfo::yypackname() const {
  return *yypackname_;
}
inline void GameInfo::set_yypackname(const ::std::string& value) {
  set_has_yypackname();
  if (yypackname_ == &::google::protobuf::internal::kEmptyString) {
    yypackname_ = new ::std::string;
  }
  yypackname_->assign(value);
}
inline void GameInfo::set_yypackname(const char* value) {
  set_has_yypackname();
  if (yypackname_ == &::google::protobuf::internal::kEmptyString) {
    yypackname_ = new ::std::string;
  }
  yypackname_->assign(value);
}
inline void GameInfo::set_yypackname(const char* value, size_t size) {
  set_has_yypackname();
  if (yypackname_ == &::google::protobuf::internal::kEmptyString) {
    yypackname_ = new ::std::string;
  }
  yypackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_yypackname() {
  set_has_yypackname();
  if (yypackname_ == &::google::protobuf::internal::kEmptyString) {
    yypackname_ = new ::std::string;
  }
  return yypackname_;
}
inline ::std::string* GameInfo::release_yypackname() {
  clear_has_yypackname();
  if (yypackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = yypackname_;
    yypackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_yypackname(::std::string* yypackname) {
  if (yypackname_ != &::google::protobuf::internal::kEmptyString) {
    delete yypackname_;
  }
  if (yypackname) {
    set_has_yypackname();
    yypackname_ = yypackname;
  } else {
    clear_has_yypackname();
    yypackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string thumbnails = 30;
inline bool GameInfo::has_thumbnails() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GameInfo::set_has_thumbnails() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GameInfo::clear_has_thumbnails() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GameInfo::clear_thumbnails() {
  if (thumbnails_ != &::google::protobuf::internal::kEmptyString) {
    thumbnails_->clear();
  }
  clear_has_thumbnails();
}
inline const ::std::string& GameInfo::thumbnails() const {
  return *thumbnails_;
}
inline void GameInfo::set_thumbnails(const ::std::string& value) {
  set_has_thumbnails();
  if (thumbnails_ == &::google::protobuf::internal::kEmptyString) {
    thumbnails_ = new ::std::string;
  }
  thumbnails_->assign(value);
}
inline void GameInfo::set_thumbnails(const char* value) {
  set_has_thumbnails();
  if (thumbnails_ == &::google::protobuf::internal::kEmptyString) {
    thumbnails_ = new ::std::string;
  }
  thumbnails_->assign(value);
}
inline void GameInfo::set_thumbnails(const char* value, size_t size) {
  set_has_thumbnails();
  if (thumbnails_ == &::google::protobuf::internal::kEmptyString) {
    thumbnails_ = new ::std::string;
  }
  thumbnails_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameInfo::mutable_thumbnails() {
  set_has_thumbnails();
  if (thumbnails_ == &::google::protobuf::internal::kEmptyString) {
    thumbnails_ = new ::std::string;
  }
  return thumbnails_;
}
inline ::std::string* GameInfo::release_thumbnails() {
  clear_has_thumbnails();
  if (thumbnails_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thumbnails_;
    thumbnails_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameInfo::set_allocated_thumbnails(::std::string* thumbnails) {
  if (thumbnails_ != &::google::protobuf::internal::kEmptyString) {
    delete thumbnails_;
  }
  if (thumbnails) {
    set_has_thumbnails();
    thumbnails_ = thumbnails;
  } else {
    clear_has_thumbnails();
    thumbnails_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameReservableRecord

// optional .pp.GameInfo game = 1;
inline bool GameReservableRecord::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameReservableRecord::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameReservableRecord::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameReservableRecord::clear_game() {
  if (game_ != NULL) game_->::pp::GameInfo::Clear();
  clear_has_game();
}
inline const ::pp::GameInfo& GameReservableRecord::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::pp::GameInfo* GameReservableRecord::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::pp::GameInfo;
  return game_;
}
inline ::pp::GameInfo* GameReservableRecord::release_game() {
  clear_has_game();
  ::pp::GameInfo* temp = game_;
  game_ = NULL;
  return temp;
}
inline void GameReservableRecord::set_allocated_game(::pp::GameInfo* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// optional uint32 bookedNum = 2;
inline bool GameReservableRecord::has_bookednum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameReservableRecord::set_has_bookednum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameReservableRecord::clear_has_bookednum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameReservableRecord::clear_bookednum() {
  bookednum_ = 0u;
  clear_has_bookednum();
}
inline ::google::protobuf::uint32 GameReservableRecord::bookednum() const {
  return bookednum_;
}
inline void GameReservableRecord::set_bookednum(::google::protobuf::uint32 value) {
  set_has_bookednum();
  bookednum_ = value;
}

// optional bool booked = 3;
inline bool GameReservableRecord::has_booked() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameReservableRecord::set_has_booked() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameReservableRecord::clear_has_booked() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameReservableRecord::clear_booked() {
  booked_ = false;
  clear_has_booked();
}
inline bool GameReservableRecord::booked() const {
  return booked_;
}
inline void GameReservableRecord::set_booked(bool value) {
  set_has_booked();
  booked_ = value;
}

// -------------------------------------------------------------------

// ConfigJsonReq

// -------------------------------------------------------------------

// ConfigJsonRes

// optional string jsondata = 1;
inline bool ConfigJsonRes::has_jsondata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigJsonRes::set_has_jsondata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigJsonRes::clear_has_jsondata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigJsonRes::clear_jsondata() {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    jsondata_->clear();
  }
  clear_has_jsondata();
}
inline const ::std::string& ConfigJsonRes::jsondata() const {
  return *jsondata_;
}
inline void ConfigJsonRes::set_jsondata(const ::std::string& value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonRes::set_jsondata(const char* value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonRes::set_jsondata(const char* value, size_t size) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonRes::mutable_jsondata() {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  return jsondata_;
}
inline ::std::string* ConfigJsonRes::release_jsondata() {
  clear_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsondata_;
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonRes::set_allocated_jsondata(::std::string* jsondata) {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    delete jsondata_;
  }
  if (jsondata) {
    set_has_jsondata();
    jsondata_ = jsondata;
  } else {
    clear_has_jsondata();
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigJsonListReq

// -------------------------------------------------------------------

// ConfigJsonListRes

// repeated .pp.ConfigJsonData items = 1;
inline int ConfigJsonListRes::items_size() const {
  return items_.size();
}
inline void ConfigJsonListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::ConfigJsonData& ConfigJsonListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::ConfigJsonData* ConfigJsonListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::ConfigJsonData* ConfigJsonListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonData >&
ConfigJsonListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonData >*
ConfigJsonListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ConfigJsonData

// required uint32 devtype = 1;
inline bool ConfigJsonData::has_devtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigJsonData::set_has_devtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigJsonData::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigJsonData::clear_devtype() {
  devtype_ = 0u;
  clear_has_devtype();
}
inline ::google::protobuf::uint32 ConfigJsonData::devtype() const {
  return devtype_;
}
inline void ConfigJsonData::set_devtype(::google::protobuf::uint32 value) {
  set_has_devtype();
  devtype_ = value;
}

// required uint32 maxversion = 2;
inline bool ConfigJsonData::has_maxversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigJsonData::set_has_maxversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigJsonData::clear_has_maxversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigJsonData::clear_maxversion() {
  maxversion_ = 0u;
  clear_has_maxversion();
}
inline ::google::protobuf::uint32 ConfigJsonData::maxversion() const {
  return maxversion_;
}
inline void ConfigJsonData::set_maxversion(::google::protobuf::uint32 value) {
  set_has_maxversion();
  maxversion_ = value;
}

// required int64 validtime = 3;
inline bool ConfigJsonData::has_validtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConfigJsonData::set_has_validtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConfigJsonData::clear_has_validtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConfigJsonData::clear_validtime() {
  validtime_ = GOOGLE_LONGLONG(0);
  clear_has_validtime();
}
inline ::google::protobuf::int64 ConfigJsonData::validtime() const {
  return validtime_;
}
inline void ConfigJsonData::set_validtime(::google::protobuf::int64 value) {
  set_has_validtime();
  validtime_ = value;
}

// optional string jsondata = 4;
inline bool ConfigJsonData::has_jsondata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ConfigJsonData::set_has_jsondata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ConfigJsonData::clear_has_jsondata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ConfigJsonData::clear_jsondata() {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    jsondata_->clear();
  }
  clear_has_jsondata();
}
inline const ::std::string& ConfigJsonData::jsondata() const {
  return *jsondata_;
}
inline void ConfigJsonData::set_jsondata(const ::std::string& value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonData::set_jsondata(const char* value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonData::set_jsondata(const char* value, size_t size) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonData::mutable_jsondata() {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  return jsondata_;
}
inline ::std::string* ConfigJsonData::release_jsondata() {
  clear_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsondata_;
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonData::set_allocated_jsondata(::std::string* jsondata) {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    delete jsondata_;
  }
  if (jsondata) {
    set_has_jsondata();
    jsondata_ = jsondata;
  } else {
    clear_has_jsondata();
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SysConfReq

// optional string key = 1;
inline bool SysConfReq::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysConfReq::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysConfReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysConfReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& SysConfReq::key() const {
  return *key_;
}
inline void SysConfReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SysConfReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void SysConfReq::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysConfReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* SysConfReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SysConfReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SysConfRes

// optional string jsondata = 1;
inline bool SysConfRes::has_jsondata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysConfRes::set_has_jsondata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysConfRes::clear_has_jsondata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysConfRes::clear_jsondata() {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    jsondata_->clear();
  }
  clear_has_jsondata();
}
inline const ::std::string& SysConfRes::jsondata() const {
  return *jsondata_;
}
inline void SysConfRes::set_jsondata(const ::std::string& value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void SysConfRes::set_jsondata(const char* value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void SysConfRes::set_jsondata(const char* value, size_t size) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysConfRes::mutable_jsondata() {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  return jsondata_;
}
inline ::std::string* SysConfRes::release_jsondata() {
  clear_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsondata_;
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SysConfRes::set_allocated_jsondata(::std::string* jsondata) {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    delete jsondata_;
  }
  if (jsondata) {
    set_has_jsondata();
    jsondata_ = jsondata;
  } else {
    clear_has_jsondata();
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserSettingItem

// required string key = 1;
inline bool UserSettingItem::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSettingItem::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSettingItem::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSettingItem::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& UserSettingItem::key() const {
  return *key_;
}
inline void UserSettingItem::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void UserSettingItem::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void UserSettingItem::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSettingItem::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* UserSettingItem::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSettingItem::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool UserSettingItem::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSettingItem::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSettingItem::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSettingItem::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& UserSettingItem::value() const {
  return *value_;
}
inline void UserSettingItem::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UserSettingItem::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void UserSettingItem::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSettingItem::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* UserSettingItem::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSettingItem::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserSettingSetReq

// repeated .pp.UserSettingItem items = 1;
inline int UserSettingSetReq::items_size() const {
  return items_.size();
}
inline void UserSettingSetReq::clear_items() {
  items_.Clear();
}
inline const ::pp::UserSettingItem& UserSettingSetReq::items(int index) const {
  return items_.Get(index);
}
inline ::pp::UserSettingItem* UserSettingSetReq::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::UserSettingItem* UserSettingSetReq::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >&
UserSettingSetReq::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >*
UserSettingSetReq::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// UserSettingSetRes

// repeated .pp.UserSettingItem items = 1;
inline int UserSettingSetRes::items_size() const {
  return items_.size();
}
inline void UserSettingSetRes::clear_items() {
  items_.Clear();
}
inline const ::pp::UserSettingItem& UserSettingSetRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::UserSettingItem* UserSettingSetRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::UserSettingItem* UserSettingSetRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >&
UserSettingSetRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >*
UserSettingSetRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// UserSettingGetReq

// -------------------------------------------------------------------

// UserSettingGetRes

// repeated .pp.UserSettingItem items = 1;
inline int UserSettingGetRes::items_size() const {
  return items_.size();
}
inline void UserSettingGetRes::clear_items() {
  items_.Clear();
}
inline const ::pp::UserSettingItem& UserSettingGetRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::UserSettingItem* UserSettingGetRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::UserSettingItem* UserSettingGetRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >&
UserSettingGetRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserSettingItem >*
UserSettingGetRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// AppStateCheckReq

// -------------------------------------------------------------------

// AppState

// optional uint32 type = 1;
inline bool AppState::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppState::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppState::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppState::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 AppState::type() const {
  return type_;
}
inline void AppState::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint64 version = 2;
inline bool AppState::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppState::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppState::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppState::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 AppState::version() const {
  return version_;
}
inline void AppState::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// optional string text = 3;
inline bool AppState::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppState::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppState::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppState::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& AppState::text() const {
  return *text_;
}
inline void AppState::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void AppState::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void AppState::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppState::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* AppState::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppState::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enable = 4;
inline bool AppState::has_enable() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppState::set_has_enable() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppState::clear_has_enable() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppState::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool AppState::enable() const {
  return enable_;
}
inline void AppState::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// -------------------------------------------------------------------

// AppStateCheckRes

// repeated .pp.AppState states = 1;
inline int AppStateCheckRes::states_size() const {
  return states_.size();
}
inline void AppStateCheckRes::clear_states() {
  states_.Clear();
}
inline const ::pp::AppState& AppStateCheckRes::states(int index) const {
  return states_.Get(index);
}
inline ::pp::AppState* AppStateCheckRes::mutable_states(int index) {
  return states_.Mutable(index);
}
inline ::pp::AppState* AppStateCheckRes::add_states() {
  return states_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::AppState >&
AppStateCheckRes::states() const {
  return states_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::AppState >*
AppStateCheckRes::mutable_states() {
  return &states_;
}

// -------------------------------------------------------------------

// AppStateUpdateReq

// optional bool iosEnable = 1;
inline bool AppStateUpdateReq::has_iosenable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppStateUpdateReq::set_has_iosenable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppStateUpdateReq::clear_has_iosenable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppStateUpdateReq::clear_iosenable() {
  iosenable_ = false;
  clear_has_iosenable();
}
inline bool AppStateUpdateReq::iosenable() const {
  return iosenable_;
}
inline void AppStateUpdateReq::set_iosenable(bool value) {
  set_has_iosenable();
  iosenable_ = value;
}

// -------------------------------------------------------------------

// AppStateUpdateRes

// optional bool iosEnable = 1;
inline bool AppStateUpdateRes::has_iosenable() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppStateUpdateRes::set_has_iosenable() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppStateUpdateRes::clear_has_iosenable() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppStateUpdateRes::clear_iosenable() {
  iosenable_ = false;
  clear_has_iosenable();
}
inline bool AppStateUpdateRes::iosenable() const {
  return iosenable_;
}
inline void AppStateUpdateRes::set_iosenable(bool value) {
  set_has_iosenable();
  iosenable_ = value;
}

// -------------------------------------------------------------------

// AppActConfigReq

// -------------------------------------------------------------------

// AppActConfigRes

// optional string icon = 1;
inline bool AppActConfigRes::has_icon() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppActConfigRes::set_has_icon() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppActConfigRes::clear_has_icon() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppActConfigRes::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& AppActConfigRes::icon() const {
  return *icon_;
}
inline void AppActConfigRes::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void AppActConfigRes::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void AppActConfigRes::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppActConfigRes::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* AppActConfigRes::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppActConfigRes::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 2;
inline bool AppActConfigRes::has_text() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AppActConfigRes::set_has_text() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AppActConfigRes::clear_has_text() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AppActConfigRes::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& AppActConfigRes::text() const {
  return *text_;
}
inline void AppActConfigRes::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void AppActConfigRes::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void AppActConfigRes::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppActConfigRes::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* AppActConfigRes::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppActConfigRes::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 3;
inline bool AppActConfigRes::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AppActConfigRes::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AppActConfigRes::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AppActConfigRes::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& AppActConfigRes::url() const {
  return *url_;
}
inline void AppActConfigRes::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AppActConfigRes::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void AppActConfigRes::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AppActConfigRes::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* AppActConfigRes::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AppActConfigRes::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 version = 4;
inline bool AppActConfigRes::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AppActConfigRes::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AppActConfigRes::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AppActConfigRes::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 AppActConfigRes::version() const {
  return version_;
}
inline void AppActConfigRes::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// AppProtoVersionUpdateReq

// optional uint32 version = 1;
inline bool AppProtoVersionUpdateReq::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppProtoVersionUpdateReq::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppProtoVersionUpdateReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppProtoVersionUpdateReq::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 AppProtoVersionUpdateReq::version() const {
  return version_;
}
inline void AppProtoVersionUpdateReq::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// AppProtoVersionUpdateRes

// required uint32 version = 1;
inline bool AppProtoVersionUpdateRes::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AppProtoVersionUpdateRes::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AppProtoVersionUpdateRes::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AppProtoVersionUpdateRes::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 AppProtoVersionUpdateRes::version() const {
  return version_;
}
inline void AppProtoVersionUpdateRes::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// ContactInfo

// optional .pp.UserInfo user = 1;
inline bool ContactInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactInfo::clear_user() {
  if (user_ != NULL) user_->::pp::UserInfo::Clear();
  clear_has_user();
}
inline const ::pp::UserInfo& ContactInfo::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::pp::UserInfo* ContactInfo::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::pp::UserInfo;
  return user_;
}
inline ::pp::UserInfo* ContactInfo::release_user() {
  clear_has_user();
  ::pp::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void ContactInfo::set_allocated_user(::pp::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional uint32 state = 2;
inline bool ContactInfo::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactInfo::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactInfo::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 ContactInfo::state() const {
  return state_;
}
inline void ContactInfo::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint64 revread = 3;
inline bool ContactInfo::has_revread() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactInfo::set_has_revread() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactInfo::clear_has_revread() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactInfo::clear_revread() {
  revread_ = GOOGLE_ULONGLONG(0);
  clear_has_revread();
}
inline ::google::protobuf::uint64 ContactInfo::revread() const {
  return revread_;
}
inline void ContactInfo::set_revread(::google::protobuf::uint64 value) {
  set_has_revread();
  revread_ = value;
}

// optional uint64 revmsg = 4;
inline bool ContactInfo::has_revmsg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactInfo::set_has_revmsg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactInfo::clear_has_revmsg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactInfo::clear_revmsg() {
  revmsg_ = GOOGLE_ULONGLONG(0);
  clear_has_revmsg();
}
inline ::google::protobuf::uint64 ContactInfo::revmsg() const {
  return revmsg_;
}
inline void ContactInfo::set_revmsg(::google::protobuf::uint64 value) {
  set_has_revmsg();
  revmsg_ = value;
}

// optional string remark = 5;
inline bool ContactInfo::has_remark() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ContactInfo::set_has_remark() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ContactInfo::clear_has_remark() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ContactInfo::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ContactInfo::remark() const {
  return *remark_;
}
inline void ContactInfo::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactInfo::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactInfo::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactInfo::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ContactInfo::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactInfo::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 timestamp = 6;
inline bool ContactInfo::has_timestamp() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ContactInfo::set_has_timestamp() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ContactInfo::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ContactInfo::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ContactInfo::timestamp() const {
  return timestamp_;
}
inline void ContactInfo::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional uint64 dailyCoin = 7;
inline bool ContactInfo::has_dailycoin() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ContactInfo::set_has_dailycoin() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ContactInfo::clear_has_dailycoin() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ContactInfo::clear_dailycoin() {
  dailycoin_ = GOOGLE_ULONGLONG(0);
  clear_has_dailycoin();
}
inline ::google::protobuf::uint64 ContactInfo::dailycoin() const {
  return dailycoin_;
}
inline void ContactInfo::set_dailycoin(::google::protobuf::uint64 value) {
  set_has_dailycoin();
  dailycoin_ = value;
}

// optional uint64 monthCoin = 8;
inline bool ContactInfo::has_monthcoin() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ContactInfo::set_has_monthcoin() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ContactInfo::clear_has_monthcoin() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ContactInfo::clear_monthcoin() {
  monthcoin_ = GOOGLE_ULONGLONG(0);
  clear_has_monthcoin();
}
inline ::google::protobuf::uint64 ContactInfo::monthcoin() const {
  return monthcoin_;
}
inline void ContactInfo::set_monthcoin(::google::protobuf::uint64 value) {
  set_has_monthcoin();
  monthcoin_ = value;
}

// optional uint64 totalCoin = 9;
inline bool ContactInfo::has_totalcoin() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ContactInfo::set_has_totalcoin() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ContactInfo::clear_has_totalcoin() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ContactInfo::clear_totalcoin() {
  totalcoin_ = GOOGLE_ULONGLONG(0);
  clear_has_totalcoin();
}
inline ::google::protobuf::uint64 ContactInfo::totalcoin() const {
  return totalcoin_;
}
inline void ContactInfo::set_totalcoin(::google::protobuf::uint64 value) {
  set_has_totalcoin();
  totalcoin_ = value;
}

// -------------------------------------------------------------------

// ContactIncrement

// required uint64 revision = 1;
inline bool ContactIncrement::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactIncrement::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactIncrement::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactIncrement::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 ContactIncrement::revision() const {
  return revision_;
}
inline void ContactIncrement::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// required .pp.ContactInfo contact = 2;
inline bool ContactIncrement::has_contact() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactIncrement::set_has_contact() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactIncrement::clear_has_contact() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactIncrement::clear_contact() {
  if (contact_ != NULL) contact_->::pp::ContactInfo::Clear();
  clear_has_contact();
}
inline const ::pp::ContactInfo& ContactIncrement::contact() const {
  return contact_ != NULL ? *contact_ : *default_instance_->contact_;
}
inline ::pp::ContactInfo* ContactIncrement::mutable_contact() {
  set_has_contact();
  if (contact_ == NULL) contact_ = new ::pp::ContactInfo;
  return contact_;
}
inline ::pp::ContactInfo* ContactIncrement::release_contact() {
  clear_has_contact();
  ::pp::ContactInfo* temp = contact_;
  contact_ = NULL;
  return temp;
}
inline void ContactIncrement::set_allocated_contact(::pp::ContactInfo* contact) {
  delete contact_;
  contact_ = contact;
  if (contact) {
    set_has_contact();
  } else {
    clear_has_contact();
  }
}

// optional int64 timestamp = 3;
inline bool ContactIncrement::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactIncrement::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactIncrement::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactIncrement::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 ContactIncrement::timestamp() const {
  return timestamp_;
}
inline void ContactIncrement::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// required .pp.ContactIncrement.ContactIncrementType incrType = 4;
inline bool ContactIncrement::has_incrtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactIncrement::set_has_incrtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactIncrement::clear_has_incrtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactIncrement::clear_incrtype() {
  incrtype_ = 1;
  clear_has_incrtype();
}
inline ::pp::ContactIncrement_ContactIncrementType ContactIncrement::incrtype() const {
  return static_cast< ::pp::ContactIncrement_ContactIncrementType >(incrtype_);
}
inline void ContactIncrement::set_incrtype(::pp::ContactIncrement_ContactIncrementType value) {
  assert(::pp::ContactIncrement_ContactIncrementType_IsValid(value));
  set_has_incrtype();
  incrtype_ = value;
}

// -------------------------------------------------------------------

// ContactListReq

// required uint64 revision = 1;
inline bool ContactListReq::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactListReq::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactListReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactListReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 ContactListReq::revision() const {
  return revision_;
}
inline void ContactListReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// ContactListRes

// required uint64 revision = 1;
inline bool ContactListRes::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactListRes::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactListRes::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactListRes::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 ContactListRes::revision() const {
  return revision_;
}
inline void ContactListRes::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// repeated .pp.ContactInfo contactList = 2;
inline int ContactListRes::contactlist_size() const {
  return contactlist_.size();
}
inline void ContactListRes::clear_contactlist() {
  contactlist_.Clear();
}
inline const ::pp::ContactInfo& ContactListRes::contactlist(int index) const {
  return contactlist_.Get(index);
}
inline ::pp::ContactInfo* ContactListRes::mutable_contactlist(int index) {
  return contactlist_.Mutable(index);
}
inline ::pp::ContactInfo* ContactListRes::add_contactlist() {
  return contactlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ContactInfo >&
ContactListRes::contactlist() const {
  return contactlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ContactInfo >*
ContactListRes::mutable_contactlist() {
  return &contactlist_;
}

// repeated .pp.ContactIncrement increments = 3;
inline int ContactListRes::increments_size() const {
  return increments_.size();
}
inline void ContactListRes::clear_increments() {
  increments_.Clear();
}
inline const ::pp::ContactIncrement& ContactListRes::increments(int index) const {
  return increments_.Get(index);
}
inline ::pp::ContactIncrement* ContactListRes::mutable_increments(int index) {
  return increments_.Mutable(index);
}
inline ::pp::ContactIncrement* ContactListRes::add_increments() {
  return increments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ContactIncrement >&
ContactListRes::increments() const {
  return increments_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ContactIncrement >*
ContactListRes::mutable_increments() {
  return &increments_;
}

// required uint64 reqRevision = 4;
inline bool ContactListRes::has_reqrevision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactListRes::set_has_reqrevision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactListRes::clear_has_reqrevision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactListRes::clear_reqrevision() {
  reqrevision_ = GOOGLE_ULONGLONG(0);
  clear_has_reqrevision();
}
inline ::google::protobuf::uint64 ContactListRes::reqrevision() const {
  return reqrevision_;
}
inline void ContactListRes::set_reqrevision(::google::protobuf::uint64 value) {
  set_has_reqrevision();
  reqrevision_ = value;
}

// -------------------------------------------------------------------

// ContactAddReq

// required uint64 peerUid = 1;
inline bool ContactAddReq::has_peeruid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactAddReq::set_has_peeruid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactAddReq::clear_has_peeruid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactAddReq::clear_peeruid() {
  peeruid_ = GOOGLE_ULONGLONG(0);
  clear_has_peeruid();
}
inline ::google::protobuf::uint64 ContactAddReq::peeruid() const {
  return peeruid_;
}
inline void ContactAddReq::set_peeruid(::google::protobuf::uint64 value) {
  set_has_peeruid();
  peeruid_ = value;
}

// optional string remark = 2;
inline bool ContactAddReq::has_remark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactAddReq::set_has_remark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactAddReq::clear_has_remark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactAddReq::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ContactAddReq::remark() const {
  return *remark_;
}
inline void ContactAddReq::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactAddReq::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactAddReq::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactAddReq::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ContactAddReq::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactAddReq::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactAddRes

// required uint64 uid = 1;
inline bool ContactAddRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactAddRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactAddRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactAddRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ContactAddRes::uid() const {
  return uid_;
}
inline void ContactAddRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional .pp.ContactApplyResult appResult = 2;
inline bool ContactAddRes::has_appresult() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactAddRes::set_has_appresult() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactAddRes::clear_has_appresult() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactAddRes::clear_appresult() {
  appresult_ = 0;
  clear_has_appresult();
}
inline ::pp::ContactApplyResult ContactAddRes::appresult() const {
  return static_cast< ::pp::ContactApplyResult >(appresult_);
}
inline void ContactAddRes::set_appresult(::pp::ContactApplyResult value) {
  assert(::pp::ContactApplyResult_IsValid(value));
  set_has_appresult();
  appresult_ = value;
}

// optional string remark = 3;
inline bool ContactAddRes::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactAddRes::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactAddRes::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactAddRes::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ContactAddRes::remark() const {
  return *remark_;
}
inline void ContactAddRes::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactAddRes::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactAddRes::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactAddRes::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ContactAddRes::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactAddRes::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactApproveReq

// required uint64 revision = 1;
inline bool ContactApproveReq::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactApproveReq::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactApproveReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactApproveReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 ContactApproveReq::revision() const {
  return revision_;
}
inline void ContactApproveReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 adminUid = 2;
inline bool ContactApproveReq::has_adminuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactApproveReq::set_has_adminuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactApproveReq::clear_has_adminuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactApproveReq::clear_adminuid() {
  adminuid_ = GOOGLE_ULONGLONG(0);
  clear_has_adminuid();
}
inline ::google::protobuf::uint64 ContactApproveReq::adminuid() const {
  return adminuid_;
}
inline void ContactApproveReq::set_adminuid(::google::protobuf::uint64 value) {
  set_has_adminuid();
  adminuid_ = value;
}

// required .pp.ContactApplyResult optype = 3;
inline bool ContactApproveReq::has_optype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactApproveReq::set_has_optype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactApproveReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactApproveReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ContactApplyResult ContactApproveReq::optype() const {
  return static_cast< ::pp::ContactApplyResult >(optype_);
}
inline void ContactApproveReq::set_optype(::pp::ContactApplyResult value) {
  assert(::pp::ContactApplyResult_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional string remark = 4;
inline bool ContactApproveReq::has_remark() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ContactApproveReq::set_has_remark() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ContactApproveReq::clear_has_remark() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ContactApproveReq::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ContactApproveReq::remark() const {
  return *remark_;
}
inline void ContactApproveReq::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactApproveReq::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactApproveReq::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactApproveReq::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ContactApproveReq::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactApproveReq::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactApproveRes

// required .pp.ContactApplyResult applyResult = 1;
inline bool ContactApproveRes::has_applyresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactApproveRes::set_has_applyresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactApproveRes::clear_has_applyresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactApproveRes::clear_applyresult() {
  applyresult_ = 0;
  clear_has_applyresult();
}
inline ::pp::ContactApplyResult ContactApproveRes::applyresult() const {
  return static_cast< ::pp::ContactApplyResult >(applyresult_);
}
inline void ContactApproveRes::set_applyresult(::pp::ContactApplyResult value) {
  assert(::pp::ContactApplyResult_IsValid(value));
  set_has_applyresult();
  applyresult_ = value;
}

// optional string remark = 2;
inline bool ContactApproveRes::has_remark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactApproveRes::set_has_remark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactApproveRes::clear_has_remark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactApproveRes::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ContactApproveRes::remark() const {
  return *remark_;
}
inline void ContactApproveRes::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactApproveRes::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactApproveRes::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactApproveRes::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ContactApproveRes::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactApproveRes::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactModifyReq

// required uint64 peerUid = 1;
inline bool ContactModifyReq::has_peeruid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactModifyReq::set_has_peeruid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactModifyReq::clear_has_peeruid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactModifyReq::clear_peeruid() {
  peeruid_ = GOOGLE_ULONGLONG(0);
  clear_has_peeruid();
}
inline ::google::protobuf::uint64 ContactModifyReq::peeruid() const {
  return peeruid_;
}
inline void ContactModifyReq::set_peeruid(::google::protobuf::uint64 value) {
  set_has_peeruid();
  peeruid_ = value;
}

// required .pp.ContactOpType opType = 2;
inline bool ContactModifyReq::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactModifyReq::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactModifyReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactModifyReq::clear_optype() {
  optype_ = 1;
  clear_has_optype();
}
inline ::pp::ContactOpType ContactModifyReq::optype() const {
  return static_cast< ::pp::ContactOpType >(optype_);
}
inline void ContactModifyReq::set_optype(::pp::ContactOpType value) {
  assert(::pp::ContactOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional string remark = 3;
inline bool ContactModifyReq::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ContactModifyReq::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ContactModifyReq::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ContactModifyReq::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& ContactModifyReq::remark() const {
  return *remark_;
}
inline void ContactModifyReq::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactModifyReq::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void ContactModifyReq::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ContactModifyReq::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* ContactModifyReq::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ContactModifyReq::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ContactModifyRes

// required uint64 peerUid = 1;
inline bool ContactModifyRes::has_peeruid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ContactModifyRes::set_has_peeruid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ContactModifyRes::clear_has_peeruid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ContactModifyRes::clear_peeruid() {
  peeruid_ = GOOGLE_ULONGLONG(0);
  clear_has_peeruid();
}
inline ::google::protobuf::uint64 ContactModifyRes::peeruid() const {
  return peeruid_;
}
inline void ContactModifyRes::set_peeruid(::google::protobuf::uint64 value) {
  set_has_peeruid();
  peeruid_ = value;
}

// required .pp.ContactOpType opType = 2;
inline bool ContactModifyRes::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ContactModifyRes::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ContactModifyRes::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ContactModifyRes::clear_optype() {
  optype_ = 1;
  clear_has_optype();
}
inline ::pp::ContactOpType ContactModifyRes::optype() const {
  return static_cast< ::pp::ContactOpType >(optype_);
}
inline void ContactModifyRes::set_optype(::pp::ContactOpType value) {
  assert(::pp::ContactOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// KeyExchangeReq

// required int32 random = 1;
inline bool KeyExchangeReq::has_random() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyExchangeReq::set_has_random() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyExchangeReq::clear_has_random() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyExchangeReq::clear_random() {
  random_ = 0;
  clear_has_random();
}
inline ::google::protobuf::int32 KeyExchangeReq::random() const {
  return random_;
}
inline void KeyExchangeReq::set_random(::google::protobuf::int32 value) {
  set_has_random();
  random_ = value;
}

// optional string rsaPubKeyN = 2;
inline bool KeyExchangeReq::has_rsapubkeyn() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyExchangeReq::set_has_rsapubkeyn() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyExchangeReq::clear_has_rsapubkeyn() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyExchangeReq::clear_rsapubkeyn() {
  if (rsapubkeyn_ != &::google::protobuf::internal::kEmptyString) {
    rsapubkeyn_->clear();
  }
  clear_has_rsapubkeyn();
}
inline const ::std::string& KeyExchangeReq::rsapubkeyn() const {
  return *rsapubkeyn_;
}
inline void KeyExchangeReq::set_rsapubkeyn(const ::std::string& value) {
  set_has_rsapubkeyn();
  if (rsapubkeyn_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeyn_ = new ::std::string;
  }
  rsapubkeyn_->assign(value);
}
inline void KeyExchangeReq::set_rsapubkeyn(const char* value) {
  set_has_rsapubkeyn();
  if (rsapubkeyn_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeyn_ = new ::std::string;
  }
  rsapubkeyn_->assign(value);
}
inline void KeyExchangeReq::set_rsapubkeyn(const char* value, size_t size) {
  set_has_rsapubkeyn();
  if (rsapubkeyn_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeyn_ = new ::std::string;
  }
  rsapubkeyn_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyExchangeReq::mutable_rsapubkeyn() {
  set_has_rsapubkeyn();
  if (rsapubkeyn_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeyn_ = new ::std::string;
  }
  return rsapubkeyn_;
}
inline ::std::string* KeyExchangeReq::release_rsapubkeyn() {
  clear_has_rsapubkeyn();
  if (rsapubkeyn_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rsapubkeyn_;
    rsapubkeyn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyExchangeReq::set_allocated_rsapubkeyn(::std::string* rsapubkeyn) {
  if (rsapubkeyn_ != &::google::protobuf::internal::kEmptyString) {
    delete rsapubkeyn_;
  }
  if (rsapubkeyn) {
    set_has_rsapubkeyn();
    rsapubkeyn_ = rsapubkeyn;
  } else {
    clear_has_rsapubkeyn();
    rsapubkeyn_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string rsaPubKeyE = 3;
inline bool KeyExchangeReq::has_rsapubkeye() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyExchangeReq::set_has_rsapubkeye() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyExchangeReq::clear_has_rsapubkeye() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyExchangeReq::clear_rsapubkeye() {
  if (rsapubkeye_ != &::google::protobuf::internal::kEmptyString) {
    rsapubkeye_->clear();
  }
  clear_has_rsapubkeye();
}
inline const ::std::string& KeyExchangeReq::rsapubkeye() const {
  return *rsapubkeye_;
}
inline void KeyExchangeReq::set_rsapubkeye(const ::std::string& value) {
  set_has_rsapubkeye();
  if (rsapubkeye_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeye_ = new ::std::string;
  }
  rsapubkeye_->assign(value);
}
inline void KeyExchangeReq::set_rsapubkeye(const char* value) {
  set_has_rsapubkeye();
  if (rsapubkeye_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeye_ = new ::std::string;
  }
  rsapubkeye_->assign(value);
}
inline void KeyExchangeReq::set_rsapubkeye(const char* value, size_t size) {
  set_has_rsapubkeye();
  if (rsapubkeye_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeye_ = new ::std::string;
  }
  rsapubkeye_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyExchangeReq::mutable_rsapubkeye() {
  set_has_rsapubkeye();
  if (rsapubkeye_ == &::google::protobuf::internal::kEmptyString) {
    rsapubkeye_ = new ::std::string;
  }
  return rsapubkeye_;
}
inline ::std::string* KeyExchangeReq::release_rsapubkeye() {
  clear_has_rsapubkeye();
  if (rsapubkeye_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = rsapubkeye_;
    rsapubkeye_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyExchangeReq::set_allocated_rsapubkeye(::std::string* rsapubkeye) {
  if (rsapubkeye_ != &::google::protobuf::internal::kEmptyString) {
    delete rsapubkeye_;
  }
  if (rsapubkeye) {
    set_has_rsapubkeye();
    rsapubkeye_ = rsapubkeye;
  } else {
    clear_has_rsapubkeye();
    rsapubkeye_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool gzip = 4;
inline bool KeyExchangeReq::has_gzip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyExchangeReq::set_has_gzip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyExchangeReq::clear_has_gzip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyExchangeReq::clear_gzip() {
  gzip_ = false;
  clear_has_gzip();
}
inline bool KeyExchangeReq::gzip() const {
  return gzip_;
}
inline void KeyExchangeReq::set_gzip(bool value) {
  set_has_gzip();
  gzip_ = value;
}

// -------------------------------------------------------------------

// KeyExchangeRes

// required int32 random = 1;
inline bool KeyExchangeRes::has_random() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyExchangeRes::set_has_random() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyExchangeRes::clear_has_random() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyExchangeRes::clear_random() {
  random_ = 0;
  clear_has_random();
}
inline ::google::protobuf::int32 KeyExchangeRes::random() const {
  return random_;
}
inline void KeyExchangeRes::set_random(::google::protobuf::int32 value) {
  set_has_random();
  random_ = value;
}

// required string key = 2;
inline bool KeyExchangeRes::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyExchangeRes::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyExchangeRes::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyExchangeRes::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyExchangeRes::key() const {
  return *key_;
}
inline void KeyExchangeRes::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyExchangeRes::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyExchangeRes::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyExchangeRes::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* KeyExchangeRes::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyExchangeRes::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .pp.EncryptType enctype = 3;
inline bool KeyExchangeRes::has_enctype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void KeyExchangeRes::set_has_enctype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void KeyExchangeRes::clear_has_enctype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void KeyExchangeRes::clear_enctype() {
  enctype_ = 0;
  clear_has_enctype();
}
inline ::pp::EncryptType KeyExchangeRes::enctype() const {
  return static_cast< ::pp::EncryptType >(enctype_);
}
inline void KeyExchangeRes::set_enctype(::pp::EncryptType value) {
  assert(::pp::EncryptType_IsValid(value));
  set_has_enctype();
  enctype_ = value;
}

// optional bool gzip = 4;
inline bool KeyExchangeRes::has_gzip() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void KeyExchangeRes::set_has_gzip() {
  _has_bits_[0] |= 0x00000008u;
}
inline void KeyExchangeRes::clear_has_gzip() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void KeyExchangeRes::clear_gzip() {
  gzip_ = false;
  clear_has_gzip();
}
inline bool KeyExchangeRes::gzip() const {
  return gzip_;
}
inline void KeyExchangeRes::set_gzip(bool value) {
  set_has_gzip();
  gzip_ = value;
}

// -------------------------------------------------------------------

// Result

// required bool success = 1;
inline bool Result::has_success() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::set_has_success() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Result::clear_has_success() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Result::clear_success() {
  success_ = false;
  clear_has_success();
}
inline bool Result::success() const {
  return success_;
}
inline void Result::set_success(bool value) {
  set_has_success();
  success_ = value;
}

// optional .pp.ErrCode code = 2;
inline bool Result::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::pp::ErrCode Result::code() const {
  return static_cast< ::pp::ErrCode >(code_);
}
inline void Result::set_code(::pp::ErrCode value) {
  assert(::pp::ErrCode_IsValid(value));
  set_has_code();
  code_ = value;
}

// optional string remarks = 3;
inline bool Result::has_remarks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Result::set_has_remarks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Result::clear_has_remarks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Result::clear_remarks() {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    remarks_->clear();
  }
  clear_has_remarks();
}
inline const ::std::string& Result::remarks() const {
  return *remarks_;
}
inline void Result::set_remarks(const ::std::string& value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void Result::set_remarks(const char* value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void Result::set_remarks(const char* value, size_t size) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Result::mutable_remarks() {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  return remarks_;
}
inline ::std::string* Result::release_remarks() {
  clear_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remarks_;
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Result::set_allocated_remarks(::std::string* remarks) {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    delete remarks_;
  }
  if (remarks) {
    set_has_remarks();
    remarks_ = remarks;
  } else {
    clear_has_remarks();
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 4;
inline bool Result::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Result::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Result::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Result::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 Result::uid() const {
  return uid_;
}
inline void Result::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 gid = 5;
inline bool Result::has_gid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Result::set_has_gid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Result::clear_has_gid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Result::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 Result::gid() const {
  return gid_;
}
inline void Result::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 revision = 6;
inline bool Result::has_revision() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Result::set_has_revision() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Result::clear_has_revision() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Result::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 Result::revision() const {
  return revision_;
}
inline void Result::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional string reason = 7;
inline bool Result::has_reason() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Result::set_has_reason() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Result::clear_has_reason() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Result::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& Result::reason() const {
  return *reason_;
}
inline void Result::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void Result::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void Result::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Result::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* Result::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Result::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserGameListReq

// optional uint64 uid = 1;
inline bool UserGameListReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGameListReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGameListReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGameListReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserGameListReq::uid() const {
  return uid_;
}
inline void UserGameListReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string name = 2;
inline bool UserGameListReq::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserGameListReq::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserGameListReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserGameListReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserGameListReq::name() const {
  return *name_;
}
inline void UserGameListReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserGameListReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserGameListReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGameListReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserGameListReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserGameListReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GameInfo template = 3;
inline bool UserGameListReq::has_template_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserGameListReq::set_has_template_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserGameListReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserGameListReq::clear_template_() {
  if (template__ != NULL) template__->::pp::GameInfo::Clear();
  clear_has_template_();
}
inline const ::pp::GameInfo& UserGameListReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::GameInfo* UserGameListReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::GameInfo;
  return template__;
}
inline ::pp::GameInfo* UserGameListReq::release_template_() {
  clear_has_template_();
  ::pp::GameInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void UserGameListReq::set_allocated_template_(::pp::GameInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// -------------------------------------------------------------------

// UserGameListRes

// optional uint64 uid = 1;
inline bool UserGameListRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGameListRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGameListRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGameListRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserGameListRes::uid() const {
  return uid_;
}
inline void UserGameListRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// repeated .pp.GameInfo games = 2;
inline int UserGameListRes::games_size() const {
  return games_.size();
}
inline void UserGameListRes::clear_games() {
  games_.Clear();
}
inline const ::pp::GameInfo& UserGameListRes::games(int index) const {
  return games_.Get(index);
}
inline ::pp::GameInfo* UserGameListRes::mutable_games(int index) {
  return games_.Mutable(index);
}
inline ::pp::GameInfo* UserGameListRes::add_games() {
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
UserGameListRes::games() const {
  return games_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
UserGameListRes::mutable_games() {
  return &games_;
}

// required .pp.Result result = 3;
inline bool UserGameListRes::has_result() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserGameListRes::set_has_result() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserGameListRes::clear_has_result() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserGameListRes::clear_result() {
  if (result_ != NULL) result_->::pp::Result::Clear();
  clear_has_result();
}
inline const ::pp::Result& UserGameListRes::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::pp::Result* UserGameListRes::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::pp::Result;
  return result_;
}
inline ::pp::Result* UserGameListRes::release_result() {
  clear_has_result();
  ::pp::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline void UserGameListRes::set_allocated_result(::pp::Result* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional string name = 4;
inline bool UserGameListRes::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserGameListRes::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserGameListRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserGameListRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserGameListRes::name() const {
  return *name_;
}
inline void UserGameListRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserGameListRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserGameListRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserGameListRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserGameListRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserGameListRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameReport

// required string packname = 1;
inline bool GameReport::has_packname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameReport::set_has_packname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameReport::clear_has_packname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameReport::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& GameReport::packname() const {
  return *packname_;
}
inline void GameReport::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void GameReport::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void GameReport::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameReport::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* GameReport::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameReport::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string version = 2;
inline bool GameReport::has_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameReport::set_has_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameReport::clear_has_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameReport::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& GameReport::version() const {
  return *version_;
}
inline void GameReport::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GameReport::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void GameReport::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameReport::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* GameReport::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameReport::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool GameReport::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameReport::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameReport::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameReport::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GameReport::name() const {
  return *name_;
}
inline void GameReport::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GameReport::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GameReport::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameReport::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GameReport::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameReport::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserGameListReportReq

// optional bool cleanold = 1;
inline bool UserGameListReportReq::has_cleanold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGameListReportReq::set_has_cleanold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGameListReportReq::clear_has_cleanold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGameListReportReq::clear_cleanold() {
  cleanold_ = false;
  clear_has_cleanold();
}
inline bool UserGameListReportReq::cleanold() const {
  return cleanold_;
}
inline void UserGameListReportReq::set_cleanold(bool value) {
  set_has_cleanold();
  cleanold_ = value;
}

// repeated .pp.GameReport addgames = 2;
inline int UserGameListReportReq::addgames_size() const {
  return addgames_.size();
}
inline void UserGameListReportReq::clear_addgames() {
  addgames_.Clear();
}
inline const ::pp::GameReport& UserGameListReportReq::addgames(int index) const {
  return addgames_.Get(index);
}
inline ::pp::GameReport* UserGameListReportReq::mutable_addgames(int index) {
  return addgames_.Mutable(index);
}
inline ::pp::GameReport* UserGameListReportReq::add_addgames() {
  return addgames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameReport >&
UserGameListReportReq::addgames() const {
  return addgames_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameReport >*
UserGameListReportReq::mutable_addgames() {
  return &addgames_;
}

// repeated .pp.GameReport removegames = 3;
inline int UserGameListReportReq::removegames_size() const {
  return removegames_.size();
}
inline void UserGameListReportReq::clear_removegames() {
  removegames_.Clear();
}
inline const ::pp::GameReport& UserGameListReportReq::removegames(int index) const {
  return removegames_.Get(index);
}
inline ::pp::GameReport* UserGameListReportReq::mutable_removegames(int index) {
  return removegames_.Mutable(index);
}
inline ::pp::GameReport* UserGameListReportReq::add_removegames() {
  return removegames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameReport >&
UserGameListReportReq::removegames() const {
  return removegames_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameReport >*
UserGameListReportReq::mutable_removegames() {
  return &removegames_;
}

// -------------------------------------------------------------------

// UserGameListReportRes

// optional bool cleanold = 1;
inline bool UserGameListReportRes::has_cleanold() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGameListReportRes::set_has_cleanold() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGameListReportRes::clear_has_cleanold() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGameListReportRes::clear_cleanold() {
  cleanold_ = false;
  clear_has_cleanold();
}
inline bool UserGameListReportRes::cleanold() const {
  return cleanold_;
}
inline void UserGameListReportRes::set_cleanold(bool value) {
  set_has_cleanold();
  cleanold_ = value;
}

// repeated .pp.GameInfo addgames = 2;
inline int UserGameListReportRes::addgames_size() const {
  return addgames_.size();
}
inline void UserGameListReportRes::clear_addgames() {
  addgames_.Clear();
}
inline const ::pp::GameInfo& UserGameListReportRes::addgames(int index) const {
  return addgames_.Get(index);
}
inline ::pp::GameInfo* UserGameListReportRes::mutable_addgames(int index) {
  return addgames_.Mutable(index);
}
inline ::pp::GameInfo* UserGameListReportRes::add_addgames() {
  return addgames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
UserGameListReportRes::addgames() const {
  return addgames_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
UserGameListReportRes::mutable_addgames() {
  return &addgames_;
}

// repeated uint32 removesid = 3;
inline int UserGameListReportRes::removesid_size() const {
  return removesid_.size();
}
inline void UserGameListReportRes::clear_removesid() {
  removesid_.Clear();
}
inline ::google::protobuf::uint32 UserGameListReportRes::removesid(int index) const {
  return removesid_.Get(index);
}
inline void UserGameListReportRes::set_removesid(int index, ::google::protobuf::uint32 value) {
  removesid_.Set(index, value);
}
inline void UserGameListReportRes::add_removesid(::google::protobuf::uint32 value) {
  removesid_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UserGameListReportRes::removesid() const {
  return removesid_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UserGameListReportRes::mutable_removesid() {
  return &removesid_;
}

// -------------------------------------------------------------------

// UserGameRunReportReq

// required uint32 gameid = 1;
inline bool UserGameRunReportReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserGameRunReportReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserGameRunReportReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserGameRunReportReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 UserGameRunReportReq::gameid() const {
  return gameid_;
}
inline void UserGameRunReportReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .pp.GameRunReportType type = 2;
inline bool UserGameRunReportReq::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserGameRunReportReq::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserGameRunReportReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserGameRunReportReq::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pp::GameRunReportType UserGameRunReportReq::type() const {
  return static_cast< ::pp::GameRunReportType >(type_);
}
inline void UserGameRunReportReq::set_type(::pp::GameRunReportType value) {
  assert(::pp::GameRunReportType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UserGameRunReportRes

// -------------------------------------------------------------------

// GameGiftListReq

// required uint32 gameId = 1;
inline bool GameGiftListReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGiftListReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGiftListReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGiftListReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameGiftListReq::gameid() const {
  return gameid_;
}
inline void GameGiftListReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 index = 2;
inline bool GameGiftListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGiftListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGiftListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGiftListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameGiftListReq::index() const {
  return index_;
}
inline void GameGiftListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GameGiftListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameGiftListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameGiftListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameGiftListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameGiftListReq::fetchs() const {
  return fetchs_;
}
inline void GameGiftListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// GameGiftListRes

// optional uint32 index = 2;
inline bool GameGiftListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGiftListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGiftListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGiftListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameGiftListRes::index() const {
  return index_;
}
inline void GameGiftListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 3;
inline bool GameGiftListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameGiftListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameGiftListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameGiftListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GameGiftListRes::total() const {
  return total_;
}
inline void GameGiftListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 gameId = 4;
inline bool GameGiftListRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameGiftListRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameGiftListRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameGiftListRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameGiftListRes::gameid() const {
  return gameid_;
}
inline void GameGiftListRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 bookedNum = 5;
inline bool GameGiftListRes::has_bookednum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameGiftListRes::set_has_bookednum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameGiftListRes::clear_has_bookednum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameGiftListRes::clear_bookednum() {
  bookednum_ = 0u;
  clear_has_bookednum();
}
inline ::google::protobuf::uint32 GameGiftListRes::bookednum() const {
  return bookednum_;
}
inline void GameGiftListRes::set_bookednum(::google::protobuf::uint32 value) {
  set_has_bookednum();
  bookednum_ = value;
}

// optional bool booked = 6;
inline bool GameGiftListRes::has_booked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameGiftListRes::set_has_booked() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameGiftListRes::clear_has_booked() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameGiftListRes::clear_booked() {
  booked_ = false;
  clear_has_booked();
}
inline bool GameGiftListRes::booked() const {
  return booked_;
}
inline void GameGiftListRes::set_booked(bool value) {
  set_has_booked();
  booked_ = value;
}

// -------------------------------------------------------------------

// GameGiftBookReq

// required uint32 gameId = 1;
inline bool GameGiftBookReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameGiftBookReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameGiftBookReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameGiftBookReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameGiftBookReq::gameid() const {
  return gameid_;
}
inline void GameGiftBookReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GameReservableListReq

// optional uint32 index = 1;
inline bool GameReservableListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameReservableListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameReservableListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameReservableListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameReservableListReq::index() const {
  return index_;
}
inline void GameReservableListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool GameReservableListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameReservableListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameReservableListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameReservableListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameReservableListReq::fetchs() const {
  return fetchs_;
}
inline void GameReservableListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// GameReservableListRes

// repeated .pp.GameReservableRecord records = 1;
inline int GameReservableListRes::records_size() const {
  return records_.size();
}
inline void GameReservableListRes::clear_records() {
  records_.Clear();
}
inline const ::pp::GameReservableRecord& GameReservableListRes::records(int index) const {
  return records_.Get(index);
}
inline ::pp::GameReservableRecord* GameReservableListRes::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::pp::GameReservableRecord* GameReservableListRes::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameReservableRecord >&
GameReservableListRes::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameReservableRecord >*
GameReservableListRes::mutable_records() {
  return &records_;
}

// optional uint32 index = 2;
inline bool GameReservableListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameReservableListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameReservableListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameReservableListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameReservableListRes::index() const {
  return index_;
}
inline void GameReservableListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 3;
inline bool GameReservableListRes::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameReservableListRes::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameReservableListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameReservableListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GameReservableListRes::total() const {
  return total_;
}
inline void GameReservableListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// -------------------------------------------------------------------

// GameSearchReq

// optional uint32 index = 1;
inline bool GameSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSearchReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameSearchReq::index() const {
  return index_;
}
inline void GameSearchReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool GameSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameSearchReq::fetchs() const {
  return fetchs_;
}
inline void GameSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional string keyword = 3;
inline bool GameSearchReq::has_keyword() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameSearchReq::set_has_keyword() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameSearchReq::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameSearchReq::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GameSearchReq::keyword() const {
  return *keyword_;
}
inline void GameSearchReq::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameSearchReq::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameSearchReq::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameSearchReq::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GameSearchReq::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameSearchReq::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 gameids = 4;
inline int GameSearchReq::gameids_size() const {
  return gameids_.size();
}
inline void GameSearchReq::clear_gameids() {
  gameids_.Clear();
}
inline ::google::protobuf::uint32 GameSearchReq::gameids(int index) const {
  return gameids_.Get(index);
}
inline void GameSearchReq::set_gameids(int index, ::google::protobuf::uint32 value) {
  gameids_.Set(index, value);
}
inline void GameSearchReq::add_gameids(::google::protobuf::uint32 value) {
  gameids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameSearchReq::gameids() const {
  return gameids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameSearchReq::mutable_gameids() {
  return &gameids_;
}

// optional uint64 groupid = 5;
inline bool GameSearchReq::has_groupid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameSearchReq::set_has_groupid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameSearchReq::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameSearchReq::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 GameSearchReq::groupid() const {
  return groupid_;
}
inline void GameSearchReq::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional .pp.GameSearchFilter filterby = 6;
inline bool GameSearchReq::has_filterby() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameSearchReq::set_has_filterby() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameSearchReq::clear_has_filterby() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameSearchReq::clear_filterby() {
  filterby_ = 0;
  clear_has_filterby();
}
inline ::pp::GameSearchFilter GameSearchReq::filterby() const {
  return static_cast< ::pp::GameSearchFilter >(filterby_);
}
inline void GameSearchReq::set_filterby(::pp::GameSearchFilter value) {
  assert(::pp::GameSearchFilter_IsValid(value));
  set_has_filterby();
  filterby_ = value;
}

// optional .pp.GameSearchSortBy sortby = 7;
inline bool GameSearchReq::has_sortby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameSearchReq::set_has_sortby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameSearchReq::clear_has_sortby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameSearchReq::clear_sortby() {
  sortby_ = 0;
  clear_has_sortby();
}
inline ::pp::GameSearchSortBy GameSearchReq::sortby() const {
  return static_cast< ::pp::GameSearchSortBy >(sortby_);
}
inline void GameSearchReq::set_sortby(::pp::GameSearchSortBy value) {
  assert(::pp::GameSearchSortBy_IsValid(value));
  set_has_sortby();
  sortby_ = value;
}

// optional .pp.GameInfo template = 8;
inline bool GameSearchReq::has_template_() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameSearchReq::set_has_template_() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameSearchReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameSearchReq::clear_template_() {
  if (template__ != NULL) template__->::pp::GameInfo::Clear();
  clear_has_template_();
}
inline const ::pp::GameInfo& GameSearchReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::GameInfo* GameSearchReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::GameInfo;
  return template__;
}
inline ::pp::GameInfo* GameSearchReq::release_template_() {
  clear_has_template_();
  ::pp::GameInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void GameSearchReq::set_allocated_template_(::pp::GameInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// -------------------------------------------------------------------

// GameSearchRes

// optional uint32 index = 1;
inline bool GameSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSearchRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameSearchRes::index() const {
  return index_;
}
inline void GameSearchRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool GameSearchRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSearchRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSearchRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSearchRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameSearchRes::fetchs() const {
  return fetchs_;
}
inline void GameSearchRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 totalresults = 3;
inline bool GameSearchRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameSearchRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameSearchRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameSearchRes::clear_totalresults() {
  totalresults_ = 0u;
  clear_has_totalresults();
}
inline ::google::protobuf::uint32 GameSearchRes::totalresults() const {
  return totalresults_;
}
inline void GameSearchRes::set_totalresults(::google::protobuf::uint32 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// optional string keyword = 4;
inline bool GameSearchRes::has_keyword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameSearchRes::set_has_keyword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameSearchRes::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameSearchRes::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GameSearchRes::keyword() const {
  return *keyword_;
}
inline void GameSearchRes::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameSearchRes::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameSearchRes::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameSearchRes::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GameSearchRes::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameSearchRes::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated uint32 gameids = 5;
inline int GameSearchRes::gameids_size() const {
  return gameids_.size();
}
inline void GameSearchRes::clear_gameids() {
  gameids_.Clear();
}
inline ::google::protobuf::uint32 GameSearchRes::gameids(int index) const {
  return gameids_.Get(index);
}
inline void GameSearchRes::set_gameids(int index, ::google::protobuf::uint32 value) {
  gameids_.Set(index, value);
}
inline void GameSearchRes::add_gameids(::google::protobuf::uint32 value) {
  gameids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
GameSearchRes::gameids() const {
  return gameids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
GameSearchRes::mutable_gameids() {
  return &gameids_;
}

// optional uint64 groupid = 6;
inline bool GameSearchRes::has_groupid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameSearchRes::set_has_groupid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameSearchRes::clear_has_groupid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameSearchRes::clear_groupid() {
  groupid_ = GOOGLE_ULONGLONG(0);
  clear_has_groupid();
}
inline ::google::protobuf::uint64 GameSearchRes::groupid() const {
  return groupid_;
}
inline void GameSearchRes::set_groupid(::google::protobuf::uint64 value) {
  set_has_groupid();
  groupid_ = value;
}

// optional .pp.GameSearchFilter filterby = 7;
inline bool GameSearchRes::has_filterby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameSearchRes::set_has_filterby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameSearchRes::clear_has_filterby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameSearchRes::clear_filterby() {
  filterby_ = 0;
  clear_has_filterby();
}
inline ::pp::GameSearchFilter GameSearchRes::filterby() const {
  return static_cast< ::pp::GameSearchFilter >(filterby_);
}
inline void GameSearchRes::set_filterby(::pp::GameSearchFilter value) {
  assert(::pp::GameSearchFilter_IsValid(value));
  set_has_filterby();
  filterby_ = value;
}

// optional .pp.GameSearchSortBy sortby = 8;
inline bool GameSearchRes::has_sortby() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GameSearchRes::set_has_sortby() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GameSearchRes::clear_has_sortby() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GameSearchRes::clear_sortby() {
  sortby_ = 0;
  clear_has_sortby();
}
inline ::pp::GameSearchSortBy GameSearchRes::sortby() const {
  return static_cast< ::pp::GameSearchSortBy >(sortby_);
}
inline void GameSearchRes::set_sortby(::pp::GameSearchSortBy value) {
  assert(::pp::GameSearchSortBy_IsValid(value));
  set_has_sortby();
  sortby_ = value;
}

// repeated .pp.GameInfo games = 9;
inline int GameSearchRes::games_size() const {
  return games_.size();
}
inline void GameSearchRes::clear_games() {
  games_.Clear();
}
inline const ::pp::GameInfo& GameSearchRes::games(int index) const {
  return games_.Get(index);
}
inline ::pp::GameInfo* GameSearchRes::mutable_games(int index) {
  return games_.Mutable(index);
}
inline ::pp::GameInfo* GameSearchRes::add_games() {
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
GameSearchRes::games() const {
  return games_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
GameSearchRes::mutable_games() {
  return &games_;
}

// -------------------------------------------------------------------

// ModifyGroupGameReq

// required uint64 gid = 1;
inline bool ModifyGroupGameReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupGameReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupGameReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupGameReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ModifyGroupGameReq::gid() const {
  return gid_;
}
inline void ModifyGroupGameReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated uint32 addgameids = 2;
inline int ModifyGroupGameReq::addgameids_size() const {
  return addgameids_.size();
}
inline void ModifyGroupGameReq::clear_addgameids() {
  addgameids_.Clear();
}
inline ::google::protobuf::uint32 ModifyGroupGameReq::addgameids(int index) const {
  return addgameids_.Get(index);
}
inline void ModifyGroupGameReq::set_addgameids(int index, ::google::protobuf::uint32 value) {
  addgameids_.Set(index, value);
}
inline void ModifyGroupGameReq::add_addgameids(::google::protobuf::uint32 value) {
  addgameids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ModifyGroupGameReq::addgameids() const {
  return addgameids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ModifyGroupGameReq::mutable_addgameids() {
  return &addgameids_;
}

// repeated uint32 removegameids = 3;
inline int ModifyGroupGameReq::removegameids_size() const {
  return removegameids_.size();
}
inline void ModifyGroupGameReq::clear_removegameids() {
  removegameids_.Clear();
}
inline ::google::protobuf::uint32 ModifyGroupGameReq::removegameids(int index) const {
  return removegameids_.Get(index);
}
inline void ModifyGroupGameReq::set_removegameids(int index, ::google::protobuf::uint32 value) {
  removegameids_.Set(index, value);
}
inline void ModifyGroupGameReq::add_removegameids(::google::protobuf::uint32 value) {
  removegameids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ModifyGroupGameReq::removegameids() const {
  return removegameids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ModifyGroupGameReq::mutable_removegameids() {
  return &removegameids_;
}

// -------------------------------------------------------------------

// ModifyGroupGameRes

// required uint64 gid = 1;
inline bool ModifyGroupGameRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupGameRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupGameRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupGameRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ModifyGroupGameRes::gid() const {
  return gid_;
}
inline void ModifyGroupGameRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated uint32 addgameids = 2;
inline int ModifyGroupGameRes::addgameids_size() const {
  return addgameids_.size();
}
inline void ModifyGroupGameRes::clear_addgameids() {
  addgameids_.Clear();
}
inline ::google::protobuf::uint32 ModifyGroupGameRes::addgameids(int index) const {
  return addgameids_.Get(index);
}
inline void ModifyGroupGameRes::set_addgameids(int index, ::google::protobuf::uint32 value) {
  addgameids_.Set(index, value);
}
inline void ModifyGroupGameRes::add_addgameids(::google::protobuf::uint32 value) {
  addgameids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ModifyGroupGameRes::addgameids() const {
  return addgameids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ModifyGroupGameRes::mutable_addgameids() {
  return &addgameids_;
}

// repeated uint32 removegameids = 3;
inline int ModifyGroupGameRes::removegameids_size() const {
  return removegameids_.size();
}
inline void ModifyGroupGameRes::clear_removegameids() {
  removegameids_.Clear();
}
inline ::google::protobuf::uint32 ModifyGroupGameRes::removegameids(int index) const {
  return removegameids_.Get(index);
}
inline void ModifyGroupGameRes::set_removegameids(int index, ::google::protobuf::uint32 value) {
  removegameids_.Set(index, value);
}
inline void ModifyGroupGameRes::add_removegameids(::google::protobuf::uint32 value) {
  removegameids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
ModifyGroupGameRes::removegameids() const {
  return removegameids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
ModifyGroupGameRes::mutable_removegameids() {
  return &removegameids_;
}

// -------------------------------------------------------------------

// DiscountInfo

// required uint32 gameid = 1;
inline bool DiscountInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DiscountInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DiscountInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DiscountInfo::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 DiscountInfo::gameid() const {
  return gameid_;
}
inline void DiscountInfo::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional string goods = 2;
inline bool DiscountInfo::has_goods() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DiscountInfo::set_has_goods() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DiscountInfo::clear_has_goods() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DiscountInfo::clear_goods() {
  if (goods_ != &::google::protobuf::internal::kEmptyString) {
    goods_->clear();
  }
  clear_has_goods();
}
inline const ::std::string& DiscountInfo::goods() const {
  return *goods_;
}
inline void DiscountInfo::set_goods(const ::std::string& value) {
  set_has_goods();
  if (goods_ == &::google::protobuf::internal::kEmptyString) {
    goods_ = new ::std::string;
  }
  goods_->assign(value);
}
inline void DiscountInfo::set_goods(const char* value) {
  set_has_goods();
  if (goods_ == &::google::protobuf::internal::kEmptyString) {
    goods_ = new ::std::string;
  }
  goods_->assign(value);
}
inline void DiscountInfo::set_goods(const char* value, size_t size) {
  set_has_goods();
  if (goods_ == &::google::protobuf::internal::kEmptyString) {
    goods_ = new ::std::string;
  }
  goods_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscountInfo::mutable_goods() {
  set_has_goods();
  if (goods_ == &::google::protobuf::internal::kEmptyString) {
    goods_ = new ::std::string;
  }
  return goods_;
}
inline ::std::string* DiscountInfo::release_goods() {
  clear_has_goods();
  if (goods_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = goods_;
    goods_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscountInfo::set_allocated_goods(::std::string* goods) {
  if (goods_ != &::google::protobuf::internal::kEmptyString) {
    delete goods_;
  }
  if (goods) {
    set_has_goods();
    goods_ = goods;
  } else {
    clear_has_goods();
    goods_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string OriginalPrice = 3;
inline bool DiscountInfo::has_originalprice() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DiscountInfo::set_has_originalprice() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DiscountInfo::clear_has_originalprice() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DiscountInfo::clear_originalprice() {
  if (originalprice_ != &::google::protobuf::internal::kEmptyString) {
    originalprice_->clear();
  }
  clear_has_originalprice();
}
inline const ::std::string& DiscountInfo::originalprice() const {
  return *originalprice_;
}
inline void DiscountInfo::set_originalprice(const ::std::string& value) {
  set_has_originalprice();
  if (originalprice_ == &::google::protobuf::internal::kEmptyString) {
    originalprice_ = new ::std::string;
  }
  originalprice_->assign(value);
}
inline void DiscountInfo::set_originalprice(const char* value) {
  set_has_originalprice();
  if (originalprice_ == &::google::protobuf::internal::kEmptyString) {
    originalprice_ = new ::std::string;
  }
  originalprice_->assign(value);
}
inline void DiscountInfo::set_originalprice(const char* value, size_t size) {
  set_has_originalprice();
  if (originalprice_ == &::google::protobuf::internal::kEmptyString) {
    originalprice_ = new ::std::string;
  }
  originalprice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscountInfo::mutable_originalprice() {
  set_has_originalprice();
  if (originalprice_ == &::google::protobuf::internal::kEmptyString) {
    originalprice_ = new ::std::string;
  }
  return originalprice_;
}
inline ::std::string* DiscountInfo::release_originalprice() {
  clear_has_originalprice();
  if (originalprice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = originalprice_;
    originalprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscountInfo::set_allocated_originalprice(::std::string* originalprice) {
  if (originalprice_ != &::google::protobuf::internal::kEmptyString) {
    delete originalprice_;
  }
  if (originalprice) {
    set_has_originalprice();
    originalprice_ = originalprice;
  } else {
    clear_has_originalprice();
    originalprice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string FirstDiscount = 4;
inline bool DiscountInfo::has_firstdiscount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DiscountInfo::set_has_firstdiscount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DiscountInfo::clear_has_firstdiscount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DiscountInfo::clear_firstdiscount() {
  if (firstdiscount_ != &::google::protobuf::internal::kEmptyString) {
    firstdiscount_->clear();
  }
  clear_has_firstdiscount();
}
inline const ::std::string& DiscountInfo::firstdiscount() const {
  return *firstdiscount_;
}
inline void DiscountInfo::set_firstdiscount(const ::std::string& value) {
  set_has_firstdiscount();
  if (firstdiscount_ == &::google::protobuf::internal::kEmptyString) {
    firstdiscount_ = new ::std::string;
  }
  firstdiscount_->assign(value);
}
inline void DiscountInfo::set_firstdiscount(const char* value) {
  set_has_firstdiscount();
  if (firstdiscount_ == &::google::protobuf::internal::kEmptyString) {
    firstdiscount_ = new ::std::string;
  }
  firstdiscount_->assign(value);
}
inline void DiscountInfo::set_firstdiscount(const char* value, size_t size) {
  set_has_firstdiscount();
  if (firstdiscount_ == &::google::protobuf::internal::kEmptyString) {
    firstdiscount_ = new ::std::string;
  }
  firstdiscount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscountInfo::mutable_firstdiscount() {
  set_has_firstdiscount();
  if (firstdiscount_ == &::google::protobuf::internal::kEmptyString) {
    firstdiscount_ = new ::std::string;
  }
  return firstdiscount_;
}
inline ::std::string* DiscountInfo::release_firstdiscount() {
  clear_has_firstdiscount();
  if (firstdiscount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = firstdiscount_;
    firstdiscount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscountInfo::set_allocated_firstdiscount(::std::string* firstdiscount) {
  if (firstdiscount_ != &::google::protobuf::internal::kEmptyString) {
    delete firstdiscount_;
  }
  if (firstdiscount) {
    set_has_firstdiscount();
    firstdiscount_ = firstdiscount;
  } else {
    clear_has_firstdiscount();
    firstdiscount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string FollowDiscount = 5;
inline bool DiscountInfo::has_followdiscount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DiscountInfo::set_has_followdiscount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DiscountInfo::clear_has_followdiscount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DiscountInfo::clear_followdiscount() {
  if (followdiscount_ != &::google::protobuf::internal::kEmptyString) {
    followdiscount_->clear();
  }
  clear_has_followdiscount();
}
inline const ::std::string& DiscountInfo::followdiscount() const {
  return *followdiscount_;
}
inline void DiscountInfo::set_followdiscount(const ::std::string& value) {
  set_has_followdiscount();
  if (followdiscount_ == &::google::protobuf::internal::kEmptyString) {
    followdiscount_ = new ::std::string;
  }
  followdiscount_->assign(value);
}
inline void DiscountInfo::set_followdiscount(const char* value) {
  set_has_followdiscount();
  if (followdiscount_ == &::google::protobuf::internal::kEmptyString) {
    followdiscount_ = new ::std::string;
  }
  followdiscount_->assign(value);
}
inline void DiscountInfo::set_followdiscount(const char* value, size_t size) {
  set_has_followdiscount();
  if (followdiscount_ == &::google::protobuf::internal::kEmptyString) {
    followdiscount_ = new ::std::string;
  }
  followdiscount_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DiscountInfo::mutable_followdiscount() {
  set_has_followdiscount();
  if (followdiscount_ == &::google::protobuf::internal::kEmptyString) {
    followdiscount_ = new ::std::string;
  }
  return followdiscount_;
}
inline ::std::string* DiscountInfo::release_followdiscount() {
  clear_has_followdiscount();
  if (followdiscount_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = followdiscount_;
    followdiscount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DiscountInfo::set_allocated_followdiscount(::std::string* followdiscount) {
  if (followdiscount_ != &::google::protobuf::internal::kEmptyString) {
    delete followdiscount_;
  }
  if (followdiscount) {
    set_has_followdiscount();
    followdiscount_ = followdiscount;
  } else {
    clear_has_followdiscount();
    followdiscount_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 id = 6;
inline bool DiscountInfo::has_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DiscountInfo::set_has_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DiscountInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DiscountInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 DiscountInfo::id() const {
  return id_;
}
inline void DiscountInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint32 status = 7;
inline bool DiscountInfo::has_status() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void DiscountInfo::set_has_status() {
  _has_bits_[0] |= 0x00000040u;
}
inline void DiscountInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void DiscountInfo::clear_status() {
  status_ = 0u;
  clear_has_status();
}
inline ::google::protobuf::uint32 DiscountInfo::status() const {
  return status_;
}
inline void DiscountInfo::set_status(::google::protobuf::uint32 value) {
  set_has_status();
  status_ = value;
}

// optional float original = 8;
inline bool DiscountInfo::has_original() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void DiscountInfo::set_has_original() {
  _has_bits_[0] |= 0x00000080u;
}
inline void DiscountInfo::clear_has_original() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void DiscountInfo::clear_original() {
  original_ = 0;
  clear_has_original();
}
inline float DiscountInfo::original() const {
  return original_;
}
inline void DiscountInfo::set_original(float value) {
  set_has_original();
  original_ = value;
}

// optional float first = 9;
inline bool DiscountInfo::has_first() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void DiscountInfo::set_has_first() {
  _has_bits_[0] |= 0x00000100u;
}
inline void DiscountInfo::clear_has_first() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void DiscountInfo::clear_first() {
  first_ = 0;
  clear_has_first();
}
inline float DiscountInfo::first() const {
  return first_;
}
inline void DiscountInfo::set_first(float value) {
  set_has_first();
  first_ = value;
}

// optional float follow = 10;
inline bool DiscountInfo::has_follow() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void DiscountInfo::set_has_follow() {
  _has_bits_[0] |= 0x00000200u;
}
inline void DiscountInfo::clear_has_follow() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void DiscountInfo::clear_follow() {
  follow_ = 0;
  clear_has_follow();
}
inline float DiscountInfo::follow() const {
  return follow_;
}
inline void DiscountInfo::set_follow(float value) {
  set_has_follow();
  follow_ = value;
}

// optional .pp.GameInfo gameInfo = 11;
inline bool DiscountInfo::has_gameinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void DiscountInfo::set_has_gameinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void DiscountInfo::clear_has_gameinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void DiscountInfo::clear_gameinfo() {
  if (gameinfo_ != NULL) gameinfo_->::pp::GameInfo::Clear();
  clear_has_gameinfo();
}
inline const ::pp::GameInfo& DiscountInfo::gameinfo() const {
  return gameinfo_ != NULL ? *gameinfo_ : *default_instance_->gameinfo_;
}
inline ::pp::GameInfo* DiscountInfo::mutable_gameinfo() {
  set_has_gameinfo();
  if (gameinfo_ == NULL) gameinfo_ = new ::pp::GameInfo;
  return gameinfo_;
}
inline ::pp::GameInfo* DiscountInfo::release_gameinfo() {
  clear_has_gameinfo();
  ::pp::GameInfo* temp = gameinfo_;
  gameinfo_ = NULL;
  return temp;
}
inline void DiscountInfo::set_allocated_gameinfo(::pp::GameInfo* gameinfo) {
  delete gameinfo_;
  gameinfo_ = gameinfo;
  if (gameinfo) {
    set_has_gameinfo();
  } else {
    clear_has_gameinfo();
  }
}

// optional uint32 sortOrder = 12;
inline bool DiscountInfo::has_sortorder() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void DiscountInfo::set_has_sortorder() {
  _has_bits_[0] |= 0x00000800u;
}
inline void DiscountInfo::clear_has_sortorder() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void DiscountInfo::clear_sortorder() {
  sortorder_ = 0u;
  clear_has_sortorder();
}
inline ::google::protobuf::uint32 DiscountInfo::sortorder() const {
  return sortorder_;
}
inline void DiscountInfo::set_sortorder(::google::protobuf::uint32 value) {
  set_has_sortorder();
  sortorder_ = value;
}

// -------------------------------------------------------------------

// GameDiscountListReq

// required uint32 gameid = 1;
inline bool GameDiscountListReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameDiscountListReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameDiscountListReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameDiscountListReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameDiscountListReq::gameid() const {
  return gameid_;
}
inline void GameDiscountListReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 index = 2;
inline bool GameDiscountListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameDiscountListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameDiscountListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameDiscountListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameDiscountListReq::index() const {
  return index_;
}
inline void GameDiscountListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GameDiscountListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameDiscountListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameDiscountListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameDiscountListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameDiscountListReq::fetchs() const {
  return fetchs_;
}
inline void GameDiscountListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// GameDiscountListRes

// required uint32 gameid = 1;
inline bool GameDiscountListRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameDiscountListRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameDiscountListRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameDiscountListRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GameDiscountListRes::gameid() const {
  return gameid_;
}
inline void GameDiscountListRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .pp.DiscountInfo discounts = 2;
inline int GameDiscountListRes::discounts_size() const {
  return discounts_.size();
}
inline void GameDiscountListRes::clear_discounts() {
  discounts_.Clear();
}
inline const ::pp::DiscountInfo& GameDiscountListRes::discounts(int index) const {
  return discounts_.Get(index);
}
inline ::pp::DiscountInfo* GameDiscountListRes::mutable_discounts(int index) {
  return discounts_.Mutable(index);
}
inline ::pp::DiscountInfo* GameDiscountListRes::add_discounts() {
  return discounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >&
GameDiscountListRes::discounts() const {
  return discounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >*
GameDiscountListRes::mutable_discounts() {
  return &discounts_;
}

// optional uint32 index = 3;
inline bool GameDiscountListRes::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameDiscountListRes::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameDiscountListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameDiscountListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameDiscountListRes::index() const {
  return index_;
}
inline void GameDiscountListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 4;
inline bool GameDiscountListRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameDiscountListRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameDiscountListRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameDiscountListRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameDiscountListRes::fetchs() const {
  return fetchs_;
}
inline void GameDiscountListRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// ModifyGroupGameApkurlReq

// required uint64 gid = 1;
inline bool ModifyGroupGameApkurlReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupGameApkurlReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupGameApkurlReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupGameApkurlReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ModifyGroupGameApkurlReq::gid() const {
  return gid_;
}
inline void ModifyGroupGameApkurlReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// required uint32 gameid = 2;
inline bool ModifyGroupGameApkurlReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyGroupGameApkurlReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyGroupGameApkurlReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyGroupGameApkurlReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ModifyGroupGameApkurlReq::gameid() const {
  return gameid_;
}
inline void ModifyGroupGameApkurlReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional string apkurl = 3;
inline bool ModifyGroupGameApkurlReq::has_apkurl() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyGroupGameApkurlReq::set_has_apkurl() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyGroupGameApkurlReq::clear_has_apkurl() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyGroupGameApkurlReq::clear_apkurl() {
  if (apkurl_ != &::google::protobuf::internal::kEmptyString) {
    apkurl_->clear();
  }
  clear_has_apkurl();
}
inline const ::std::string& ModifyGroupGameApkurlReq::apkurl() const {
  return *apkurl_;
}
inline void ModifyGroupGameApkurlReq::set_apkurl(const ::std::string& value) {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  apkurl_->assign(value);
}
inline void ModifyGroupGameApkurlReq::set_apkurl(const char* value) {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  apkurl_->assign(value);
}
inline void ModifyGroupGameApkurlReq::set_apkurl(const char* value, size_t size) {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  apkurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyGroupGameApkurlReq::mutable_apkurl() {
  set_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    apkurl_ = new ::std::string;
  }
  return apkurl_;
}
inline ::std::string* ModifyGroupGameApkurlReq::release_apkurl() {
  clear_has_apkurl();
  if (apkurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = apkurl_;
    apkurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyGroupGameApkurlReq::set_allocated_apkurl(::std::string* apkurl) {
  if (apkurl_ != &::google::protobuf::internal::kEmptyString) {
    delete apkurl_;
  }
  if (apkurl) {
    set_has_apkurl();
    apkurl_ = apkurl;
  } else {
    clear_has_apkurl();
    apkurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModifyGroupGameApkurlRes

// -------------------------------------------------------------------

// SendInstallGameMsgReq

// required uint64 gid = 1;
inline bool SendInstallGameMsgReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SendInstallGameMsgReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SendInstallGameMsgReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SendInstallGameMsgReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 SendInstallGameMsgReq::gid() const {
  return gid_;
}
inline void SendInstallGameMsgReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// required uint32 gameid = 2;
inline bool SendInstallGameMsgReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SendInstallGameMsgReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SendInstallGameMsgReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SendInstallGameMsgReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 SendInstallGameMsgReq::gameid() const {
  return gameid_;
}
inline void SendInstallGameMsgReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .pp.SendMsgType sendtype = 3;
inline bool SendInstallGameMsgReq::has_sendtype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SendInstallGameMsgReq::set_has_sendtype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SendInstallGameMsgReq::clear_has_sendtype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SendInstallGameMsgReq::clear_sendtype() {
  sendtype_ = 0;
  clear_has_sendtype();
}
inline ::pp::SendMsgType SendInstallGameMsgReq::sendtype() const {
  return static_cast< ::pp::SendMsgType >(sendtype_);
}
inline void SendInstallGameMsgReq::set_sendtype(::pp::SendMsgType value) {
  assert(::pp::SendMsgType_IsValid(value));
  set_has_sendtype();
  sendtype_ = value;
}

// repeated uint64 uids = 4;
inline int SendInstallGameMsgReq::uids_size() const {
  return uids_.size();
}
inline void SendInstallGameMsgReq::clear_uids() {
  uids_.Clear();
}
inline ::google::protobuf::uint64 SendInstallGameMsgReq::uids(int index) const {
  return uids_.Get(index);
}
inline void SendInstallGameMsgReq::set_uids(int index, ::google::protobuf::uint64 value) {
  uids_.Set(index, value);
}
inline void SendInstallGameMsgReq::add_uids(::google::protobuf::uint64 value) {
  uids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
SendInstallGameMsgReq::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
SendInstallGameMsgReq::mutable_uids() {
  return &uids_;
}

// -------------------------------------------------------------------

// SendInstallGameMsgRes

// -------------------------------------------------------------------

// GameAddReq

// required .pp.GameInfo game = 1;
inline bool GameAddReq::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameAddReq::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameAddReq::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameAddReq::clear_game() {
  if (game_ != NULL) game_->::pp::GameInfo::Clear();
  clear_has_game();
}
inline const ::pp::GameInfo& GameAddReq::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::pp::GameInfo* GameAddReq::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::pp::GameInfo;
  return game_;
}
inline ::pp::GameInfo* GameAddReq::release_game() {
  clear_has_game();
  ::pp::GameInfo* temp = game_;
  game_ = NULL;
  return temp;
}
inline void GameAddReq::set_allocated_game(::pp::GameInfo* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// -------------------------------------------------------------------

// GameAddRes

// optional .pp.GameInfo game = 1;
inline bool GameAddRes::has_game() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameAddRes::set_has_game() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameAddRes::clear_has_game() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameAddRes::clear_game() {
  if (game_ != NULL) game_->::pp::GameInfo::Clear();
  clear_has_game();
}
inline const ::pp::GameInfo& GameAddRes::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::pp::GameInfo* GameAddRes::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::pp::GameInfo;
  return game_;
}
inline ::pp::GameInfo* GameAddRes::release_game() {
  clear_has_game();
  ::pp::GameInfo* temp = game_;
  game_ = NULL;
  return temp;
}
inline void GameAddRes::set_allocated_game(::pp::GameInfo* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// -------------------------------------------------------------------

// GameModifyReq

// required .pp.GameLibType gamelibtype = 1;
inline bool GameModifyReq::has_gamelibtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameModifyReq::set_has_gamelibtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameModifyReq::clear_has_gamelibtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameModifyReq::clear_gamelibtype() {
  gamelibtype_ = 0;
  clear_has_gamelibtype();
}
inline ::pp::GameLibType GameModifyReq::gamelibtype() const {
  return static_cast< ::pp::GameLibType >(gamelibtype_);
}
inline void GameModifyReq::set_gamelibtype(::pp::GameLibType value) {
  assert(::pp::GameLibType_IsValid(value));
  set_has_gamelibtype();
  gamelibtype_ = value;
}

// repeated .pp.GameInfo games = 2;
inline int GameModifyReq::games_size() const {
  return games_.size();
}
inline void GameModifyReq::clear_games() {
  games_.Clear();
}
inline const ::pp::GameInfo& GameModifyReq::games(int index) const {
  return games_.Get(index);
}
inline ::pp::GameInfo* GameModifyReq::mutable_games(int index) {
  return games_.Mutable(index);
}
inline ::pp::GameInfo* GameModifyReq::add_games() {
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
GameModifyReq::games() const {
  return games_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
GameModifyReq::mutable_games() {
  return &games_;
}

// -------------------------------------------------------------------

// GameModifyRes

// required .pp.GameLibType gamelibtype = 1;
inline bool GameModifyRes::has_gamelibtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameModifyRes::set_has_gamelibtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameModifyRes::clear_has_gamelibtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameModifyRes::clear_gamelibtype() {
  gamelibtype_ = 0;
  clear_has_gamelibtype();
}
inline ::pp::GameLibType GameModifyRes::gamelibtype() const {
  return static_cast< ::pp::GameLibType >(gamelibtype_);
}
inline void GameModifyRes::set_gamelibtype(::pp::GameLibType value) {
  assert(::pp::GameLibType_IsValid(value));
  set_has_gamelibtype();
  gamelibtype_ = value;
}

// repeated .pp.GameInfo games = 2;
inline int GameModifyRes::games_size() const {
  return games_.size();
}
inline void GameModifyRes::clear_games() {
  games_.Clear();
}
inline const ::pp::GameInfo& GameModifyRes::games(int index) const {
  return games_.Get(index);
}
inline ::pp::GameInfo* GameModifyRes::mutable_games(int index) {
  return games_.Mutable(index);
}
inline ::pp::GameInfo* GameModifyRes::add_games() {
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
GameModifyRes::games() const {
  return games_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
GameModifyRes::mutable_games() {
  return &games_;
}

// -------------------------------------------------------------------

// ModifyOurGameStateReq

// required uint32 gameid = 1;
inline bool ModifyOurGameStateReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyOurGameStateReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyOurGameStateReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyOurGameStateReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ModifyOurGameStateReq::gameid() const {
  return gameid_;
}
inline void ModifyOurGameStateReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .pp.ModifyGameOpType opType = 2;
inline bool ModifyOurGameStateReq::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyOurGameStateReq::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyOurGameStateReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyOurGameStateReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ModifyGameOpType ModifyOurGameStateReq::optype() const {
  return static_cast< ::pp::ModifyGameOpType >(optype_);
}
inline void ModifyOurGameStateReq::set_optype(::pp::ModifyGameOpType value) {
  assert(::pp::ModifyGameOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// ModifyOurGameStateRes

// required uint32 gameid = 1;
inline bool ModifyOurGameStateRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyOurGameStateRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyOurGameStateRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyOurGameStateRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ModifyOurGameStateRes::gameid() const {
  return gameid_;
}
inline void ModifyOurGameStateRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional .pp.ModifyGameOpType opType = 2;
inline bool ModifyOurGameStateRes::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyOurGameStateRes::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyOurGameStateRes::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyOurGameStateRes::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ModifyGameOpType ModifyOurGameStateRes::optype() const {
  return static_cast< ::pp::ModifyGameOpType >(optype_);
}
inline void ModifyOurGameStateRes::set_optype(::pp::ModifyGameOpType value) {
  assert(::pp::ModifyGameOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// SearchGamesListReq

// required .pp.GameLibType searchType = 1;
inline bool SearchGamesListReq::has_searchtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SearchGamesListReq::set_has_searchtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SearchGamesListReq::clear_has_searchtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SearchGamesListReq::clear_searchtype() {
  searchtype_ = 0;
  clear_has_searchtype();
}
inline ::pp::GameLibType SearchGamesListReq::searchtype() const {
  return static_cast< ::pp::GameLibType >(searchtype_);
}
inline void SearchGamesListReq::set_searchtype(::pp::GameLibType value) {
  assert(::pp::GameLibType_IsValid(value));
  set_has_searchtype();
  searchtype_ = value;
}

// optional string keywords = 2;
inline bool SearchGamesListReq::has_keywords() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchGamesListReq::set_has_keywords() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchGamesListReq::clear_has_keywords() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchGamesListReq::clear_keywords() {
  if (keywords_ != &::google::protobuf::internal::kEmptyString) {
    keywords_->clear();
  }
  clear_has_keywords();
}
inline const ::std::string& SearchGamesListReq::keywords() const {
  return *keywords_;
}
inline void SearchGamesListReq::set_keywords(const ::std::string& value) {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void SearchGamesListReq::set_keywords(const char* value) {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(value);
}
inline void SearchGamesListReq::set_keywords(const char* value, size_t size) {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  keywords_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SearchGamesListReq::mutable_keywords() {
  set_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    keywords_ = new ::std::string;
  }
  return keywords_;
}
inline ::std::string* SearchGamesListReq::release_keywords() {
  clear_has_keywords();
  if (keywords_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keywords_;
    keywords_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SearchGamesListReq::set_allocated_keywords(::std::string* keywords) {
  if (keywords_ != &::google::protobuf::internal::kEmptyString) {
    delete keywords_;
  }
  if (keywords) {
    set_has_keywords();
    keywords_ = keywords;
  } else {
    clear_has_keywords();
    keywords_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 index = 3;
inline bool SearchGamesListReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchGamesListReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchGamesListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchGamesListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SearchGamesListReq::index() const {
  return index_;
}
inline void SearchGamesListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 4;
inline bool SearchGamesListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SearchGamesListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SearchGamesListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SearchGamesListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 SearchGamesListReq::fetchs() const {
  return fetchs_;
}
inline void SearchGamesListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// SearchGamesListRes

// repeated .pp.GameInfo games = 1;
inline int SearchGamesListRes::games_size() const {
  return games_.size();
}
inline void SearchGamesListRes::clear_games() {
  games_.Clear();
}
inline const ::pp::GameInfo& SearchGamesListRes::games(int index) const {
  return games_.Get(index);
}
inline ::pp::GameInfo* SearchGamesListRes::mutable_games(int index) {
  return games_.Mutable(index);
}
inline ::pp::GameInfo* SearchGamesListRes::add_games() {
  return games_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
SearchGamesListRes::games() const {
  return games_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
SearchGamesListRes::mutable_games() {
  return &games_;
}

// optional uint32 index = 2;
inline bool SearchGamesListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SearchGamesListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SearchGamesListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SearchGamesListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 SearchGamesListRes::index() const {
  return index_;
}
inline void SearchGamesListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 3;
inline bool SearchGamesListRes::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SearchGamesListRes::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SearchGamesListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SearchGamesListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 SearchGamesListRes::total() const {
  return total_;
}
inline void SearchGamesListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// -------------------------------------------------------------------

// GameCountReq

// required .pp.GameLibType gamelibtype = 1;
inline bool GameCountReq::has_gamelibtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCountReq::set_has_gamelibtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCountReq::clear_has_gamelibtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCountReq::clear_gamelibtype() {
  gamelibtype_ = 0;
  clear_has_gamelibtype();
}
inline ::pp::GameLibType GameCountReq::gamelibtype() const {
  return static_cast< ::pp::GameLibType >(gamelibtype_);
}
inline void GameCountReq::set_gamelibtype(::pp::GameLibType value) {
  assert(::pp::GameLibType_IsValid(value));
  set_has_gamelibtype();
  gamelibtype_ = value;
}

// -------------------------------------------------------------------

// GameCountRes

// required .pp.GameLibType gamelibtype = 1;
inline bool GameCountRes::has_gamelibtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCountRes::set_has_gamelibtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCountRes::clear_has_gamelibtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCountRes::clear_gamelibtype() {
  gamelibtype_ = 0;
  clear_has_gamelibtype();
}
inline ::pp::GameLibType GameCountRes::gamelibtype() const {
  return static_cast< ::pp::GameLibType >(gamelibtype_);
}
inline void GameCountRes::set_gamelibtype(::pp::GameLibType value) {
  assert(::pp::GameLibType_IsValid(value));
  set_has_gamelibtype();
  gamelibtype_ = value;
}

// optional uint32 count = 2;
inline bool GameCountRes::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameCountRes::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameCountRes::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameCountRes::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 GameCountRes::count() const {
  return count_;
}
inline void GameCountRes::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// RecommendPackNameReq

// required string packname = 1;
inline bool RecommendPackNameReq::has_packname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecommendPackNameReq::set_has_packname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecommendPackNameReq::clear_has_packname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecommendPackNameReq::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& RecommendPackNameReq::packname() const {
  return *packname_;
}
inline void RecommendPackNameReq::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void RecommendPackNameReq::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void RecommendPackNameReq::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecommendPackNameReq::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* RecommendPackNameReq::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecommendPackNameReq::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RecommendPackNameRes

// required string packname = 1;
inline bool RecommendPackNameRes::has_packname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RecommendPackNameRes::set_has_packname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RecommendPackNameRes::clear_has_packname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RecommendPackNameRes::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& RecommendPackNameRes::packname() const {
  return *packname_;
}
inline void RecommendPackNameRes::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void RecommendPackNameRes::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void RecommendPackNameRes::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecommendPackNameRes::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* RecommendPackNameRes::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RecommendPackNameRes::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string recommendName = 2;
inline int RecommendPackNameRes::recommendname_size() const {
  return recommendname_.size();
}
inline void RecommendPackNameRes::clear_recommendname() {
  recommendname_.Clear();
}
inline const ::std::string& RecommendPackNameRes::recommendname(int index) const {
  return recommendname_.Get(index);
}
inline ::std::string* RecommendPackNameRes::mutable_recommendname(int index) {
  return recommendname_.Mutable(index);
}
inline void RecommendPackNameRes::set_recommendname(int index, const ::std::string& value) {
  recommendname_.Mutable(index)->assign(value);
}
inline void RecommendPackNameRes::set_recommendname(int index, const char* value) {
  recommendname_.Mutable(index)->assign(value);
}
inline void RecommendPackNameRes::set_recommendname(int index, const char* value, size_t size) {
  recommendname_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RecommendPackNameRes::add_recommendname() {
  return recommendname_.Add();
}
inline void RecommendPackNameRes::add_recommendname(const ::std::string& value) {
  recommendname_.Add()->assign(value);
}
inline void RecommendPackNameRes::add_recommendname(const char* value) {
  recommendname_.Add()->assign(value);
}
inline void RecommendPackNameRes::add_recommendname(const char* value, size_t size) {
  recommendname_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
RecommendPackNameRes::recommendname() const {
  return recommendname_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
RecommendPackNameRes::mutable_recommendname() {
  return &recommendname_;
}

// -------------------------------------------------------------------

// ModifyGameFilterReq

// optional .pp.ModifyGameOpType opType = 1;
inline bool ModifyGameFilterReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGameFilterReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGameFilterReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGameFilterReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ModifyGameOpType ModifyGameFilterReq::optype() const {
  return static_cast< ::pp::ModifyGameOpType >(optype_);
}
inline void ModifyGameFilterReq::set_optype(::pp::ModifyGameOpType value) {
  assert(::pp::ModifyGameOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional string srcpackname = 2;
inline bool ModifyGameFilterReq::has_srcpackname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyGameFilterReq::set_has_srcpackname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyGameFilterReq::clear_has_srcpackname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyGameFilterReq::clear_srcpackname() {
  if (srcpackname_ != &::google::protobuf::internal::kEmptyString) {
    srcpackname_->clear();
  }
  clear_has_srcpackname();
}
inline const ::std::string& ModifyGameFilterReq::srcpackname() const {
  return *srcpackname_;
}
inline void ModifyGameFilterReq::set_srcpackname(const ::std::string& value) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(value);
}
inline void ModifyGameFilterReq::set_srcpackname(const char* value) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(value);
}
inline void ModifyGameFilterReq::set_srcpackname(const char* value, size_t size) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyGameFilterReq::mutable_srcpackname() {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  return srcpackname_;
}
inline ::std::string* ModifyGameFilterReq::release_srcpackname() {
  clear_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcpackname_;
    srcpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyGameFilterReq::set_allocated_srcpackname(::std::string* srcpackname) {
  if (srcpackname_ != &::google::protobuf::internal::kEmptyString) {
    delete srcpackname_;
  }
  if (srcpackname) {
    set_has_srcpackname();
    srcpackname_ = srcpackname;
  } else {
    clear_has_srcpackname();
    srcpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string packname = 3;
inline bool ModifyGameFilterReq::has_packname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyGameFilterReq::set_has_packname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyGameFilterReq::clear_has_packname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyGameFilterReq::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& ModifyGameFilterReq::packname() const {
  return *packname_;
}
inline void ModifyGameFilterReq::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void ModifyGameFilterReq::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void ModifyGameFilterReq::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyGameFilterReq::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* ModifyGameFilterReq::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyGameFilterReq::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ModifyGameFilterRes

// optional .pp.ModifyGameOpType opType = 1;
inline bool ModifyGameFilterRes::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGameFilterRes::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGameFilterRes::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGameFilterRes::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ModifyGameOpType ModifyGameFilterRes::optype() const {
  return static_cast< ::pp::ModifyGameOpType >(optype_);
}
inline void ModifyGameFilterRes::set_optype(::pp::ModifyGameOpType value) {
  assert(::pp::ModifyGameOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional string srcpackname = 2;
inline bool ModifyGameFilterRes::has_srcpackname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ModifyGameFilterRes::set_has_srcpackname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ModifyGameFilterRes::clear_has_srcpackname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ModifyGameFilterRes::clear_srcpackname() {
  if (srcpackname_ != &::google::protobuf::internal::kEmptyString) {
    srcpackname_->clear();
  }
  clear_has_srcpackname();
}
inline const ::std::string& ModifyGameFilterRes::srcpackname() const {
  return *srcpackname_;
}
inline void ModifyGameFilterRes::set_srcpackname(const ::std::string& value) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(value);
}
inline void ModifyGameFilterRes::set_srcpackname(const char* value) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(value);
}
inline void ModifyGameFilterRes::set_srcpackname(const char* value, size_t size) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyGameFilterRes::mutable_srcpackname() {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  return srcpackname_;
}
inline ::std::string* ModifyGameFilterRes::release_srcpackname() {
  clear_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcpackname_;
    srcpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyGameFilterRes::set_allocated_srcpackname(::std::string* srcpackname) {
  if (srcpackname_ != &::google::protobuf::internal::kEmptyString) {
    delete srcpackname_;
  }
  if (srcpackname) {
    set_has_srcpackname();
    srcpackname_ = srcpackname;
  } else {
    clear_has_srcpackname();
    srcpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string packname = 3;
inline bool ModifyGameFilterRes::has_packname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ModifyGameFilterRes::set_has_packname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ModifyGameFilterRes::clear_has_packname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ModifyGameFilterRes::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& ModifyGameFilterRes::packname() const {
  return *packname_;
}
inline void ModifyGameFilterRes::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void ModifyGameFilterRes::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void ModifyGameFilterRes::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ModifyGameFilterRes::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* ModifyGameFilterRes::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ModifyGameFilterRes::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameFilterInfo

// optional string srcpackname = 1;
inline bool GameFilterInfo::has_srcpackname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameFilterInfo::set_has_srcpackname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameFilterInfo::clear_has_srcpackname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameFilterInfo::clear_srcpackname() {
  if (srcpackname_ != &::google::protobuf::internal::kEmptyString) {
    srcpackname_->clear();
  }
  clear_has_srcpackname();
}
inline const ::std::string& GameFilterInfo::srcpackname() const {
  return *srcpackname_;
}
inline void GameFilterInfo::set_srcpackname(const ::std::string& value) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(value);
}
inline void GameFilterInfo::set_srcpackname(const char* value) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(value);
}
inline void GameFilterInfo::set_srcpackname(const char* value, size_t size) {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  srcpackname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameFilterInfo::mutable_srcpackname() {
  set_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    srcpackname_ = new ::std::string;
  }
  return srcpackname_;
}
inline ::std::string* GameFilterInfo::release_srcpackname() {
  clear_has_srcpackname();
  if (srcpackname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = srcpackname_;
    srcpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameFilterInfo::set_allocated_srcpackname(::std::string* srcpackname) {
  if (srcpackname_ != &::google::protobuf::internal::kEmptyString) {
    delete srcpackname_;
  }
  if (srcpackname) {
    set_has_srcpackname();
    srcpackname_ = srcpackname;
  } else {
    clear_has_srcpackname();
    srcpackname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string packname = 2;
inline bool GameFilterInfo::has_packname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameFilterInfo::set_has_packname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameFilterInfo::clear_has_packname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameFilterInfo::clear_packname() {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    packname_->clear();
  }
  clear_has_packname();
}
inline const ::std::string& GameFilterInfo::packname() const {
  return *packname_;
}
inline void GameFilterInfo::set_packname(const ::std::string& value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void GameFilterInfo::set_packname(const char* value) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(value);
}
inline void GameFilterInfo::set_packname(const char* value, size_t size) {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  packname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameFilterInfo::mutable_packname() {
  set_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    packname_ = new ::std::string;
  }
  return packname_;
}
inline ::std::string* GameFilterInfo::release_packname() {
  clear_has_packname();
  if (packname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = packname_;
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameFilterInfo::set_allocated_packname(::std::string* packname) {
  if (packname_ != &::google::protobuf::internal::kEmptyString) {
    delete packname_;
  }
  if (packname) {
    set_has_packname();
    packname_ = packname;
  } else {
    clear_has_packname();
    packname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GameFilterSearchReq

// optional uint32 index = 1;
inline bool GameFilterSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameFilterSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameFilterSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameFilterSearchReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameFilterSearchReq::index() const {
  return index_;
}
inline void GameFilterSearchReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool GameFilterSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameFilterSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameFilterSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameFilterSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameFilterSearchReq::fetchs() const {
  return fetchs_;
}
inline void GameFilterSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional string keyword = 3;
inline bool GameFilterSearchReq::has_keyword() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameFilterSearchReq::set_has_keyword() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameFilterSearchReq::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameFilterSearchReq::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GameFilterSearchReq::keyword() const {
  return *keyword_;
}
inline void GameFilterSearchReq::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameFilterSearchReq::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameFilterSearchReq::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameFilterSearchReq::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GameFilterSearchReq::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameFilterSearchReq::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GameFilterType filterby = 4;
inline bool GameFilterSearchReq::has_filterby() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameFilterSearchReq::set_has_filterby() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameFilterSearchReq::clear_has_filterby() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameFilterSearchReq::clear_filterby() {
  filterby_ = 0;
  clear_has_filterby();
}
inline ::pp::GameFilterType GameFilterSearchReq::filterby() const {
  return static_cast< ::pp::GameFilterType >(filterby_);
}
inline void GameFilterSearchReq::set_filterby(::pp::GameFilterType value) {
  assert(::pp::GameFilterType_IsValid(value));
  set_has_filterby();
  filterby_ = value;
}

// -------------------------------------------------------------------

// GameFilterSearchRes

// optional uint32 index = 1;
inline bool GameFilterSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameFilterSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameFilterSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameFilterSearchRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameFilterSearchRes::index() const {
  return index_;
}
inline void GameFilterSearchRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool GameFilterSearchRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameFilterSearchRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameFilterSearchRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameFilterSearchRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GameFilterSearchRes::fetchs() const {
  return fetchs_;
}
inline void GameFilterSearchRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional string keyword = 3;
inline bool GameFilterSearchRes::has_keyword() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameFilterSearchRes::set_has_keyword() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameFilterSearchRes::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameFilterSearchRes::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GameFilterSearchRes::keyword() const {
  return *keyword_;
}
inline void GameFilterSearchRes::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameFilterSearchRes::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GameFilterSearchRes::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameFilterSearchRes::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GameFilterSearchRes::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameFilterSearchRes::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GameFilterType filterby = 4;
inline bool GameFilterSearchRes::has_filterby() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameFilterSearchRes::set_has_filterby() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameFilterSearchRes::clear_has_filterby() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameFilterSearchRes::clear_filterby() {
  filterby_ = 0;
  clear_has_filterby();
}
inline ::pp::GameFilterType GameFilterSearchRes::filterby() const {
  return static_cast< ::pp::GameFilterType >(filterby_);
}
inline void GameFilterSearchRes::set_filterby(::pp::GameFilterType value) {
  assert(::pp::GameFilterType_IsValid(value));
  set_has_filterby();
  filterby_ = value;
}

// repeated .pp.GameFilterInfo gameFilters = 5;
inline int GameFilterSearchRes::gamefilters_size() const {
  return gamefilters_.size();
}
inline void GameFilterSearchRes::clear_gamefilters() {
  gamefilters_.Clear();
}
inline const ::pp::GameFilterInfo& GameFilterSearchRes::gamefilters(int index) const {
  return gamefilters_.Get(index);
}
inline ::pp::GameFilterInfo* GameFilterSearchRes::mutable_gamefilters(int index) {
  return gamefilters_.Mutable(index);
}
inline ::pp::GameFilterInfo* GameFilterSearchRes::add_gamefilters() {
  return gamefilters_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameFilterInfo >&
GameFilterSearchRes::gamefilters() const {
  return gamefilters_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameFilterInfo >*
GameFilterSearchRes::mutable_gamefilters() {
  return &gamefilters_;
}

// -------------------------------------------------------------------

// GameSpiderReq

// optional .pp.SpiderSrcFliter srcfilter = 1;
inline bool GameSpiderReq::has_srcfilter() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameSpiderReq::set_has_srcfilter() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameSpiderReq::clear_has_srcfilter() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameSpiderReq::clear_srcfilter() {
  srcfilter_ = 1;
  clear_has_srcfilter();
}
inline ::pp::SpiderSrcFliter GameSpiderReq::srcfilter() const {
  return static_cast< ::pp::SpiderSrcFliter >(srcfilter_);
}
inline void GameSpiderReq::set_srcfilter(::pp::SpiderSrcFliter value) {
  assert(::pp::SpiderSrcFliter_IsValid(value));
  set_has_srcfilter();
  srcfilter_ = value;
}

// optional .pp.SpiderMethodFilter methodfilter = 2;
inline bool GameSpiderReq::has_methodfilter() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameSpiderReq::set_has_methodfilter() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameSpiderReq::clear_has_methodfilter() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameSpiderReq::clear_methodfilter() {
  methodfilter_ = 1;
  clear_has_methodfilter();
}
inline ::pp::SpiderMethodFilter GameSpiderReq::methodfilter() const {
  return static_cast< ::pp::SpiderMethodFilter >(methodfilter_);
}
inline void GameSpiderReq::set_methodfilter(::pp::SpiderMethodFilter value) {
  assert(::pp::SpiderMethodFilter_IsValid(value));
  set_has_methodfilter();
  methodfilter_ = value;
}

// optional uint32 index = 3;
inline bool GameSpiderReq::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameSpiderReq::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameSpiderReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameSpiderReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GameSpiderReq::index() const {
  return index_;
}
inline void GameSpiderReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 pagesize = 4;
inline bool GameSpiderReq::has_pagesize() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameSpiderReq::set_has_pagesize() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameSpiderReq::clear_has_pagesize() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameSpiderReq::clear_pagesize() {
  pagesize_ = 0u;
  clear_has_pagesize();
}
inline ::google::protobuf::uint32 GameSpiderReq::pagesize() const {
  return pagesize_;
}
inline void GameSpiderReq::set_pagesize(::google::protobuf::uint32 value) {
  set_has_pagesize();
  pagesize_ = value;
}

// optional uint32 totalcount = 5;
inline bool GameSpiderReq::has_totalcount() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameSpiderReq::set_has_totalcount() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameSpiderReq::clear_has_totalcount() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameSpiderReq::clear_totalcount() {
  totalcount_ = 0u;
  clear_has_totalcount();
}
inline ::google::protobuf::uint32 GameSpiderReq::totalcount() const {
  return totalcount_;
}
inline void GameSpiderReq::set_totalcount(::google::protobuf::uint32 value) {
  set_has_totalcount();
  totalcount_ = value;
}

// optional uint32 minr = 6;
inline bool GameSpiderReq::has_minr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GameSpiderReq::set_has_minr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GameSpiderReq::clear_has_minr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GameSpiderReq::clear_minr() {
  minr_ = 0u;
  clear_has_minr();
}
inline ::google::protobuf::uint32 GameSpiderReq::minr() const {
  return minr_;
}
inline void GameSpiderReq::set_minr(::google::protobuf::uint32 value) {
  set_has_minr();
  minr_ = value;
}

// optional uint32 maxr = 7;
inline bool GameSpiderReq::has_maxr() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GameSpiderReq::set_has_maxr() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GameSpiderReq::clear_has_maxr() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GameSpiderReq::clear_maxr() {
  maxr_ = 0u;
  clear_has_maxr();
}
inline ::google::protobuf::uint32 GameSpiderReq::maxr() const {
  return maxr_;
}
inline void GameSpiderReq::set_maxr(::google::protobuf::uint32 value) {
  set_has_maxr();
  maxr_ = value;
}

// -------------------------------------------------------------------

// GameSpiderRes

// -------------------------------------------------------------------

// ModifyGameDiscountReq

// required .pp.ModifyGameOpType opType = 1;
inline bool ModifyGameDiscountReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGameDiscountReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGameDiscountReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGameDiscountReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ModifyGameOpType ModifyGameDiscountReq::optype() const {
  return static_cast< ::pp::ModifyGameOpType >(optype_);
}
inline void ModifyGameDiscountReq::set_optype(::pp::ModifyGameOpType value) {
  assert(::pp::ModifyGameOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// repeated .pp.DiscountInfo discounts = 2;
inline int ModifyGameDiscountReq::discounts_size() const {
  return discounts_.size();
}
inline void ModifyGameDiscountReq::clear_discounts() {
  discounts_.Clear();
}
inline const ::pp::DiscountInfo& ModifyGameDiscountReq::discounts(int index) const {
  return discounts_.Get(index);
}
inline ::pp::DiscountInfo* ModifyGameDiscountReq::mutable_discounts(int index) {
  return discounts_.Mutable(index);
}
inline ::pp::DiscountInfo* ModifyGameDiscountReq::add_discounts() {
  return discounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >&
ModifyGameDiscountReq::discounts() const {
  return discounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >*
ModifyGameDiscountReq::mutable_discounts() {
  return &discounts_;
}

// -------------------------------------------------------------------

// ModifyGameDiscountRes

// required .pp.ModifyGameOpType opType = 1;
inline bool ModifyGameDiscountRes::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGameDiscountRes::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGameDiscountRes::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGameDiscountRes::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::ModifyGameOpType ModifyGameDiscountRes::optype() const {
  return static_cast< ::pp::ModifyGameOpType >(optype_);
}
inline void ModifyGameDiscountRes::set_optype(::pp::ModifyGameOpType value) {
  assert(::pp::ModifyGameOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// repeated .pp.DiscountInfo discounts = 2;
inline int ModifyGameDiscountRes::discounts_size() const {
  return discounts_.size();
}
inline void ModifyGameDiscountRes::clear_discounts() {
  discounts_.Clear();
}
inline const ::pp::DiscountInfo& ModifyGameDiscountRes::discounts(int index) const {
  return discounts_.Get(index);
}
inline ::pp::DiscountInfo* ModifyGameDiscountRes::mutable_discounts(int index) {
  return discounts_.Mutable(index);
}
inline ::pp::DiscountInfo* ModifyGameDiscountRes::add_discounts() {
  return discounts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >&
ModifyGameDiscountRes::discounts() const {
  return discounts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::DiscountInfo >*
ModifyGameDiscountRes::mutable_discounts() {
  return &discounts_;
}

// -------------------------------------------------------------------

// ModifyGroupDiscountReq

// required uint32 gameid = 1;
inline bool ModifyGroupDiscountReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupDiscountReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupDiscountReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupDiscountReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ModifyGroupDiscountReq::gameid() const {
  return gameid_;
}
inline void ModifyGroupDiscountReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated uint64 gids = 2;
inline int ModifyGroupDiscountReq::gids_size() const {
  return gids_.size();
}
inline void ModifyGroupDiscountReq::clear_gids() {
  gids_.Clear();
}
inline ::google::protobuf::uint64 ModifyGroupDiscountReq::gids(int index) const {
  return gids_.Get(index);
}
inline void ModifyGroupDiscountReq::set_gids(int index, ::google::protobuf::uint64 value) {
  gids_.Set(index, value);
}
inline void ModifyGroupDiscountReq::add_gids(::google::protobuf::uint64 value) {
  gids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ModifyGroupDiscountReq::gids() const {
  return gids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ModifyGroupDiscountReq::mutable_gids() {
  return &gids_;
}

// -------------------------------------------------------------------

// ModifyGroupDiscountRes

// optional uint32 gameid = 1;
inline bool ModifyGroupDiscountRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ModifyGroupDiscountRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ModifyGroupDiscountRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ModifyGroupDiscountRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 ModifyGroupDiscountRes::gameid() const {
  return gameid_;
}
inline void ModifyGroupDiscountRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated uint64 gids = 2;
inline int ModifyGroupDiscountRes::gids_size() const {
  return gids_.size();
}
inline void ModifyGroupDiscountRes::clear_gids() {
  gids_.Clear();
}
inline ::google::protobuf::uint64 ModifyGroupDiscountRes::gids(int index) const {
  return gids_.Get(index);
}
inline void ModifyGroupDiscountRes::set_gids(int index, ::google::protobuf::uint64 value) {
  gids_.Set(index, value);
}
inline void ModifyGroupDiscountRes::add_gids(::google::protobuf::uint64 value) {
  gids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
ModifyGroupDiscountRes::gids() const {
  return gids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
ModifyGroupDiscountRes::mutable_gids() {
  return &gids_;
}

// -------------------------------------------------------------------

// GroupDiscountListReq

// required uint32 gameid = 1;
inline bool GroupDiscountListReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupDiscountListReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupDiscountListReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupDiscountListReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupDiscountListReq::gameid() const {
  return gameid_;
}
inline void GroupDiscountListReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GroupDiscountListRes

// optional uint32 gameid = 1;
inline bool GroupDiscountListRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupDiscountListRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupDiscountListRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupDiscountListRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupDiscountListRes::gameid() const {
  return gameid_;
}
inline void GroupDiscountListRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional string gids = 2;
inline bool GroupDiscountListRes::has_gids() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupDiscountListRes::set_has_gids() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupDiscountListRes::clear_has_gids() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupDiscountListRes::clear_gids() {
  if (gids_ != &::google::protobuf::internal::kEmptyString) {
    gids_->clear();
  }
  clear_has_gids();
}
inline const ::std::string& GroupDiscountListRes::gids() const {
  return *gids_;
}
inline void GroupDiscountListRes::set_gids(const ::std::string& value) {
  set_has_gids();
  if (gids_ == &::google::protobuf::internal::kEmptyString) {
    gids_ = new ::std::string;
  }
  gids_->assign(value);
}
inline void GroupDiscountListRes::set_gids(const char* value) {
  set_has_gids();
  if (gids_ == &::google::protobuf::internal::kEmptyString) {
    gids_ = new ::std::string;
  }
  gids_->assign(value);
}
inline void GroupDiscountListRes::set_gids(const char* value, size_t size) {
  set_has_gids();
  if (gids_ == &::google::protobuf::internal::kEmptyString) {
    gids_ = new ::std::string;
  }
  gids_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupDiscountListRes::mutable_gids() {
  set_has_gids();
  if (gids_ == &::google::protobuf::internal::kEmptyString) {
    gids_ = new ::std::string;
  }
  return gids_;
}
inline ::std::string* GroupDiscountListRes::release_gids() {
  clear_has_gids();
  if (gids_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gids_;
    gids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupDiscountListRes::set_allocated_gids(::std::string* gids) {
  if (gids_ != &::google::protobuf::internal::kEmptyString) {
    delete gids_;
  }
  if (gids) {
    set_has_gids();
    gids_ = gids;
  } else {
    clear_has_gids();
    gids_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserYYCoinsPayMethodReq

// -------------------------------------------------------------------

// UserYYCoinsPayMethod

// required string name = 1;
inline bool UserYYCoinsPayMethod::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsPayMethod::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsPayMethod::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsPayMethod::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserYYCoinsPayMethod::name() const {
  return *name_;
}
inline void UserYYCoinsPayMethod::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserYYCoinsPayMethod::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserYYCoinsPayMethod::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayMethod::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserYYCoinsPayMethod::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayMethod::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string chId = 2;
inline bool UserYYCoinsPayMethod::has_chid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsPayMethod::set_has_chid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsPayMethod::clear_has_chid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsPayMethod::clear_chid() {
  if (chid_ != &::google::protobuf::internal::kEmptyString) {
    chid_->clear();
  }
  clear_has_chid();
}
inline const ::std::string& UserYYCoinsPayMethod::chid() const {
  return *chid_;
}
inline void UserYYCoinsPayMethod::set_chid(const ::std::string& value) {
  set_has_chid();
  if (chid_ == &::google::protobuf::internal::kEmptyString) {
    chid_ = new ::std::string;
  }
  chid_->assign(value);
}
inline void UserYYCoinsPayMethod::set_chid(const char* value) {
  set_has_chid();
  if (chid_ == &::google::protobuf::internal::kEmptyString) {
    chid_ = new ::std::string;
  }
  chid_->assign(value);
}
inline void UserYYCoinsPayMethod::set_chid(const char* value, size_t size) {
  set_has_chid();
  if (chid_ == &::google::protobuf::internal::kEmptyString) {
    chid_ = new ::std::string;
  }
  chid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayMethod::mutable_chid() {
  set_has_chid();
  if (chid_ == &::google::protobuf::internal::kEmptyString) {
    chid_ = new ::std::string;
  }
  return chid_;
}
inline ::std::string* UserYYCoinsPayMethod::release_chid() {
  clear_has_chid();
  if (chid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = chid_;
    chid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayMethod::set_allocated_chid(::std::string* chid) {
  if (chid_ != &::google::protobuf::internal::kEmptyString) {
    delete chid_;
  }
  if (chid) {
    set_has_chid();
    chid_ = chid;
  } else {
    clear_has_chid();
    chid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string payMethod = 3;
inline bool UserYYCoinsPayMethod::has_paymethod() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsPayMethod::set_has_paymethod() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsPayMethod::clear_has_paymethod() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsPayMethod::clear_paymethod() {
  if (paymethod_ != &::google::protobuf::internal::kEmptyString) {
    paymethod_->clear();
  }
  clear_has_paymethod();
}
inline const ::std::string& UserYYCoinsPayMethod::paymethod() const {
  return *paymethod_;
}
inline void UserYYCoinsPayMethod::set_paymethod(const ::std::string& value) {
  set_has_paymethod();
  if (paymethod_ == &::google::protobuf::internal::kEmptyString) {
    paymethod_ = new ::std::string;
  }
  paymethod_->assign(value);
}
inline void UserYYCoinsPayMethod::set_paymethod(const char* value) {
  set_has_paymethod();
  if (paymethod_ == &::google::protobuf::internal::kEmptyString) {
    paymethod_ = new ::std::string;
  }
  paymethod_->assign(value);
}
inline void UserYYCoinsPayMethod::set_paymethod(const char* value, size_t size) {
  set_has_paymethod();
  if (paymethod_ == &::google::protobuf::internal::kEmptyString) {
    paymethod_ = new ::std::string;
  }
  paymethod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayMethod::mutable_paymethod() {
  set_has_paymethod();
  if (paymethod_ == &::google::protobuf::internal::kEmptyString) {
    paymethod_ = new ::std::string;
  }
  return paymethod_;
}
inline ::std::string* UserYYCoinsPayMethod::release_paymethod() {
  clear_has_paymethod();
  if (paymethod_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paymethod_;
    paymethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayMethod::set_allocated_paymethod(::std::string* paymethod) {
  if (paymethod_ != &::google::protobuf::internal::kEmptyString) {
    delete paymethod_;
  }
  if (paymethod) {
    set_has_paymethod();
    paymethod_ = paymethod;
  } else {
    clear_has_paymethod();
    paymethod_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool tel = 4;
inline bool UserYYCoinsPayMethod::has_tel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserYYCoinsPayMethod::set_has_tel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserYYCoinsPayMethod::clear_has_tel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserYYCoinsPayMethod::clear_tel() {
  tel_ = false;
  clear_has_tel();
}
inline bool UserYYCoinsPayMethod::tel() const {
  return tel_;
}
inline void UserYYCoinsPayMethod::set_tel(bool value) {
  set_has_tel();
  tel_ = value;
}

// optional bool card = 5;
inline bool UserYYCoinsPayMethod::has_card() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserYYCoinsPayMethod::set_has_card() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserYYCoinsPayMethod::clear_has_card() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserYYCoinsPayMethod::clear_card() {
  card_ = false;
  clear_has_card();
}
inline bool UserYYCoinsPayMethod::card() const {
  return card_;
}
inline void UserYYCoinsPayMethod::set_card(bool value) {
  set_has_card();
  card_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsPayMethodRes

// repeated .pp.UserYYCoinsPayMethod methods = 1;
inline int UserYYCoinsPayMethodRes::methods_size() const {
  return methods_.size();
}
inline void UserYYCoinsPayMethodRes::clear_methods() {
  methods_.Clear();
}
inline const ::pp::UserYYCoinsPayMethod& UserYYCoinsPayMethodRes::methods(int index) const {
  return methods_.Get(index);
}
inline ::pp::UserYYCoinsPayMethod* UserYYCoinsPayMethodRes::mutable_methods(int index) {
  return methods_.Mutable(index);
}
inline ::pp::UserYYCoinsPayMethod* UserYYCoinsPayMethodRes::add_methods() {
  return methods_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsPayMethod >&
UserYYCoinsPayMethodRes::methods() const {
  return methods_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsPayMethod >*
UserYYCoinsPayMethodRes::mutable_methods() {
  return &methods_;
}

// -------------------------------------------------------------------

// UserYYCoinsBuyReq

// required uint32 itemId = 1;
inline bool UserYYCoinsBuyReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsBuyReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsBuyReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 UserYYCoinsBuyReq::itemid() const {
  return itemid_;
}
inline void UserYYCoinsBuyReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint32 num = 2;
inline bool UserYYCoinsBuyReq::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsBuyReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsBuyReq::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 UserYYCoinsBuyReq::num() const {
  return num_;
}
inline void UserYYCoinsBuyReq::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional string chId = 3 [default = "Zfb"];
inline bool UserYYCoinsBuyReq::has_chid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_chid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsBuyReq::clear_has_chid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsBuyReq::clear_chid() {
  if (chid_ != _default_chid_) {
    chid_->assign(*_default_chid_);
  }
  clear_has_chid();
}
inline const ::std::string& UserYYCoinsBuyReq::chid() const {
  return *chid_;
}
inline void UserYYCoinsBuyReq::set_chid(const ::std::string& value) {
  set_has_chid();
  if (chid_ == _default_chid_) {
    chid_ = new ::std::string;
  }
  chid_->assign(value);
}
inline void UserYYCoinsBuyReq::set_chid(const char* value) {
  set_has_chid();
  if (chid_ == _default_chid_) {
    chid_ = new ::std::string;
  }
  chid_->assign(value);
}
inline void UserYYCoinsBuyReq::set_chid(const char* value, size_t size) {
  set_has_chid();
  if (chid_ == _default_chid_) {
    chid_ = new ::std::string;
  }
  chid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyReq::mutable_chid() {
  set_has_chid();
  if (chid_ == _default_chid_) {
    chid_ = new ::std::string(*_default_chid_);
  }
  return chid_;
}
inline ::std::string* UserYYCoinsBuyReq::release_chid() {
  clear_has_chid();
  if (chid_ == _default_chid_) {
    return NULL;
  } else {
    ::std::string* temp = chid_;
    chid_ = const_cast< ::std::string*>(_default_chid_);
    return temp;
  }
}
inline void UserYYCoinsBuyReq::set_allocated_chid(::std::string* chid) {
  if (chid_ != _default_chid_) {
    delete chid_;
  }
  if (chid) {
    set_has_chid();
    chid_ = chid;
  } else {
    clear_has_chid();
    chid_ = const_cast< ::std::string*>(_default_chid_);
  }
}

// optional string payMethod = 4 [default = "WapAlipay"];
inline bool UserYYCoinsBuyReq::has_paymethod() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_paymethod() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserYYCoinsBuyReq::clear_has_paymethod() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserYYCoinsBuyReq::clear_paymethod() {
  if (paymethod_ != _default_paymethod_) {
    paymethod_->assign(*_default_paymethod_);
  }
  clear_has_paymethod();
}
inline const ::std::string& UserYYCoinsBuyReq::paymethod() const {
  return *paymethod_;
}
inline void UserYYCoinsBuyReq::set_paymethod(const ::std::string& value) {
  set_has_paymethod();
  if (paymethod_ == _default_paymethod_) {
    paymethod_ = new ::std::string;
  }
  paymethod_->assign(value);
}
inline void UserYYCoinsBuyReq::set_paymethod(const char* value) {
  set_has_paymethod();
  if (paymethod_ == _default_paymethod_) {
    paymethod_ = new ::std::string;
  }
  paymethod_->assign(value);
}
inline void UserYYCoinsBuyReq::set_paymethod(const char* value, size_t size) {
  set_has_paymethod();
  if (paymethod_ == _default_paymethod_) {
    paymethod_ = new ::std::string;
  }
  paymethod_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyReq::mutable_paymethod() {
  set_has_paymethod();
  if (paymethod_ == _default_paymethod_) {
    paymethod_ = new ::std::string(*_default_paymethod_);
  }
  return paymethod_;
}
inline ::std::string* UserYYCoinsBuyReq::release_paymethod() {
  clear_has_paymethod();
  if (paymethod_ == _default_paymethod_) {
    return NULL;
  } else {
    ::std::string* temp = paymethod_;
    paymethod_ = const_cast< ::std::string*>(_default_paymethod_);
    return temp;
  }
}
inline void UserYYCoinsBuyReq::set_allocated_paymethod(::std::string* paymethod) {
  if (paymethod_ != _default_paymethod_) {
    delete paymethod_;
  }
  if (paymethod) {
    set_has_paymethod();
    paymethod_ = paymethod;
  } else {
    clear_has_paymethod();
    paymethod_ = const_cast< ::std::string*>(_default_paymethod_);
  }
}

// optional string tel = 5;
inline bool UserYYCoinsBuyReq::has_tel() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_tel() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserYYCoinsBuyReq::clear_has_tel() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserYYCoinsBuyReq::clear_tel() {
  if (tel_ != &::google::protobuf::internal::kEmptyString) {
    tel_->clear();
  }
  clear_has_tel();
}
inline const ::std::string& UserYYCoinsBuyReq::tel() const {
  return *tel_;
}
inline void UserYYCoinsBuyReq::set_tel(const ::std::string& value) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(value);
}
inline void UserYYCoinsBuyReq::set_tel(const char* value) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(value);
}
inline void UserYYCoinsBuyReq::set_tel(const char* value, size_t size) {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  tel_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyReq::mutable_tel() {
  set_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    tel_ = new ::std::string;
  }
  return tel_;
}
inline ::std::string* UserYYCoinsBuyReq::release_tel() {
  clear_has_tel();
  if (tel_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tel_;
    tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsBuyReq::set_allocated_tel(::std::string* tel) {
  if (tel_ != &::google::protobuf::internal::kEmptyString) {
    delete tel_;
  }
  if (tel) {
    set_has_tel();
    tel_ = tel;
  } else {
    clear_has_tel();
    tel_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cardNum = 6;
inline bool UserYYCoinsBuyReq::has_cardnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_cardnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserYYCoinsBuyReq::clear_has_cardnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserYYCoinsBuyReq::clear_cardnum() {
  if (cardnum_ != &::google::protobuf::internal::kEmptyString) {
    cardnum_->clear();
  }
  clear_has_cardnum();
}
inline const ::std::string& UserYYCoinsBuyReq::cardnum() const {
  return *cardnum_;
}
inline void UserYYCoinsBuyReq::set_cardnum(const ::std::string& value) {
  set_has_cardnum();
  if (cardnum_ == &::google::protobuf::internal::kEmptyString) {
    cardnum_ = new ::std::string;
  }
  cardnum_->assign(value);
}
inline void UserYYCoinsBuyReq::set_cardnum(const char* value) {
  set_has_cardnum();
  if (cardnum_ == &::google::protobuf::internal::kEmptyString) {
    cardnum_ = new ::std::string;
  }
  cardnum_->assign(value);
}
inline void UserYYCoinsBuyReq::set_cardnum(const char* value, size_t size) {
  set_has_cardnum();
  if (cardnum_ == &::google::protobuf::internal::kEmptyString) {
    cardnum_ = new ::std::string;
  }
  cardnum_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyReq::mutable_cardnum() {
  set_has_cardnum();
  if (cardnum_ == &::google::protobuf::internal::kEmptyString) {
    cardnum_ = new ::std::string;
  }
  return cardnum_;
}
inline ::std::string* UserYYCoinsBuyReq::release_cardnum() {
  clear_has_cardnum();
  if (cardnum_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardnum_;
    cardnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsBuyReq::set_allocated_cardnum(::std::string* cardnum) {
  if (cardnum_ != &::google::protobuf::internal::kEmptyString) {
    delete cardnum_;
  }
  if (cardnum) {
    set_has_cardnum();
    cardnum_ = cardnum;
  } else {
    clear_has_cardnum();
    cardnum_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cardPass = 7;
inline bool UserYYCoinsBuyReq::has_cardpass() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_cardpass() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserYYCoinsBuyReq::clear_has_cardpass() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserYYCoinsBuyReq::clear_cardpass() {
  if (cardpass_ != &::google::protobuf::internal::kEmptyString) {
    cardpass_->clear();
  }
  clear_has_cardpass();
}
inline const ::std::string& UserYYCoinsBuyReq::cardpass() const {
  return *cardpass_;
}
inline void UserYYCoinsBuyReq::set_cardpass(const ::std::string& value) {
  set_has_cardpass();
  if (cardpass_ == &::google::protobuf::internal::kEmptyString) {
    cardpass_ = new ::std::string;
  }
  cardpass_->assign(value);
}
inline void UserYYCoinsBuyReq::set_cardpass(const char* value) {
  set_has_cardpass();
  if (cardpass_ == &::google::protobuf::internal::kEmptyString) {
    cardpass_ = new ::std::string;
  }
  cardpass_->assign(value);
}
inline void UserYYCoinsBuyReq::set_cardpass(const char* value, size_t size) {
  set_has_cardpass();
  if (cardpass_ == &::google::protobuf::internal::kEmptyString) {
    cardpass_ = new ::std::string;
  }
  cardpass_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyReq::mutable_cardpass() {
  set_has_cardpass();
  if (cardpass_ == &::google::protobuf::internal::kEmptyString) {
    cardpass_ = new ::std::string;
  }
  return cardpass_;
}
inline ::std::string* UserYYCoinsBuyReq::release_cardpass() {
  clear_has_cardpass();
  if (cardpass_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardpass_;
    cardpass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsBuyReq::set_allocated_cardpass(::std::string* cardpass) {
  if (cardpass_ != &::google::protobuf::internal::kEmptyString) {
    delete cardpass_;
  }
  if (cardpass) {
    set_has_cardpass();
    cardpass_ = cardpass;
  } else {
    clear_has_cardpass();
    cardpass_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 8;
inline bool UserYYCoinsBuyReq::has_uid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserYYCoinsBuyReq::set_has_uid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserYYCoinsBuyReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserYYCoinsBuyReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserYYCoinsBuyReq::uid() const {
  return uid_;
}
inline void UserYYCoinsBuyReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsBuyRes

// optional uint64 orderid = 2;
inline bool UserYYCoinsBuyRes::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsBuyRes::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsBuyRes::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsBuyRes::clear_orderid() {
  orderid_ = GOOGLE_ULONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::uint64 UserYYCoinsBuyRes::orderid() const {
  return orderid_;
}
inline void UserYYCoinsBuyRes::set_orderid(::google::protobuf::uint64 value) {
  set_has_orderid();
  orderid_ = value;
}

// optional string payurl = 3;
inline bool UserYYCoinsBuyRes::has_payurl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsBuyRes::set_has_payurl() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsBuyRes::clear_has_payurl() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsBuyRes::clear_payurl() {
  if (payurl_ != &::google::protobuf::internal::kEmptyString) {
    payurl_->clear();
  }
  clear_has_payurl();
}
inline const ::std::string& UserYYCoinsBuyRes::payurl() const {
  return *payurl_;
}
inline void UserYYCoinsBuyRes::set_payurl(const ::std::string& value) {
  set_has_payurl();
  if (payurl_ == &::google::protobuf::internal::kEmptyString) {
    payurl_ = new ::std::string;
  }
  payurl_->assign(value);
}
inline void UserYYCoinsBuyRes::set_payurl(const char* value) {
  set_has_payurl();
  if (payurl_ == &::google::protobuf::internal::kEmptyString) {
    payurl_ = new ::std::string;
  }
  payurl_->assign(value);
}
inline void UserYYCoinsBuyRes::set_payurl(const char* value, size_t size) {
  set_has_payurl();
  if (payurl_ == &::google::protobuf::internal::kEmptyString) {
    payurl_ = new ::std::string;
  }
  payurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyRes::mutable_payurl() {
  set_has_payurl();
  if (payurl_ == &::google::protobuf::internal::kEmptyString) {
    payurl_ = new ::std::string;
  }
  return payurl_;
}
inline ::std::string* UserYYCoinsBuyRes::release_payurl() {
  clear_has_payurl();
  if (payurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = payurl_;
    payurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsBuyRes::set_allocated_payurl(::std::string* payurl) {
  if (payurl_ != &::google::protobuf::internal::kEmptyString) {
    delete payurl_;
  }
  if (payurl) {
    set_has_payurl();
    payurl_ = payurl;
  } else {
    clear_has_payurl();
    payurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserYYCoinsBuyFeedbackReq

// required uint64 orderid = 1;
inline bool UserYYCoinsBuyFeedbackReq::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsBuyFeedbackReq::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsBuyFeedbackReq::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsBuyFeedbackReq::clear_orderid() {
  orderid_ = GOOGLE_ULONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::uint64 UserYYCoinsBuyFeedbackReq::orderid() const {
  return orderid_;
}
inline void UserYYCoinsBuyFeedbackReq::set_orderid(::google::protobuf::uint64 value) {
  set_has_orderid();
  orderid_ = value;
}

// optional string appStoreReceipt = 2;
inline bool UserYYCoinsBuyFeedbackReq::has_appstorereceipt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsBuyFeedbackReq::set_has_appstorereceipt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsBuyFeedbackReq::clear_has_appstorereceipt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsBuyFeedbackReq::clear_appstorereceipt() {
  if (appstorereceipt_ != &::google::protobuf::internal::kEmptyString) {
    appstorereceipt_->clear();
  }
  clear_has_appstorereceipt();
}
inline const ::std::string& UserYYCoinsBuyFeedbackReq::appstorereceipt() const {
  return *appstorereceipt_;
}
inline void UserYYCoinsBuyFeedbackReq::set_appstorereceipt(const ::std::string& value) {
  set_has_appstorereceipt();
  if (appstorereceipt_ == &::google::protobuf::internal::kEmptyString) {
    appstorereceipt_ = new ::std::string;
  }
  appstorereceipt_->assign(value);
}
inline void UserYYCoinsBuyFeedbackReq::set_appstorereceipt(const char* value) {
  set_has_appstorereceipt();
  if (appstorereceipt_ == &::google::protobuf::internal::kEmptyString) {
    appstorereceipt_ = new ::std::string;
  }
  appstorereceipt_->assign(value);
}
inline void UserYYCoinsBuyFeedbackReq::set_appstorereceipt(const char* value, size_t size) {
  set_has_appstorereceipt();
  if (appstorereceipt_ == &::google::protobuf::internal::kEmptyString) {
    appstorereceipt_ = new ::std::string;
  }
  appstorereceipt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyFeedbackReq::mutable_appstorereceipt() {
  set_has_appstorereceipt();
  if (appstorereceipt_ == &::google::protobuf::internal::kEmptyString) {
    appstorereceipt_ = new ::std::string;
  }
  return appstorereceipt_;
}
inline ::std::string* UserYYCoinsBuyFeedbackReq::release_appstorereceipt() {
  clear_has_appstorereceipt();
  if (appstorereceipt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appstorereceipt_;
    appstorereceipt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsBuyFeedbackReq::set_allocated_appstorereceipt(::std::string* appstorereceipt) {
  if (appstorereceipt_ != &::google::protobuf::internal::kEmptyString) {
    delete appstorereceipt_;
  }
  if (appstorereceipt) {
    set_has_appstorereceipt();
    appstorereceipt_ = appstorereceipt;
  } else {
    clear_has_appstorereceipt();
    appstorereceipt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string appStoreTransactionId = 3;
inline bool UserYYCoinsBuyFeedbackReq::has_appstoretransactionid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsBuyFeedbackReq::set_has_appstoretransactionid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsBuyFeedbackReq::clear_has_appstoretransactionid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsBuyFeedbackReq::clear_appstoretransactionid() {
  if (appstoretransactionid_ != &::google::protobuf::internal::kEmptyString) {
    appstoretransactionid_->clear();
  }
  clear_has_appstoretransactionid();
}
inline const ::std::string& UserYYCoinsBuyFeedbackReq::appstoretransactionid() const {
  return *appstoretransactionid_;
}
inline void UserYYCoinsBuyFeedbackReq::set_appstoretransactionid(const ::std::string& value) {
  set_has_appstoretransactionid();
  if (appstoretransactionid_ == &::google::protobuf::internal::kEmptyString) {
    appstoretransactionid_ = new ::std::string;
  }
  appstoretransactionid_->assign(value);
}
inline void UserYYCoinsBuyFeedbackReq::set_appstoretransactionid(const char* value) {
  set_has_appstoretransactionid();
  if (appstoretransactionid_ == &::google::protobuf::internal::kEmptyString) {
    appstoretransactionid_ = new ::std::string;
  }
  appstoretransactionid_->assign(value);
}
inline void UserYYCoinsBuyFeedbackReq::set_appstoretransactionid(const char* value, size_t size) {
  set_has_appstoretransactionid();
  if (appstoretransactionid_ == &::google::protobuf::internal::kEmptyString) {
    appstoretransactionid_ = new ::std::string;
  }
  appstoretransactionid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsBuyFeedbackReq::mutable_appstoretransactionid() {
  set_has_appstoretransactionid();
  if (appstoretransactionid_ == &::google::protobuf::internal::kEmptyString) {
    appstoretransactionid_ = new ::std::string;
  }
  return appstoretransactionid_;
}
inline ::std::string* UserYYCoinsBuyFeedbackReq::release_appstoretransactionid() {
  clear_has_appstoretransactionid();
  if (appstoretransactionid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appstoretransactionid_;
    appstoretransactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsBuyFeedbackReq::set_allocated_appstoretransactionid(::std::string* appstoretransactionid) {
  if (appstoretransactionid_ != &::google::protobuf::internal::kEmptyString) {
    delete appstoretransactionid_;
  }
  if (appstoretransactionid) {
    set_has_appstoretransactionid();
    appstoretransactionid_ = appstoretransactionid;
  } else {
    clear_has_appstoretransactionid();
    appstoretransactionid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserYYCoinsBuyFeedbackRes

// required uint64 orderid = 2;
inline bool UserYYCoinsBuyFeedbackRes::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsBuyFeedbackRes::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsBuyFeedbackRes::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsBuyFeedbackRes::clear_orderid() {
  orderid_ = GOOGLE_ULONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::uint64 UserYYCoinsBuyFeedbackRes::orderid() const {
  return orderid_;
}
inline void UserYYCoinsBuyFeedbackRes::set_orderid(::google::protobuf::uint64 value) {
  set_has_orderid();
  orderid_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsRecord

// required uint64 orderId = 1;
inline bool UserYYCoinsRecord::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsRecord::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsRecord::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsRecord::clear_orderid() {
  orderid_ = GOOGLE_ULONGLONG(0);
  clear_has_orderid();
}
inline ::google::protobuf::uint64 UserYYCoinsRecord::orderid() const {
  return orderid_;
}
inline void UserYYCoinsRecord::set_orderid(::google::protobuf::uint64 value) {
  set_has_orderid();
  orderid_ = value;
}

// required uint32 itemId = 2;
inline bool UserYYCoinsRecord::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsRecord::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsRecord::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsRecord::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 UserYYCoinsRecord::itemid() const {
  return itemid_;
}
inline void UserYYCoinsRecord::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// required uint32 num = 3;
inline bool UserYYCoinsRecord::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsRecord::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsRecord::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsRecord::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 UserYYCoinsRecord::num() const {
  return num_;
}
inline void UserYYCoinsRecord::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// required .pp.UserYYCoinsRecord.OrderType orderType = 4;
inline bool UserYYCoinsRecord::has_ordertype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserYYCoinsRecord::set_has_ordertype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserYYCoinsRecord::clear_has_ordertype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserYYCoinsRecord::clear_ordertype() {
  ordertype_ = 1;
  clear_has_ordertype();
}
inline ::pp::UserYYCoinsRecord_OrderType UserYYCoinsRecord::ordertype() const {
  return static_cast< ::pp::UserYYCoinsRecord_OrderType >(ordertype_);
}
inline void UserYYCoinsRecord::set_ordertype(::pp::UserYYCoinsRecord_OrderType value) {
  assert(::pp::UserYYCoinsRecord_OrderType_IsValid(value));
  set_has_ordertype();
  ordertype_ = value;
}

// optional int64 createtime = 5;
inline bool UserYYCoinsRecord::has_createtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserYYCoinsRecord::set_has_createtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserYYCoinsRecord::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserYYCoinsRecord::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserYYCoinsRecord::createtime() const {
  return createtime_;
}
inline void UserYYCoinsRecord::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional string remarks = 6;
inline bool UserYYCoinsRecord::has_remarks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserYYCoinsRecord::set_has_remarks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserYYCoinsRecord::clear_has_remarks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserYYCoinsRecord::clear_remarks() {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    remarks_->clear();
  }
  clear_has_remarks();
}
inline const ::std::string& UserYYCoinsRecord::remarks() const {
  return *remarks_;
}
inline void UserYYCoinsRecord::set_remarks(const ::std::string& value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void UserYYCoinsRecord::set_remarks(const char* value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void UserYYCoinsRecord::set_remarks(const char* value, size_t size) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsRecord::mutable_remarks() {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  return remarks_;
}
inline ::std::string* UserYYCoinsRecord::release_remarks() {
  clear_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remarks_;
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsRecord::set_allocated_remarks(::std::string* remarks) {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    delete remarks_;
  }
  if (remarks) {
    set_has_remarks();
    remarks_ = remarks;
  } else {
    clear_has_remarks();
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserYYCoinsOrderState state = 7;
inline bool UserYYCoinsRecord::has_state() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserYYCoinsRecord::set_has_state() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserYYCoinsRecord::clear_has_state() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserYYCoinsRecord::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::UserYYCoinsOrderState UserYYCoinsRecord::state() const {
  return static_cast< ::pp::UserYYCoinsOrderState >(state_);
}
inline void UserYYCoinsRecord::set_state(::pp::UserYYCoinsOrderState value) {
  assert(::pp::UserYYCoinsOrderState_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsQueryReq

// -------------------------------------------------------------------

// UserYYCoinsQueryRes

// optional uint64 yyuid = 1;
inline bool UserYYCoinsQueryRes::has_yyuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsQueryRes::set_has_yyuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsQueryRes::clear_has_yyuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsQueryRes::clear_yyuid() {
  yyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_yyuid();
}
inline ::google::protobuf::uint64 UserYYCoinsQueryRes::yyuid() const {
  return yyuid_;
}
inline void UserYYCoinsQueryRes::set_yyuid(::google::protobuf::uint64 value) {
  set_has_yyuid();
  yyuid_ = value;
}

// optional float coins = 2;
inline bool UserYYCoinsQueryRes::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsQueryRes::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsQueryRes::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsQueryRes::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline float UserYYCoinsQueryRes::coins() const {
  return coins_;
}
inline void UserYYCoinsQueryRes::set_coins(float value) {
  set_has_coins();
  coins_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsHistoryReq

// optional .pp.UserYYCoinsOrderState state = 1;
inline bool UserYYCoinsHistoryReq::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsHistoryReq::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsHistoryReq::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsHistoryReq::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::UserYYCoinsOrderState UserYYCoinsHistoryReq::state() const {
  return static_cast< ::pp::UserYYCoinsOrderState >(state_);
}
inline void UserYYCoinsHistoryReq::set_state(::pp::UserYYCoinsOrderState value) {
  assert(::pp::UserYYCoinsOrderState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint32 index = 2;
inline bool UserYYCoinsHistoryReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsHistoryReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsHistoryReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsHistoryReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserYYCoinsHistoryReq::index() const {
  return index_;
}
inline void UserYYCoinsHistoryReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool UserYYCoinsHistoryReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsHistoryReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsHistoryReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsHistoryReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserYYCoinsHistoryReq::fetchs() const {
  return fetchs_;
}
inline void UserYYCoinsHistoryReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsHistoryRes

// optional int32 totalnum = 1;
inline bool UserYYCoinsHistoryRes::has_totalnum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsHistoryRes::set_has_totalnum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsHistoryRes::clear_has_totalnum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsHistoryRes::clear_totalnum() {
  totalnum_ = 0;
  clear_has_totalnum();
}
inline ::google::protobuf::int32 UserYYCoinsHistoryRes::totalnum() const {
  return totalnum_;
}
inline void UserYYCoinsHistoryRes::set_totalnum(::google::protobuf::int32 value) {
  set_has_totalnum();
  totalnum_ = value;
}

// optional uint32 index = 2;
inline bool UserYYCoinsHistoryRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsHistoryRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsHistoryRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsHistoryRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserYYCoinsHistoryRes::index() const {
  return index_;
}
inline void UserYYCoinsHistoryRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool UserYYCoinsHistoryRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsHistoryRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsHistoryRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsHistoryRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserYYCoinsHistoryRes::fetchs() const {
  return fetchs_;
}
inline void UserYYCoinsHistoryRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 totalrecord = 4;
inline bool UserYYCoinsHistoryRes::has_totalrecord() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserYYCoinsHistoryRes::set_has_totalrecord() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserYYCoinsHistoryRes::clear_has_totalrecord() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserYYCoinsHistoryRes::clear_totalrecord() {
  totalrecord_ = 0u;
  clear_has_totalrecord();
}
inline ::google::protobuf::uint32 UserYYCoinsHistoryRes::totalrecord() const {
  return totalrecord_;
}
inline void UserYYCoinsHistoryRes::set_totalrecord(::google::protobuf::uint32 value) {
  set_has_totalrecord();
  totalrecord_ = value;
}

// repeated .pp.UserYYCoinsRecord records = 5;
inline int UserYYCoinsHistoryRes::records_size() const {
  return records_.size();
}
inline void UserYYCoinsHistoryRes::clear_records() {
  records_.Clear();
}
inline const ::pp::UserYYCoinsRecord& UserYYCoinsHistoryRes::records(int index) const {
  return records_.Get(index);
}
inline ::pp::UserYYCoinsRecord* UserYYCoinsHistoryRes::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::pp::UserYYCoinsRecord* UserYYCoinsHistoryRes::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsRecord >&
UserYYCoinsHistoryRes::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsRecord >*
UserYYCoinsHistoryRes::mutable_records() {
  return &records_;
}

// optional .pp.UserYYCoinsOrderState state = 6;
inline bool UserYYCoinsHistoryRes::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserYYCoinsHistoryRes::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserYYCoinsHistoryRes::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserYYCoinsHistoryRes::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::UserYYCoinsOrderState UserYYCoinsHistoryRes::state() const {
  return static_cast< ::pp::UserYYCoinsOrderState >(state_);
}
inline void UserYYCoinsHistoryRes::set_state(::pp::UserYYCoinsOrderState value) {
  assert(::pp::UserYYCoinsOrderState_IsValid(value));
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsPayGateCallbackReq

// required string appId = 1;
inline bool UserYYCoinsPayGateCallbackReq::has_appid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsPayGateCallbackReq::set_has_appid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_has_appid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_appid() {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    appid_->clear();
  }
  clear_has_appid();
}
inline const ::std::string& UserYYCoinsPayGateCallbackReq::appid() const {
  return *appid_;
}
inline void UserYYCoinsPayGateCallbackReq::set_appid(const ::std::string& value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_appid(const char* value) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_appid(const char* value, size_t size) {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  appid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::mutable_appid() {
  set_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    appid_ = new ::std::string;
  }
  return appid_;
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::release_appid() {
  clear_has_appid();
  if (appid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = appid_;
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayGateCallbackReq::set_allocated_appid(::std::string* appid) {
  if (appid_ != &::google::protobuf::internal::kEmptyString) {
    delete appid_;
  }
  if (appid) {
    set_has_appid();
    appid_ = appid;
  } else {
    clear_has_appid();
    appid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string sign = 2;
inline bool UserYYCoinsPayGateCallbackReq::has_sign() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsPayGateCallbackReq::set_has_sign() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_has_sign() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_sign() {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    sign_->clear();
  }
  clear_has_sign();
}
inline const ::std::string& UserYYCoinsPayGateCallbackReq::sign() const {
  return *sign_;
}
inline void UserYYCoinsPayGateCallbackReq::set_sign(const ::std::string& value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_sign(const char* value) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_sign(const char* value, size_t size) {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  sign_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::mutable_sign() {
  set_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    sign_ = new ::std::string;
  }
  return sign_;
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::release_sign() {
  clear_has_sign();
  if (sign_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sign_;
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayGateCallbackReq::set_allocated_sign(::std::string* sign) {
  if (sign_ != &::google::protobuf::internal::kEmptyString) {
    delete sign_;
  }
  if (sign) {
    set_has_sign();
    sign_ = sign;
  } else {
    clear_has_sign();
    sign_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param = 3;
inline bool UserYYCoinsPayGateCallbackReq::has_param() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsPayGateCallbackReq::set_has_param() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_has_param() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& UserYYCoinsPayGateCallbackReq::param() const {
  return *param_;
}
inline void UserYYCoinsPayGateCallbackReq::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayGateCallbackReq::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string data = 4;
inline bool UserYYCoinsPayGateCallbackReq::has_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserYYCoinsPayGateCallbackReq::set_has_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_has_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserYYCoinsPayGateCallbackReq::clear_data() {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& UserYYCoinsPayGateCallbackReq::data() const {
  return *data_;
}
inline void UserYYCoinsPayGateCallbackReq::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(value);
}
inline void UserYYCoinsPayGateCallbackReq::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    data_ = new ::std::string;
  }
  return data_;
}
inline ::std::string* UserYYCoinsPayGateCallbackReq::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsPayGateCallbackReq::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::kEmptyString) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserYYCoinsShopListReq

// required uint32 index = 1;
inline bool UserYYCoinsShopListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsShopListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsShopListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsShopListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserYYCoinsShopListReq::index() const {
  return index_;
}
inline void UserYYCoinsShopListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool UserYYCoinsShopListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsShopListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsShopListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsShopListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserYYCoinsShopListReq::fetchs() const {
  return fetchs_;
}
inline void UserYYCoinsShopListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// UserYYCoinsShopListRes

// required uint32 index = 1;
inline bool UserYYCoinsShopListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsShopListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsShopListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsShopListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserYYCoinsShopListRes::index() const {
  return index_;
}
inline void UserYYCoinsShopListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 total = 2;
inline bool UserYYCoinsShopListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsShopListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsShopListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsShopListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserYYCoinsShopListRes::total() const {
  return total_;
}
inline void UserYYCoinsShopListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.UserYYCoinsShopItem records = 3;
inline int UserYYCoinsShopListRes::records_size() const {
  return records_.size();
}
inline void UserYYCoinsShopListRes::clear_records() {
  records_.Clear();
}
inline const ::pp::UserYYCoinsShopItem& UserYYCoinsShopListRes::records(int index) const {
  return records_.Get(index);
}
inline ::pp::UserYYCoinsShopItem* UserYYCoinsShopListRes::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::pp::UserYYCoinsShopItem* UserYYCoinsShopListRes::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsShopItem >&
UserYYCoinsShopListRes::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserYYCoinsShopItem >*
UserYYCoinsShopListRes::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// UserYYCoinsShopItem

// required uint32 itemId = 1;
inline bool UserYYCoinsShopItem::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserYYCoinsShopItem::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserYYCoinsShopItem::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserYYCoinsShopItem::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 UserYYCoinsShopItem::itemid() const {
  return itemid_;
}
inline void UserYYCoinsShopItem::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional float coins = 2;
inline bool UserYYCoinsShopItem::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserYYCoinsShopItem::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserYYCoinsShopItem::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserYYCoinsShopItem::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline float UserYYCoinsShopItem::coins() const {
  return coins_;
}
inline void UserYYCoinsShopItem::set_coins(float value) {
  set_has_coins();
  coins_ = value;
}

// optional float price = 3;
inline bool UserYYCoinsShopItem::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserYYCoinsShopItem::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserYYCoinsShopItem::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserYYCoinsShopItem::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float UserYYCoinsShopItem::price() const {
  return price_;
}
inline void UserYYCoinsShopItem::set_price(float value) {
  set_has_price();
  price_ = value;
}

// optional float discount = 4;
inline bool UserYYCoinsShopItem::has_discount() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserYYCoinsShopItem::set_has_discount() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserYYCoinsShopItem::clear_has_discount() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserYYCoinsShopItem::clear_discount() {
  discount_ = 0;
  clear_has_discount();
}
inline float UserYYCoinsShopItem::discount() const {
  return discount_;
}
inline void UserYYCoinsShopItem::set_discount(float value) {
  set_has_discount();
  discount_ = value;
}

// optional bool available = 5;
inline bool UserYYCoinsShopItem::has_available() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserYYCoinsShopItem::set_has_available() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserYYCoinsShopItem::clear_has_available() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserYYCoinsShopItem::clear_available() {
  available_ = false;
  clear_has_available();
}
inline bool UserYYCoinsShopItem::available() const {
  return available_;
}
inline void UserYYCoinsShopItem::set_available(bool value) {
  set_has_available();
  available_ = value;
}

// optional string discountText = 6;
inline bool UserYYCoinsShopItem::has_discounttext() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserYYCoinsShopItem::set_has_discounttext() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserYYCoinsShopItem::clear_has_discounttext() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserYYCoinsShopItem::clear_discounttext() {
  if (discounttext_ != &::google::protobuf::internal::kEmptyString) {
    discounttext_->clear();
  }
  clear_has_discounttext();
}
inline const ::std::string& UserYYCoinsShopItem::discounttext() const {
  return *discounttext_;
}
inline void UserYYCoinsShopItem::set_discounttext(const ::std::string& value) {
  set_has_discounttext();
  if (discounttext_ == &::google::protobuf::internal::kEmptyString) {
    discounttext_ = new ::std::string;
  }
  discounttext_->assign(value);
}
inline void UserYYCoinsShopItem::set_discounttext(const char* value) {
  set_has_discounttext();
  if (discounttext_ == &::google::protobuf::internal::kEmptyString) {
    discounttext_ = new ::std::string;
  }
  discounttext_->assign(value);
}
inline void UserYYCoinsShopItem::set_discounttext(const char* value, size_t size) {
  set_has_discounttext();
  if (discounttext_ == &::google::protobuf::internal::kEmptyString) {
    discounttext_ = new ::std::string;
  }
  discounttext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserYYCoinsShopItem::mutable_discounttext() {
  set_has_discounttext();
  if (discounttext_ == &::google::protobuf::internal::kEmptyString) {
    discounttext_ = new ::std::string;
  }
  return discounttext_;
}
inline ::std::string* UserYYCoinsShopItem::release_discounttext() {
  clear_has_discounttext();
  if (discounttext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = discounttext_;
    discounttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserYYCoinsShopItem::set_allocated_discounttext(::std::string* discounttext) {
  if (discounttext_ != &::google::protobuf::internal::kEmptyString) {
    delete discounttext_;
  }
  if (discounttext) {
    set_has_discounttext();
    discounttext_ = discounttext;
  } else {
    clear_has_discounttext();
    discounttext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupRolerState

// optional .pp.GroupRolerStateType state = 1;
inline bool GroupRolerState::has_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupRolerState::set_has_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupRolerState::clear_has_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupRolerState::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::GroupRolerStateType GroupRolerState::state() const {
  return static_cast< ::pp::GroupRolerStateType >(state_);
}
inline void GroupRolerState::set_state(::pp::GroupRolerStateType value) {
  assert(::pp::GroupRolerStateType_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional .pp.GroupMemberRoler roler = 2;
inline bool GroupRolerState::has_roler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupRolerState::set_has_roler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupRolerState::clear_has_roler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupRolerState::clear_roler() {
  roler_ = 0;
  clear_has_roler();
}
inline ::pp::GroupMemberRoler GroupRolerState::roler() const {
  return static_cast< ::pp::GroupMemberRoler >(roler_);
}
inline void GroupRolerState::set_roler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_roler();
  roler_ = value;
}

// -------------------------------------------------------------------

// GroupLabel

// optional uint64 sid = 1;
inline bool GroupLabel::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupLabel::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupLabel::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupLabel::clear_sid() {
  sid_ = GOOGLE_ULONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::uint64 GroupLabel::sid() const {
  return sid_;
}
inline void GroupLabel::set_sid(::google::protobuf::uint64 value) {
  set_has_sid();
  sid_ = value;
}

// optional string label = 2;
inline bool GroupLabel::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupLabel::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupLabel::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupLabel::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& GroupLabel::label() const {
  return *label_;
}
inline void GroupLabel::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void GroupLabel::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void GroupLabel::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupLabel::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* GroupLabel::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupLabel::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string color = 3;
inline bool GroupLabel::has_color() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupLabel::set_has_color() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupLabel::clear_has_color() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupLabel::clear_color() {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& GroupLabel::color() const {
  return *color_;
}
inline void GroupLabel::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void GroupLabel::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void GroupLabel::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupLabel::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  return color_;
}
inline ::std::string* GroupLabel::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupLabel::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupInfo

// optional uint64 gid = 1;
inline bool GroupInfo::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfo::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfo::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfo::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupInfo::gid() const {
  return gid_;
}
inline void GroupInfo::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 dGid = 2;
inline bool GroupInfo::has_dgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfo::set_has_dgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfo::clear_has_dgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfo::clear_dgid() {
  dgid_ = GOOGLE_ULONGLONG(0);
  clear_has_dgid();
}
inline ::google::protobuf::uint64 GroupInfo::dgid() const {
  return dgid_;
}
inline void GroupInfo::set_dgid(::google::protobuf::uint64 value) {
  set_has_dgid();
  dgid_ = value;
}

// optional string name = 3;
inline bool GroupInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& GroupInfo::name() const {
  return *name_;
}
inline void GroupInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GroupInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void GroupInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* GroupInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string intro = 4;
inline bool GroupInfo::has_intro() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupInfo::set_has_intro() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupInfo::clear_has_intro() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupInfo::clear_intro() {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    intro_->clear();
  }
  clear_has_intro();
}
inline const ::std::string& GroupInfo::intro() const {
  return *intro_;
}
inline void GroupInfo::set_intro(const ::std::string& value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void GroupInfo::set_intro(const char* value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void GroupInfo::set_intro(const char* value, size_t size) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_intro() {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  return intro_;
}
inline ::std::string* GroupInfo::release_intro() {
  clear_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intro_;
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfo::set_allocated_intro(::std::string* intro) {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    delete intro_;
  }
  if (intro) {
    set_has_intro();
    intro_ = intro;
  } else {
    clear_has_intro();
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string logoUrl = 5;
inline bool GroupInfo::has_logourl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupInfo::set_has_logourl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupInfo::clear_has_logourl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupInfo::clear_logourl() {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    logourl_->clear();
  }
  clear_has_logourl();
}
inline const ::std::string& GroupInfo::logourl() const {
  return *logourl_;
}
inline void GroupInfo::set_logourl(const ::std::string& value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void GroupInfo::set_logourl(const char* value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void GroupInfo::set_logourl(const char* value, size_t size) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_logourl() {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  return logourl_;
}
inline ::std::string* GroupInfo::release_logourl() {
  clear_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logourl_;
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfo::set_allocated_logourl(::std::string* logourl) {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    delete logourl_;
  }
  if (logourl) {
    set_has_logourl();
    logourl_ = logourl;
  } else {
    clear_has_logourl();
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string notice = 6;
inline bool GroupInfo::has_notice() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupInfo::set_has_notice() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupInfo::clear_has_notice() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupInfo::clear_notice() {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    notice_->clear();
  }
  clear_has_notice();
}
inline const ::std::string& GroupInfo::notice() const {
  return *notice_;
}
inline void GroupInfo::set_notice(const ::std::string& value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void GroupInfo::set_notice(const char* value) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(value);
}
inline void GroupInfo::set_notice(const char* value, size_t size) {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  notice_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_notice() {
  set_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    notice_ = new ::std::string;
  }
  return notice_;
}
inline ::std::string* GroupInfo::release_notice() {
  clear_has_notice();
  if (notice_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = notice_;
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfo::set_allocated_notice(::std::string* notice) {
  if (notice_ != &::google::protobuf::internal::kEmptyString) {
    delete notice_;
  }
  if (notice) {
    set_has_notice();
    notice_ = notice;
  } else {
    clear_has_notice();
    notice_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GroupType gtype = 7;
inline bool GroupInfo::has_gtype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupInfo::set_has_gtype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupInfo::clear_has_gtype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupInfo::clear_gtype() {
  gtype_ = 0;
  clear_has_gtype();
}
inline ::pp::GroupType GroupInfo::gtype() const {
  return static_cast< ::pp::GroupType >(gtype_);
}
inline void GroupInfo::set_gtype(::pp::GroupType value) {
  assert(::pp::GroupType_IsValid(value));
  set_has_gtype();
  gtype_ = value;
}

// optional uint64 ownerId = 8;
inline bool GroupInfo::has_ownerid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupInfo::set_has_ownerid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupInfo::clear_has_ownerid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupInfo::clear_ownerid() {
  ownerid_ = GOOGLE_ULONGLONG(0);
  clear_has_ownerid();
}
inline ::google::protobuf::uint64 GroupInfo::ownerid() const {
  return ownerid_;
}
inline void GroupInfo::set_ownerid(::google::protobuf::uint64 value) {
  set_has_ownerid();
  ownerid_ = value;
}

// optional .pp.GroupApprove approve = 9;
inline bool GroupInfo::has_approve() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupInfo::set_has_approve() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupInfo::clear_has_approve() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupInfo::clear_approve() {
  approve_ = 0;
  clear_has_approve();
}
inline ::pp::GroupApprove GroupInfo::approve() const {
  return static_cast< ::pp::GroupApprove >(approve_);
}
inline void GroupInfo::set_approve(::pp::GroupApprove value) {
  assert(::pp::GroupApprove_IsValid(value));
  set_has_approve();
  approve_ = value;
}

// optional string password = 10;
inline bool GroupInfo::has_password() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupInfo::set_has_password() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupInfo::clear_has_password() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupInfo::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GroupInfo::password() const {
  return *password_;
}
inline void GroupInfo::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupInfo::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupInfo::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GroupInfo::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfo::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GroupState state = 11;
inline bool GroupInfo::has_state() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupInfo::set_has_state() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupInfo::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::GroupState GroupInfo::state() const {
  return static_cast< ::pp::GroupState >(state_);
}
inline void GroupInfo::set_state(::pp::GroupState value) {
  assert(::pp::GroupState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint64 maxMsgRev = 12;
inline bool GroupInfo::has_maxmsgrev() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupInfo::set_has_maxmsgrev() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupInfo::clear_has_maxmsgrev() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupInfo::clear_maxmsgrev() {
  maxmsgrev_ = GOOGLE_ULONGLONG(0);
  clear_has_maxmsgrev();
}
inline ::google::protobuf::uint64 GroupInfo::maxmsgrev() const {
  return maxmsgrev_;
}
inline void GroupInfo::set_maxmsgrev(::google::protobuf::uint64 value) {
  set_has_maxmsgrev();
  maxmsgrev_ = value;
}

// optional uint32 members = 13;
inline bool GroupInfo::has_members() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void GroupInfo::set_has_members() {
  _has_bits_[0] |= 0x00001000u;
}
inline void GroupInfo::clear_has_members() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void GroupInfo::clear_members() {
  members_ = 0u;
  clear_has_members();
}
inline ::google::protobuf::uint32 GroupInfo::members() const {
  return members_;
}
inline void GroupInfo::set_members(::google::protobuf::uint32 value) {
  set_has_members();
  members_ = value;
}

// optional uint32 level = 14;
inline bool GroupInfo::has_level() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void GroupInfo::set_has_level() {
  _has_bits_[0] |= 0x00002000u;
}
inline void GroupInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void GroupInfo::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 GroupInfo::level() const {
  return level_;
}
inline void GroupInfo::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// optional int64 createTime = 15;
inline bool GroupInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void GroupInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void GroupInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void GroupInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 GroupInfo::createtime() const {
  return createtime_;
}
inline void GroupInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional .pp.UserInfo ownerInfo = 16;
inline bool GroupInfo::has_ownerinfo() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void GroupInfo::set_has_ownerinfo() {
  _has_bits_[0] |= 0x00008000u;
}
inline void GroupInfo::clear_has_ownerinfo() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void GroupInfo::clear_ownerinfo() {
  if (ownerinfo_ != NULL) ownerinfo_->::pp::UserInfo::Clear();
  clear_has_ownerinfo();
}
inline const ::pp::UserInfo& GroupInfo::ownerinfo() const {
  return ownerinfo_ != NULL ? *ownerinfo_ : *default_instance_->ownerinfo_;
}
inline ::pp::UserInfo* GroupInfo::mutable_ownerinfo() {
  set_has_ownerinfo();
  if (ownerinfo_ == NULL) ownerinfo_ = new ::pp::UserInfo;
  return ownerinfo_;
}
inline ::pp::UserInfo* GroupInfo::release_ownerinfo() {
  clear_has_ownerinfo();
  ::pp::UserInfo* temp = ownerinfo_;
  ownerinfo_ = NULL;
  return temp;
}
inline void GroupInfo::set_allocated_ownerinfo(::pp::UserInfo* ownerinfo) {
  delete ownerinfo_;
  ownerinfo_ = ownerinfo;
  if (ownerinfo) {
    set_has_ownerinfo();
  } else {
    clear_has_ownerinfo();
  }
}

// optional uint64 parentGid = 17;
inline bool GroupInfo::has_parentgid() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void GroupInfo::set_has_parentgid() {
  _has_bits_[0] |= 0x00010000u;
}
inline void GroupInfo::clear_has_parentgid() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void GroupInfo::clear_parentgid() {
  parentgid_ = GOOGLE_ULONGLONG(0);
  clear_has_parentgid();
}
inline ::google::protobuf::uint64 GroupInfo::parentgid() const {
  return parentgid_;
}
inline void GroupInfo::set_parentgid(::google::protobuf::uint64 value) {
  set_has_parentgid();
  parentgid_ = value;
}

// optional .pp.GroupModeType mode = 18;
inline bool GroupInfo::has_mode() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void GroupInfo::set_has_mode() {
  _has_bits_[0] |= 0x00020000u;
}
inline void GroupInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void GroupInfo::clear_mode() {
  mode_ = 0;
  clear_has_mode();
}
inline ::pp::GroupModeType GroupInfo::mode() const {
  return static_cast< ::pp::GroupModeType >(mode_);
}
inline void GroupInfo::set_mode(::pp::GroupModeType value) {
  assert(::pp::GroupModeType_IsValid(value));
  set_has_mode();
  mode_ = value;
}

// repeated .pp.GroupRolerState rolerStates = 19;
inline int GroupInfo::rolerstates_size() const {
  return rolerstates_.size();
}
inline void GroupInfo::clear_rolerstates() {
  rolerstates_.Clear();
}
inline const ::pp::GroupRolerState& GroupInfo::rolerstates(int index) const {
  return rolerstates_.Get(index);
}
inline ::pp::GroupRolerState* GroupInfo::mutable_rolerstates(int index) {
  return rolerstates_.Mutable(index);
}
inline ::pp::GroupRolerState* GroupInfo::add_rolerstates() {
  return rolerstates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupRolerState >&
GroupInfo::rolerstates() const {
  return rolerstates_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupRolerState >*
GroupInfo::mutable_rolerstates() {
  return &rolerstates_;
}

// optional .pp.GroupData gdata = 20;
inline bool GroupInfo::has_gdata() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void GroupInfo::set_has_gdata() {
  _has_bits_[0] |= 0x00080000u;
}
inline void GroupInfo::clear_has_gdata() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void GroupInfo::clear_gdata() {
  if (gdata_ != NULL) gdata_->::pp::GroupData::Clear();
  clear_has_gdata();
}
inline const ::pp::GroupData& GroupInfo::gdata() const {
  return gdata_ != NULL ? *gdata_ : *default_instance_->gdata_;
}
inline ::pp::GroupData* GroupInfo::mutable_gdata() {
  set_has_gdata();
  if (gdata_ == NULL) gdata_ = new ::pp::GroupData;
  return gdata_;
}
inline ::pp::GroupData* GroupInfo::release_gdata() {
  clear_has_gdata();
  ::pp::GroupData* temp = gdata_;
  gdata_ = NULL;
  return temp;
}
inline void GroupInfo::set_allocated_gdata(::pp::GroupData* gdata) {
  delete gdata_;
  gdata_ = gdata;
  if (gdata) {
    set_has_gdata();
  } else {
    clear_has_gdata();
  }
}

// optional .pp.UserInfo babyInfo = 21;
inline bool GroupInfo::has_babyinfo() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void GroupInfo::set_has_babyinfo() {
  _has_bits_[0] |= 0x00100000u;
}
inline void GroupInfo::clear_has_babyinfo() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void GroupInfo::clear_babyinfo() {
  if (babyinfo_ != NULL) babyinfo_->::pp::UserInfo::Clear();
  clear_has_babyinfo();
}
inline const ::pp::UserInfo& GroupInfo::babyinfo() const {
  return babyinfo_ != NULL ? *babyinfo_ : *default_instance_->babyinfo_;
}
inline ::pp::UserInfo* GroupInfo::mutable_babyinfo() {
  set_has_babyinfo();
  if (babyinfo_ == NULL) babyinfo_ = new ::pp::UserInfo;
  return babyinfo_;
}
inline ::pp::UserInfo* GroupInfo::release_babyinfo() {
  clear_has_babyinfo();
  ::pp::UserInfo* temp = babyinfo_;
  babyinfo_ = NULL;
  return temp;
}
inline void GroupInfo::set_allocated_babyinfo(::pp::UserInfo* babyinfo) {
  delete babyinfo_;
  babyinfo_ = babyinfo;
  if (babyinfo) {
    set_has_babyinfo();
  } else {
    clear_has_babyinfo();
  }
}

// optional .pp.GroupGames games = 22;
inline bool GroupInfo::has_games() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void GroupInfo::set_has_games() {
  _has_bits_[0] |= 0x00200000u;
}
inline void GroupInfo::clear_has_games() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void GroupInfo::clear_games() {
  if (games_ != NULL) games_->::pp::GroupGames::Clear();
  clear_has_games();
}
inline const ::pp::GroupGames& GroupInfo::games() const {
  return games_ != NULL ? *games_ : *default_instance_->games_;
}
inline ::pp::GroupGames* GroupInfo::mutable_games() {
  set_has_games();
  if (games_ == NULL) games_ = new ::pp::GroupGames;
  return games_;
}
inline ::pp::GroupGames* GroupInfo::release_games() {
  clear_has_games();
  ::pp::GroupGames* temp = games_;
  games_ = NULL;
  return temp;
}
inline void GroupInfo::set_allocated_games(::pp::GroupGames* games) {
  delete games_;
  games_ = games;
  if (games) {
    set_has_games();
  } else {
    clear_has_games();
  }
}

// optional uint32 mainGameId = 23;
inline bool GroupInfo::has_maingameid() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void GroupInfo::set_has_maingameid() {
  _has_bits_[0] |= 0x00400000u;
}
inline void GroupInfo::clear_has_maingameid() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void GroupInfo::clear_maingameid() {
  maingameid_ = 0u;
  clear_has_maingameid();
}
inline ::google::protobuf::uint32 GroupInfo::maingameid() const {
  return maingameid_;
}
inline void GroupInfo::set_maingameid(::google::protobuf::uint32 value) {
  set_has_maingameid();
  maingameid_ = value;
}

// optional uint32 live = 24;
inline bool GroupInfo::has_live() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void GroupInfo::set_has_live() {
  _has_bits_[0] |= 0x00800000u;
}
inline void GroupInfo::clear_has_live() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void GroupInfo::clear_live() {
  live_ = 0u;
  clear_has_live();
}
inline ::google::protobuf::uint32 GroupInfo::live() const {
  return live_;
}
inline void GroupInfo::set_live(::google::protobuf::uint32 value) {
  set_has_live();
  live_ = value;
}

// optional uint64 sid = 25;
inline bool GroupInfo::has_sid() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void GroupInfo::set_has_sid() {
  _has_bits_[0] |= 0x01000000u;
}
inline void GroupInfo::clear_has_sid() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void GroupInfo::clear_sid() {
  sid_ = GOOGLE_ULONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::uint64 GroupInfo::sid() const {
  return sid_;
}
inline void GroupInfo::set_sid(::google::protobuf::uint64 value) {
  set_has_sid();
  sid_ = value;
}

// optional uint64 asid = 26;
inline bool GroupInfo::has_asid() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void GroupInfo::set_has_asid() {
  _has_bits_[0] |= 0x02000000u;
}
inline void GroupInfo::clear_has_asid() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void GroupInfo::clear_asid() {
  asid_ = GOOGLE_ULONGLONG(0);
  clear_has_asid();
}
inline ::google::protobuf::uint64 GroupInfo::asid() const {
  return asid_;
}
inline void GroupInfo::set_asid(::google::protobuf::uint64 value) {
  set_has_asid();
  asid_ = value;
}

// optional uint32 lobbyOrderIdx = 27;
inline bool GroupInfo::has_lobbyorderidx() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void GroupInfo::set_has_lobbyorderidx() {
  _has_bits_[0] |= 0x04000000u;
}
inline void GroupInfo::clear_has_lobbyorderidx() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void GroupInfo::clear_lobbyorderidx() {
  lobbyorderidx_ = 0u;
  clear_has_lobbyorderidx();
}
inline ::google::protobuf::uint32 GroupInfo::lobbyorderidx() const {
  return lobbyorderidx_;
}
inline void GroupInfo::set_lobbyorderidx(::google::protobuf::uint32 value) {
  set_has_lobbyorderidx();
  lobbyorderidx_ = value;
}

// optional .pp.GroupLabel label = 30;
inline bool GroupInfo::has_label() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void GroupInfo::set_has_label() {
  _has_bits_[0] |= 0x08000000u;
}
inline void GroupInfo::clear_has_label() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void GroupInfo::clear_label() {
  if (label_ != NULL) label_->::pp::GroupLabel::Clear();
  clear_has_label();
}
inline const ::pp::GroupLabel& GroupInfo::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::pp::GroupLabel* GroupInfo::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::pp::GroupLabel;
  return label_;
}
inline ::pp::GroupLabel* GroupInfo::release_label() {
  clear_has_label();
  ::pp::GroupLabel* temp = label_;
  label_ = NULL;
  return temp;
}
inline void GroupInfo::set_allocated_label(::pp::GroupLabel* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// optional string code = 100;
inline bool GroupInfo::has_code() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void GroupInfo::set_has_code() {
  _has_bits_[0] |= 0x10000000u;
}
inline void GroupInfo::clear_has_code() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void GroupInfo::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& GroupInfo::code() const {
  return *code_;
}
inline void GroupInfo::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void GroupInfo::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void GroupInfo::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupInfo::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* GroupInfo::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupInfo::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupGames

// repeated .pp.GameInfo relGames = 1;
inline int GroupGames::relgames_size() const {
  return relgames_.size();
}
inline void GroupGames::clear_relgames() {
  relgames_.Clear();
}
inline const ::pp::GameInfo& GroupGames::relgames(int index) const {
  return relgames_.Get(index);
}
inline ::pp::GameInfo* GroupGames::mutable_relgames(int index) {
  return relgames_.Mutable(index);
}
inline ::pp::GameInfo* GroupGames::add_relgames() {
  return relgames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >&
GroupGames::relgames() const {
  return relgames_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GameInfo >*
GroupGames::mutable_relgames() {
  return &relgames_;
}

// -------------------------------------------------------------------

// GroupPresents

// repeated .pp.PresentInfo presentlist = 1;
inline int GroupPresents::presentlist_size() const {
  return presentlist_.size();
}
inline void GroupPresents::clear_presentlist() {
  presentlist_.Clear();
}
inline const ::pp::PresentInfo& GroupPresents::presentlist(int index) const {
  return presentlist_.Get(index);
}
inline ::pp::PresentInfo* GroupPresents::mutable_presentlist(int index) {
  return presentlist_.Mutable(index);
}
inline ::pp::PresentInfo* GroupPresents::add_presentlist() {
  return presentlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >&
GroupPresents::presentlist() const {
  return presentlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >*
GroupPresents::mutable_presentlist() {
  return &presentlist_;
}

// optional uint32 total = 2;
inline bool GroupPresents::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPresents::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPresents::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPresents::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GroupPresents::total() const {
  return total_;
}
inline void GroupPresents::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// -------------------------------------------------------------------

// GroupData

// optional uint64 gid = 1;
inline bool GroupData::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupData::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupData::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupData::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupData::gid() const {
  return gid_;
}
inline void GroupData::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 coins = 3;
inline bool GroupData::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupData::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupData::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupData::clear_coins() {
  coins_ = 0u;
  clear_has_coins();
}
inline ::google::protobuf::uint32 GroupData::coins() const {
  return coins_;
}
inline void GroupData::set_coins(::google::protobuf::uint32 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint32 passion = 4;
inline bool GroupData::has_passion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupData::set_has_passion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupData::clear_has_passion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupData::clear_passion() {
  passion_ = 0u;
  clear_has_passion();
}
inline ::google::protobuf::uint32 GroupData::passion() const {
  return passion_;
}
inline void GroupData::set_passion(::google::protobuf::uint32 value) {
  set_has_passion();
  passion_ = value;
}

// optional uint32 todayPassion = 5;
inline bool GroupData::has_todaypassion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupData::set_has_todaypassion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupData::clear_has_todaypassion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupData::clear_todaypassion() {
  todaypassion_ = 0u;
  clear_has_todaypassion();
}
inline ::google::protobuf::uint32 GroupData::todaypassion() const {
  return todaypassion_;
}
inline void GroupData::set_todaypassion(::google::protobuf::uint32 value) {
  set_has_todaypassion();
  todaypassion_ = value;
}

// optional uint32 ydIncrPassion = 6;
inline bool GroupData::has_ydincrpassion() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupData::set_has_ydincrpassion() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupData::clear_has_ydincrpassion() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupData::clear_ydincrpassion() {
  ydincrpassion_ = 0u;
  clear_has_ydincrpassion();
}
inline ::google::protobuf::uint32 GroupData::ydincrpassion() const {
  return ydincrpassion_;
}
inline void GroupData::set_ydincrpassion(::google::protobuf::uint32 value) {
  set_has_ydincrpassion();
  ydincrpassion_ = value;
}

// optional uint32 ydLossPassion = 7;
inline bool GroupData::has_ydlosspassion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupData::set_has_ydlosspassion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupData::clear_has_ydlosspassion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupData::clear_ydlosspassion() {
  ydlosspassion_ = 0u;
  clear_has_ydlosspassion();
}
inline ::google::protobuf::uint32 GroupData::ydlosspassion() const {
  return ydlosspassion_;
}
inline void GroupData::set_ydlosspassion(::google::protobuf::uint32 value) {
  set_has_ydlosspassion();
  ydlosspassion_ = value;
}

// optional uint32 nextPassion = 8;
inline bool GroupData::has_nextpassion() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupData::set_has_nextpassion() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupData::clear_has_nextpassion() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupData::clear_nextpassion() {
  nextpassion_ = 0u;
  clear_has_nextpassion();
}
inline ::google::protobuf::uint32 GroupData::nextpassion() const {
  return nextpassion_;
}
inline void GroupData::set_nextpassion(::google::protobuf::uint32 value) {
  set_has_nextpassion();
  nextpassion_ = value;
}

// optional uint32 nextMembers = 9;
inline bool GroupData::has_nextmembers() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupData::set_has_nextmembers() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupData::clear_has_nextmembers() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupData::clear_nextmembers() {
  nextmembers_ = 0u;
  clear_has_nextmembers();
}
inline ::google::protobuf::uint32 GroupData::nextmembers() const {
  return nextmembers_;
}
inline void GroupData::set_nextmembers(::google::protobuf::uint32 value) {
  set_has_nextmembers();
  nextmembers_ = value;
}

// optional uint32 maxMembers = 10;
inline bool GroupData::has_maxmembers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupData::set_has_maxmembers() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupData::clear_has_maxmembers() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupData::clear_maxmembers() {
  maxmembers_ = 0u;
  clear_has_maxmembers();
}
inline ::google::protobuf::uint32 GroupData::maxmembers() const {
  return maxmembers_;
}
inline void GroupData::set_maxmembers(::google::protobuf::uint32 value) {
  set_has_maxmembers();
  maxmembers_ = value;
}

// -------------------------------------------------------------------

// GroupTeamOpReq

// repeated uint64 addGids = 1;
inline int GroupTeamOpReq::addgids_size() const {
  return addgids_.size();
}
inline void GroupTeamOpReq::clear_addgids() {
  addgids_.Clear();
}
inline ::google::protobuf::uint64 GroupTeamOpReq::addgids(int index) const {
  return addgids_.Get(index);
}
inline void GroupTeamOpReq::set_addgids(int index, ::google::protobuf::uint64 value) {
  addgids_.Set(index, value);
}
inline void GroupTeamOpReq::add_addgids(::google::protobuf::uint64 value) {
  addgids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GroupTeamOpReq::addgids() const {
  return addgids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GroupTeamOpReq::mutable_addgids() {
  return &addgids_;
}

// repeated uint64 delGids = 2;
inline int GroupTeamOpReq::delgids_size() const {
  return delgids_.size();
}
inline void GroupTeamOpReq::clear_delgids() {
  delgids_.Clear();
}
inline ::google::protobuf::uint64 GroupTeamOpReq::delgids(int index) const {
  return delgids_.Get(index);
}
inline void GroupTeamOpReq::set_delgids(int index, ::google::protobuf::uint64 value) {
  delgids_.Set(index, value);
}
inline void GroupTeamOpReq::add_delgids(::google::protobuf::uint64 value) {
  delgids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GroupTeamOpReq::delgids() const {
  return delgids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GroupTeamOpReq::mutable_delgids() {
  return &delgids_;
}

// -------------------------------------------------------------------

// GroupApplyReq

// optional uint64 gid = 1;
inline bool GroupApplyReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupApplyReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupApplyReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupApplyReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupApplyReq::gid() const {
  return gid_;
}
inline void GroupApplyReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 uid = 2;
inline bool GroupApplyReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupApplyReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupApplyReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupApplyReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 GroupApplyReq::uid() const {
  return uid_;
}
inline void GroupApplyReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional .pp.GroupMemberRoler roler = 3;
inline bool GroupApplyReq::has_roler() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupApplyReq::set_has_roler() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupApplyReq::clear_has_roler() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupApplyReq::clear_roler() {
  roler_ = 0;
  clear_has_roler();
}
inline ::pp::GroupMemberRoler GroupApplyReq::roler() const {
  return static_cast< ::pp::GroupMemberRoler >(roler_);
}
inline void GroupApplyReq::set_roler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_roler();
  roler_ = value;
}

// optional string password = 4;
inline bool GroupApplyReq::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupApplyReq::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupApplyReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupApplyReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GroupApplyReq::password() const {
  return *password_;
}
inline void GroupApplyReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupApplyReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupApplyReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupApplyReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GroupApplyReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupApplyReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string remark = 5;
inline bool GroupApplyReq::has_remark() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupApplyReq::set_has_remark() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupApplyReq::clear_has_remark() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupApplyReq::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& GroupApplyReq::remark() const {
  return *remark_;
}
inline void GroupApplyReq::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void GroupApplyReq::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void GroupApplyReq::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupApplyReq::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* GroupApplyReq::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupApplyReq::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupApplyRes

// optional .pp.GroupInfo groupInfo = 1;
inline bool GroupApplyRes::has_groupinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupApplyRes::set_has_groupinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupApplyRes::clear_has_groupinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupApplyRes::clear_groupinfo() {
  if (groupinfo_ != NULL) groupinfo_->::pp::GroupInfo::Clear();
  clear_has_groupinfo();
}
inline const ::pp::GroupInfo& GroupApplyRes::groupinfo() const {
  return groupinfo_ != NULL ? *groupinfo_ : *default_instance_->groupinfo_;
}
inline ::pp::GroupInfo* GroupApplyRes::mutable_groupinfo() {
  set_has_groupinfo();
  if (groupinfo_ == NULL) groupinfo_ = new ::pp::GroupInfo;
  return groupinfo_;
}
inline ::pp::GroupInfo* GroupApplyRes::release_groupinfo() {
  clear_has_groupinfo();
  ::pp::GroupInfo* temp = groupinfo_;
  groupinfo_ = NULL;
  return temp;
}
inline void GroupApplyRes::set_allocated_groupinfo(::pp::GroupInfo* groupinfo) {
  delete groupinfo_;
  groupinfo_ = groupinfo;
  if (groupinfo) {
    set_has_groupinfo();
  } else {
    clear_has_groupinfo();
  }
}

// optional .pp.GroupMember member = 2;
inline bool GroupApplyRes::has_member() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupApplyRes::set_has_member() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupApplyRes::clear_has_member() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupApplyRes::clear_member() {
  if (member_ != NULL) member_->::pp::GroupMember::Clear();
  clear_has_member();
}
inline const ::pp::GroupMember& GroupApplyRes::member() const {
  return member_ != NULL ? *member_ : *default_instance_->member_;
}
inline ::pp::GroupMember* GroupApplyRes::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::pp::GroupMember;
  return member_;
}
inline ::pp::GroupMember* GroupApplyRes::release_member() {
  clear_has_member();
  ::pp::GroupMember* temp = member_;
  member_ = NULL;
  return temp;
}
inline void GroupApplyRes::set_allocated_member(::pp::GroupMember* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
}

// optional string token = 3;
inline bool GroupApplyRes::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupApplyRes::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupApplyRes::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupApplyRes::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& GroupApplyRes::token() const {
  return *token_;
}
inline void GroupApplyRes::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void GroupApplyRes::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void GroupApplyRes::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupApplyRes::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* GroupApplyRes::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupApplyRes::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupApproveReq

// required uint64 revision = 1;
inline bool GroupApproveReq::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupApproveReq::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupApproveReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupApproveReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupApproveReq::revision() const {
  return revision_;
}
inline void GroupApproveReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 gid = 2;
inline bool GroupApproveReq::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupApproveReq::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupApproveReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupApproveReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupApproveReq::gid() const {
  return gid_;
}
inline void GroupApproveReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 adminUid = 3;
inline bool GroupApproveReq::has_adminuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupApproveReq::set_has_adminuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupApproveReq::clear_has_adminuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupApproveReq::clear_adminuid() {
  adminuid_ = GOOGLE_ULONGLONG(0);
  clear_has_adminuid();
}
inline ::google::protobuf::uint64 GroupApproveReq::adminuid() const {
  return adminuid_;
}
inline void GroupApproveReq::set_adminuid(::google::protobuf::uint64 value) {
  set_has_adminuid();
  adminuid_ = value;
}

// required .pp.GroupIncrementType optype = 4;
inline bool GroupApproveReq::has_optype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupApproveReq::set_has_optype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupApproveReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupApproveReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::GroupIncrementType GroupApproveReq::optype() const {
  return static_cast< ::pp::GroupIncrementType >(optype_);
}
inline void GroupApproveReq::set_optype(::pp::GroupIncrementType value) {
  assert(::pp::GroupIncrementType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional string remark = 5;
inline bool GroupApproveReq::has_remark() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupApproveReq::set_has_remark() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupApproveReq::clear_has_remark() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupApproveReq::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& GroupApproveReq::remark() const {
  return *remark_;
}
inline void GroupApproveReq::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void GroupApproveReq::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void GroupApproveReq::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupApproveReq::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* GroupApproveReq::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupApproveReq::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupApproveRes

// required .pp.GroupIncrementType applyResult = 1;
inline bool GroupApproveRes::has_applyresult() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupApproveRes::set_has_applyresult() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupApproveRes::clear_has_applyresult() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupApproveRes::clear_applyresult() {
  applyresult_ = 0;
  clear_has_applyresult();
}
inline ::pp::GroupIncrementType GroupApproveRes::applyresult() const {
  return static_cast< ::pp::GroupIncrementType >(applyresult_);
}
inline void GroupApproveRes::set_applyresult(::pp::GroupIncrementType value) {
  assert(::pp::GroupIncrementType_IsValid(value));
  set_has_applyresult();
  applyresult_ = value;
}

// optional string remark = 2;
inline bool GroupApproveRes::has_remark() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupApproveRes::set_has_remark() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupApproveRes::clear_has_remark() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupApproveRes::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& GroupApproveRes::remark() const {
  return *remark_;
}
inline void GroupApproveRes::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void GroupApproveRes::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void GroupApproveRes::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupApproveRes::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* GroupApproveRes::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupApproveRes::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupQuitReq

// optional uint64 gid = 1;
inline bool GroupQuitReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupQuitReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupQuitReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupQuitReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupQuitReq::gid() const {
  return gid_;
}
inline void GroupQuitReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 uid = 2;
inline bool GroupQuitReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupQuitReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupQuitReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupQuitReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 GroupQuitReq::uid() const {
  return uid_;
}
inline void GroupQuitReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional bool yyrepeate = 3;
inline bool GroupQuitReq::has_yyrepeate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupQuitReq::set_has_yyrepeate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupQuitReq::clear_has_yyrepeate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupQuitReq::clear_yyrepeate() {
  yyrepeate_ = false;
  clear_has_yyrepeate();
}
inline bool GroupQuitReq::yyrepeate() const {
  return yyrepeate_;
}
inline void GroupQuitReq::set_yyrepeate(bool value) {
  set_has_yyrepeate();
  yyrepeate_ = value;
}

// -------------------------------------------------------------------

// GroupInfoReq

// optional uint64 gid = 1;
inline bool GroupInfoReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupInfoReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupInfoReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupInfoReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupInfoReq::gid() const {
  return gid_;
}
inline void GroupInfoReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupInfo template = 2;
inline bool GroupInfoReq::has_template_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupInfoReq::set_has_template_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupInfoReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupInfoReq::clear_template_() {
  if (template__ != NULL) template__->::pp::GroupInfo::Clear();
  clear_has_template_();
}
inline const ::pp::GroupInfo& GroupInfoReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::GroupInfo* GroupInfoReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::GroupInfo;
  return template__;
}
inline ::pp::GroupInfo* GroupInfoReq::release_template_() {
  clear_has_template_();
  ::pp::GroupInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void GroupInfoReq::set_allocated_template_(::pp::GroupInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// -------------------------------------------------------------------

// GroupCheckinReq

// optional uint64 gid = 1;
inline bool GroupCheckinReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupCheckinReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupCheckinReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupCheckinReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupCheckinReq::gid() const {
  return gid_;
}
inline void GroupCheckinReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// GroupCheckinRes

// optional uint32 progress = 1;
inline bool GroupCheckinRes::has_progress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupCheckinRes::set_has_progress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupCheckinRes::clear_has_progress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupCheckinRes::clear_progress() {
  progress_ = 0u;
  clear_has_progress();
}
inline ::google::protobuf::uint32 GroupCheckinRes::progress() const {
  return progress_;
}
inline void GroupCheckinRes::set_progress(::google::protobuf::uint32 value) {
  set_has_progress();
  progress_ = value;
}

// -------------------------------------------------------------------

// GroupSearchReq

// optional string keyword = 1;
inline bool GroupSearchReq::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSearchReq::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSearchReq::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSearchReq::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GroupSearchReq::keyword() const {
  return *keyword_;
}
inline void GroupSearchReq::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupSearchReq::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupSearchReq::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSearchReq::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GroupSearchReq::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupSearchReq::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 index = 2;
inline bool GroupSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSearchReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GroupSearchReq::index() const {
  return index_;
}
inline void GroupSearchReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GroupSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupSearchReq::fetchs() const {
  return fetchs_;
}
inline void GroupSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.GroupType gtype = 5;
inline bool GroupSearchReq::has_gtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSearchReq::set_has_gtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSearchReq::clear_has_gtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSearchReq::clear_gtype() {
  gtype_ = 0;
  clear_has_gtype();
}
inline ::pp::GroupType GroupSearchReq::gtype() const {
  return static_cast< ::pp::GroupType >(gtype_);
}
inline void GroupSearchReq::set_gtype(::pp::GroupType value) {
  assert(::pp::GroupType_IsValid(value));
  set_has_gtype();
  gtype_ = value;
}

// optional .pp.GroupSearchBy searchBy = 10;
inline bool GroupSearchReq::has_searchby() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupSearchReq::set_has_searchby() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupSearchReq::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupSearchReq::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::GroupSearchBy GroupSearchReq::searchby() const {
  return static_cast< ::pp::GroupSearchBy >(searchby_);
}
inline void GroupSearchReq::set_searchby(::pp::GroupSearchBy value) {
  assert(::pp::GroupSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional .pp.GroupSearchOrderBy orderBy = 11;
inline bool GroupSearchReq::has_orderby() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupSearchReq::set_has_orderby() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupSearchReq::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupSearchReq::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::GroupSearchOrderBy GroupSearchReq::orderby() const {
  return static_cast< ::pp::GroupSearchOrderBy >(orderby_);
}
inline void GroupSearchReq::set_orderby(::pp::GroupSearchOrderBy value) {
  assert(::pp::GroupSearchOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional .pp.GroupInfo template = 15;
inline bool GroupSearchReq::has_template_() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupSearchReq::set_has_template_() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupSearchReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupSearchReq::clear_template_() {
  if (template__ != NULL) template__->::pp::GroupInfo::Clear();
  clear_has_template_();
}
inline const ::pp::GroupInfo& GroupSearchReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::GroupInfo* GroupSearchReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::GroupInfo;
  return template__;
}
inline ::pp::GroupInfo* GroupSearchReq::release_template_() {
  clear_has_template_();
  ::pp::GroupInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void GroupSearchReq::set_allocated_template_(::pp::GroupInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// optional uint32 gameid = 16;
inline bool GroupSearchReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupSearchReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupSearchReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupSearchReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupSearchReq::gameid() const {
  return gameid_;
}
inline void GroupSearchReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint64 giftid = 17;
inline bool GroupSearchReq::has_giftid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupSearchReq::set_has_giftid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupSearchReq::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupSearchReq::clear_giftid() {
  giftid_ = GOOGLE_ULONGLONG(0);
  clear_has_giftid();
}
inline ::google::protobuf::uint64 GroupSearchReq::giftid() const {
  return giftid_;
}
inline void GroupSearchReq::set_giftid(::google::protobuf::uint64 value) {
  set_has_giftid();
  giftid_ = value;
}

// optional uint64 cacheKey = 100;
inline bool GroupSearchReq::has_cachekey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupSearchReq::set_has_cachekey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupSearchReq::clear_has_cachekey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupSearchReq::clear_cachekey() {
  cachekey_ = GOOGLE_ULONGLONG(0);
  clear_has_cachekey();
}
inline ::google::protobuf::uint64 GroupSearchReq::cachekey() const {
  return cachekey_;
}
inline void GroupSearchReq::set_cachekey(::google::protobuf::uint64 value) {
  set_has_cachekey();
  cachekey_ = value;
}

// -------------------------------------------------------------------

// GroupSearchRes

// optional string keyword = 1;
inline bool GroupSearchRes::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSearchRes::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSearchRes::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSearchRes::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GroupSearchRes::keyword() const {
  return *keyword_;
}
inline void GroupSearchRes::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupSearchRes::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupSearchRes::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSearchRes::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GroupSearchRes::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupSearchRes::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 total = 2;
inline bool GroupSearchRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupSearchRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupSearchRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupSearchRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GroupSearchRes::total() const {
  return total_;
}
inline void GroupSearchRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 index = 3;
inline bool GroupSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupSearchRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GroupSearchRes::index() const {
  return index_;
}
inline void GroupSearchRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 4;
inline bool GroupSearchRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupSearchRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupSearchRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupSearchRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupSearchRes::fetchs() const {
  return fetchs_;
}
inline void GroupSearchRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.GroupType gtype = 5;
inline bool GroupSearchRes::has_gtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupSearchRes::set_has_gtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupSearchRes::clear_has_gtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupSearchRes::clear_gtype() {
  gtype_ = 0;
  clear_has_gtype();
}
inline ::pp::GroupType GroupSearchRes::gtype() const {
  return static_cast< ::pp::GroupType >(gtype_);
}
inline void GroupSearchRes::set_gtype(::pp::GroupType value) {
  assert(::pp::GroupType_IsValid(value));
  set_has_gtype();
  gtype_ = value;
}

// optional .pp.GroupSearchBy searchBy = 10;
inline bool GroupSearchRes::has_searchby() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupSearchRes::set_has_searchby() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupSearchRes::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupSearchRes::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::GroupSearchBy GroupSearchRes::searchby() const {
  return static_cast< ::pp::GroupSearchBy >(searchby_);
}
inline void GroupSearchRes::set_searchby(::pp::GroupSearchBy value) {
  assert(::pp::GroupSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional .pp.GroupSearchOrderBy orderBy = 11;
inline bool GroupSearchRes::has_orderby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupSearchRes::set_has_orderby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupSearchRes::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupSearchRes::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::GroupSearchOrderBy GroupSearchRes::orderby() const {
  return static_cast< ::pp::GroupSearchOrderBy >(orderby_);
}
inline void GroupSearchRes::set_orderby(::pp::GroupSearchOrderBy value) {
  assert(::pp::GroupSearchOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// repeated .pp.GroupInfo groups = 20;
inline int GroupSearchRes::groups_size() const {
  return groups_.size();
}
inline void GroupSearchRes::clear_groups() {
  groups_.Clear();
}
inline const ::pp::GroupInfo& GroupSearchRes::groups(int index) const {
  return groups_.Get(index);
}
inline ::pp::GroupInfo* GroupSearchRes::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::pp::GroupInfo* GroupSearchRes::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
GroupSearchRes::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
GroupSearchRes::mutable_groups() {
  return &groups_;
}

// optional uint32 gameid = 21;
inline bool GroupSearchRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupSearchRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupSearchRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupSearchRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupSearchRes::gameid() const {
  return gameid_;
}
inline void GroupSearchRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint64 giftid = 22;
inline bool GroupSearchRes::has_giftid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupSearchRes::set_has_giftid() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupSearchRes::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupSearchRes::clear_giftid() {
  giftid_ = GOOGLE_ULONGLONG(0);
  clear_has_giftid();
}
inline ::google::protobuf::uint64 GroupSearchRes::giftid() const {
  return giftid_;
}
inline void GroupSearchRes::set_giftid(::google::protobuf::uint64 value) {
  set_has_giftid();
  giftid_ = value;
}

// optional uint64 cacheKey = 100;
inline bool GroupSearchRes::has_cachekey() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupSearchRes::set_has_cachekey() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupSearchRes::clear_has_cachekey() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupSearchRes::clear_cachekey() {
  cachekey_ = GOOGLE_ULONGLONG(0);
  clear_has_cachekey();
}
inline ::google::protobuf::uint64 GroupSearchRes::cachekey() const {
  return cachekey_;
}
inline void GroupSearchRes::set_cachekey(::google::protobuf::uint64 value) {
  set_has_cachekey();
  cachekey_ = value;
}

// -------------------------------------------------------------------

// GroupSearchKeywordsReq

// optional string keyword = 1;
inline bool GroupSearchKeywordsReq::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupSearchKeywordsReq::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupSearchKeywordsReq::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupSearchKeywordsReq::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GroupSearchKeywordsReq::keyword() const {
  return *keyword_;
}
inline void GroupSearchKeywordsReq::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupSearchKeywordsReq::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupSearchKeywordsReq::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSearchKeywordsReq::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GroupSearchKeywordsReq::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupSearchKeywordsReq::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupSearchKeywordsRes

// repeated string keywords = 1;
inline int GroupSearchKeywordsRes::keywords_size() const {
  return keywords_.size();
}
inline void GroupSearchKeywordsRes::clear_keywords() {
  keywords_.Clear();
}
inline const ::std::string& GroupSearchKeywordsRes::keywords(int index) const {
  return keywords_.Get(index);
}
inline ::std::string* GroupSearchKeywordsRes::mutable_keywords(int index) {
  return keywords_.Mutable(index);
}
inline void GroupSearchKeywordsRes::set_keywords(int index, const ::std::string& value) {
  keywords_.Mutable(index)->assign(value);
}
inline void GroupSearchKeywordsRes::set_keywords(int index, const char* value) {
  keywords_.Mutable(index)->assign(value);
}
inline void GroupSearchKeywordsRes::set_keywords(int index, const char* value, size_t size) {
  keywords_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupSearchKeywordsRes::add_keywords() {
  return keywords_.Add();
}
inline void GroupSearchKeywordsRes::add_keywords(const ::std::string& value) {
  keywords_.Add()->assign(value);
}
inline void GroupSearchKeywordsRes::add_keywords(const char* value) {
  keywords_.Add()->assign(value);
}
inline void GroupSearchKeywordsRes::add_keywords(const char* value, size_t size) {
  keywords_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GroupSearchKeywordsRes::keywords() const {
  return keywords_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GroupSearchKeywordsRes::mutable_keywords() {
  return &keywords_;
}

// -------------------------------------------------------------------

// GroupListReq

// optional uint64 revision = 1;
inline bool GroupListReq::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupListReq::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupListReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupListReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupListReq::revision() const {
  return revision_;
}
inline void GroupListReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// GroupIncrement

// optional uint64 revision = 1;
inline bool GroupIncrement::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupIncrement::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupIncrement::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupIncrement::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupIncrement::revision() const {
  return revision_;
}
inline void GroupIncrement::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional .pp.GroupIncrementType type = 2;
inline bool GroupIncrement::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupIncrement::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupIncrement::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupIncrement::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pp::GroupIncrementType GroupIncrement::type() const {
  return static_cast< ::pp::GroupIncrementType >(type_);
}
inline void GroupIncrement::set_type(::pp::GroupIncrementType value) {
  assert(::pp::GroupIncrementType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .pp.GroupInfo group = 3;
inline bool GroupIncrement::has_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupIncrement::set_has_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupIncrement::clear_has_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupIncrement::clear_group() {
  if (group_ != NULL) group_->::pp::GroupInfo::Clear();
  clear_has_group();
}
inline const ::pp::GroupInfo& GroupIncrement::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pp::GroupInfo* GroupIncrement::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pp::GroupInfo;
  return group_;
}
inline ::pp::GroupInfo* GroupIncrement::release_group() {
  clear_has_group();
  ::pp::GroupInfo* temp = group_;
  group_ = NULL;
  return temp;
}
inline void GroupIncrement::set_allocated_group(::pp::GroupInfo* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// -------------------------------------------------------------------

// GroupInfoList

// repeated .pp.GroupInfo groups = 1;
inline int GroupInfoList::groups_size() const {
  return groups_.size();
}
inline void GroupInfoList::clear_groups() {
  groups_.Clear();
}
inline const ::pp::GroupInfo& GroupInfoList::groups(int index) const {
  return groups_.Get(index);
}
inline ::pp::GroupInfo* GroupInfoList::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::pp::GroupInfo* GroupInfoList::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
GroupInfoList::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
GroupInfoList::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// GroupListRes

// optional uint64 revision = 1;
inline bool GroupListRes::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupListRes::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupListRes::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupListRes::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupListRes::revision() const {
  return revision_;
}
inline void GroupListRes::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional .pp.GroupInfoList grouplist = 2;
inline bool GroupListRes::has_grouplist() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupListRes::set_has_grouplist() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupListRes::clear_has_grouplist() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupListRes::clear_grouplist() {
  if (grouplist_ != NULL) grouplist_->::pp::GroupInfoList::Clear();
  clear_has_grouplist();
}
inline const ::pp::GroupInfoList& GroupListRes::grouplist() const {
  return grouplist_ != NULL ? *grouplist_ : *default_instance_->grouplist_;
}
inline ::pp::GroupInfoList* GroupListRes::mutable_grouplist() {
  set_has_grouplist();
  if (grouplist_ == NULL) grouplist_ = new ::pp::GroupInfoList;
  return grouplist_;
}
inline ::pp::GroupInfoList* GroupListRes::release_grouplist() {
  clear_has_grouplist();
  ::pp::GroupInfoList* temp = grouplist_;
  grouplist_ = NULL;
  return temp;
}
inline void GroupListRes::set_allocated_grouplist(::pp::GroupInfoList* grouplist) {
  delete grouplist_;
  grouplist_ = grouplist;
  if (grouplist) {
    set_has_grouplist();
  } else {
    clear_has_grouplist();
  }
}

// repeated .pp.GroupIncrement increments = 3;
inline int GroupListRes::increments_size() const {
  return increments_.size();
}
inline void GroupListRes::clear_increments() {
  increments_.Clear();
}
inline const ::pp::GroupIncrement& GroupListRes::increments(int index) const {
  return increments_.Get(index);
}
inline ::pp::GroupIncrement* GroupListRes::mutable_increments(int index) {
  return increments_.Mutable(index);
}
inline ::pp::GroupIncrement* GroupListRes::add_increments() {
  return increments_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupIncrement >&
GroupListRes::increments() const {
  return increments_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupIncrement >*
GroupListRes::mutable_increments() {
  return &increments_;
}

// optional uint64 reqrevision = 4;
inline bool GroupListRes::has_reqrevision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupListRes::set_has_reqrevision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupListRes::clear_has_reqrevision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupListRes::clear_reqrevision() {
  reqrevision_ = GOOGLE_ULONGLONG(0);
  clear_has_reqrevision();
}
inline ::google::protobuf::uint64 GroupListRes::reqrevision() const {
  return reqrevision_;
}
inline void GroupListRes::set_reqrevision(::google::protobuf::uint64 value) {
  set_has_reqrevision();
  reqrevision_ = value;
}

// -------------------------------------------------------------------

// GroupLobbyOrderModifyReq

// repeated uint64 gids = 1;
inline int GroupLobbyOrderModifyReq::gids_size() const {
  return gids_.size();
}
inline void GroupLobbyOrderModifyReq::clear_gids() {
  gids_.Clear();
}
inline ::google::protobuf::uint64 GroupLobbyOrderModifyReq::gids(int index) const {
  return gids_.Get(index);
}
inline void GroupLobbyOrderModifyReq::set_gids(int index, ::google::protobuf::uint64 value) {
  gids_.Set(index, value);
}
inline void GroupLobbyOrderModifyReq::add_gids(::google::protobuf::uint64 value) {
  gids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GroupLobbyOrderModifyReq::gids() const {
  return gids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GroupLobbyOrderModifyReq::mutable_gids() {
  return &gids_;
}

// optional uint64 parendGid = 2;
inline bool GroupLobbyOrderModifyReq::has_parendgid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupLobbyOrderModifyReq::set_has_parendgid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupLobbyOrderModifyReq::clear_has_parendgid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupLobbyOrderModifyReq::clear_parendgid() {
  parendgid_ = GOOGLE_ULONGLONG(0);
  clear_has_parendgid();
}
inline ::google::protobuf::uint64 GroupLobbyOrderModifyReq::parendgid() const {
  return parendgid_;
}
inline void GroupLobbyOrderModifyReq::set_parendgid(::google::protobuf::uint64 value) {
  set_has_parendgid();
  parendgid_ = value;
}

// -------------------------------------------------------------------

// GroupLobbyOrderModifyRes

// -------------------------------------------------------------------

// GroupLabelOpReq

// optional .pp.EntityOpType opType = 1;
inline bool GroupLabelOpReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupLabelOpReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupLabelOpReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupLabelOpReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::EntityOpType GroupLabelOpReq::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void GroupLabelOpReq::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional .pp.GroupLabel label = 2;
inline bool GroupLabelOpReq::has_label() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupLabelOpReq::set_has_label() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupLabelOpReq::clear_has_label() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupLabelOpReq::clear_label() {
  if (label_ != NULL) label_->::pp::GroupLabel::Clear();
  clear_has_label();
}
inline const ::pp::GroupLabel& GroupLabelOpReq::label() const {
  return label_ != NULL ? *label_ : *default_instance_->label_;
}
inline ::pp::GroupLabel* GroupLabelOpReq::mutable_label() {
  set_has_label();
  if (label_ == NULL) label_ = new ::pp::GroupLabel;
  return label_;
}
inline ::pp::GroupLabel* GroupLabelOpReq::release_label() {
  clear_has_label();
  ::pp::GroupLabel* temp = label_;
  label_ = NULL;
  return temp;
}
inline void GroupLabelOpReq::set_allocated_label(::pp::GroupLabel* label) {
  delete label_;
  label_ = label;
  if (label) {
    set_has_label();
  } else {
    clear_has_label();
  }
}

// -------------------------------------------------------------------

// GroupAppSendReq

// optional uint64 gid = 1;
inline bool GroupAppSendReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupAppSendReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupAppSendReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupAppSendReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupAppSendReq::gid() const {
  return gid_;
}
inline void GroupAppSendReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupApp app = 2;
inline bool GroupAppSendReq::has_app() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupAppSendReq::set_has_app() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupAppSendReq::clear_has_app() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupAppSendReq::clear_app() {
  if (app_ != NULL) app_->::pp::GroupApp::Clear();
  clear_has_app();
}
inline const ::pp::GroupApp& GroupAppSendReq::app() const {
  return app_ != NULL ? *app_ : *default_instance_->app_;
}
inline ::pp::GroupApp* GroupAppSendReq::mutable_app() {
  set_has_app();
  if (app_ == NULL) app_ = new ::pp::GroupApp;
  return app_;
}
inline ::pp::GroupApp* GroupAppSendReq::release_app() {
  clear_has_app();
  ::pp::GroupApp* temp = app_;
  app_ = NULL;
  return temp;
}
inline void GroupAppSendReq::set_allocated_app(::pp::GroupApp* app) {
  delete app_;
  app_ = app;
  if (app) {
    set_has_app();
  } else {
    clear_has_app();
  }
}

// -------------------------------------------------------------------

// GroupAppSendRes

// optional uint32 res = 1;
inline bool GroupAppSendRes::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupAppSendRes::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupAppSendRes::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupAppSendRes::clear_res() {
  res_ = 0u;
  clear_has_res();
}
inline ::google::protobuf::uint32 GroupAppSendRes::res() const {
  return res_;
}
inline void GroupAppSendRes::set_res(::google::protobuf::uint32 value) {
  set_has_res();
  res_ = value;
}

// -------------------------------------------------------------------

// GroupAppReq

// required uint64 gid = 1;
inline bool GroupAppReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupAppReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupAppReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupAppReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupAppReq::gid() const {
  return gid_;
}
inline void GroupAppReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 revision = 2;
inline bool GroupAppReq::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupAppReq::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupAppReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupAppReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupAppReq::revision() const {
  return revision_;
}
inline void GroupAppReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint32 fetchs = 3;
inline bool GroupAppReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupAppReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupAppReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupAppReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupAppReq::fetchs() const {
  return fetchs_;
}
inline void GroupAppReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 topn = 4;
inline bool GroupAppReq::has_topn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupAppReq::set_has_topn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupAppReq::clear_has_topn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupAppReq::clear_topn() {
  topn_ = 0u;
  clear_has_topn();
}
inline ::google::protobuf::uint32 GroupAppReq::topn() const {
  return topn_;
}
inline void GroupAppReq::set_topn(::google::protobuf::uint32 value) {
  set_has_topn();
  topn_ = value;
}

// -------------------------------------------------------------------

// GroupApp

// required uint64 refmsg = 1;
inline bool GroupApp::has_refmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupApp::set_has_refmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupApp::clear_has_refmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupApp::clear_refmsg() {
  refmsg_ = GOOGLE_ULONGLONG(0);
  clear_has_refmsg();
}
inline ::google::protobuf::uint64 GroupApp::refmsg() const {
  return refmsg_;
}
inline void GroupApp::set_refmsg(::google::protobuf::uint64 value) {
  set_has_refmsg();
  refmsg_ = value;
}

// required .pp.GroupAppType apptype = 2;
inline bool GroupApp::has_apptype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupApp::set_has_apptype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupApp::clear_has_apptype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupApp::clear_apptype() {
  apptype_ = 0;
  clear_has_apptype();
}
inline ::pp::GroupAppType GroupApp::apptype() const {
  return static_cast< ::pp::GroupAppType >(apptype_);
}
inline void GroupApp::set_apptype(::pp::GroupAppType value) {
  assert(::pp::GroupAppType_IsValid(value));
  set_has_apptype();
  apptype_ = value;
}

// optional .pp.GroupAppOp appop = 3;
inline bool GroupApp::has_appop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupApp::set_has_appop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupApp::clear_has_appop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupApp::clear_appop() {
  appop_ = 0;
  clear_has_appop();
}
inline ::pp::GroupAppOp GroupApp::appop() const {
  return static_cast< ::pp::GroupAppOp >(appop_);
}
inline void GroupApp::set_appop(::pp::GroupAppOp value) {
  assert(::pp::GroupAppOp_IsValid(value));
  set_has_appop();
  appop_ = value;
}

// optional string msg = 4;
inline bool GroupApp::has_msg() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupApp::set_has_msg() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupApp::clear_has_msg() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupApp::clear_msg() {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    msg_->clear();
  }
  clear_has_msg();
}
inline const ::std::string& GroupApp::msg() const {
  return *msg_;
}
inline void GroupApp::set_msg(const ::std::string& value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GroupApp::set_msg(const char* value) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(value);
}
inline void GroupApp::set_msg(const char* value, size_t size) {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  msg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupApp::mutable_msg() {
  set_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    msg_ = new ::std::string;
  }
  return msg_;
}
inline ::std::string* GroupApp::release_msg() {
  clear_has_msg();
  if (msg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msg_;
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupApp::set_allocated_msg(::std::string* msg) {
  if (msg_ != &::google::protobuf::internal::kEmptyString) {
    delete msg_;
  }
  if (msg) {
    set_has_msg();
    msg_ = msg;
  } else {
    clear_has_msg();
    msg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 5;
inline bool GroupApp::has_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupApp::set_has_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupApp::clear_has_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupApp::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 GroupApp::uid() const {
  return uid_;
}
inline void GroupApp::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 revision = 6;
inline bool GroupApp::has_revision() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupApp::set_has_revision() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupApp::clear_has_revision() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupApp::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupApp::revision() const {
  return revision_;
}
inline void GroupApp::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional int64 timestamp = 7;
inline bool GroupApp::has_timestamp() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupApp::set_has_timestamp() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupApp::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupApp::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 GroupApp::timestamp() const {
  return timestamp_;
}
inline void GroupApp::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// -------------------------------------------------------------------

// GroupAppList

// required uint64 revision = 1;
inline bool GroupAppList::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupAppList::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupAppList::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupAppList::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupAppList::revision() const {
  return revision_;
}
inline void GroupAppList::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// required uint64 gid = 2;
inline bool GroupAppList::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupAppList::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupAppList::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupAppList::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupAppList::gid() const {
  return gid_;
}
inline void GroupAppList::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated .pp.GroupApp apps = 3;
inline int GroupAppList::apps_size() const {
  return apps_.size();
}
inline void GroupAppList::clear_apps() {
  apps_.Clear();
}
inline const ::pp::GroupApp& GroupAppList::apps(int index) const {
  return apps_.Get(index);
}
inline ::pp::GroupApp* GroupAppList::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::pp::GroupApp* GroupAppList::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupApp >&
GroupAppList::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupApp >*
GroupAppList::mutable_apps() {
  return &apps_;
}

// -------------------------------------------------------------------

// GroupAppListReq

// repeated .pp.GroupAppReq groups = 1;
inline int GroupAppListReq::groups_size() const {
  return groups_.size();
}
inline void GroupAppListReq::clear_groups() {
  groups_.Clear();
}
inline const ::pp::GroupAppReq& GroupAppListReq::groups(int index) const {
  return groups_.Get(index);
}
inline ::pp::GroupAppReq* GroupAppListReq::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::pp::GroupAppReq* GroupAppListReq::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupAppReq >&
GroupAppListReq::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupAppReq >*
GroupAppListReq::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// GroupAppListRes

// repeated .pp.GroupAppList applist = 1;
inline int GroupAppListRes::applist_size() const {
  return applist_.size();
}
inline void GroupAppListRes::clear_applist() {
  applist_.Clear();
}
inline const ::pp::GroupAppList& GroupAppListRes::applist(int index) const {
  return applist_.Get(index);
}
inline ::pp::GroupAppList* GroupAppListRes::mutable_applist(int index) {
  return applist_.Mutable(index);
}
inline ::pp::GroupAppList* GroupAppListRes::add_applist() {
  return applist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupAppList >&
GroupAppListRes::applist() const {
  return applist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupAppList >*
GroupAppListRes::mutable_applist() {
  return &applist_;
}

// -------------------------------------------------------------------

// GroupMsgAppReq

// required uint64 gid = 1;
inline bool GroupMsgAppReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgAppReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgAppReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgAppReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgAppReq::gid() const {
  return gid_;
}
inline void GroupMsgAppReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated uint64 refmsgs = 2;
inline int GroupMsgAppReq::refmsgs_size() const {
  return refmsgs_.size();
}
inline void GroupMsgAppReq::clear_refmsgs() {
  refmsgs_.Clear();
}
inline ::google::protobuf::uint64 GroupMsgAppReq::refmsgs(int index) const {
  return refmsgs_.Get(index);
}
inline void GroupMsgAppReq::set_refmsgs(int index, ::google::protobuf::uint64 value) {
  refmsgs_.Set(index, value);
}
inline void GroupMsgAppReq::add_refmsgs(::google::protobuf::uint64 value) {
  refmsgs_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
GroupMsgAppReq::refmsgs() const {
  return refmsgs_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
GroupMsgAppReq::mutable_refmsgs() {
  return &refmsgs_;
}

// -------------------------------------------------------------------

// GroupMsgApp

// required uint64 refmsg = 1;
inline bool GroupMsgApp::has_refmsg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgApp::set_has_refmsg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgApp::clear_has_refmsg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgApp::clear_refmsg() {
  refmsg_ = GOOGLE_ULONGLONG(0);
  clear_has_refmsg();
}
inline ::google::protobuf::uint64 GroupMsgApp::refmsg() const {
  return refmsg_;
}
inline void GroupMsgApp::set_refmsg(::google::protobuf::uint64 value) {
  set_has_refmsg();
  refmsg_ = value;
}

// optional .pp.ExtProps extprops = 3;
inline bool GroupMsgApp::has_extprops() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgApp::set_has_extprops() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgApp::clear_has_extprops() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgApp::clear_extprops() {
  if (extprops_ != NULL) extprops_->::pp::ExtProps::Clear();
  clear_has_extprops();
}
inline const ::pp::ExtProps& GroupMsgApp::extprops() const {
  return extprops_ != NULL ? *extprops_ : *default_instance_->extprops_;
}
inline ::pp::ExtProps* GroupMsgApp::mutable_extprops() {
  set_has_extprops();
  if (extprops_ == NULL) extprops_ = new ::pp::ExtProps;
  return extprops_;
}
inline ::pp::ExtProps* GroupMsgApp::release_extprops() {
  clear_has_extprops();
  ::pp::ExtProps* temp = extprops_;
  extprops_ = NULL;
  return temp;
}
inline void GroupMsgApp::set_allocated_extprops(::pp::ExtProps* extprops) {
  delete extprops_;
  extprops_ = extprops;
  if (extprops) {
    set_has_extprops();
  } else {
    clear_has_extprops();
  }
}

// -------------------------------------------------------------------

// GroupMsgAppRes

// required uint64 gid = 1;
inline bool GroupMsgAppRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgAppRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgAppRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgAppRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgAppRes::gid() const {
  return gid_;
}
inline void GroupMsgAppRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated .pp.GroupMsgApp apps = 2;
inline int GroupMsgAppRes::apps_size() const {
  return apps_.size();
}
inline void GroupMsgAppRes::clear_apps() {
  apps_.Clear();
}
inline const ::pp::GroupMsgApp& GroupMsgAppRes::apps(int index) const {
  return apps_.Get(index);
}
inline ::pp::GroupMsgApp* GroupMsgAppRes::mutable_apps(int index) {
  return apps_.Mutable(index);
}
inline ::pp::GroupMsgApp* GroupMsgAppRes::add_apps() {
  return apps_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgApp >&
GroupMsgAppRes::apps() const {
  return apps_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgApp >*
GroupMsgAppRes::mutable_apps() {
  return &apps_;
}

// -------------------------------------------------------------------

// GroupMemberRolerItem

// optional uint32 roler = 1;
inline bool GroupMemberRolerItem::has_roler() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberRolerItem::set_has_roler() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberRolerItem::clear_has_roler() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberRolerItem::clear_roler() {
  roler_ = 0u;
  clear_has_roler();
}
inline ::google::protobuf::uint32 GroupMemberRolerItem::roler() const {
  return roler_;
}
inline void GroupMemberRolerItem::set_roler(::google::protobuf::uint32 value) {
  set_has_roler();
  roler_ = value;
}

// optional uint32 state = 2;
inline bool GroupMemberRolerItem::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberRolerItem::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberRolerItem::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberRolerItem::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 GroupMemberRolerItem::state() const {
  return state_;
}
inline void GroupMemberRolerItem::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// GroupMemberRolerListReq

// optional uint64 gid = 1;
inline bool GroupMemberRolerListReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberRolerListReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberRolerListReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberRolerListReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberRolerListReq::gid() const {
  return gid_;
}
inline void GroupMemberRolerListReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// GroupMemberRolerListRes

// optional uint64 gid = 1;
inline bool GroupMemberRolerListRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberRolerListRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberRolerListRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberRolerListRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberRolerListRes::gid() const {
  return gid_;
}
inline void GroupMemberRolerListRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated .pp.GroupMemberRolerItem items = 2;
inline int GroupMemberRolerListRes::items_size() const {
  return items_.size();
}
inline void GroupMemberRolerListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::GroupMemberRolerItem& GroupMemberRolerListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::GroupMemberRolerItem* GroupMemberRolerListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::GroupMemberRolerItem* GroupMemberRolerListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberRolerItem >&
GroupMemberRolerListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberRolerItem >*
GroupMemberRolerListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// GroupMemberRolerSetReq

// optional uint64 gid = 1;
inline bool GroupMemberRolerSetReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberRolerSetReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberRolerSetReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberRolerSetReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberRolerSetReq::gid() const {
  return gid_;
}
inline void GroupMemberRolerSetReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMemberRolerItem item = 2;
inline bool GroupMemberRolerSetReq::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberRolerSetReq::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberRolerSetReq::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberRolerSetReq::clear_item() {
  if (item_ != NULL) item_->::pp::GroupMemberRolerItem::Clear();
  clear_has_item();
}
inline const ::pp::GroupMemberRolerItem& GroupMemberRolerSetReq::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::pp::GroupMemberRolerItem* GroupMemberRolerSetReq::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::pp::GroupMemberRolerItem;
  return item_;
}
inline ::pp::GroupMemberRolerItem* GroupMemberRolerSetReq::release_item() {
  clear_has_item();
  ::pp::GroupMemberRolerItem* temp = item_;
  item_ = NULL;
  return temp;
}
inline void GroupMemberRolerSetReq::set_allocated_item(::pp::GroupMemberRolerItem* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// GroupMemberCheckinState

// optional uint32 progress = 1;
inline bool GroupMemberCheckinState::has_progress() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberCheckinState::set_has_progress() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberCheckinState::clear_has_progress() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberCheckinState::clear_progress() {
  progress_ = 0u;
  clear_has_progress();
}
inline ::google::protobuf::uint32 GroupMemberCheckinState::progress() const {
  return progress_;
}
inline void GroupMemberCheckinState::set_progress(::google::protobuf::uint32 value) {
  set_has_progress();
  progress_ = value;
}

// optional int64 updateTime = 2;
inline bool GroupMemberCheckinState::has_updatetime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberCheckinState::set_has_updatetime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberCheckinState::clear_has_updatetime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberCheckinState::clear_updatetime() {
  updatetime_ = GOOGLE_LONGLONG(0);
  clear_has_updatetime();
}
inline ::google::protobuf::int64 GroupMemberCheckinState::updatetime() const {
  return updatetime_;
}
inline void GroupMemberCheckinState::set_updatetime(::google::protobuf::int64 value) {
  set_has_updatetime();
  updatetime_ = value;
}

// -------------------------------------------------------------------

// GroupMember

// optional .pp.UserInfo user = 1;
inline bool GroupMember::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMember::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMember::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMember::clear_user() {
  if (user_ != NULL) user_->::pp::UserInfo::Clear();
  clear_has_user();
}
inline const ::pp::UserInfo& GroupMember::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::pp::UserInfo* GroupMember::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::pp::UserInfo;
  return user_;
}
inline ::pp::UserInfo* GroupMember::release_user() {
  clear_has_user();
  ::pp::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void GroupMember::set_allocated_user(::pp::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional .pp.GroupMemberRoler roler = 2;
inline bool GroupMember::has_roler() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMember::set_has_roler() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMember::clear_has_roler() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMember::clear_roler() {
  roler_ = 0;
  clear_has_roler();
}
inline ::pp::GroupMemberRoler GroupMember::roler() const {
  return static_cast< ::pp::GroupMemberRoler >(roler_);
}
inline void GroupMember::set_roler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_roler();
  roler_ = value;
}

// optional string cardname = 3;
inline bool GroupMember::has_cardname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMember::set_has_cardname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMember::clear_has_cardname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMember::clear_cardname() {
  if (cardname_ != &::google::protobuf::internal::kEmptyString) {
    cardname_->clear();
  }
  clear_has_cardname();
}
inline const ::std::string& GroupMember::cardname() const {
  return *cardname_;
}
inline void GroupMember::set_cardname(const ::std::string& value) {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  cardname_->assign(value);
}
inline void GroupMember::set_cardname(const char* value) {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  cardname_->assign(value);
}
inline void GroupMember::set_cardname(const char* value, size_t size) {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  cardname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMember::mutable_cardname() {
  set_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    cardname_ = new ::std::string;
  }
  return cardname_;
}
inline ::std::string* GroupMember::release_cardname() {
  clear_has_cardname();
  if (cardname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cardname_;
    cardname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMember::set_allocated_cardname(::std::string* cardname) {
  if (cardname_ != &::google::protobuf::internal::kEmptyString) {
    delete cardname_;
  }
  if (cardname) {
    set_has_cardname();
    cardname_ = cardname;
  } else {
    clear_has_cardname();
    cardname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GroupMemberState state = 4;
inline bool GroupMember::has_state() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMember::set_has_state() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMember::clear_has_state() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMember::clear_state() {
  state_ = 0;
  clear_has_state();
}
inline ::pp::GroupMemberState GroupMember::state() const {
  return static_cast< ::pp::GroupMemberState >(state_);
}
inline void GroupMember::set_state(::pp::GroupMemberState value) {
  assert(::pp::GroupMemberState_IsValid(value));
  set_has_state();
  state_ = value;
}

// optional uint32 score = 5;
inline bool GroupMember::has_score() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMember::set_has_score() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMember::clear_has_score() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMember::clear_score() {
  score_ = 0u;
  clear_has_score();
}
inline ::google::protobuf::uint32 GroupMember::score() const {
  return score_;
}
inline void GroupMember::set_score(::google::protobuf::uint32 value) {
  set_has_score();
  score_ = value;
}

// optional .pp.GroupMemberCheckinState checkinState = 6;
inline bool GroupMember::has_checkinstate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMember::set_has_checkinstate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMember::clear_has_checkinstate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMember::clear_checkinstate() {
  if (checkinstate_ != NULL) checkinstate_->::pp::GroupMemberCheckinState::Clear();
  clear_has_checkinstate();
}
inline const ::pp::GroupMemberCheckinState& GroupMember::checkinstate() const {
  return checkinstate_ != NULL ? *checkinstate_ : *default_instance_->checkinstate_;
}
inline ::pp::GroupMemberCheckinState* GroupMember::mutable_checkinstate() {
  set_has_checkinstate();
  if (checkinstate_ == NULL) checkinstate_ = new ::pp::GroupMemberCheckinState;
  return checkinstate_;
}
inline ::pp::GroupMemberCheckinState* GroupMember::release_checkinstate() {
  clear_has_checkinstate();
  ::pp::GroupMemberCheckinState* temp = checkinstate_;
  checkinstate_ = NULL;
  return temp;
}
inline void GroupMember::set_allocated_checkinstate(::pp::GroupMemberCheckinState* checkinstate) {
  delete checkinstate_;
  checkinstate_ = checkinstate;
  if (checkinstate) {
    set_has_checkinstate();
  } else {
    clear_has_checkinstate();
  }
}

// optional uint32 contrib = 7;
inline bool GroupMember::has_contrib() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMember::set_has_contrib() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMember::clear_has_contrib() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMember::clear_contrib() {
  contrib_ = 0u;
  clear_has_contrib();
}
inline ::google::protobuf::uint32 GroupMember::contrib() const {
  return contrib_;
}
inline void GroupMember::set_contrib(::google::protobuf::uint32 value) {
  set_has_contrib();
  contrib_ = value;
}

// optional .pp.GroupType gtype = 8;
inline bool GroupMember::has_gtype() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMember::set_has_gtype() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMember::clear_has_gtype() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMember::clear_gtype() {
  gtype_ = 0;
  clear_has_gtype();
}
inline ::pp::GroupType GroupMember::gtype() const {
  return static_cast< ::pp::GroupType >(gtype_);
}
inline void GroupMember::set_gtype(::pp::GroupType value) {
  assert(::pp::GroupType_IsValid(value));
  set_has_gtype();
  gtype_ = value;
}

// optional .pp.GroupMemberRoler guildRoler = 9;
inline bool GroupMember::has_guildroler() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupMember::set_has_guildroler() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupMember::clear_has_guildroler() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupMember::clear_guildroler() {
  guildroler_ = 0;
  clear_has_guildroler();
}
inline ::pp::GroupMemberRoler GroupMember::guildroler() const {
  return static_cast< ::pp::GroupMemberRoler >(guildroler_);
}
inline void GroupMember::set_guildroler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_guildroler();
  guildroler_ = value;
}

// -------------------------------------------------------------------

// GroupMemberListReq

// optional uint64 gid = 1;
inline bool GroupMemberListReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberListReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberListReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberListReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberListReq::gid() const {
  return gid_;
}
inline void GroupMemberListReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 revision = 2;
inline bool GroupMemberListReq::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberListReq::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberListReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberListReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupMemberListReq::revision() const {
  return revision_;
}
inline void GroupMemberListReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// GroupMemberIncrement

// optional uint64 revision = 1;
inline bool GroupMemberIncrement::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberIncrement::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberIncrement::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberIncrement::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupMemberIncrement::revision() const {
  return revision_;
}
inline void GroupMemberIncrement::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional .pp.GroupMemberIncrementType type = 2;
inline bool GroupMemberIncrement::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberIncrement::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberIncrement::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberIncrement::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pp::GroupMemberIncrementType GroupMemberIncrement::type() const {
  return static_cast< ::pp::GroupMemberIncrementType >(type_);
}
inline void GroupMemberIncrement::set_type(::pp::GroupMemberIncrementType value) {
  assert(::pp::GroupMemberIncrementType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .pp.GroupMember member = 3;
inline bool GroupMemberIncrement::has_member() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberIncrement::set_has_member() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberIncrement::clear_has_member() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberIncrement::clear_member() {
  if (member_ != NULL) member_->::pp::GroupMember::Clear();
  clear_has_member();
}
inline const ::pp::GroupMember& GroupMemberIncrement::member() const {
  return member_ != NULL ? *member_ : *default_instance_->member_;
}
inline ::pp::GroupMember* GroupMemberIncrement::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::pp::GroupMember;
  return member_;
}
inline ::pp::GroupMember* GroupMemberIncrement::release_member() {
  clear_has_member();
  ::pp::GroupMember* temp = member_;
  member_ = NULL;
  return temp;
}
inline void GroupMemberIncrement::set_allocated_member(::pp::GroupMember* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
}

// optional string remakrs = 4;
inline bool GroupMemberIncrement::has_remakrs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMemberIncrement::set_has_remakrs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMemberIncrement::clear_has_remakrs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMemberIncrement::clear_remakrs() {
  if (remakrs_ != &::google::protobuf::internal::kEmptyString) {
    remakrs_->clear();
  }
  clear_has_remakrs();
}
inline const ::std::string& GroupMemberIncrement::remakrs() const {
  return *remakrs_;
}
inline void GroupMemberIncrement::set_remakrs(const ::std::string& value) {
  set_has_remakrs();
  if (remakrs_ == &::google::protobuf::internal::kEmptyString) {
    remakrs_ = new ::std::string;
  }
  remakrs_->assign(value);
}
inline void GroupMemberIncrement::set_remakrs(const char* value) {
  set_has_remakrs();
  if (remakrs_ == &::google::protobuf::internal::kEmptyString) {
    remakrs_ = new ::std::string;
  }
  remakrs_->assign(value);
}
inline void GroupMemberIncrement::set_remakrs(const char* value, size_t size) {
  set_has_remakrs();
  if (remakrs_ == &::google::protobuf::internal::kEmptyString) {
    remakrs_ = new ::std::string;
  }
  remakrs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMemberIncrement::mutable_remakrs() {
  set_has_remakrs();
  if (remakrs_ == &::google::protobuf::internal::kEmptyString) {
    remakrs_ = new ::std::string;
  }
  return remakrs_;
}
inline ::std::string* GroupMemberIncrement::release_remakrs() {
  clear_has_remakrs();
  if (remakrs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remakrs_;
    remakrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMemberIncrement::set_allocated_remakrs(::std::string* remakrs) {
  if (remakrs_ != &::google::protobuf::internal::kEmptyString) {
    delete remakrs_;
  }
  if (remakrs) {
    set_has_remakrs();
    remakrs_ = remakrs;
  } else {
    clear_has_remakrs();
    remakrs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GroupMemberRolerItem rolerset = 5;
inline bool GroupMemberIncrement::has_rolerset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberIncrement::set_has_rolerset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberIncrement::clear_has_rolerset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberIncrement::clear_rolerset() {
  if (rolerset_ != NULL) rolerset_->::pp::GroupMemberRolerItem::Clear();
  clear_has_rolerset();
}
inline const ::pp::GroupMemberRolerItem& GroupMemberIncrement::rolerset() const {
  return rolerset_ != NULL ? *rolerset_ : *default_instance_->rolerset_;
}
inline ::pp::GroupMemberRolerItem* GroupMemberIncrement::mutable_rolerset() {
  set_has_rolerset();
  if (rolerset_ == NULL) rolerset_ = new ::pp::GroupMemberRolerItem;
  return rolerset_;
}
inline ::pp::GroupMemberRolerItem* GroupMemberIncrement::release_rolerset() {
  clear_has_rolerset();
  ::pp::GroupMemberRolerItem* temp = rolerset_;
  rolerset_ = NULL;
  return temp;
}
inline void GroupMemberIncrement::set_allocated_rolerset(::pp::GroupMemberRolerItem* rolerset) {
  delete rolerset_;
  rolerset_ = rolerset;
  if (rolerset) {
    set_has_rolerset();
  } else {
    clear_has_rolerset();
  }
}

// -------------------------------------------------------------------

// GroupMemberList

// repeated .pp.GroupMember members = 1;
inline int GroupMemberList::members_size() const {
  return members_.size();
}
inline void GroupMemberList::clear_members() {
  members_.Clear();
}
inline const ::pp::GroupMember& GroupMemberList::members(int index) const {
  return members_.Get(index);
}
inline ::pp::GroupMember* GroupMemberList::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::pp::GroupMember* GroupMemberList::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >&
GroupMemberList::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >*
GroupMemberList::mutable_members() {
  return &members_;
}

// -------------------------------------------------------------------

// GroupMemberListRes

// optional uint64 revision = 1;
inline bool GroupMemberListRes::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberListRes::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberListRes::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberListRes::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupMemberListRes::revision() const {
  return revision_;
}
inline void GroupMemberListRes::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 gid = 2;
inline bool GroupMemberListRes::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberListRes::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberListRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberListRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberListRes::gid() const {
  return gid_;
}
inline void GroupMemberListRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMemberList memberlist = 3;
inline bool GroupMemberListRes::has_memberlist() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberListRes::set_has_memberlist() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberListRes::clear_has_memberlist() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberListRes::clear_memberlist() {
  if (memberlist_ != NULL) memberlist_->::pp::GroupMemberList::Clear();
  clear_has_memberlist();
}
inline const ::pp::GroupMemberList& GroupMemberListRes::memberlist() const {
  return memberlist_ != NULL ? *memberlist_ : *default_instance_->memberlist_;
}
inline ::pp::GroupMemberList* GroupMemberListRes::mutable_memberlist() {
  set_has_memberlist();
  if (memberlist_ == NULL) memberlist_ = new ::pp::GroupMemberList;
  return memberlist_;
}
inline ::pp::GroupMemberList* GroupMemberListRes::release_memberlist() {
  clear_has_memberlist();
  ::pp::GroupMemberList* temp = memberlist_;
  memberlist_ = NULL;
  return temp;
}
inline void GroupMemberListRes::set_allocated_memberlist(::pp::GroupMemberList* memberlist) {
  delete memberlist_;
  memberlist_ = memberlist;
  if (memberlist) {
    set_has_memberlist();
  } else {
    clear_has_memberlist();
  }
}

// repeated .pp.GroupMemberIncrement increment = 4;
inline int GroupMemberListRes::increment_size() const {
  return increment_.size();
}
inline void GroupMemberListRes::clear_increment() {
  increment_.Clear();
}
inline const ::pp::GroupMemberIncrement& GroupMemberListRes::increment(int index) const {
  return increment_.Get(index);
}
inline ::pp::GroupMemberIncrement* GroupMemberListRes::mutable_increment(int index) {
  return increment_.Mutable(index);
}
inline ::pp::GroupMemberIncrement* GroupMemberListRes::add_increment() {
  return increment_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberIncrement >&
GroupMemberListRes::increment() const {
  return increment_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMemberIncrement >*
GroupMemberListRes::mutable_increment() {
  return &increment_;
}

// optional uint64 reqrevision = 5;
inline bool GroupMemberListRes::has_reqrevision() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberListRes::set_has_reqrevision() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberListRes::clear_has_reqrevision() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberListRes::clear_reqrevision() {
  reqrevision_ = GOOGLE_ULONGLONG(0);
  clear_has_reqrevision();
}
inline ::google::protobuf::uint64 GroupMemberListRes::reqrevision() const {
  return reqrevision_;
}
inline void GroupMemberListRes::set_reqrevision(::google::protobuf::uint64 value) {
  set_has_reqrevision();
  reqrevision_ = value;
}

// -------------------------------------------------------------------

// GroupMemberReq

// optional uint64 gid = 1;
inline bool GroupMemberReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberReq::gid() const {
  return gid_;
}
inline void GroupMemberReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 uid = 2;
inline bool GroupMemberReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 GroupMemberReq::uid() const {
  return uid_;
}
inline void GroupMemberReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// GroupMemberRes

// optional uint64 gid = 1;
inline bool GroupMemberRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberRes::gid() const {
  return gid_;
}
inline void GroupMemberRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMember member = 2;
inline bool GroupMemberRes::has_member() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberRes::set_has_member() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberRes::clear_has_member() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberRes::clear_member() {
  if (member_ != NULL) member_->::pp::GroupMember::Clear();
  clear_has_member();
}
inline const ::pp::GroupMember& GroupMemberRes::member() const {
  return member_ != NULL ? *member_ : *default_instance_->member_;
}
inline ::pp::GroupMember* GroupMemberRes::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::pp::GroupMember;
  return member_;
}
inline ::pp::GroupMember* GroupMemberRes::release_member() {
  clear_has_member();
  ::pp::GroupMember* temp = member_;
  member_ = NULL;
  return temp;
}
inline void GroupMemberRes::set_allocated_member(::pp::GroupMember* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
}

// -------------------------------------------------------------------

// GroupMemberModifyReq

// optional uint64 gid = 1;
inline bool GroupMemberModifyReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberModifyReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberModifyReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberModifyReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberModifyReq::gid() const {
  return gid_;
}
inline void GroupMemberModifyReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMember member = 2;
inline bool GroupMemberModifyReq::has_member() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberModifyReq::set_has_member() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberModifyReq::clear_has_member() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberModifyReq::clear_member() {
  if (member_ != NULL) member_->::pp::GroupMember::Clear();
  clear_has_member();
}
inline const ::pp::GroupMember& GroupMemberModifyReq::member() const {
  return member_ != NULL ? *member_ : *default_instance_->member_;
}
inline ::pp::GroupMember* GroupMemberModifyReq::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::pp::GroupMember;
  return member_;
}
inline ::pp::GroupMember* GroupMemberModifyReq::release_member() {
  clear_has_member();
  ::pp::GroupMember* temp = member_;
  member_ = NULL;
  return temp;
}
inline void GroupMemberModifyReq::set_allocated_member(::pp::GroupMember* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
}

// -------------------------------------------------------------------

// GroupMemberKickReq

// optional uint64 gid = 1;
inline bool GroupMemberKickReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberKickReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberKickReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberKickReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberKickReq::gid() const {
  return gid_;
}
inline void GroupMemberKickReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 uid = 2;
inline bool GroupMemberKickReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberKickReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberKickReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberKickReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 GroupMemberKickReq::uid() const {
  return uid_;
}
inline void GroupMemberKickReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 seconds = 3;
inline bool GroupMemberKickReq::has_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberKickReq::set_has_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberKickReq::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberKickReq::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 GroupMemberKickReq::seconds() const {
  return seconds_;
}
inline void GroupMemberKickReq::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// -------------------------------------------------------------------

// GroupMemberSearchReq

// optional uint64 gid = 1;
inline bool GroupMemberSearchReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberSearchReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberSearchReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberSearchReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberSearchReq::gid() const {
  return gid_;
}
inline void GroupMemberSearchReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 index = 2;
inline bool GroupMemberSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberSearchReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GroupMemberSearchReq::index() const {
  return index_;
}
inline void GroupMemberSearchReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GroupMemberSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupMemberSearchReq::fetchs() const {
  return fetchs_;
}
inline void GroupMemberSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional string keyword = 4;
inline bool GroupMemberSearchReq::has_keyword() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMemberSearchReq::set_has_keyword() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMemberSearchReq::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMemberSearchReq::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GroupMemberSearchReq::keyword() const {
  return *keyword_;
}
inline void GroupMemberSearchReq::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupMemberSearchReq::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupMemberSearchReq::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMemberSearchReq::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GroupMemberSearchReq::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMemberSearchReq::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GroupMemberRoler miniroler = 5;
inline bool GroupMemberSearchReq::has_miniroler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberSearchReq::set_has_miniroler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberSearchReq::clear_has_miniroler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberSearchReq::clear_miniroler() {
  miniroler_ = 0;
  clear_has_miniroler();
}
inline ::pp::GroupMemberRoler GroupMemberSearchReq::miniroler() const {
  return static_cast< ::pp::GroupMemberRoler >(miniroler_);
}
inline void GroupMemberSearchReq::set_miniroler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_miniroler();
  miniroler_ = value;
}

// optional .pp.GroupMemberRoler maxiroler = 6;
inline bool GroupMemberSearchReq::has_maxiroler() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMemberSearchReq::set_has_maxiroler() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMemberSearchReq::clear_has_maxiroler() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMemberSearchReq::clear_maxiroler() {
  maxiroler_ = 0;
  clear_has_maxiroler();
}
inline ::pp::GroupMemberRoler GroupMemberSearchReq::maxiroler() const {
  return static_cast< ::pp::GroupMemberRoler >(maxiroler_);
}
inline void GroupMemberSearchReq::set_maxiroler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_maxiroler();
  maxiroler_ = value;
}

// optional .pp.GroupMemberSortBy sortby = 7;
inline bool GroupMemberSearchReq::has_sortby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMemberSearchReq::set_has_sortby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMemberSearchReq::clear_has_sortby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMemberSearchReq::clear_sortby() {
  sortby_ = 1;
  clear_has_sortby();
}
inline ::pp::GroupMemberSortBy GroupMemberSearchReq::sortby() const {
  return static_cast< ::pp::GroupMemberSortBy >(sortby_);
}
inline void GroupMemberSearchReq::set_sortby(::pp::GroupMemberSortBy value) {
  assert(::pp::GroupMemberSortBy_IsValid(value));
  set_has_sortby();
  sortby_ = value;
}

// optional .pp.GroupMemberOrderBy orderby = 8;
inline bool GroupMemberSearchReq::has_orderby() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMemberSearchReq::set_has_orderby() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMemberSearchReq::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMemberSearchReq::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::GroupMemberOrderBy GroupMemberSearchReq::orderby() const {
  return static_cast< ::pp::GroupMemberOrderBy >(orderby_);
}
inline void GroupMemberSearchReq::set_orderby(::pp::GroupMemberOrderBy value) {
  assert(::pp::GroupMemberOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional .pp.GroupMemberSearchBy searchby = 9;
inline bool GroupMemberSearchReq::has_searchby() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupMemberSearchReq::set_has_searchby() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupMemberSearchReq::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupMemberSearchReq::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::GroupMemberSearchBy GroupMemberSearchReq::searchby() const {
  return static_cast< ::pp::GroupMemberSearchBy >(searchby_);
}
inline void GroupMemberSearchReq::set_searchby(::pp::GroupMemberSearchBy value) {
  assert(::pp::GroupMemberSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional .pp.GroupMember template = 11;
inline bool GroupMemberSearchReq::has_template_() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupMemberSearchReq::set_has_template_() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupMemberSearchReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupMemberSearchReq::clear_template_() {
  if (template__ != NULL) template__->::pp::GroupMember::Clear();
  clear_has_template_();
}
inline const ::pp::GroupMember& GroupMemberSearchReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::GroupMember* GroupMemberSearchReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::GroupMember;
  return template__;
}
inline ::pp::GroupMember* GroupMemberSearchReq::release_template_() {
  clear_has_template_();
  ::pp::GroupMember* temp = template__;
  template__ = NULL;
  return temp;
}
inline void GroupMemberSearchReq::set_allocated_template_(::pp::GroupMember* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// optional uint32 gameid = 12;
inline bool GroupMemberSearchReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupMemberSearchReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupMemberSearchReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupMemberSearchReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupMemberSearchReq::gameid() const {
  return gameid_;
}
inline void GroupMemberSearchReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GroupMemberSearchRes

// optional uint64 gid = 1;
inline bool GroupMemberSearchRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberSearchRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberSearchRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberSearchRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberSearchRes::gid() const {
  return gid_;
}
inline void GroupMemberSearchRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 index = 2;
inline bool GroupMemberSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberSearchRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GroupMemberSearchRes::index() const {
  return index_;
}
inline void GroupMemberSearchRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 totalresults = 3;
inline bool GroupMemberSearchRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberSearchRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberSearchRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberSearchRes::clear_totalresults() {
  totalresults_ = 0u;
  clear_has_totalresults();
}
inline ::google::protobuf::uint32 GroupMemberSearchRes::totalresults() const {
  return totalresults_;
}
inline void GroupMemberSearchRes::set_totalresults(::google::protobuf::uint32 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// optional uint32 fetchs = 4;
inline bool GroupMemberSearchRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMemberSearchRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMemberSearchRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMemberSearchRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupMemberSearchRes::fetchs() const {
  return fetchs_;
}
inline void GroupMemberSearchRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.GroupMemberRoler miniroler = 5;
inline bool GroupMemberSearchRes::has_miniroler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberSearchRes::set_has_miniroler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberSearchRes::clear_has_miniroler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberSearchRes::clear_miniroler() {
  miniroler_ = 0;
  clear_has_miniroler();
}
inline ::pp::GroupMemberRoler GroupMemberSearchRes::miniroler() const {
  return static_cast< ::pp::GroupMemberRoler >(miniroler_);
}
inline void GroupMemberSearchRes::set_miniroler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_miniroler();
  miniroler_ = value;
}

// optional .pp.GroupMemberRoler maxiroler = 6;
inline bool GroupMemberSearchRes::has_maxiroler() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMemberSearchRes::set_has_maxiroler() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMemberSearchRes::clear_has_maxiroler() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMemberSearchRes::clear_maxiroler() {
  maxiroler_ = 0;
  clear_has_maxiroler();
}
inline ::pp::GroupMemberRoler GroupMemberSearchRes::maxiroler() const {
  return static_cast< ::pp::GroupMemberRoler >(maxiroler_);
}
inline void GroupMemberSearchRes::set_maxiroler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_maxiroler();
  maxiroler_ = value;
}

// optional .pp.GroupMemberSortBy sortby = 7;
inline bool GroupMemberSearchRes::has_sortby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMemberSearchRes::set_has_sortby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMemberSearchRes::clear_has_sortby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMemberSearchRes::clear_sortby() {
  sortby_ = 1;
  clear_has_sortby();
}
inline ::pp::GroupMemberSortBy GroupMemberSearchRes::sortby() const {
  return static_cast< ::pp::GroupMemberSortBy >(sortby_);
}
inline void GroupMemberSearchRes::set_sortby(::pp::GroupMemberSortBy value) {
  assert(::pp::GroupMemberSortBy_IsValid(value));
  set_has_sortby();
  sortby_ = value;
}

// optional .pp.GroupMemberOrderBy orderby = 8;
inline bool GroupMemberSearchRes::has_orderby() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMemberSearchRes::set_has_orderby() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMemberSearchRes::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMemberSearchRes::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::GroupMemberOrderBy GroupMemberSearchRes::orderby() const {
  return static_cast< ::pp::GroupMemberOrderBy >(orderby_);
}
inline void GroupMemberSearchRes::set_orderby(::pp::GroupMemberOrderBy value) {
  assert(::pp::GroupMemberOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional .pp.GroupMemberSearchBy searchby = 9;
inline bool GroupMemberSearchRes::has_searchby() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupMemberSearchRes::set_has_searchby() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupMemberSearchRes::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupMemberSearchRes::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::GroupMemberSearchBy GroupMemberSearchRes::searchby() const {
  return static_cast< ::pp::GroupMemberSearchBy >(searchby_);
}
inline void GroupMemberSearchRes::set_searchby(::pp::GroupMemberSearchBy value) {
  assert(::pp::GroupMemberSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional string keyword = 10;
inline bool GroupMemberSearchRes::has_keyword() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupMemberSearchRes::set_has_keyword() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupMemberSearchRes::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupMemberSearchRes::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& GroupMemberSearchRes::keyword() const {
  return *keyword_;
}
inline void GroupMemberSearchRes::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupMemberSearchRes::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void GroupMemberSearchRes::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMemberSearchRes::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* GroupMemberSearchRes::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMemberSearchRes::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.GroupMember members = 11;
inline int GroupMemberSearchRes::members_size() const {
  return members_.size();
}
inline void GroupMemberSearchRes::clear_members() {
  members_.Clear();
}
inline const ::pp::GroupMember& GroupMemberSearchRes::members(int index) const {
  return members_.Get(index);
}
inline ::pp::GroupMember* GroupMemberSearchRes::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::pp::GroupMember* GroupMemberSearchRes::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >&
GroupMemberSearchRes::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMember >*
GroupMemberSearchRes::mutable_members() {
  return &members_;
}

// optional uint32 gameid = 12;
inline bool GroupMemberSearchRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupMemberSearchRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupMemberSearchRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupMemberSearchRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupMemberSearchRes::gameid() const {
  return gameid_;
}
inline void GroupMemberSearchRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GroupMemberCountReq

// optional uint64 gid = 1;
inline bool GroupMemberCountReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberCountReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberCountReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberCountReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberCountReq::gid() const {
  return gid_;
}
inline void GroupMemberCountReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMemberCountType countType = 2;
inline bool GroupMemberCountReq::has_counttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberCountReq::set_has_counttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberCountReq::clear_has_counttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberCountReq::clear_counttype() {
  counttype_ = 0;
  clear_has_counttype();
}
inline ::pp::GroupMemberCountType GroupMemberCountReq::counttype() const {
  return static_cast< ::pp::GroupMemberCountType >(counttype_);
}
inline void GroupMemberCountReq::set_counttype(::pp::GroupMemberCountType value) {
  assert(::pp::GroupMemberCountType_IsValid(value));
  set_has_counttype();
  counttype_ = value;
}

// optional uint32 gameid = 3;
inline bool GroupMemberCountReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberCountReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberCountReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberCountReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupMemberCountReq::gameid() const {
  return gameid_;
}
inline void GroupMemberCountReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GroupMemberCountRes

// optional uint64 gid = 1;
inline bool GroupMemberCountRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMemberCountRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMemberCountRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMemberCountRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMemberCountRes::gid() const {
  return gid_;
}
inline void GroupMemberCountRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMemberCountType countType = 2;
inline bool GroupMemberCountRes::has_counttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMemberCountRes::set_has_counttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMemberCountRes::clear_has_counttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMemberCountRes::clear_counttype() {
  counttype_ = 0;
  clear_has_counttype();
}
inline ::pp::GroupMemberCountType GroupMemberCountRes::counttype() const {
  return static_cast< ::pp::GroupMemberCountType >(counttype_);
}
inline void GroupMemberCountRes::set_counttype(::pp::GroupMemberCountType value) {
  assert(::pp::GroupMemberCountType_IsValid(value));
  set_has_counttype();
  counttype_ = value;
}

// optional uint32 members = 3;
inline bool GroupMemberCountRes::has_members() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMemberCountRes::set_has_members() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMemberCountRes::clear_has_members() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMemberCountRes::clear_members() {
  members_ = 0u;
  clear_has_members();
}
inline ::google::protobuf::uint32 GroupMemberCountRes::members() const {
  return members_;
}
inline void GroupMemberCountRes::set_members(::google::protobuf::uint32 value) {
  set_has_members();
  members_ = value;
}

// optional uint32 gameid = 4;
inline bool GroupMemberCountRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMemberCountRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMemberCountRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMemberCountRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupMemberCountRes::gameid() const {
  return gameid_;
}
inline void GroupMemberCountRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 uninstalls = 5;
inline bool GroupMemberCountRes::has_uninstalls() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMemberCountRes::set_has_uninstalls() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMemberCountRes::clear_has_uninstalls() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMemberCountRes::clear_uninstalls() {
  uninstalls_ = 0u;
  clear_has_uninstalls();
}
inline ::google::protobuf::uint32 GroupMemberCountRes::uninstalls() const {
  return uninstalls_;
}
inline void GroupMemberCountRes::set_uninstalls(::google::protobuf::uint32 value) {
  set_has_uninstalls();
  uninstalls_ = value;
}

// -------------------------------------------------------------------

// GroupMsgVoiceReq

// optional uint64 gid = 1;
inline bool GroupMsgVoiceReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgVoiceReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgVoiceReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgVoiceReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgVoiceReq::gid() const {
  return gid_;
}
inline void GroupMsgVoiceReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 duration = 2;
inline bool GroupMsgVoiceReq::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgVoiceReq::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgVoiceReq::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgVoiceReq::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 GroupMsgVoiceReq::duration() const {
  return duration_;
}
inline void GroupMsgVoiceReq::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// -------------------------------------------------------------------

// GroupMsgVoiceRes

// optional uint64 gid = 1;
inline bool GroupMsgVoiceRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgVoiceRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgVoiceRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgVoiceRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgVoiceRes::gid() const {
  return gid_;
}
inline void GroupMsgVoiceRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 duration = 2;
inline bool GroupMsgVoiceRes::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgVoiceRes::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgVoiceRes::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgVoiceRes::clear_duration() {
  duration_ = 0u;
  clear_has_duration();
}
inline ::google::protobuf::uint32 GroupMsgVoiceRes::duration() const {
  return duration_;
}
inline void GroupMsgVoiceRes::set_duration(::google::protobuf::uint32 value) {
  set_has_duration();
  duration_ = value;
}

// optional string token = 3;
inline bool GroupMsgVoiceRes::has_token() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsgVoiceRes::set_has_token() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsgVoiceRes::clear_has_token() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsgVoiceRes::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& GroupMsgVoiceRes::token() const {
  return *token_;
}
inline void GroupMsgVoiceRes::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void GroupMsgVoiceRes::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void GroupMsgVoiceRes::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMsgVoiceRes::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* GroupMsgVoiceRes::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMsgVoiceRes::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupMsgReq

// optional uint64 gid = 1;
inline bool GroupMsgReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgReq::gid() const {
  return gid_;
}
inline void GroupMsgReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 revision = 2;
inline bool GroupMsgReq::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgReq::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupMsgReq::revision() const {
  return revision_;
}
inline void GroupMsgReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint32 fetchs = 3;
inline bool GroupMsgReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsgReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsgReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsgReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupMsgReq::fetchs() const {
  return fetchs_;
}
inline void GroupMsgReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 topn = 4;
inline bool GroupMsgReq::has_topn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMsgReq::set_has_topn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMsgReq::clear_has_topn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMsgReq::clear_topn() {
  topn_ = 0u;
  clear_has_topn();
}
inline ::google::protobuf::uint32 GroupMsgReq::topn() const {
  return topn_;
}
inline void GroupMsgReq::set_topn(::google::protobuf::uint32 value) {
  set_has_topn();
  topn_ = value;
}

// optional string password = 5;
inline bool GroupMsgReq::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMsgReq::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMsgReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMsgReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GroupMsgReq::password() const {
  return *password_;
}
inline void GroupMsgReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupMsgReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupMsgReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMsgReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GroupMsgReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMsgReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupMsgListReq

// repeated .pp.GroupMsgReq groups = 1;
inline int GroupMsgListReq::groups_size() const {
  return groups_.size();
}
inline void GroupMsgListReq::clear_groups() {
  groups_.Clear();
}
inline const ::pp::GroupMsgReq& GroupMsgListReq::groups(int index) const {
  return groups_.Get(index);
}
inline ::pp::GroupMsgReq* GroupMsgListReq::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::pp::GroupMsgReq* GroupMsgListReq::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgReq >&
GroupMsgListReq::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgReq >*
GroupMsgListReq::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// GroupMsg

// optional uint64 revision = 1;
inline bool GroupMsg::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsg::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsg::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsg::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupMsg::revision() const {
  return revision_;
}
inline void GroupMsg::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional string message = 2;
inline bool GroupMsg::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsg::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& GroupMsg::message() const {
  return *message_;
}
inline void GroupMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void GroupMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void GroupMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* GroupMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 timestamp = 3;
inline bool GroupMsg::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsg::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsg::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsg::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 GroupMsg::timestamp() const {
  return timestamp_;
}
inline void GroupMsg::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .pp.GroupMsgType msgtype = 5;
inline bool GroupMsg::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMsg::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMsg::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMsg::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::pp::GroupMsgType GroupMsg::msgtype() const {
  return static_cast< ::pp::GroupMsgType >(msgtype_);
}
inline void GroupMsg::set_msgtype(::pp::GroupMsgType value) {
  assert(::pp::GroupMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// optional .pp.GroupMember groupmember = 6;
inline bool GroupMsg::has_groupmember() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMsg::set_has_groupmember() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMsg::clear_has_groupmember() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMsg::clear_groupmember() {
  if (groupmember_ != NULL) groupmember_->::pp::GroupMember::Clear();
  clear_has_groupmember();
}
inline const ::pp::GroupMember& GroupMsg::groupmember() const {
  return groupmember_ != NULL ? *groupmember_ : *default_instance_->groupmember_;
}
inline ::pp::GroupMember* GroupMsg::mutable_groupmember() {
  set_has_groupmember();
  if (groupmember_ == NULL) groupmember_ = new ::pp::GroupMember;
  return groupmember_;
}
inline ::pp::GroupMember* GroupMsg::release_groupmember() {
  clear_has_groupmember();
  ::pp::GroupMember* temp = groupmember_;
  groupmember_ = NULL;
  return temp;
}
inline void GroupMsg::set_allocated_groupmember(::pp::GroupMember* groupmember) {
  delete groupmember_;
  groupmember_ = groupmember;
  if (groupmember) {
    set_has_groupmember();
  } else {
    clear_has_groupmember();
  }
}

// optional int64 storetime = 8;
inline bool GroupMsg::has_storetime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMsg::set_has_storetime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMsg::clear_has_storetime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMsg::clear_storetime() {
  storetime_ = GOOGLE_LONGLONG(0);
  clear_has_storetime();
}
inline ::google::protobuf::int64 GroupMsg::storetime() const {
  return storetime_;
}
inline void GroupMsg::set_storetime(::google::protobuf::int64 value) {
  set_has_storetime();
  storetime_ = value;
}

// optional string extfield = 9;
inline bool GroupMsg::has_extfield() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMsg::set_has_extfield() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMsg::clear_has_extfield() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMsg::clear_extfield() {
  if (extfield_ != &::google::protobuf::internal::kEmptyString) {
    extfield_->clear();
  }
  clear_has_extfield();
}
inline const ::std::string& GroupMsg::extfield() const {
  return *extfield_;
}
inline void GroupMsg::set_extfield(const ::std::string& value) {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  extfield_->assign(value);
}
inline void GroupMsg::set_extfield(const char* value) {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  extfield_->assign(value);
}
inline void GroupMsg::set_extfield(const char* value, size_t size) {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  extfield_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMsg::mutable_extfield() {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  return extfield_;
}
inline ::std::string* GroupMsg::release_extfield() {
  clear_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extfield_;
    extfield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMsg::set_allocated_extfield(::std::string* extfield) {
  if (extfield_ != &::google::protobuf::internal::kEmptyString) {
    delete extfield_;
  }
  if (extfield) {
    set_has_extfield();
    extfield_ = extfield;
  } else {
    clear_has_extfield();
    extfield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 refmsg = 10;
inline bool GroupMsg::has_refmsg() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMsg::set_has_refmsg() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMsg::clear_has_refmsg() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMsg::clear_refmsg() {
  refmsg_ = GOOGLE_ULONGLONG(0);
  clear_has_refmsg();
}
inline ::google::protobuf::uint64 GroupMsg::refmsg() const {
  return refmsg_;
}
inline void GroupMsg::set_refmsg(::google::protobuf::uint64 value) {
  set_has_refmsg();
  refmsg_ = value;
}

// optional .pp.MessageContentType contentType = 12;
inline bool GroupMsg::has_contenttype() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupMsg::set_has_contenttype() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupMsg::clear_has_contenttype() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupMsg::clear_contenttype() {
  contenttype_ = 0;
  clear_has_contenttype();
}
inline ::pp::MessageContentType GroupMsg::contenttype() const {
  return static_cast< ::pp::MessageContentType >(contenttype_);
}
inline void GroupMsg::set_contenttype(::pp::MessageContentType value) {
  assert(::pp::MessageContentType_IsValid(value));
  set_has_contenttype();
  contenttype_ = value;
}

// optional .pp.GroupInfo group = 13;
inline bool GroupMsg::has_group() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupMsg::set_has_group() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupMsg::clear_has_group() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupMsg::clear_group() {
  if (group_ != NULL) group_->::pp::GroupInfo::Clear();
  clear_has_group();
}
inline const ::pp::GroupInfo& GroupMsg::group() const {
  return group_ != NULL ? *group_ : *default_instance_->group_;
}
inline ::pp::GroupInfo* GroupMsg::mutable_group() {
  set_has_group();
  if (group_ == NULL) group_ = new ::pp::GroupInfo;
  return group_;
}
inline ::pp::GroupInfo* GroupMsg::release_group() {
  clear_has_group();
  ::pp::GroupInfo* temp = group_;
  group_ = NULL;
  return temp;
}
inline void GroupMsg::set_allocated_group(::pp::GroupInfo* group) {
  delete group_;
  group_ = group;
  if (group) {
    set_has_group();
  } else {
    clear_has_group();
  }
}

// optional .pp.ExtProps extprops = 14;
inline bool GroupMsg::has_extprops() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void GroupMsg::set_has_extprops() {
  _has_bits_[0] |= 0x00000400u;
}
inline void GroupMsg::clear_has_extprops() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void GroupMsg::clear_extprops() {
  if (extprops_ != NULL) extprops_->::pp::ExtProps::Clear();
  clear_has_extprops();
}
inline const ::pp::ExtProps& GroupMsg::extprops() const {
  return extprops_ != NULL ? *extprops_ : *default_instance_->extprops_;
}
inline ::pp::ExtProps* GroupMsg::mutable_extprops() {
  set_has_extprops();
  if (extprops_ == NULL) extprops_ = new ::pp::ExtProps;
  return extprops_;
}
inline ::pp::ExtProps* GroupMsg::release_extprops() {
  clear_has_extprops();
  ::pp::ExtProps* temp = extprops_;
  extprops_ = NULL;
  return temp;
}
inline void GroupMsg::set_allocated_extprops(::pp::ExtProps* extprops) {
  delete extprops_;
  extprops_ = extprops;
  if (extprops) {
    set_has_extprops();
  } else {
    clear_has_extprops();
  }
}

// -------------------------------------------------------------------

// GroupMsgList

// optional uint64 revision = 1;
inline bool GroupMsgList::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgList::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgList::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgList::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 GroupMsgList::revision() const {
  return revision_;
}
inline void GroupMsgList::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 gid = 2;
inline bool GroupMsgList::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgList::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgList::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgList::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgList::gid() const {
  return gid_;
}
inline void GroupMsgList::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated .pp.GroupMsg msgs = 3;
inline int GroupMsgList::msgs_size() const {
  return msgs_.size();
}
inline void GroupMsgList::clear_msgs() {
  msgs_.Clear();
}
inline const ::pp::GroupMsg& GroupMsgList::msgs(int index) const {
  return msgs_.Get(index);
}
inline ::pp::GroupMsg* GroupMsgList::mutable_msgs(int index) {
  return msgs_.Mutable(index);
}
inline ::pp::GroupMsg* GroupMsgList::add_msgs() {
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >&
GroupMsgList::msgs() const {
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >*
GroupMsgList::mutable_msgs() {
  return &msgs_;
}

// optional uint64 apprevision = 5;
inline bool GroupMsgList::has_apprevision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMsgList::set_has_apprevision() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMsgList::clear_has_apprevision() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMsgList::clear_apprevision() {
  apprevision_ = GOOGLE_ULONGLONG(0);
  clear_has_apprevision();
}
inline ::google::protobuf::uint64 GroupMsgList::apprevision() const {
  return apprevision_;
}
inline void GroupMsgList::set_apprevision(::google::protobuf::uint64 value) {
  set_has_apprevision();
  apprevision_ = value;
}

// optional uint64 revread = 7;
inline bool GroupMsgList::has_revread() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMsgList::set_has_revread() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMsgList::clear_has_revread() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMsgList::clear_revread() {
  revread_ = GOOGLE_ULONGLONG(0);
  clear_has_revread();
}
inline ::google::protobuf::uint64 GroupMsgList::revread() const {
  return revread_;
}
inline void GroupMsgList::set_revread(::google::protobuf::uint64 value) {
  set_has_revread();
  revread_ = value;
}

// optional uint32 fetchs = 8;
inline bool GroupMsgList::has_fetchs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMsgList::set_has_fetchs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMsgList::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMsgList::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupMsgList::fetchs() const {
  return fetchs_;
}
inline void GroupMsgList::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 topn = 9;
inline bool GroupMsgList::has_topn() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMsgList::set_has_topn() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMsgList::clear_has_topn() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMsgList::clear_topn() {
  topn_ = 0u;
  clear_has_topn();
}
inline ::google::protobuf::uint32 GroupMsgList::topn() const {
  return topn_;
}
inline void GroupMsgList::set_topn(::google::protobuf::uint32 value) {
  set_has_topn();
  topn_ = value;
}

// -------------------------------------------------------------------

// GroupMsgListRes

// repeated .pp.GroupMsgList msglists = 1;
inline int GroupMsgListRes::msglists_size() const {
  return msglists_.size();
}
inline void GroupMsgListRes::clear_msglists() {
  msglists_.Clear();
}
inline const ::pp::GroupMsgList& GroupMsgListRes::msglists(int index) const {
  return msglists_.Get(index);
}
inline ::pp::GroupMsgList* GroupMsgListRes::mutable_msglists(int index) {
  return msglists_.Mutable(index);
}
inline ::pp::GroupMsgList* GroupMsgListRes::add_msglists() {
  return msglists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgList >&
GroupMsgListRes::msglists() const {
  return msglists_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsgList >*
GroupMsgListRes::mutable_msglists() {
  return &msglists_;
}

// repeated .pp.UserInfo users = 2;
inline int GroupMsgListRes::users_size() const {
  return users_.size();
}
inline void GroupMsgListRes::clear_users() {
  users_.Clear();
}
inline const ::pp::UserInfo& GroupMsgListRes::users(int index) const {
  return users_.Get(index);
}
inline ::pp::UserInfo* GroupMsgListRes::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::pp::UserInfo* GroupMsgListRes::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
GroupMsgListRes::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
GroupMsgListRes::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// GroupMsgSearchReq

// optional uint64 gid = 1;
inline bool GroupMsgSearchReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgSearchReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgSearchReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgSearchReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgSearchReq::gid() const {
  return gid_;
}
inline void GroupMsgSearchReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 index = 2;
inline bool GroupMsgSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgSearchReq::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 GroupMsgSearchReq::index() const {
  return index_;
}
inline void GroupMsgSearchReq::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GroupMsgSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsgSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsgSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsgSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupMsgSearchReq::fetchs() const {
  return fetchs_;
}
inline void GroupMsgSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.GroupMsgType msgtype = 4;
inline bool GroupMsgSearchReq::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMsgSearchReq::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMsgSearchReq::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMsgSearchReq::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::pp::GroupMsgType GroupMsgSearchReq::msgtype() const {
  return static_cast< ::pp::GroupMsgType >(msgtype_);
}
inline void GroupMsgSearchReq::set_msgtype(::pp::GroupMsgType value) {
  assert(::pp::GroupMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// optional string password = 5;
inline bool GroupMsgSearchReq::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMsgSearchReq::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMsgSearchReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMsgSearchReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& GroupMsgSearchReq::password() const {
  return *password_;
}
inline void GroupMsgSearchReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupMsgSearchReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void GroupMsgSearchReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMsgSearchReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* GroupMsgSearchReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMsgSearchReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.MessageContentType contentTypes = 6;
inline int GroupMsgSearchReq::contenttypes_size() const {
  return contenttypes_.size();
}
inline void GroupMsgSearchReq::clear_contenttypes() {
  contenttypes_.Clear();
}
inline ::pp::MessageContentType GroupMsgSearchReq::contenttypes(int index) const {
  return static_cast< ::pp::MessageContentType >(contenttypes_.Get(index));
}
inline void GroupMsgSearchReq::set_contenttypes(int index, ::pp::MessageContentType value) {
  assert(::pp::MessageContentType_IsValid(value));
  contenttypes_.Set(index, value);
}
inline void GroupMsgSearchReq::add_contenttypes(::pp::MessageContentType value) {
  assert(::pp::MessageContentType_IsValid(value));
  contenttypes_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GroupMsgSearchReq::contenttypes() const {
  return contenttypes_;
}
inline ::google::protobuf::RepeatedField<int>*
GroupMsgSearchReq::mutable_contenttypes() {
  return &contenttypes_;
}

// optional .pp.GroupMsgSortBy sortby = 7;
inline bool GroupMsgSearchReq::has_sortby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMsgSearchReq::set_has_sortby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMsgSearchReq::clear_has_sortby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMsgSearchReq::clear_sortby() {
  sortby_ = 0;
  clear_has_sortby();
}
inline ::pp::GroupMsgSortBy GroupMsgSearchReq::sortby() const {
  return static_cast< ::pp::GroupMsgSortBy >(sortby_);
}
inline void GroupMsgSearchReq::set_sortby(::pp::GroupMsgSortBy value) {
  assert(::pp::GroupMsgSortBy_IsValid(value));
  set_has_sortby();
  sortby_ = value;
}

// optional .pp.GroupMsgOrderBy orderby = 8;
inline bool GroupMsgSearchReq::has_orderby() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMsgSearchReq::set_has_orderby() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMsgSearchReq::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMsgSearchReq::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::GroupMsgOrderBy GroupMsgSearchReq::orderby() const {
  return static_cast< ::pp::GroupMsgOrderBy >(orderby_);
}
inline void GroupMsgSearchReq::set_orderby(::pp::GroupMsgOrderBy value) {
  assert(::pp::GroupMsgOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional bool compress = 9;
inline bool GroupMsgSearchReq::has_compress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void GroupMsgSearchReq::set_has_compress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void GroupMsgSearchReq::clear_has_compress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void GroupMsgSearchReq::clear_compress() {
  compress_ = false;
  clear_has_compress();
}
inline bool GroupMsgSearchReq::compress() const {
  return compress_;
}
inline void GroupMsgSearchReq::set_compress(bool value) {
  set_has_compress();
  compress_ = value;
}

// optional int64 cacheKey = 10;
inline bool GroupMsgSearchReq::has_cachekey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupMsgSearchReq::set_has_cachekey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupMsgSearchReq::clear_has_cachekey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupMsgSearchReq::clear_cachekey() {
  cachekey_ = GOOGLE_LONGLONG(0);
  clear_has_cachekey();
}
inline ::google::protobuf::int64 GroupMsgSearchReq::cachekey() const {
  return cachekey_;
}
inline void GroupMsgSearchReq::set_cachekey(::google::protobuf::int64 value) {
  set_has_cachekey();
  cachekey_ = value;
}

// -------------------------------------------------------------------

// GroupMsgSearchRes

// optional uint64 gid = 1;
inline bool GroupMsgSearchRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgSearchRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgSearchRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgSearchRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgSearchRes::gid() const {
  return gid_;
}
inline void GroupMsgSearchRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 index = 2;
inline bool GroupMsgSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgSearchRes::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 GroupMsgSearchRes::index() const {
  return index_;
}
inline void GroupMsgSearchRes::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
}

// optional uint64 totalresults = 3;
inline bool GroupMsgSearchRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMsgSearchRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMsgSearchRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMsgSearchRes::clear_totalresults() {
  totalresults_ = GOOGLE_ULONGLONG(0);
  clear_has_totalresults();
}
inline ::google::protobuf::uint64 GroupMsgSearchRes::totalresults() const {
  return totalresults_;
}
inline void GroupMsgSearchRes::set_totalresults(::google::protobuf::uint64 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// optional uint32 fetchs = 4;
inline bool GroupMsgSearchRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMsgSearchRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMsgSearchRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMsgSearchRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupMsgSearchRes::fetchs() const {
  return fetchs_;
}
inline void GroupMsgSearchRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.GroupMsgType msgtype = 5;
inline bool GroupMsgSearchRes::has_msgtype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMsgSearchRes::set_has_msgtype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMsgSearchRes::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMsgSearchRes::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::pp::GroupMsgType GroupMsgSearchRes::msgtype() const {
  return static_cast< ::pp::GroupMsgType >(msgtype_);
}
inline void GroupMsgSearchRes::set_msgtype(::pp::GroupMsgType value) {
  assert(::pp::GroupMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// repeated .pp.MessageContentType contentTypes = 6;
inline int GroupMsgSearchRes::contenttypes_size() const {
  return contenttypes_.size();
}
inline void GroupMsgSearchRes::clear_contenttypes() {
  contenttypes_.Clear();
}
inline ::pp::MessageContentType GroupMsgSearchRes::contenttypes(int index) const {
  return static_cast< ::pp::MessageContentType >(contenttypes_.Get(index));
}
inline void GroupMsgSearchRes::set_contenttypes(int index, ::pp::MessageContentType value) {
  assert(::pp::MessageContentType_IsValid(value));
  contenttypes_.Set(index, value);
}
inline void GroupMsgSearchRes::add_contenttypes(::pp::MessageContentType value) {
  assert(::pp::MessageContentType_IsValid(value));
  contenttypes_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
GroupMsgSearchRes::contenttypes() const {
  return contenttypes_;
}
inline ::google::protobuf::RepeatedField<int>*
GroupMsgSearchRes::mutable_contenttypes() {
  return &contenttypes_;
}

// optional .pp.GroupMsgSortBy sortby = 7;
inline bool GroupMsgSearchRes::has_sortby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMsgSearchRes::set_has_sortby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMsgSearchRes::clear_has_sortby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMsgSearchRes::clear_sortby() {
  sortby_ = 0;
  clear_has_sortby();
}
inline ::pp::GroupMsgSortBy GroupMsgSearchRes::sortby() const {
  return static_cast< ::pp::GroupMsgSortBy >(sortby_);
}
inline void GroupMsgSearchRes::set_sortby(::pp::GroupMsgSortBy value) {
  assert(::pp::GroupMsgSortBy_IsValid(value));
  set_has_sortby();
  sortby_ = value;
}

// optional .pp.GroupMsgOrderBy orderby = 8;
inline bool GroupMsgSearchRes::has_orderby() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void GroupMsgSearchRes::set_has_orderby() {
  _has_bits_[0] |= 0x00000080u;
}
inline void GroupMsgSearchRes::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void GroupMsgSearchRes::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::GroupMsgOrderBy GroupMsgSearchRes::orderby() const {
  return static_cast< ::pp::GroupMsgOrderBy >(orderby_);
}
inline void GroupMsgSearchRes::set_orderby(::pp::GroupMsgOrderBy value) {
  assert(::pp::GroupMsgOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// repeated .pp.GroupMsg msgs = 9;
inline int GroupMsgSearchRes::msgs_size() const {
  return msgs_.size();
}
inline void GroupMsgSearchRes::clear_msgs() {
  msgs_.Clear();
}
inline const ::pp::GroupMsg& GroupMsgSearchRes::msgs(int index) const {
  return msgs_.Get(index);
}
inline ::pp::GroupMsg* GroupMsgSearchRes::mutable_msgs(int index) {
  return msgs_.Mutable(index);
}
inline ::pp::GroupMsg* GroupMsgSearchRes::add_msgs() {
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >&
GroupMsgSearchRes::msgs() const {
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMsg >*
GroupMsgSearchRes::mutable_msgs() {
  return &msgs_;
}

// optional .pp.ErrCode errcode = 10;
inline bool GroupMsgSearchRes::has_errcode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void GroupMsgSearchRes::set_has_errcode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void GroupMsgSearchRes::clear_has_errcode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void GroupMsgSearchRes::clear_errcode() {
  errcode_ = 0;
  clear_has_errcode();
}
inline ::pp::ErrCode GroupMsgSearchRes::errcode() const {
  return static_cast< ::pp::ErrCode >(errcode_);
}
inline void GroupMsgSearchRes::set_errcode(::pp::ErrCode value) {
  assert(::pp::ErrCode_IsValid(value));
  set_has_errcode();
  errcode_ = value;
}

// repeated .pp.UserInfo users = 11;
inline int GroupMsgSearchRes::users_size() const {
  return users_.size();
}
inline void GroupMsgSearchRes::clear_users() {
  users_.Clear();
}
inline const ::pp::UserInfo& GroupMsgSearchRes::users(int index) const {
  return users_.Get(index);
}
inline ::pp::UserInfo* GroupMsgSearchRes::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::pp::UserInfo* GroupMsgSearchRes::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
GroupMsgSearchRes::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
GroupMsgSearchRes::mutable_users() {
  return &users_;
}

// optional int64 cacheKey = 12;
inline bool GroupMsgSearchRes::has_cachekey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void GroupMsgSearchRes::set_has_cachekey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void GroupMsgSearchRes::clear_has_cachekey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void GroupMsgSearchRes::clear_cachekey() {
  cachekey_ = GOOGLE_LONGLONG(0);
  clear_has_cachekey();
}
inline ::google::protobuf::int64 GroupMsgSearchRes::cachekey() const {
  return cachekey_;
}
inline void GroupMsgSearchRes::set_cachekey(::google::protobuf::int64 value) {
  set_has_cachekey();
  cachekey_ = value;
}

// -------------------------------------------------------------------

// GroupMsgSendReq

// optional uint64 gid = 1;
inline bool GroupMsgSendReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMsgSendReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMsgSendReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMsgSendReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMsgSendReq::gid() const {
  return gid_;
}
inline void GroupMsgSendReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.GroupMsg msg = 2;
inline bool GroupMsgSendReq::has_msg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMsgSendReq::set_has_msg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMsgSendReq::clear_has_msg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMsgSendReq::clear_msg() {
  if (msg_ != NULL) msg_->::pp::GroupMsg::Clear();
  clear_has_msg();
}
inline const ::pp::GroupMsg& GroupMsgSendReq::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::pp::GroupMsg* GroupMsgSendReq::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::pp::GroupMsg;
  return msg_;
}
inline ::pp::GroupMsg* GroupMsgSendReq::release_msg() {
  clear_has_msg();
  ::pp::GroupMsg* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void GroupMsgSendReq::set_allocated_msg(::pp::GroupMsg* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// -------------------------------------------------------------------

// YYAccountInfo

// optional uint64 yyuid = 1;
inline bool YYAccountInfo::has_yyuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYAccountInfo::set_has_yyuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYAccountInfo::clear_has_yyuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYAccountInfo::clear_yyuid() {
  yyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_yyuid();
}
inline ::google::protobuf::uint64 YYAccountInfo::yyuid() const {
  return yyuid_;
}
inline void YYAccountInfo::set_yyuid(::google::protobuf::uint64 value) {
  set_has_yyuid();
  yyuid_ = value;
}

// optional .pp.SexType sex = 2;
inline bool YYAccountInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYAccountInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYAccountInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYAccountInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::pp::SexType YYAccountInfo::sex() const {
  return static_cast< ::pp::SexType >(sex_);
}
inline void YYAccountInfo::set_sex(::pp::SexType value) {
  assert(::pp::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// optional string passport = 3;
inline bool YYAccountInfo::has_passport() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYAccountInfo::set_has_passport() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYAccountInfo::clear_has_passport() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYAccountInfo::clear_passport() {
  if (passport_ != &::google::protobuf::internal::kEmptyString) {
    passport_->clear();
  }
  clear_has_passport();
}
inline const ::std::string& YYAccountInfo::passport() const {
  return *passport_;
}
inline void YYAccountInfo::set_passport(const ::std::string& value) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::kEmptyString) {
    passport_ = new ::std::string;
  }
  passport_->assign(value);
}
inline void YYAccountInfo::set_passport(const char* value) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::kEmptyString) {
    passport_ = new ::std::string;
  }
  passport_->assign(value);
}
inline void YYAccountInfo::set_passport(const char* value, size_t size) {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::kEmptyString) {
    passport_ = new ::std::string;
  }
  passport_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYAccountInfo::mutable_passport() {
  set_has_passport();
  if (passport_ == &::google::protobuf::internal::kEmptyString) {
    passport_ = new ::std::string;
  }
  return passport_;
}
inline ::std::string* YYAccountInfo::release_passport() {
  clear_has_passport();
  if (passport_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passport_;
    passport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYAccountInfo::set_allocated_passport(::std::string* passport) {
  if (passport_ != &::google::protobuf::internal::kEmptyString) {
    delete passport_;
  }
  if (passport) {
    set_has_passport();
    passport_ = passport;
  } else {
    clear_has_passport();
    passport_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick = 4;
inline bool YYAccountInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYAccountInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYAccountInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYAccountInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& YYAccountInfo::nick() const {
  return *nick_;
}
inline void YYAccountInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void YYAccountInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void YYAccountInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYAccountInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* YYAccountInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYAccountInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string logourl = 5;
inline bool YYAccountInfo::has_logourl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YYAccountInfo::set_has_logourl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YYAccountInfo::clear_has_logourl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YYAccountInfo::clear_logourl() {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    logourl_->clear();
  }
  clear_has_logourl();
}
inline const ::std::string& YYAccountInfo::logourl() const {
  return *logourl_;
}
inline void YYAccountInfo::set_logourl(const ::std::string& value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void YYAccountInfo::set_logourl(const char* value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void YYAccountInfo::set_logourl(const char* value, size_t size) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYAccountInfo::mutable_logourl() {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  return logourl_;
}
inline ::std::string* YYAccountInfo::release_logourl() {
  clear_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logourl_;
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYAccountInfo::set_allocated_logourl(::std::string* logourl) {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    delete logourl_;
  }
  if (logourl) {
    set_has_logourl();
    logourl_ = logourl;
  } else {
    clear_has_logourl();
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string birthday = 6;
inline bool YYAccountInfo::has_birthday() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YYAccountInfo::set_has_birthday() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YYAccountInfo::clear_has_birthday() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YYAccountInfo::clear_birthday() {
  if (birthday_ != &::google::protobuf::internal::kEmptyString) {
    birthday_->clear();
  }
  clear_has_birthday();
}
inline const ::std::string& YYAccountInfo::birthday() const {
  return *birthday_;
}
inline void YYAccountInfo::set_birthday(const ::std::string& value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void YYAccountInfo::set_birthday(const char* value) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(value);
}
inline void YYAccountInfo::set_birthday(const char* value, size_t size) {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  birthday_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYAccountInfo::mutable_birthday() {
  set_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    birthday_ = new ::std::string;
  }
  return birthday_;
}
inline ::std::string* YYAccountInfo::release_birthday() {
  clear_has_birthday();
  if (birthday_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = birthday_;
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYAccountInfo::set_allocated_birthday(::std::string* birthday) {
  if (birthday_ != &::google::protobuf::internal::kEmptyString) {
    delete birthday_;
  }
  if (birthday) {
    set_has_birthday();
    birthday_ = birthday;
  } else {
    clear_has_birthday();
    birthday_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string openid = 9;
inline bool YYAccountInfo::has_openid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void YYAccountInfo::set_has_openid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void YYAccountInfo::clear_has_openid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void YYAccountInfo::clear_openid() {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    openid_->clear();
  }
  clear_has_openid();
}
inline const ::std::string& YYAccountInfo::openid() const {
  return *openid_;
}
inline void YYAccountInfo::set_openid(const ::std::string& value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void YYAccountInfo::set_openid(const char* value) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(value);
}
inline void YYAccountInfo::set_openid(const char* value, size_t size) {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  openid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYAccountInfo::mutable_openid() {
  set_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    openid_ = new ::std::string;
  }
  return openid_;
}
inline ::std::string* YYAccountInfo::release_openid() {
  clear_has_openid();
  if (openid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = openid_;
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYAccountInfo::set_allocated_openid(::std::string* openid) {
  if (openid_ != &::google::protobuf::internal::kEmptyString) {
    delete openid_;
  }
  if (openid) {
    set_has_openid();
    openid_ = openid;
  } else {
    clear_has_openid();
    openid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLoginReq

// optional uint64 uid = 1;
inline bool UserLoginReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserLoginReq::uid() const {
  return uid_;
}
inline void UserLoginReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string password = 2;
inline bool UserLoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& UserLoginReq::password() const {
  return *password_;
}
inline void UserLoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserLoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserLoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* UserLoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string macid = 3;
inline bool UserLoginReq::has_macid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginReq::set_has_macid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginReq::clear_has_macid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginReq::clear_macid() {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    macid_->clear();
  }
  clear_has_macid();
}
inline const ::std::string& UserLoginReq::macid() const {
  return *macid_;
}
inline void UserLoginReq::set_macid(const ::std::string& value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void UserLoginReq::set_macid(const char* value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void UserLoginReq::set_macid(const char* value, size_t size) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_macid() {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  return macid_;
}
inline ::std::string* UserLoginReq::release_macid() {
  clear_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macid_;
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_macid(::std::string* macid) {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    delete macid_;
  }
  if (macid) {
    set_has_macid();
    macid_ = macid;
  } else {
    clear_has_macid();
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cookie = 4;
inline bool UserLoginReq::has_cookie() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginReq::set_has_cookie() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginReq::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginReq::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& UserLoginReq::cookie() const {
  return *cookie_;
}
inline void UserLoginReq::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UserLoginReq::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UserLoginReq::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* UserLoginReq::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 5;
inline bool UserLoginReq::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginReq::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLoginReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLoginReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserLoginReq::name() const {
  return *name_;
}
inline void UserLoginReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserLoginReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserLoginReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserLoginReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string identifyingCode = 6;
inline bool UserLoginReq::has_identifyingcode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLoginReq::set_has_identifyingcode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserLoginReq::clear_has_identifyingcode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserLoginReq::clear_identifyingcode() {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    identifyingcode_->clear();
  }
  clear_has_identifyingcode();
}
inline const ::std::string& UserLoginReq::identifyingcode() const {
  return *identifyingcode_;
}
inline void UserLoginReq::set_identifyingcode(const ::std::string& value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void UserLoginReq::set_identifyingcode(const char* value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void UserLoginReq::set_identifyingcode(const char* value, size_t size) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_identifyingcode() {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  return identifyingcode_;
}
inline ::std::string* UserLoginReq::release_identifyingcode() {
  clear_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifyingcode_;
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_identifyingcode(::std::string* identifyingcode) {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    delete identifyingcode_;
  }
  if (identifyingcode) {
    set_has_identifyingcode();
    identifyingcode_ = identifyingcode;
  } else {
    clear_has_identifyingcode();
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 yyuid = 7;
inline bool UserLoginReq::has_yyuid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginReq::set_has_yyuid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLoginReq::clear_has_yyuid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLoginReq::clear_yyuid() {
  yyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_yyuid();
}
inline ::google::protobuf::uint64 UserLoginReq::yyuid() const {
  return yyuid_;
}
inline void UserLoginReq::set_yyuid(::google::protobuf::uint64 value) {
  set_has_yyuid();
  yyuid_ = value;
}

// optional uint32 pushSerialnum = 8;
inline bool UserLoginReq::has_pushserialnum() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginReq::set_has_pushserialnum() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLoginReq::clear_has_pushserialnum() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLoginReq::clear_pushserialnum() {
  pushserialnum_ = 0u;
  clear_has_pushserialnum();
}
inline ::google::protobuf::uint32 UserLoginReq::pushserialnum() const {
  return pushserialnum_;
}
inline void UserLoginReq::set_pushserialnum(::google::protobuf::uint32 value) {
  set_has_pushserialnum();
  pushserialnum_ = value;
}

// optional bool newsession = 9;
inline bool UserLoginReq::has_newsession() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserLoginReq::set_has_newsession() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserLoginReq::clear_has_newsession() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserLoginReq::clear_newsession() {
  newsession_ = false;
  clear_has_newsession();
}
inline bool UserLoginReq::newsession() const {
  return newsession_;
}
inline void UserLoginReq::set_newsession(bool value) {
  set_has_newsession();
  newsession_ = value;
}

// optional .pp.AccountType accountType = 10;
inline bool UserLoginReq::has_accounttype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserLoginReq::set_has_accounttype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserLoginReq::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserLoginReq::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::pp::AccountType UserLoginReq::accounttype() const {
  return static_cast< ::pp::AccountType >(accounttype_);
}
inline void UserLoginReq::set_accounttype(::pp::AccountType value) {
  assert(::pp::AccountType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional .pp.YYAccountInfo accountInfo = 11;
inline bool UserLoginReq::has_accountinfo() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserLoginReq::set_has_accountinfo() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserLoginReq::clear_has_accountinfo() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserLoginReq::clear_accountinfo() {
  if (accountinfo_ != NULL) accountinfo_->::pp::YYAccountInfo::Clear();
  clear_has_accountinfo();
}
inline const ::pp::YYAccountInfo& UserLoginReq::accountinfo() const {
  return accountinfo_ != NULL ? *accountinfo_ : *default_instance_->accountinfo_;
}
inline ::pp::YYAccountInfo* UserLoginReq::mutable_accountinfo() {
  set_has_accountinfo();
  if (accountinfo_ == NULL) accountinfo_ = new ::pp::YYAccountInfo;
  return accountinfo_;
}
inline ::pp::YYAccountInfo* UserLoginReq::release_accountinfo() {
  clear_has_accountinfo();
  ::pp::YYAccountInfo* temp = accountinfo_;
  accountinfo_ = NULL;
  return temp;
}
inline void UserLoginReq::set_allocated_accountinfo(::pp::YYAccountInfo* accountinfo) {
  delete accountinfo_;
  accountinfo_ = accountinfo;
  if (accountinfo) {
    set_has_accountinfo();
  } else {
    clear_has_accountinfo();
  }
}

// optional string devtype = 20;
inline bool UserLoginReq::has_devtype() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserLoginReq::set_has_devtype() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserLoginReq::clear_has_devtype() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserLoginReq::clear_devtype() {
  if (devtype_ != &::google::protobuf::internal::kEmptyString) {
    devtype_->clear();
  }
  clear_has_devtype();
}
inline const ::std::string& UserLoginReq::devtype() const {
  return *devtype_;
}
inline void UserLoginReq::set_devtype(const ::std::string& value) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(value);
}
inline void UserLoginReq::set_devtype(const char* value) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(value);
}
inline void UserLoginReq::set_devtype(const char* value, size_t size) {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  devtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_devtype() {
  set_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    devtype_ = new ::std::string;
  }
  return devtype_;
}
inline ::std::string* UserLoginReq::release_devtype() {
  clear_has_devtype();
  if (devtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = devtype_;
    devtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_devtype(::std::string* devtype) {
  if (devtype_ != &::google::protobuf::internal::kEmptyString) {
    delete devtype_;
  }
  if (devtype) {
    set_has_devtype();
    devtype_ = devtype;
  } else {
    clear_has_devtype();
    devtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string osinfo = 21;
inline bool UserLoginReq::has_osinfo() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserLoginReq::set_has_osinfo() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserLoginReq::clear_has_osinfo() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserLoginReq::clear_osinfo() {
  if (osinfo_ != &::google::protobuf::internal::kEmptyString) {
    osinfo_->clear();
  }
  clear_has_osinfo();
}
inline const ::std::string& UserLoginReq::osinfo() const {
  return *osinfo_;
}
inline void UserLoginReq::set_osinfo(const ::std::string& value) {
  set_has_osinfo();
  if (osinfo_ == &::google::protobuf::internal::kEmptyString) {
    osinfo_ = new ::std::string;
  }
  osinfo_->assign(value);
}
inline void UserLoginReq::set_osinfo(const char* value) {
  set_has_osinfo();
  if (osinfo_ == &::google::protobuf::internal::kEmptyString) {
    osinfo_ = new ::std::string;
  }
  osinfo_->assign(value);
}
inline void UserLoginReq::set_osinfo(const char* value, size_t size) {
  set_has_osinfo();
  if (osinfo_ == &::google::protobuf::internal::kEmptyString) {
    osinfo_ = new ::std::string;
  }
  osinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_osinfo() {
  set_has_osinfo();
  if (osinfo_ == &::google::protobuf::internal::kEmptyString) {
    osinfo_ = new ::std::string;
  }
  return osinfo_;
}
inline ::std::string* UserLoginReq::release_osinfo() {
  clear_has_osinfo();
  if (osinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osinfo_;
    osinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_osinfo(::std::string* osinfo) {
  if (osinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete osinfo_;
  }
  if (osinfo) {
    set_has_osinfo();
    osinfo_ = osinfo;
  } else {
    clear_has_osinfo();
    osinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string finger = 22;
inline bool UserLoginReq::has_finger() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserLoginReq::set_has_finger() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserLoginReq::clear_has_finger() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserLoginReq::clear_finger() {
  if (finger_ != &::google::protobuf::internal::kEmptyString) {
    finger_->clear();
  }
  clear_has_finger();
}
inline const ::std::string& UserLoginReq::finger() const {
  return *finger_;
}
inline void UserLoginReq::set_finger(const ::std::string& value) {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  finger_->assign(value);
}
inline void UserLoginReq::set_finger(const char* value) {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  finger_->assign(value);
}
inline void UserLoginReq::set_finger(const char* value, size_t size) {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  finger_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_finger() {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  return finger_;
}
inline ::std::string* UserLoginReq::release_finger() {
  clear_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finger_;
    finger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_finger(::std::string* finger) {
  if (finger_ != &::google::protobuf::internal::kEmptyString) {
    delete finger_;
  }
  if (finger) {
    set_has_finger();
    finger_ = finger;
  } else {
    clear_has_finger();
    finger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.ProtoVersion protoVersion = 30;
inline bool UserLoginReq::has_protoversion() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserLoginReq::set_has_protoversion() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserLoginReq::clear_has_protoversion() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserLoginReq::clear_protoversion() {
  protoversion_ = 0;
  clear_has_protoversion();
}
inline ::pp::ProtoVersion UserLoginReq::protoversion() const {
  return static_cast< ::pp::ProtoVersion >(protoversion_);
}
inline void UserLoginReq::set_protoversion(::pp::ProtoVersion value) {
  assert(::pp::ProtoVersion_IsValid(value));
  set_has_protoversion();
  protoversion_ = value;
}

// optional string ipaddress = 50;
inline bool UserLoginReq::has_ipaddress() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserLoginReq::set_has_ipaddress() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserLoginReq::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserLoginReq::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& UserLoginReq::ipaddress() const {
  return *ipaddress_;
}
inline void UserLoginReq::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void UserLoginReq::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void UserLoginReq::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* UserLoginReq::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fromStore = 60;
inline bool UserLoginReq::has_fromstore() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserLoginReq::set_has_fromstore() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserLoginReq::clear_has_fromstore() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserLoginReq::clear_fromstore() {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    fromstore_->clear();
  }
  clear_has_fromstore();
}
inline const ::std::string& UserLoginReq::fromstore() const {
  return *fromstore_;
}
inline void UserLoginReq::set_fromstore(const ::std::string& value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void UserLoginReq::set_fromstore(const char* value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void UserLoginReq::set_fromstore(const char* value, size_t size) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginReq::mutable_fromstore() {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  return fromstore_;
}
inline ::std::string* UserLoginReq::release_fromstore() {
  clear_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromstore_;
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginReq::set_allocated_fromstore(::std::string* fromstore) {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    delete fromstore_;
  }
  if (fromstore) {
    set_has_fromstore();
    fromstore_ = fromstore;
  } else {
    clear_has_fromstore();
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLoginRes

// optional string cookie = 1;
inline bool UserLoginRes::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginRes::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginRes::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginRes::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& UserLoginRes::cookie() const {
  return *cookie_;
}
inline void UserLoginRes::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UserLoginRes::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UserLoginRes::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginRes::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* UserLoginRes::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginRes::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool newsession = 2;
inline bool UserLoginRes::has_newsession() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginRes::set_has_newsession() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginRes::clear_has_newsession() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginRes::clear_newsession() {
  newsession_ = false;
  clear_has_newsession();
}
inline bool UserLoginRes::newsession() const {
  return newsession_;
}
inline void UserLoginRes::set_newsession(bool value) {
  set_has_newsession();
  newsession_ = value;
}

// optional .pp.UserInfo userinfo = 3;
inline bool UserLoginRes::has_userinfo() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginRes::set_has_userinfo() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginRes::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginRes::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& UserLoginRes::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* UserLoginRes::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* UserLoginRes::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserLoginRes::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional bool newuser = 4 [default = false];
inline bool UserLoginRes::has_newuser() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginRes::set_has_newuser() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginRes::clear_has_newuser() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginRes::clear_newuser() {
  newuser_ = false;
  clear_has_newuser();
}
inline bool UserLoginRes::newuser() const {
  return newuser_;
}
inline void UserLoginRes::set_newuser(bool value) {
  set_has_newuser();
  newuser_ = value;
}

// optional int64 forbidtime = 5;
inline bool UserLoginRes::has_forbidtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginRes::set_has_forbidtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLoginRes::clear_has_forbidtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLoginRes::clear_forbidtime() {
  forbidtime_ = GOOGLE_LONGLONG(0);
  clear_has_forbidtime();
}
inline ::google::protobuf::int64 UserLoginRes::forbidtime() const {
  return forbidtime_;
}
inline void UserLoginRes::set_forbidtime(::google::protobuf::int64 value) {
  set_has_forbidtime();
  forbidtime_ = value;
}

// optional int64 currenttime = 6;
inline bool UserLoginRes::has_currenttime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLoginRes::set_has_currenttime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserLoginRes::clear_has_currenttime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserLoginRes::clear_currenttime() {
  currenttime_ = GOOGLE_LONGLONG(0);
  clear_has_currenttime();
}
inline ::google::protobuf::int64 UserLoginRes::currenttime() const {
  return currenttime_;
}
inline void UserLoginRes::set_currenttime(::google::protobuf::int64 value) {
  set_has_currenttime();
  currenttime_ = value;
}

// optional int64 logfileupload = 7;
inline bool UserLoginRes::has_logfileupload() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginRes::set_has_logfileupload() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLoginRes::clear_has_logfileupload() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLoginRes::clear_logfileupload() {
  logfileupload_ = GOOGLE_LONGLONG(0);
  clear_has_logfileupload();
}
inline ::google::protobuf::int64 UserLoginRes::logfileupload() const {
  return logfileupload_;
}
inline void UserLoginRes::set_logfileupload(::google::protobuf::int64 value) {
  set_has_logfileupload();
  logfileupload_ = value;
}

// optional uint32 loglevel = 8;
inline bool UserLoginRes::has_loglevel() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginRes::set_has_loglevel() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLoginRes::clear_has_loglevel() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLoginRes::clear_loglevel() {
  loglevel_ = 0u;
  clear_has_loglevel();
}
inline ::google::protobuf::uint32 UserLoginRes::loglevel() const {
  return loglevel_;
}
inline void UserLoginRes::set_loglevel(::google::protobuf::uint32 value) {
  set_has_loglevel();
  loglevel_ = value;
}

// -------------------------------------------------------------------

// UserLogoutReq

// -------------------------------------------------------------------

// UserLogoutRes

// -------------------------------------------------------------------

// UserPushTokenRegisterReq

// required string deviceId = 1;
inline bool UserPushTokenRegisterReq::has_deviceid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPushTokenRegisterReq::set_has_deviceid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPushTokenRegisterReq::clear_has_deviceid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPushTokenRegisterReq::clear_deviceid() {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    deviceid_->clear();
  }
  clear_has_deviceid();
}
inline const ::std::string& UserPushTokenRegisterReq::deviceid() const {
  return *deviceid_;
}
inline void UserPushTokenRegisterReq::set_deviceid(const ::std::string& value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void UserPushTokenRegisterReq::set_deviceid(const char* value) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(value);
}
inline void UserPushTokenRegisterReq::set_deviceid(const char* value, size_t size) {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  deviceid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPushTokenRegisterReq::mutable_deviceid() {
  set_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    deviceid_ = new ::std::string;
  }
  return deviceid_;
}
inline ::std::string* UserPushTokenRegisterReq::release_deviceid() {
  clear_has_deviceid();
  if (deviceid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = deviceid_;
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPushTokenRegisterReq::set_allocated_deviceid(::std::string* deviceid) {
  if (deviceid_ != &::google::protobuf::internal::kEmptyString) {
    delete deviceid_;
  }
  if (deviceid) {
    set_has_deviceid();
    deviceid_ = deviceid;
  } else {
    clear_has_deviceid();
    deviceid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string token = 2;
inline bool UserPushTokenRegisterReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPushTokenRegisterReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPushTokenRegisterReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPushTokenRegisterReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserPushTokenRegisterReq::token() const {
  return *token_;
}
inline void UserPushTokenRegisterReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserPushTokenRegisterReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserPushTokenRegisterReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPushTokenRegisterReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UserPushTokenRegisterReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPushTokenRegisterReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserPushTokenRegisterReq.DeviceType type = 3 [default = Android];
inline bool UserPushTokenRegisterReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPushTokenRegisterReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPushTokenRegisterReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPushTokenRegisterReq::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pp::UserPushTokenRegisterReq_DeviceType UserPushTokenRegisterReq::type() const {
  return static_cast< ::pp::UserPushTokenRegisterReq_DeviceType >(type_);
}
inline void UserPushTokenRegisterReq::set_type(::pp::UserPushTokenRegisterReq_DeviceType value) {
  assert(::pp::UserPushTokenRegisterReq_DeviceType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UserPushTokenRegisterRes

// -------------------------------------------------------------------

// UserWebLoginReq

// optional string verifycode = 1;
inline bool UserWebLoginReq::has_verifycode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserWebLoginReq::set_has_verifycode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserWebLoginReq::clear_has_verifycode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserWebLoginReq::clear_verifycode() {
  if (verifycode_ != &::google::protobuf::internal::kEmptyString) {
    verifycode_->clear();
  }
  clear_has_verifycode();
}
inline const ::std::string& UserWebLoginReq::verifycode() const {
  return *verifycode_;
}
inline void UserWebLoginReq::set_verifycode(const ::std::string& value) {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  verifycode_->assign(value);
}
inline void UserWebLoginReq::set_verifycode(const char* value) {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  verifycode_->assign(value);
}
inline void UserWebLoginReq::set_verifycode(const char* value, size_t size) {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  verifycode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserWebLoginReq::mutable_verifycode() {
  set_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    verifycode_ = new ::std::string;
  }
  return verifycode_;
}
inline ::std::string* UserWebLoginReq::release_verifycode() {
  clear_has_verifycode();
  if (verifycode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = verifycode_;
    verifycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserWebLoginReq::set_allocated_verifycode(::std::string* verifycode) {
  if (verifycode_ != &::google::protobuf::internal::kEmptyString) {
    delete verifycode_;
  }
  if (verifycode) {
    set_has_verifycode();
    verifycode_ = verifycode;
  } else {
    clear_has_verifycode();
    verifycode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 100;
inline bool UserWebLoginReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserWebLoginReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserWebLoginReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserWebLoginReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserWebLoginReq::uid() const {
  return uid_;
}
inline void UserWebLoginReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 roletype = 101;
inline bool UserWebLoginReq::has_roletype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserWebLoginReq::set_has_roletype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserWebLoginReq::clear_has_roletype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserWebLoginReq::clear_roletype() {
  roletype_ = 0u;
  clear_has_roletype();
}
inline ::google::protobuf::uint32 UserWebLoginReq::roletype() const {
  return roletype_;
}
inline void UserWebLoginReq::set_roletype(::google::protobuf::uint32 value) {
  set_has_roletype();
  roletype_ = value;
}

// optional string password = 102;
inline bool UserWebLoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserWebLoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserWebLoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserWebLoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& UserWebLoginReq::password() const {
  return *password_;
}
inline void UserWebLoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserWebLoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserWebLoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserWebLoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* UserWebLoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserWebLoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilephone = 103;
inline bool UserWebLoginReq::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserWebLoginReq::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserWebLoginReq::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserWebLoginReq::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& UserWebLoginReq::mobilephone() const {
  return *mobilephone_;
}
inline void UserWebLoginReq::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void UserWebLoginReq::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void UserWebLoginReq::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserWebLoginReq::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* UserWebLoginReq::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserWebLoginReq::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool qmode = 104;
inline bool UserWebLoginReq::has_qmode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserWebLoginReq::set_has_qmode() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserWebLoginReq::clear_has_qmode() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserWebLoginReq::clear_qmode() {
  qmode_ = false;
  clear_has_qmode();
}
inline bool UserWebLoginReq::qmode() const {
  return qmode_;
}
inline void UserWebLoginReq::set_qmode(bool value) {
  set_has_qmode();
  qmode_ = value;
}

// -------------------------------------------------------------------

// UserWebLoginRes

// -------------------------------------------------------------------

// UserTokenReq

// optional string macid = 1;
inline bool UserTokenReq::has_macid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTokenReq::set_has_macid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTokenReq::clear_has_macid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTokenReq::clear_macid() {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    macid_->clear();
  }
  clear_has_macid();
}
inline const ::std::string& UserTokenReq::macid() const {
  return *macid_;
}
inline void UserTokenReq::set_macid(const ::std::string& value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void UserTokenReq::set_macid(const char* value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void UserTokenReq::set_macid(const char* value, size_t size) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTokenReq::mutable_macid() {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  return macid_;
}
inline ::std::string* UserTokenReq::release_macid() {
  clear_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macid_;
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTokenReq::set_allocated_macid(::std::string* macid) {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    delete macid_;
  }
  if (macid) {
    set_has_macid();
    macid_ = macid;
  } else {
    clear_has_macid();
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobilephone = 2;
inline bool UserTokenReq::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTokenReq::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTokenReq::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTokenReq::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& UserTokenReq::mobilephone() const {
  return *mobilephone_;
}
inline void UserTokenReq::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void UserTokenReq::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void UserTokenReq::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTokenReq::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* UserTokenReq::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTokenReq::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool checkrepeat = 3;
inline bool UserTokenReq::has_checkrepeat() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTokenReq::set_has_checkrepeat() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTokenReq::clear_has_checkrepeat() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTokenReq::clear_checkrepeat() {
  checkrepeat_ = false;
  clear_has_checkrepeat();
}
inline bool UserTokenReq::checkrepeat() const {
  return checkrepeat_;
}
inline void UserTokenReq::set_checkrepeat(bool value) {
  set_has_checkrepeat();
  checkrepeat_ = value;
}

// -------------------------------------------------------------------

// UserTokenRes

// required string token = 1;
inline bool UserTokenRes::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTokenRes::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTokenRes::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTokenRes::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserTokenRes::token() const {
  return *token_;
}
inline void UserTokenRes::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserTokenRes::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserTokenRes::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTokenRes::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UserTokenRes::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTokenRes::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserActivateReq

// required string macid = 1;
inline bool UserActivateReq::has_macid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserActivateReq::set_has_macid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserActivateReq::clear_has_macid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserActivateReq::clear_macid() {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    macid_->clear();
  }
  clear_has_macid();
}
inline const ::std::string& UserActivateReq::macid() const {
  return *macid_;
}
inline void UserActivateReq::set_macid(const ::std::string& value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void UserActivateReq::set_macid(const char* value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void UserActivateReq::set_macid(const char* value, size_t size) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_macid() {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  return macid_;
}
inline ::std::string* UserActivateReq::release_macid() {
  clear_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macid_;
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_macid(::std::string* macid) {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    delete macid_;
  }
  if (macid) {
    set_has_macid();
    macid_ = macid;
  } else {
    clear_has_macid();
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 2;
inline bool UserActivateReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserActivateReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserActivateReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserActivateReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& UserActivateReq::token() const {
  return *token_;
}
inline void UserActivateReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserActivateReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void UserActivateReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* UserActivateReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string identifyingCode = 3;
inline bool UserActivateReq::has_identifyingcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserActivateReq::set_has_identifyingcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserActivateReq::clear_has_identifyingcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserActivateReq::clear_identifyingcode() {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    identifyingcode_->clear();
  }
  clear_has_identifyingcode();
}
inline const ::std::string& UserActivateReq::identifyingcode() const {
  return *identifyingcode_;
}
inline void UserActivateReq::set_identifyingcode(const ::std::string& value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void UserActivateReq::set_identifyingcode(const char* value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void UserActivateReq::set_identifyingcode(const char* value, size_t size) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_identifyingcode() {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  return identifyingcode_;
}
inline ::std::string* UserActivateReq::release_identifyingcode() {
  clear_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifyingcode_;
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_identifyingcode(::std::string* identifyingcode) {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    delete identifyingcode_;
  }
  if (identifyingcode) {
    set_has_identifyingcode();
    identifyingcode_ = identifyingcode;
  } else {
    clear_has_identifyingcode();
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 10;
inline bool UserActivateReq::has_password() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserActivateReq::set_has_password() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserActivateReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserActivateReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& UserActivateReq::password() const {
  return *password_;
}
inline void UserActivateReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserActivateReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void UserActivateReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* UserActivateReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserInfo userInfo = 11;
inline bool UserActivateReq::has_userinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserActivateReq::set_has_userinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserActivateReq::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserActivateReq::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& UserActivateReq::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* UserActivateReq::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* UserActivateReq::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserActivateReq::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional uint64 refereeUid = 15;
inline bool UserActivateReq::has_refereeuid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserActivateReq::set_has_refereeuid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserActivateReq::clear_has_refereeuid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserActivateReq::clear_refereeuid() {
  refereeuid_ = GOOGLE_ULONGLONG(0);
  clear_has_refereeuid();
}
inline ::google::protobuf::uint64 UserActivateReq::refereeuid() const {
  return refereeuid_;
}
inline void UserActivateReq::set_refereeuid(::google::protobuf::uint64 value) {
  set_has_refereeuid();
  refereeuid_ = value;
}

// optional string finger = 22;
inline bool UserActivateReq::has_finger() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserActivateReq::set_has_finger() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserActivateReq::clear_has_finger() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserActivateReq::clear_finger() {
  if (finger_ != &::google::protobuf::internal::kEmptyString) {
    finger_->clear();
  }
  clear_has_finger();
}
inline const ::std::string& UserActivateReq::finger() const {
  return *finger_;
}
inline void UserActivateReq::set_finger(const ::std::string& value) {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  finger_->assign(value);
}
inline void UserActivateReq::set_finger(const char* value) {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  finger_->assign(value);
}
inline void UserActivateReq::set_finger(const char* value, size_t size) {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  finger_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_finger() {
  set_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    finger_ = new ::std::string;
  }
  return finger_;
}
inline ::std::string* UserActivateReq::release_finger() {
  clear_has_finger();
  if (finger_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = finger_;
    finger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_finger(::std::string* finger) {
  if (finger_ != &::google::protobuf::internal::kEmptyString) {
    delete finger_;
  }
  if (finger) {
    set_has_finger();
    finger_ = finger;
  } else {
    clear_has_finger();
    finger_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.ProtoVersion protoVersion = 30;
inline bool UserActivateReq::has_protoversion() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserActivateReq::set_has_protoversion() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserActivateReq::clear_has_protoversion() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserActivateReq::clear_protoversion() {
  protoversion_ = 0;
  clear_has_protoversion();
}
inline ::pp::ProtoVersion UserActivateReq::protoversion() const {
  return static_cast< ::pp::ProtoVersion >(protoversion_);
}
inline void UserActivateReq::set_protoversion(::pp::ProtoVersion value) {
  assert(::pp::ProtoVersion_IsValid(value));
  set_has_protoversion();
  protoversion_ = value;
}

// optional string ipaddress = 40;
inline bool UserActivateReq::has_ipaddress() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserActivateReq::set_has_ipaddress() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserActivateReq::clear_has_ipaddress() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserActivateReq::clear_ipaddress() {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    ipaddress_->clear();
  }
  clear_has_ipaddress();
}
inline const ::std::string& UserActivateReq::ipaddress() const {
  return *ipaddress_;
}
inline void UserActivateReq::set_ipaddress(const ::std::string& value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void UserActivateReq::set_ipaddress(const char* value) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(value);
}
inline void UserActivateReq::set_ipaddress(const char* value, size_t size) {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  ipaddress_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_ipaddress() {
  set_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    ipaddress_ = new ::std::string;
  }
  return ipaddress_;
}
inline ::std::string* UserActivateReq::release_ipaddress() {
  clear_has_ipaddress();
  if (ipaddress_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ipaddress_;
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_ipaddress(::std::string* ipaddress) {
  if (ipaddress_ != &::google::protobuf::internal::kEmptyString) {
    delete ipaddress_;
  }
  if (ipaddress) {
    set_has_ipaddress();
    ipaddress_ = ipaddress;
  } else {
    clear_has_ipaddress();
    ipaddress_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool resetpassword = 50;
inline bool UserActivateReq::has_resetpassword() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserActivateReq::set_has_resetpassword() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserActivateReq::clear_has_resetpassword() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserActivateReq::clear_resetpassword() {
  resetpassword_ = false;
  clear_has_resetpassword();
}
inline bool UserActivateReq::resetpassword() const {
  return resetpassword_;
}
inline void UserActivateReq::set_resetpassword(bool value) {
  set_has_resetpassword();
  resetpassword_ = value;
}

// optional string fromStore = 60;
inline bool UserActivateReq::has_fromstore() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserActivateReq::set_has_fromstore() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserActivateReq::clear_has_fromstore() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserActivateReq::clear_fromstore() {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    fromstore_->clear();
  }
  clear_has_fromstore();
}
inline const ::std::string& UserActivateReq::fromstore() const {
  return *fromstore_;
}
inline void UserActivateReq::set_fromstore(const ::std::string& value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void UserActivateReq::set_fromstore(const char* value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void UserActivateReq::set_fromstore(const char* value, size_t size) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_fromstore() {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  return fromstore_;
}
inline ::std::string* UserActivateReq::release_fromstore() {
  clear_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromstore_;
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_fromstore(::std::string* fromstore) {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    delete fromstore_;
  }
  if (fromstore) {
    set_has_fromstore();
    fromstore_ = fromstore;
  } else {
    clear_has_fromstore();
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string inviteCode = 100;
inline bool UserActivateReq::has_invitecode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserActivateReq::set_has_invitecode() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserActivateReq::clear_has_invitecode() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserActivateReq::clear_invitecode() {
  if (invitecode_ != &::google::protobuf::internal::kEmptyString) {
    invitecode_->clear();
  }
  clear_has_invitecode();
}
inline const ::std::string& UserActivateReq::invitecode() const {
  return *invitecode_;
}
inline void UserActivateReq::set_invitecode(const ::std::string& value) {
  set_has_invitecode();
  if (invitecode_ == &::google::protobuf::internal::kEmptyString) {
    invitecode_ = new ::std::string;
  }
  invitecode_->assign(value);
}
inline void UserActivateReq::set_invitecode(const char* value) {
  set_has_invitecode();
  if (invitecode_ == &::google::protobuf::internal::kEmptyString) {
    invitecode_ = new ::std::string;
  }
  invitecode_->assign(value);
}
inline void UserActivateReq::set_invitecode(const char* value, size_t size) {
  set_has_invitecode();
  if (invitecode_ == &::google::protobuf::internal::kEmptyString) {
    invitecode_ = new ::std::string;
  }
  invitecode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserActivateReq::mutable_invitecode() {
  set_has_invitecode();
  if (invitecode_ == &::google::protobuf::internal::kEmptyString) {
    invitecode_ = new ::std::string;
  }
  return invitecode_;
}
inline ::std::string* UserActivateReq::release_invitecode() {
  clear_has_invitecode();
  if (invitecode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = invitecode_;
    invitecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserActivateReq::set_allocated_invitecode(::std::string* invitecode) {
  if (invitecode_ != &::google::protobuf::internal::kEmptyString) {
    delete invitecode_;
  }
  if (invitecode) {
    set_has_invitecode();
    invitecode_ = invitecode;
  } else {
    clear_has_invitecode();
    invitecode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserActivateRes

// -------------------------------------------------------------------

// AccountBindReq

// required string macid = 1;
inline bool AccountBindReq::has_macid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBindReq::set_has_macid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBindReq::clear_has_macid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBindReq::clear_macid() {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    macid_->clear();
  }
  clear_has_macid();
}
inline const ::std::string& AccountBindReq::macid() const {
  return *macid_;
}
inline void AccountBindReq::set_macid(const ::std::string& value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void AccountBindReq::set_macid(const char* value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void AccountBindReq::set_macid(const char* value, size_t size) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountBindReq::mutable_macid() {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  return macid_;
}
inline ::std::string* AccountBindReq::release_macid() {
  clear_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macid_;
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountBindReq::set_allocated_macid(::std::string* macid) {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    delete macid_;
  }
  if (macid) {
    set_has_macid();
    macid_ = macid;
  } else {
    clear_has_macid();
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 2;
inline bool AccountBindReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountBindReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountBindReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountBindReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AccountBindReq::token() const {
  return *token_;
}
inline void AccountBindReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountBindReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountBindReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountBindReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AccountBindReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountBindReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string identifyingCode = 3;
inline bool AccountBindReq::has_identifyingcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountBindReq::set_has_identifyingcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountBindReq::clear_has_identifyingcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountBindReq::clear_identifyingcode() {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    identifyingcode_->clear();
  }
  clear_has_identifyingcode();
}
inline const ::std::string& AccountBindReq::identifyingcode() const {
  return *identifyingcode_;
}
inline void AccountBindReq::set_identifyingcode(const ::std::string& value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void AccountBindReq::set_identifyingcode(const char* value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void AccountBindReq::set_identifyingcode(const char* value, size_t size) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountBindReq::mutable_identifyingcode() {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  return identifyingcode_;
}
inline ::std::string* AccountBindReq::release_identifyingcode() {
  clear_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifyingcode_;
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountBindReq::set_allocated_identifyingcode(::std::string* identifyingcode) {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    delete identifyingcode_;
  }
  if (identifyingcode) {
    set_has_identifyingcode();
    identifyingcode_ = identifyingcode;
  } else {
    clear_has_identifyingcode();
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 10;
inline bool AccountBindReq::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountBindReq::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountBindReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountBindReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 AccountBindReq::uid() const {
  return uid_;
}
inline void AccountBindReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string password = 11;
inline bool AccountBindReq::has_password() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountBindReq::set_has_password() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountBindReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountBindReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AccountBindReq::password() const {
  return *password_;
}
inline void AccountBindReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountBindReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountBindReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountBindReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AccountBindReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountBindReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountBindRes

// optional string cookie = 1;
inline bool AccountBindRes::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountBindRes::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountBindRes::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountBindRes::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& AccountBindRes::cookie() const {
  return *cookie_;
}
inline void AccountBindRes::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void AccountBindRes::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void AccountBindRes::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountBindRes::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* AccountBindRes::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountBindRes::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CpsAccountBindReq

// required string macid = 1;
inline bool CpsAccountBindReq::has_macid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpsAccountBindReq::set_has_macid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CpsAccountBindReq::clear_has_macid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CpsAccountBindReq::clear_macid() {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    macid_->clear();
  }
  clear_has_macid();
}
inline const ::std::string& CpsAccountBindReq::macid() const {
  return *macid_;
}
inline void CpsAccountBindReq::set_macid(const ::std::string& value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void CpsAccountBindReq::set_macid(const char* value) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(value);
}
inline void CpsAccountBindReq::set_macid(const char* value, size_t size) {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  macid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsAccountBindReq::mutable_macid() {
  set_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    macid_ = new ::std::string;
  }
  return macid_;
}
inline ::std::string* CpsAccountBindReq::release_macid() {
  clear_has_macid();
  if (macid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = macid_;
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsAccountBindReq::set_allocated_macid(::std::string* macid) {
  if (macid_ != &::google::protobuf::internal::kEmptyString) {
    delete macid_;
  }
  if (macid) {
    set_has_macid();
    macid_ = macid;
  } else {
    clear_has_macid();
    macid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 2;
inline bool CpsAccountBindReq::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpsAccountBindReq::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CpsAccountBindReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CpsAccountBindReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& CpsAccountBindReq::token() const {
  return *token_;
}
inline void CpsAccountBindReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CpsAccountBindReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void CpsAccountBindReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsAccountBindReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* CpsAccountBindReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsAccountBindReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string identifyingCode = 3;
inline bool CpsAccountBindReq::has_identifyingcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CpsAccountBindReq::set_has_identifyingcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CpsAccountBindReq::clear_has_identifyingcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CpsAccountBindReq::clear_identifyingcode() {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    identifyingcode_->clear();
  }
  clear_has_identifyingcode();
}
inline const ::std::string& CpsAccountBindReq::identifyingcode() const {
  return *identifyingcode_;
}
inline void CpsAccountBindReq::set_identifyingcode(const ::std::string& value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void CpsAccountBindReq::set_identifyingcode(const char* value) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(value);
}
inline void CpsAccountBindReq::set_identifyingcode(const char* value, size_t size) {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  identifyingcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsAccountBindReq::mutable_identifyingcode() {
  set_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    identifyingcode_ = new ::std::string;
  }
  return identifyingcode_;
}
inline ::std::string* CpsAccountBindReq::release_identifyingcode() {
  clear_has_identifyingcode();
  if (identifyingcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = identifyingcode_;
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsAccountBindReq::set_allocated_identifyingcode(::std::string* identifyingcode) {
  if (identifyingcode_ != &::google::protobuf::internal::kEmptyString) {
    delete identifyingcode_;
  }
  if (identifyingcode) {
    set_has_identifyingcode();
    identifyingcode_ = identifyingcode;
  } else {
    clear_has_identifyingcode();
    identifyingcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 thirdUid = 4;
inline bool CpsAccountBindReq::has_thirduid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CpsAccountBindReq::set_has_thirduid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CpsAccountBindReq::clear_has_thirduid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CpsAccountBindReq::clear_thirduid() {
  thirduid_ = GOOGLE_ULONGLONG(0);
  clear_has_thirduid();
}
inline ::google::protobuf::uint64 CpsAccountBindReq::thirduid() const {
  return thirduid_;
}
inline void CpsAccountBindReq::set_thirduid(::google::protobuf::uint64 value) {
  set_has_thirduid();
  thirduid_ = value;
}

// optional .pp.AccountType accountType = 5;
inline bool CpsAccountBindReq::has_accounttype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CpsAccountBindReq::set_has_accounttype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CpsAccountBindReq::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CpsAccountBindReq::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::pp::AccountType CpsAccountBindReq::accounttype() const {
  return static_cast< ::pp::AccountType >(accounttype_);
}
inline void CpsAccountBindReq::set_accounttype(::pp::AccountType value) {
  assert(::pp::AccountType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional uint64 uid = 10;
inline bool CpsAccountBindReq::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CpsAccountBindReq::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CpsAccountBindReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CpsAccountBindReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CpsAccountBindReq::uid() const {
  return uid_;
}
inline void CpsAccountBindReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string password = 11;
inline bool CpsAccountBindReq::has_password() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CpsAccountBindReq::set_has_password() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CpsAccountBindReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CpsAccountBindReq::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& CpsAccountBindReq::password() const {
  return *password_;
}
inline void CpsAccountBindReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CpsAccountBindReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void CpsAccountBindReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsAccountBindReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* CpsAccountBindReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsAccountBindReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ip = 12;
inline bool CpsAccountBindReq::has_ip() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CpsAccountBindReq::set_has_ip() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CpsAccountBindReq::clear_has_ip() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CpsAccountBindReq::clear_ip() {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    ip_->clear();
  }
  clear_has_ip();
}
inline const ::std::string& CpsAccountBindReq::ip() const {
  return *ip_;
}
inline void CpsAccountBindReq::set_ip(const ::std::string& value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CpsAccountBindReq::set_ip(const char* value) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(value);
}
inline void CpsAccountBindReq::set_ip(const char* value, size_t size) {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  ip_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsAccountBindReq::mutable_ip() {
  set_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    ip_ = new ::std::string;
  }
  return ip_;
}
inline ::std::string* CpsAccountBindReq::release_ip() {
  clear_has_ip();
  if (ip_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ip_;
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsAccountBindReq::set_allocated_ip(::std::string* ip) {
  if (ip_ != &::google::protobuf::internal::kEmptyString) {
    delete ip_;
  }
  if (ip) {
    set_has_ip();
    ip_ = ip;
  } else {
    clear_has_ip();
    ip_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CpsAccountBindRes

// optional string cookie = 1;
inline bool CpsAccountBindRes::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpsAccountBindRes::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CpsAccountBindRes::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CpsAccountBindRes::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& CpsAccountBindRes::cookie() const {
  return *cookie_;
}
inline void CpsAccountBindRes::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void CpsAccountBindRes::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void CpsAccountBindRes::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsAccountBindRes::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* CpsAccountBindRes::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsAccountBindRes::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserInfo uinfo = 2;
inline bool CpsAccountBindRes::has_uinfo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CpsAccountBindRes::set_has_uinfo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CpsAccountBindRes::clear_has_uinfo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CpsAccountBindRes::clear_uinfo() {
  if (uinfo_ != NULL) uinfo_->::pp::UserInfo::Clear();
  clear_has_uinfo();
}
inline const ::pp::UserInfo& CpsAccountBindRes::uinfo() const {
  return uinfo_ != NULL ? *uinfo_ : *default_instance_->uinfo_;
}
inline ::pp::UserInfo* CpsAccountBindRes::mutable_uinfo() {
  set_has_uinfo();
  if (uinfo_ == NULL) uinfo_ = new ::pp::UserInfo;
  return uinfo_;
}
inline ::pp::UserInfo* CpsAccountBindRes::release_uinfo() {
  clear_has_uinfo();
  ::pp::UserInfo* temp = uinfo_;
  uinfo_ = NULL;
  return temp;
}
inline void CpsAccountBindRes::set_allocated_uinfo(::pp::UserInfo* uinfo) {
  delete uinfo_;
  uinfo_ = uinfo;
  if (uinfo) {
    set_has_uinfo();
  } else {
    clear_has_uinfo();
  }
}

// -------------------------------------------------------------------

// CpsWebLoginReq

// required string key = 1;
inline bool CpsWebLoginReq::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CpsWebLoginReq::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CpsWebLoginReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CpsWebLoginReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& CpsWebLoginReq::key() const {
  return *key_;
}
inline void CpsWebLoginReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CpsWebLoginReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void CpsWebLoginReq::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CpsWebLoginReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* CpsWebLoginReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CpsWebLoginReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CpsWebLoginRes

// -------------------------------------------------------------------

// UserHeartBeat

// required uint32 flags = 1;
inline bool UserHeartBeat::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHeartBeat::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHeartBeat::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHeartBeat::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 UserHeartBeat::flags() const {
  return flags_;
}
inline void UserHeartBeat::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional int64 currenttime = 2;
inline bool UserHeartBeat::has_currenttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHeartBeat::set_has_currenttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHeartBeat::clear_has_currenttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHeartBeat::clear_currenttime() {
  currenttime_ = GOOGLE_LONGLONG(0);
  clear_has_currenttime();
}
inline ::google::protobuf::int64 UserHeartBeat::currenttime() const {
  return currenttime_;
}
inline void UserHeartBeat::set_currenttime(::google::protobuf::int64 value) {
  set_has_currenttime();
  currenttime_ = value;
}

// optional int64 giftListVersion = 101;
inline bool UserHeartBeat::has_giftlistversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHeartBeat::set_has_giftlistversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHeartBeat::clear_has_giftlistversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHeartBeat::clear_giftlistversion() {
  giftlistversion_ = GOOGLE_LONGLONG(0);
  clear_has_giftlistversion();
}
inline ::google::protobuf::int64 UserHeartBeat::giftlistversion() const {
  return giftlistversion_;
}
inline void UserHeartBeat::set_giftlistversion(::google::protobuf::int64 value) {
  set_has_giftlistversion();
  giftlistversion_ = value;
}

// -------------------------------------------------------------------

// UserHeartBeatReq

// required uint32 flags = 1;
inline bool UserHeartBeatReq::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHeartBeatReq::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHeartBeatReq::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHeartBeatReq::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 UserHeartBeatReq::flags() const {
  return flags_;
}
inline void UserHeartBeatReq::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional int64 currenttime = 2;
inline bool UserHeartBeatReq::has_currenttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHeartBeatReq::set_has_currenttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHeartBeatReq::clear_has_currenttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHeartBeatReq::clear_currenttime() {
  currenttime_ = GOOGLE_LONGLONG(0);
  clear_has_currenttime();
}
inline ::google::protobuf::int64 UserHeartBeatReq::currenttime() const {
  return currenttime_;
}
inline void UserHeartBeatReq::set_currenttime(::google::protobuf::int64 value) {
  set_has_currenttime();
  currenttime_ = value;
}

// optional int64 giftListVersion = 101;
inline bool UserHeartBeatReq::has_giftlistversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHeartBeatReq::set_has_giftlistversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHeartBeatReq::clear_has_giftlistversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHeartBeatReq::clear_giftlistversion() {
  giftlistversion_ = GOOGLE_LONGLONG(0);
  clear_has_giftlistversion();
}
inline ::google::protobuf::int64 UserHeartBeatReq::giftlistversion() const {
  return giftlistversion_;
}
inline void UserHeartBeatReq::set_giftlistversion(::google::protobuf::int64 value) {
  set_has_giftlistversion();
  giftlistversion_ = value;
}

// -------------------------------------------------------------------

// UserHeartBeatRes

// required uint32 flags = 1;
inline bool UserHeartBeatRes::has_flags() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserHeartBeatRes::set_has_flags() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserHeartBeatRes::clear_has_flags() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserHeartBeatRes::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 UserHeartBeatRes::flags() const {
  return flags_;
}
inline void UserHeartBeatRes::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional int64 currenttime = 2;
inline bool UserHeartBeatRes::has_currenttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserHeartBeatRes::set_has_currenttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserHeartBeatRes::clear_has_currenttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserHeartBeatRes::clear_currenttime() {
  currenttime_ = GOOGLE_LONGLONG(0);
  clear_has_currenttime();
}
inline ::google::protobuf::int64 UserHeartBeatRes::currenttime() const {
  return currenttime_;
}
inline void UserHeartBeatRes::set_currenttime(::google::protobuf::int64 value) {
  set_has_currenttime();
  currenttime_ = value;
}

// optional int64 giftListVersion = 101;
inline bool UserHeartBeatRes::has_giftlistversion() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserHeartBeatRes::set_has_giftlistversion() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserHeartBeatRes::clear_has_giftlistversion() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserHeartBeatRes::clear_giftlistversion() {
  giftlistversion_ = GOOGLE_LONGLONG(0);
  clear_has_giftlistversion();
}
inline ::google::protobuf::int64 UserHeartBeatRes::giftlistversion() const {
  return giftlistversion_;
}
inline void UserHeartBeatRes::set_giftlistversion(::google::protobuf::int64 value) {
  set_has_giftlistversion();
  giftlistversion_ = value;
}

// -------------------------------------------------------------------

// SessionResumeReq

// required string cookie = 2;
inline bool SessionResumeReq::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionResumeReq::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionResumeReq::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionResumeReq::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& SessionResumeReq::cookie() const {
  return *cookie_;
}
inline void SessionResumeReq::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void SessionResumeReq::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void SessionResumeReq::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SessionResumeReq::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* SessionResumeReq::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SessionResumeReq::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SessionResumeRes

// -------------------------------------------------------------------

// SessionSuspendReq

// optional bool suspend = 1;
inline bool SessionSuspendReq::has_suspend() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SessionSuspendReq::set_has_suspend() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SessionSuspendReq::clear_has_suspend() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SessionSuspendReq::clear_suspend() {
  suspend_ = false;
  clear_has_suspend();
}
inline bool SessionSuspendReq::suspend() const {
  return suspend_;
}
inline void SessionSuspendReq::set_suspend(bool value) {
  set_has_suspend();
  suspend_ = value;
}

// -------------------------------------------------------------------

// UptokenReq

// required string cookie = 1;
inline bool UptokenReq::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UptokenReq::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UptokenReq::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UptokenReq::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& UptokenReq::cookie() const {
  return *cookie_;
}
inline void UptokenReq::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UptokenReq::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UptokenReq::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UptokenReq::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* UptokenReq::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UptokenReq::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string buckets = 2;
inline int UptokenReq::buckets_size() const {
  return buckets_.size();
}
inline void UptokenReq::clear_buckets() {
  buckets_.Clear();
}
inline const ::std::string& UptokenReq::buckets(int index) const {
  return buckets_.Get(index);
}
inline ::std::string* UptokenReq::mutable_buckets(int index) {
  return buckets_.Mutable(index);
}
inline void UptokenReq::set_buckets(int index, const ::std::string& value) {
  buckets_.Mutable(index)->assign(value);
}
inline void UptokenReq::set_buckets(int index, const char* value) {
  buckets_.Mutable(index)->assign(value);
}
inline void UptokenReq::set_buckets(int index, const char* value, size_t size) {
  buckets_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UptokenReq::add_buckets() {
  return buckets_.Add();
}
inline void UptokenReq::add_buckets(const ::std::string& value) {
  buckets_.Add()->assign(value);
}
inline void UptokenReq::add_buckets(const char* value) {
  buckets_.Add()->assign(value);
}
inline void UptokenReq::add_buckets(const char* value, size_t size) {
  buckets_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UptokenReq::buckets() const {
  return buckets_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UptokenReq::mutable_buckets() {
  return &buckets_;
}

// optional string filename = 3;
inline bool UptokenReq::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UptokenReq::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UptokenReq::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UptokenReq::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& UptokenReq::filename() const {
  return *filename_;
}
inline void UptokenReq::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UptokenReq::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void UptokenReq::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UptokenReq::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* UptokenReq::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UptokenReq::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool needKey = 4;
inline bool UptokenReq::has_needkey() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UptokenReq::set_has_needkey() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UptokenReq::clear_has_needkey() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UptokenReq::clear_needkey() {
  needkey_ = false;
  clear_has_needkey();
}
inline bool UptokenReq::needkey() const {
  return needkey_;
}
inline void UptokenReq::set_needkey(bool value) {
  set_has_needkey();
  needkey_ = value;
}

// -------------------------------------------------------------------

// Uptoken

// required string token = 1;
inline bool Uptoken::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Uptoken::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Uptoken::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Uptoken::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& Uptoken::token() const {
  return *token_;
}
inline void Uptoken::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Uptoken::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void Uptoken::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Uptoken::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* Uptoken::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Uptoken::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string bucket = 2;
inline bool Uptoken::has_bucket() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Uptoken::set_has_bucket() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Uptoken::clear_has_bucket() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Uptoken::clear_bucket() {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    bucket_->clear();
  }
  clear_has_bucket();
}
inline const ::std::string& Uptoken::bucket() const {
  return *bucket_;
}
inline void Uptoken::set_bucket(const ::std::string& value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void Uptoken::set_bucket(const char* value) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(value);
}
inline void Uptoken::set_bucket(const char* value, size_t size) {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  bucket_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Uptoken::mutable_bucket() {
  set_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    bucket_ = new ::std::string;
  }
  return bucket_;
}
inline ::std::string* Uptoken::release_bucket() {
  clear_has_bucket();
  if (bucket_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bucket_;
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Uptoken::set_allocated_bucket(::std::string* bucket) {
  if (bucket_ != &::google::protobuf::internal::kEmptyString) {
    delete bucket_;
  }
  if (bucket) {
    set_has_bucket();
    bucket_ = bucket;
  } else {
    clear_has_bucket();
    bucket_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UptokenRes

// repeated .pp.Uptoken tokens = 1;
inline int UptokenRes::tokens_size() const {
  return tokens_.size();
}
inline void UptokenRes::clear_tokens() {
  tokens_.Clear();
}
inline const ::pp::Uptoken& UptokenRes::tokens(int index) const {
  return tokens_.Get(index);
}
inline ::pp::Uptoken* UptokenRes::mutable_tokens(int index) {
  return tokens_.Mutable(index);
}
inline ::pp::Uptoken* UptokenRes::add_tokens() {
  return tokens_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::Uptoken >&
UptokenRes::tokens() const {
  return tokens_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::Uptoken >*
UptokenRes::mutable_tokens() {
  return &tokens_;
}

// optional string bs2token = 2;
inline bool UptokenRes::has_bs2token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UptokenRes::set_has_bs2token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UptokenRes::clear_has_bs2token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UptokenRes::clear_bs2token() {
  if (bs2token_ != &::google::protobuf::internal::kEmptyString) {
    bs2token_->clear();
  }
  clear_has_bs2token();
}
inline const ::std::string& UptokenRes::bs2token() const {
  return *bs2token_;
}
inline void UptokenRes::set_bs2token(const ::std::string& value) {
  set_has_bs2token();
  if (bs2token_ == &::google::protobuf::internal::kEmptyString) {
    bs2token_ = new ::std::string;
  }
  bs2token_->assign(value);
}
inline void UptokenRes::set_bs2token(const char* value) {
  set_has_bs2token();
  if (bs2token_ == &::google::protobuf::internal::kEmptyString) {
    bs2token_ = new ::std::string;
  }
  bs2token_->assign(value);
}
inline void UptokenRes::set_bs2token(const char* value, size_t size) {
  set_has_bs2token();
  if (bs2token_ == &::google::protobuf::internal::kEmptyString) {
    bs2token_ = new ::std::string;
  }
  bs2token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UptokenRes::mutable_bs2token() {
  set_has_bs2token();
  if (bs2token_ == &::google::protobuf::internal::kEmptyString) {
    bs2token_ = new ::std::string;
  }
  return bs2token_;
}
inline ::std::string* UptokenRes::release_bs2token() {
  clear_has_bs2token();
  if (bs2token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bs2token_;
    bs2token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UptokenRes::set_allocated_bs2token(::std::string* bs2token) {
  if (bs2token_ != &::google::protobuf::internal::kEmptyString) {
    delete bs2token_;
  }
  if (bs2token) {
    set_has_bs2token();
    bs2token_ = bs2token;
  } else {
    clear_has_bs2token();
    bs2token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 appkey = 3;
inline bool UptokenRes::has_appkey() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UptokenRes::set_has_appkey() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UptokenRes::clear_has_appkey() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UptokenRes::clear_appkey() {
  appkey_ = 0u;
  clear_has_appkey();
}
inline ::google::protobuf::uint32 UptokenRes::appkey() const {
  return appkey_;
}
inline void UptokenRes::set_appkey(::google::protobuf::uint32 value) {
  set_has_appkey();
  appkey_ = value;
}

// optional string secret = 4;
inline bool UptokenRes::has_secret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UptokenRes::set_has_secret() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UptokenRes::clear_has_secret() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UptokenRes::clear_secret() {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    secret_->clear();
  }
  clear_has_secret();
}
inline const ::std::string& UptokenRes::secret() const {
  return *secret_;
}
inline void UptokenRes::set_secret(const ::std::string& value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void UptokenRes::set_secret(const char* value) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(value);
}
inline void UptokenRes::set_secret(const char* value, size_t size) {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  secret_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UptokenRes::mutable_secret() {
  set_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    secret_ = new ::std::string;
  }
  return secret_;
}
inline ::std::string* UptokenRes::release_secret() {
  clear_has_secret();
  if (secret_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = secret_;
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UptokenRes::set_allocated_secret(::std::string* secret) {
  if (secret_ != &::google::protobuf::internal::kEmptyString) {
    delete secret_;
  }
  if (secret) {
    set_has_secret();
    secret_ = secret;
  } else {
    clear_has_secret();
    secret_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageImage

// optional string prefix = 1;
inline bool MessageImage::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageImage::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageImage::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageImage::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& MessageImage::prefix() const {
  return *prefix_;
}
inline void MessageImage::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessageImage::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessageImage::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageImage::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* MessageImage::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageImage::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string hashs = 2;
inline int MessageImage::hashs_size() const {
  return hashs_.size();
}
inline void MessageImage::clear_hashs() {
  hashs_.Clear();
}
inline const ::std::string& MessageImage::hashs(int index) const {
  return hashs_.Get(index);
}
inline ::std::string* MessageImage::mutable_hashs(int index) {
  return hashs_.Mutable(index);
}
inline void MessageImage::set_hashs(int index, const ::std::string& value) {
  hashs_.Mutable(index)->assign(value);
}
inline void MessageImage::set_hashs(int index, const char* value) {
  hashs_.Mutable(index)->assign(value);
}
inline void MessageImage::set_hashs(int index, const char* value, size_t size) {
  hashs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageImage::add_hashs() {
  return hashs_.Add();
}
inline void MessageImage::add_hashs(const ::std::string& value) {
  hashs_.Add()->assign(value);
}
inline void MessageImage::add_hashs(const char* value) {
  hashs_.Add()->assign(value);
}
inline void MessageImage::add_hashs(const char* value, size_t size) {
  hashs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessageImage::hashs() const {
  return hashs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessageImage::mutable_hashs() {
  return &hashs_;
}

// repeated uint32 types = 3;
inline int MessageImage::types_size() const {
  return types_.size();
}
inline void MessageImage::clear_types() {
  types_.Clear();
}
inline ::google::protobuf::uint32 MessageImage::types(int index) const {
  return types_.Get(index);
}
inline void MessageImage::set_types(int index, ::google::protobuf::uint32 value) {
  types_.Set(index, value);
}
inline void MessageImage::add_types(::google::protobuf::uint32 value) {
  types_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
MessageImage::types() const {
  return types_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
MessageImage::mutable_types() {
  return &types_;
}

// optional string summary = 4;
inline bool MessageImage::has_summary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageImage::set_has_summary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageImage::clear_has_summary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageImage::clear_summary() {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& MessageImage::summary() const {
  return *summary_;
}
inline void MessageImage::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessageImage::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessageImage::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageImage::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  return summary_;
}
inline ::std::string* MessageImage::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageImage::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageVoice

// optional string prefix = 1;
inline bool MessageVoice::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageVoice::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageVoice::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageVoice::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& MessageVoice::prefix() const {
  return *prefix_;
}
inline void MessageVoice::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessageVoice::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessageVoice::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVoice::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* MessageVoice::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVoice::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hashs = 2;
inline bool MessageVoice::has_hashs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageVoice::set_has_hashs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageVoice::clear_has_hashs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageVoice::clear_hashs() {
  if (hashs_ != &::google::protobuf::internal::kEmptyString) {
    hashs_->clear();
  }
  clear_has_hashs();
}
inline const ::std::string& MessageVoice::hashs() const {
  return *hashs_;
}
inline void MessageVoice::set_hashs(const ::std::string& value) {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  hashs_->assign(value);
}
inline void MessageVoice::set_hashs(const char* value) {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  hashs_->assign(value);
}
inline void MessageVoice::set_hashs(const char* value, size_t size) {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  hashs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVoice::mutable_hashs() {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  return hashs_;
}
inline ::std::string* MessageVoice::release_hashs() {
  clear_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hashs_;
    hashs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVoice::set_allocated_hashs(::std::string* hashs) {
  if (hashs_ != &::google::protobuf::internal::kEmptyString) {
    delete hashs_;
  }
  if (hashs) {
    set_has_hashs();
    hashs_ = hashs;
  } else {
    clear_has_hashs();
    hashs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 len = 3;
inline bool MessageVoice::has_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageVoice::set_has_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageVoice::clear_has_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageVoice::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 MessageVoice::len() const {
  return len_;
}
inline void MessageVoice::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// optional string summary = 4;
inline bool MessageVoice::has_summary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageVoice::set_has_summary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageVoice::clear_has_summary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageVoice::clear_summary() {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& MessageVoice::summary() const {
  return *summary_;
}
inline void MessageVoice::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessageVoice::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessageVoice::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVoice::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  return summary_;
}
inline ::std::string* MessageVoice::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVoice::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volumns = 5;
inline bool MessageVoice::has_volumns() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageVoice::set_has_volumns() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageVoice::clear_has_volumns() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageVoice::clear_volumns() {
  if (volumns_ != &::google::protobuf::internal::kEmptyString) {
    volumns_->clear();
  }
  clear_has_volumns();
}
inline const ::std::string& MessageVoice::volumns() const {
  return *volumns_;
}
inline void MessageVoice::set_volumns(const ::std::string& value) {
  set_has_volumns();
  if (volumns_ == &::google::protobuf::internal::kEmptyString) {
    volumns_ = new ::std::string;
  }
  volumns_->assign(value);
}
inline void MessageVoice::set_volumns(const char* value) {
  set_has_volumns();
  if (volumns_ == &::google::protobuf::internal::kEmptyString) {
    volumns_ = new ::std::string;
  }
  volumns_->assign(value);
}
inline void MessageVoice::set_volumns(const char* value, size_t size) {
  set_has_volumns();
  if (volumns_ == &::google::protobuf::internal::kEmptyString) {
    volumns_ = new ::std::string;
  }
  volumns_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVoice::mutable_volumns() {
  set_has_volumns();
  if (volumns_ == &::google::protobuf::internal::kEmptyString) {
    volumns_ = new ::std::string;
  }
  return volumns_;
}
inline ::std::string* MessageVoice::release_volumns() {
  clear_has_volumns();
  if (volumns_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volumns_;
    volumns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVoice::set_allocated_volumns(::std::string* volumns) {
  if (volumns_ != &::google::protobuf::internal::kEmptyString) {
    delete volumns_;
  }
  if (volumns) {
    set_has_volumns();
    volumns_ = volumns;
  } else {
    clear_has_volumns();
    volumns_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageVideo

// optional string prefix = 1;
inline bool MessageVideo::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageVideo::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageVideo::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageVideo::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& MessageVideo::prefix() const {
  return *prefix_;
}
inline void MessageVideo::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessageVideo::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessageVideo::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVideo::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* MessageVideo::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVideo::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string hashs = 2;
inline bool MessageVideo::has_hashs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageVideo::set_has_hashs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageVideo::clear_has_hashs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageVideo::clear_hashs() {
  if (hashs_ != &::google::protobuf::internal::kEmptyString) {
    hashs_->clear();
  }
  clear_has_hashs();
}
inline const ::std::string& MessageVideo::hashs() const {
  return *hashs_;
}
inline void MessageVideo::set_hashs(const ::std::string& value) {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  hashs_->assign(value);
}
inline void MessageVideo::set_hashs(const char* value) {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  hashs_->assign(value);
}
inline void MessageVideo::set_hashs(const char* value, size_t size) {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  hashs_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVideo::mutable_hashs() {
  set_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    hashs_ = new ::std::string;
  }
  return hashs_;
}
inline ::std::string* MessageVideo::release_hashs() {
  clear_has_hashs();
  if (hashs_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = hashs_;
    hashs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVideo::set_allocated_hashs(::std::string* hashs) {
  if (hashs_ != &::google::protobuf::internal::kEmptyString) {
    delete hashs_;
  }
  if (hashs) {
    set_has_hashs();
    hashs_ = hashs;
  } else {
    clear_has_hashs();
    hashs_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 len = 3;
inline bool MessageVideo::has_len() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageVideo::set_has_len() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageVideo::clear_has_len() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageVideo::clear_len() {
  len_ = 0u;
  clear_has_len();
}
inline ::google::protobuf::uint32 MessageVideo::len() const {
  return len_;
}
inline void MessageVideo::set_len(::google::protobuf::uint32 value) {
  set_has_len();
  len_ = value;
}

// optional uint32 iframe = 4;
inline bool MessageVideo::has_iframe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageVideo::set_has_iframe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageVideo::clear_has_iframe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageVideo::clear_iframe() {
  iframe_ = 0u;
  clear_has_iframe();
}
inline ::google::protobuf::uint32 MessageVideo::iframe() const {
  return iframe_;
}
inline void MessageVideo::set_iframe(::google::protobuf::uint32 value) {
  set_has_iframe();
  iframe_ = value;
}

// optional string summary = 5;
inline bool MessageVideo::has_summary() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageVideo::set_has_summary() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageVideo::clear_has_summary() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageVideo::clear_summary() {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& MessageVideo::summary() const {
  return *summary_;
}
inline void MessageVideo::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessageVideo::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessageVideo::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageVideo::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  return summary_;
}
inline ::std::string* MessageVideo::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageVideo::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessagePub

// optional string title = 1;
inline bool MessagePub::has_title() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessagePub::set_has_title() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessagePub::clear_has_title() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessagePub::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& MessagePub::title() const {
  return *title_;
}
inline void MessagePub::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MessagePub::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MessagePub::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePub::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* MessagePub::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePub::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 2;
inline bool MessagePub::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessagePub::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessagePub::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessagePub::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& MessagePub::url() const {
  return *url_;
}
inline void MessagePub::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void MessagePub::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void MessagePub::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePub::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* MessagePub::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePub::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string summary = 3;
inline bool MessagePub::has_summary() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessagePub::set_has_summary() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessagePub::clear_has_summary() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessagePub::clear_summary() {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    summary_->clear();
  }
  clear_has_summary();
}
inline const ::std::string& MessagePub::summary() const {
  return *summary_;
}
inline void MessagePub::set_summary(const ::std::string& value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessagePub::set_summary(const char* value) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(value);
}
inline void MessagePub::set_summary(const char* value, size_t size) {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  summary_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePub::mutable_summary() {
  set_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    summary_ = new ::std::string;
  }
  return summary_;
}
inline ::std::string* MessagePub::release_summary() {
  clear_has_summary();
  if (summary_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = summary_;
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePub::set_allocated_summary(::std::string* summary) {
  if (summary_ != &::google::protobuf::internal::kEmptyString) {
    delete summary_;
  }
  if (summary) {
    set_has_summary();
    summary_ = summary;
  } else {
    clear_has_summary();
    summary_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string prefix = 4;
inline bool MessagePub::has_prefix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessagePub::set_has_prefix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessagePub::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessagePub::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& MessagePub::prefix() const {
  return *prefix_;
}
inline void MessagePub::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessagePub::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
}
inline void MessagePub::set_prefix(const char* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePub::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    prefix_ = new ::std::string;
  }
  return prefix_;
}
inline ::std::string* MessagePub::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePub::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::kEmptyString) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string images = 5;
inline int MessagePub::images_size() const {
  return images_.size();
}
inline void MessagePub::clear_images() {
  images_.Clear();
}
inline const ::std::string& MessagePub::images(int index) const {
  return images_.Get(index);
}
inline ::std::string* MessagePub::mutable_images(int index) {
  return images_.Mutable(index);
}
inline void MessagePub::set_images(int index, const ::std::string& value) {
  images_.Mutable(index)->assign(value);
}
inline void MessagePub::set_images(int index, const char* value) {
  images_.Mutable(index)->assign(value);
}
inline void MessagePub::set_images(int index, const char* value, size_t size) {
  images_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePub::add_images() {
  return images_.Add();
}
inline void MessagePub::add_images(const ::std::string& value) {
  images_.Add()->assign(value);
}
inline void MessagePub::add_images(const char* value) {
  images_.Add()->assign(value);
}
inline void MessagePub::add_images(const char* value, size_t size) {
  images_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MessagePub::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MessagePub::mutable_images() {
  return &images_;
}

// optional string op = 6;
inline bool MessagePub::has_op() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessagePub::set_has_op() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessagePub::clear_has_op() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessagePub::clear_op() {
  if (op_ != &::google::protobuf::internal::kEmptyString) {
    op_->clear();
  }
  clear_has_op();
}
inline const ::std::string& MessagePub::op() const {
  return *op_;
}
inline void MessagePub::set_op(const ::std::string& value) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::kEmptyString) {
    op_ = new ::std::string;
  }
  op_->assign(value);
}
inline void MessagePub::set_op(const char* value) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::kEmptyString) {
    op_ = new ::std::string;
  }
  op_->assign(value);
}
inline void MessagePub::set_op(const char* value, size_t size) {
  set_has_op();
  if (op_ == &::google::protobuf::internal::kEmptyString) {
    op_ = new ::std::string;
  }
  op_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessagePub::mutable_op() {
  set_has_op();
  if (op_ == &::google::protobuf::internal::kEmptyString) {
    op_ = new ::std::string;
  }
  return op_;
}
inline ::std::string* MessagePub::release_op() {
  clear_has_op();
  if (op_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = op_;
    op_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessagePub::set_allocated_op(::std::string* op) {
  if (op_ != &::google::protobuf::internal::kEmptyString) {
    delete op_;
  }
  if (op) {
    set_has_op();
    op_ = op;
  } else {
    clear_has_op();
    op_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 starttime = 7;
inline bool MessagePub::has_starttime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessagePub::set_has_starttime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessagePub::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessagePub::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 MessagePub::starttime() const {
  return starttime_;
}
inline void MessagePub::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional int64 stoptime = 8;
inline bool MessagePub::has_stoptime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void MessagePub::set_has_stoptime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void MessagePub::clear_has_stoptime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void MessagePub::clear_stoptime() {
  stoptime_ = GOOGLE_LONGLONG(0);
  clear_has_stoptime();
}
inline ::google::protobuf::int64 MessagePub::stoptime() const {
  return stoptime_;
}
inline void MessagePub::set_stoptime(::google::protobuf::int64 value) {
  set_has_stoptime();
  stoptime_ = value;
}

// -------------------------------------------------------------------

// MessageTxtlink

// optional string txt = 1;
inline bool MessageTxtlink::has_txt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageTxtlink::set_has_txt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageTxtlink::clear_has_txt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageTxtlink::clear_txt() {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    txt_->clear();
  }
  clear_has_txt();
}
inline const ::std::string& MessageTxtlink::txt() const {
  return *txt_;
}
inline void MessageTxtlink::set_txt(const ::std::string& value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void MessageTxtlink::set_txt(const char* value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void MessageTxtlink::set_txt(const char* value, size_t size) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageTxtlink::mutable_txt() {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  return txt_;
}
inline ::std::string* MessageTxtlink::release_txt() {
  clear_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txt_;
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageTxtlink::set_allocated_txt(::std::string* txt) {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    delete txt_;
  }
  if (txt) {
    set_has_txt();
    txt_ = txt;
  } else {
    clear_has_txt();
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string url = 2;
inline bool MessageTxtlink::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageTxtlink::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageTxtlink::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageTxtlink::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& MessageTxtlink::url() const {
  return *url_;
}
inline void MessageTxtlink::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void MessageTxtlink::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void MessageTxtlink::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageTxtlink::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* MessageTxtlink::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageTxtlink::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string desc = 3;
inline bool MessageTxtlink::has_desc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageTxtlink::set_has_desc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageTxtlink::clear_has_desc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageTxtlink::clear_desc() {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& MessageTxtlink::desc() const {
  return *desc_;
}
inline void MessageTxtlink::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MessageTxtlink::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
}
inline void MessageTxtlink::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageTxtlink::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    desc_ = new ::std::string;
  }
  return desc_;
}
inline ::std::string* MessageTxtlink::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageTxtlink::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::kEmptyString) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string color = 4;
inline bool MessageTxtlink::has_color() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageTxtlink::set_has_color() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageTxtlink::clear_has_color() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageTxtlink::clear_color() {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    color_->clear();
  }
  clear_has_color();
}
inline const ::std::string& MessageTxtlink::color() const {
  return *color_;
}
inline void MessageTxtlink::set_color(const ::std::string& value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void MessageTxtlink::set_color(const char* value) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(value);
}
inline void MessageTxtlink::set_color(const char* value, size_t size) {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  color_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageTxtlink::mutable_color() {
  set_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    color_ = new ::std::string;
  }
  return color_;
}
inline ::std::string* MessageTxtlink::release_color() {
  clear_has_color();
  if (color_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = color_;
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageTxtlink::set_allocated_color(::std::string* color) {
  if (color_ != &::google::protobuf::internal::kEmptyString) {
    delete color_;
  }
  if (color) {
    set_has_color();
    color_ = color;
  } else {
    clear_has_color();
    color_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string icon = 5;
inline bool MessageTxtlink::has_icon() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageTxtlink::set_has_icon() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageTxtlink::clear_has_icon() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageTxtlink::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& MessageTxtlink::icon() const {
  return *icon_;
}
inline void MessageTxtlink::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void MessageTxtlink::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void MessageTxtlink::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageTxtlink::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* MessageTxtlink::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageTxtlink::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bg = 6;
inline bool MessageTxtlink::has_bg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageTxtlink::set_has_bg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageTxtlink::clear_has_bg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageTxtlink::clear_bg() {
  if (bg_ != &::google::protobuf::internal::kEmptyString) {
    bg_->clear();
  }
  clear_has_bg();
}
inline const ::std::string& MessageTxtlink::bg() const {
  return *bg_;
}
inline void MessageTxtlink::set_bg(const ::std::string& value) {
  set_has_bg();
  if (bg_ == &::google::protobuf::internal::kEmptyString) {
    bg_ = new ::std::string;
  }
  bg_->assign(value);
}
inline void MessageTxtlink::set_bg(const char* value) {
  set_has_bg();
  if (bg_ == &::google::protobuf::internal::kEmptyString) {
    bg_ = new ::std::string;
  }
  bg_->assign(value);
}
inline void MessageTxtlink::set_bg(const char* value, size_t size) {
  set_has_bg();
  if (bg_ == &::google::protobuf::internal::kEmptyString) {
    bg_ = new ::std::string;
  }
  bg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageTxtlink::mutable_bg() {
  set_has_bg();
  if (bg_ == &::google::protobuf::internal::kEmptyString) {
    bg_ = new ::std::string;
  }
  return bg_;
}
inline ::std::string* MessageTxtlink::release_bg() {
  clear_has_bg();
  if (bg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bg_;
    bg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageTxtlink::set_allocated_bg(::std::string* bg) {
  if (bg_ != &::google::protobuf::internal::kEmptyString) {
    delete bg_;
  }
  if (bg) {
    set_has_bg();
    bg_ = bg;
  } else {
    clear_has_bg();
    bg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageGroupNotice

// optional uint32 memincr = 1;
inline bool MessageGroupNotice::has_memincr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageGroupNotice::set_has_memincr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageGroupNotice::clear_has_memincr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageGroupNotice::clear_memincr() {
  memincr_ = 0u;
  clear_has_memincr();
}
inline ::google::protobuf::uint32 MessageGroupNotice::memincr() const {
  return memincr_;
}
inline void MessageGroupNotice::set_memincr(::google::protobuf::uint32 value) {
  set_has_memincr();
  memincr_ = value;
}

// optional uint32 itemid = 2;
inline bool MessageGroupNotice::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageGroupNotice::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageGroupNotice::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageGroupNotice::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 MessageGroupNotice::itemid() const {
  return itemid_;
}
inline void MessageGroupNotice::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 num = 3;
inline bool MessageGroupNotice::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageGroupNotice::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageGroupNotice::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageGroupNotice::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 MessageGroupNotice::num() const {
  return num_;
}
inline void MessageGroupNotice::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint64 showlikeuid = 4;
inline bool MessageGroupNotice::has_showlikeuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageGroupNotice::set_has_showlikeuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageGroupNotice::clear_has_showlikeuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageGroupNotice::clear_showlikeuid() {
  showlikeuid_ = GOOGLE_ULONGLONG(0);
  clear_has_showlikeuid();
}
inline ::google::protobuf::uint64 MessageGroupNotice::showlikeuid() const {
  return showlikeuid_;
}
inline void MessageGroupNotice::set_showlikeuid(::google::protobuf::uint64 value) {
  set_has_showlikeuid();
  showlikeuid_ = value;
}

// optional .pp.GroupMemberRolerItem roler = 5;
inline bool MessageGroupNotice::has_roler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageGroupNotice::set_has_roler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageGroupNotice::clear_has_roler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageGroupNotice::clear_roler() {
  if (roler_ != NULL) roler_->::pp::GroupMemberRolerItem::Clear();
  clear_has_roler();
}
inline const ::pp::GroupMemberRolerItem& MessageGroupNotice::roler() const {
  return roler_ != NULL ? *roler_ : *default_instance_->roler_;
}
inline ::pp::GroupMemberRolerItem* MessageGroupNotice::mutable_roler() {
  set_has_roler();
  if (roler_ == NULL) roler_ = new ::pp::GroupMemberRolerItem;
  return roler_;
}
inline ::pp::GroupMemberRolerItem* MessageGroupNotice::release_roler() {
  clear_has_roler();
  ::pp::GroupMemberRolerItem* temp = roler_;
  roler_ = NULL;
  return temp;
}
inline void MessageGroupNotice::set_allocated_roler(::pp::GroupMemberRolerItem* roler) {
  delete roler_;
  roler_ = roler;
  if (roler) {
    set_has_roler();
  } else {
    clear_has_roler();
  }
}

// -------------------------------------------------------------------

// MessageInputStatus

// optional uint32 speaking = 1;
inline bool MessageInputStatus::has_speaking() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageInputStatus::set_has_speaking() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageInputStatus::clear_has_speaking() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageInputStatus::clear_speaking() {
  speaking_ = 0u;
  clear_has_speaking();
}
inline ::google::protobuf::uint32 MessageInputStatus::speaking() const {
  return speaking_;
}
inline void MessageInputStatus::set_speaking(::google::protobuf::uint32 value) {
  set_has_speaking();
  speaking_ = value;
}

// optional uint64 speakeruid = 2;
inline bool MessageInputStatus::has_speakeruid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageInputStatus::set_has_speakeruid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageInputStatus::clear_has_speakeruid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageInputStatus::clear_speakeruid() {
  speakeruid_ = GOOGLE_ULONGLONG(0);
  clear_has_speakeruid();
}
inline ::google::protobuf::uint64 MessageInputStatus::speakeruid() const {
  return speakeruid_;
}
inline void MessageInputStatus::set_speakeruid(::google::protobuf::uint64 value) {
  set_has_speakeruid();
  speakeruid_ = value;
}

// -------------------------------------------------------------------

// MessageEvent

// optional uint32 eventType = 1;
inline bool MessageEvent::has_eventtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageEvent::set_has_eventtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageEvent::clear_has_eventtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageEvent::clear_eventtype() {
  eventtype_ = 0u;
  clear_has_eventtype();
}
inline ::google::protobuf::uint32 MessageEvent::eventtype() const {
  return eventtype_;
}
inline void MessageEvent::set_eventtype(::google::protobuf::uint32 value) {
  set_has_eventtype();
  eventtype_ = value;
}

// optional uint64 uid = 2;
inline bool MessageEvent::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageEvent::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageEvent::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageEvent::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 MessageEvent::uid() const {
  return uid_;
}
inline void MessageEvent::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 gid = 3;
inline bool MessageEvent::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageEvent::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageEvent::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageEvent::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 MessageEvent::gid() const {
  return gid_;
}
inline void MessageEvent::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 itemId = 4;
inline bool MessageEvent::has_itemid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageEvent::set_has_itemid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageEvent::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageEvent::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 MessageEvent::itemid() const {
  return itemid_;
}
inline void MessageEvent::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 itemNum = 5;
inline bool MessageEvent::has_itemnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageEvent::set_has_itemnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageEvent::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageEvent::clear_itemnum() {
  itemnum_ = 0u;
  clear_has_itemnum();
}
inline ::google::protobuf::uint32 MessageEvent::itemnum() const {
  return itemnum_;
}
inline void MessageEvent::set_itemnum(::google::protobuf::uint32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional uint32 itemLevel = 6;
inline bool MessageEvent::has_itemlevel() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageEvent::set_has_itemlevel() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageEvent::clear_has_itemlevel() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageEvent::clear_itemlevel() {
  itemlevel_ = 0u;
  clear_has_itemlevel();
}
inline ::google::protobuf::uint32 MessageEvent::itemlevel() const {
  return itemlevel_;
}
inline void MessageEvent::set_itemlevel(::google::protobuf::uint32 value) {
  set_has_itemlevel();
  itemlevel_ = value;
}

// optional string extField = 7;
inline bool MessageEvent::has_extfield() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageEvent::set_has_extfield() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageEvent::clear_has_extfield() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageEvent::clear_extfield() {
  if (extfield_ != &::google::protobuf::internal::kEmptyString) {
    extfield_->clear();
  }
  clear_has_extfield();
}
inline const ::std::string& MessageEvent::extfield() const {
  return *extfield_;
}
inline void MessageEvent::set_extfield(const ::std::string& value) {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  extfield_->assign(value);
}
inline void MessageEvent::set_extfield(const char* value) {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  extfield_->assign(value);
}
inline void MessageEvent::set_extfield(const char* value, size_t size) {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  extfield_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageEvent::mutable_extfield() {
  set_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    extfield_ = new ::std::string;
  }
  return extfield_;
}
inline ::std::string* MessageEvent::release_extfield() {
  clear_has_extfield();
  if (extfield_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extfield_;
    extfield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageEvent::set_allocated_extfield(::std::string* extfield) {
  if (extfield_ != &::google::protobuf::internal::kEmptyString) {
    delete extfield_;
  }
  if (extfield) {
    set_has_extfield();
    extfield_ = extfield;
  } else {
    clear_has_extfield();
    extfield_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MessageUserApply

// optional .pp.UserInfo userInfo = 1;
inline bool MessageUserApply::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageUserApply::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageUserApply::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageUserApply::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& MessageUserApply::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* MessageUserApply::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* MessageUserApply::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void MessageUserApply::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional uint32 optype = 2;
inline bool MessageUserApply::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageUserApply::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageUserApply::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageUserApply::clear_optype() {
  optype_ = 0u;
  clear_has_optype();
}
inline ::google::protobuf::uint32 MessageUserApply::optype() const {
  return optype_;
}
inline void MessageUserApply::set_optype(::google::protobuf::uint32 value) {
  set_has_optype();
  optype_ = value;
}

// optional string remark = 3;
inline bool MessageUserApply::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageUserApply::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageUserApply::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageUserApply::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& MessageUserApply::remark() const {
  return *remark_;
}
inline void MessageUserApply::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void MessageUserApply::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void MessageUserApply::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageUserApply::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* MessageUserApply::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageUserApply::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 opuid = 4;
inline bool MessageUserApply::has_opuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageUserApply::set_has_opuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageUserApply::clear_has_opuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageUserApply::clear_opuid() {
  opuid_ = GOOGLE_ULONGLONG(0);
  clear_has_opuid();
}
inline ::google::protobuf::uint64 MessageUserApply::opuid() const {
  return opuid_;
}
inline void MessageUserApply::set_opuid(::google::protobuf::uint64 value) {
  set_has_opuid();
  opuid_ = value;
}

// optional uint32 opresult = 5;
inline bool MessageUserApply::has_opresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageUserApply::set_has_opresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageUserApply::clear_has_opresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageUserApply::clear_opresult() {
  opresult_ = 0u;
  clear_has_opresult();
}
inline ::google::protobuf::uint32 MessageUserApply::opresult() const {
  return opresult_;
}
inline void MessageUserApply::set_opresult(::google::protobuf::uint32 value) {
  set_has_opresult();
  opresult_ = value;
}

// optional uint32 roler = 7;
inline bool MessageUserApply::has_roler() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageUserApply::set_has_roler() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageUserApply::clear_has_roler() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageUserApply::clear_roler() {
  roler_ = 0u;
  clear_has_roler();
}
inline ::google::protobuf::uint32 MessageUserApply::roler() const {
  return roler_;
}
inline void MessageUserApply::set_roler(::google::protobuf::uint32 value) {
  set_has_roler();
  roler_ = value;
}

// -------------------------------------------------------------------

// MessageGroupApply

// optional .pp.UserInfo userInfo = 1;
inline bool MessageGroupApply::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageGroupApply::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageGroupApply::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageGroupApply::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& MessageGroupApply::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* MessageGroupApply::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* MessageGroupApply::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void MessageGroupApply::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional uint32 optype = 2;
inline bool MessageGroupApply::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageGroupApply::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageGroupApply::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageGroupApply::clear_optype() {
  optype_ = 0u;
  clear_has_optype();
}
inline ::google::protobuf::uint32 MessageGroupApply::optype() const {
  return optype_;
}
inline void MessageGroupApply::set_optype(::google::protobuf::uint32 value) {
  set_has_optype();
  optype_ = value;
}

// optional string remark = 3;
inline bool MessageGroupApply::has_remark() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageGroupApply::set_has_remark() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageGroupApply::clear_has_remark() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageGroupApply::clear_remark() {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    remark_->clear();
  }
  clear_has_remark();
}
inline const ::std::string& MessageGroupApply::remark() const {
  return *remark_;
}
inline void MessageGroupApply::set_remark(const ::std::string& value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void MessageGroupApply::set_remark(const char* value) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(value);
}
inline void MessageGroupApply::set_remark(const char* value, size_t size) {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  remark_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageGroupApply::mutable_remark() {
  set_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    remark_ = new ::std::string;
  }
  return remark_;
}
inline ::std::string* MessageGroupApply::release_remark() {
  clear_has_remark();
  if (remark_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remark_;
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageGroupApply::set_allocated_remark(::std::string* remark) {
  if (remark_ != &::google::protobuf::internal::kEmptyString) {
    delete remark_;
  }
  if (remark) {
    set_has_remark();
    remark_ = remark;
  } else {
    clear_has_remark();
    remark_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 opuid = 4;
inline bool MessageGroupApply::has_opuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageGroupApply::set_has_opuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageGroupApply::clear_has_opuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageGroupApply::clear_opuid() {
  opuid_ = GOOGLE_ULONGLONG(0);
  clear_has_opuid();
}
inline ::google::protobuf::uint64 MessageGroupApply::opuid() const {
  return opuid_;
}
inline void MessageGroupApply::set_opuid(::google::protobuf::uint64 value) {
  set_has_opuid();
  opuid_ = value;
}

// optional uint32 opresult = 5;
inline bool MessageGroupApply::has_opresult() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageGroupApply::set_has_opresult() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageGroupApply::clear_has_opresult() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageGroupApply::clear_opresult() {
  opresult_ = 0u;
  clear_has_opresult();
}
inline ::google::protobuf::uint32 MessageGroupApply::opresult() const {
  return opresult_;
}
inline void MessageGroupApply::set_opresult(::google::protobuf::uint32 value) {
  set_has_opresult();
  opresult_ = value;
}

// optional uint64 gid = 6;
inline bool MessageGroupApply::has_gid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MessageGroupApply::set_has_gid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MessageGroupApply::clear_has_gid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MessageGroupApply::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 MessageGroupApply::gid() const {
  return gid_;
}
inline void MessageGroupApply::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 roler = 7;
inline bool MessageGroupApply::has_roler() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageGroupApply::set_has_roler() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageGroupApply::clear_has_roler() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageGroupApply::clear_roler() {
  roler_ = 0u;
  clear_has_roler();
}
inline ::google::protobuf::uint32 MessageGroupApply::roler() const {
  return roler_;
}
inline void MessageGroupApply::set_roler(::google::protobuf::uint32 value) {
  set_has_roler();
  roler_ = value;
}

// -------------------------------------------------------------------

// MessageUserTask

// optional uint32 type = 1;
inline bool MessageUserTask::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageUserTask::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageUserTask::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageUserTask::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 MessageUserTask::type() const {
  return type_;
}
inline void MessageUserTask::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional uint32 coins = 2;
inline bool MessageUserTask::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageUserTask::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageUserTask::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageUserTask::clear_coins() {
  coins_ = 0u;
  clear_has_coins();
}
inline ::google::protobuf::uint32 MessageUserTask::coins() const {
  return coins_;
}
inline void MessageUserTask::set_coins(::google::protobuf::uint32 value) {
  set_has_coins();
  coins_ = value;
}

// optional string name = 3;
inline bool MessageUserTask::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageUserTask::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageUserTask::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageUserTask::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& MessageUserTask::name() const {
  return *name_;
}
inline void MessageUserTask::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MessageUserTask::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void MessageUserTask::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageUserTask::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* MessageUserTask::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageUserTask::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 passion = 4;
inline bool MessageUserTask::has_passion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageUserTask::set_has_passion() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageUserTask::clear_has_passion() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageUserTask::clear_passion() {
  passion_ = 0u;
  clear_has_passion();
}
inline ::google::protobuf::uint32 MessageUserTask::passion() const {
  return passion_;
}
inline void MessageUserTask::set_passion(::google::protobuf::uint32 value) {
  set_has_passion();
  passion_ = value;
}

// -------------------------------------------------------------------

// MessageBody

// optional uint32 contentType = 1;
inline bool MessageBody::has_contenttype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageBody::set_has_contenttype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageBody::clear_has_contenttype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageBody::clear_contenttype() {
  contenttype_ = 0u;
  clear_has_contenttype();
}
inline ::google::protobuf::uint32 MessageBody::contenttype() const {
  return contenttype_;
}
inline void MessageBody::set_contenttype(::google::protobuf::uint32 value) {
  set_has_contenttype();
  contenttype_ = value;
}

// optional string txt = 2;
inline bool MessageBody::has_txt() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageBody::set_has_txt() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageBody::clear_has_txt() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageBody::clear_txt() {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    txt_->clear();
  }
  clear_has_txt();
}
inline const ::std::string& MessageBody::txt() const {
  return *txt_;
}
inline void MessageBody::set_txt(const ::std::string& value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void MessageBody::set_txt(const char* value) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(value);
}
inline void MessageBody::set_txt(const char* value, size_t size) {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  txt_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageBody::mutable_txt() {
  set_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    txt_ = new ::std::string;
  }
  return txt_;
}
inline ::std::string* MessageBody::release_txt() {
  clear_has_txt();
  if (txt_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = txt_;
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageBody::set_allocated_txt(::std::string* txt) {
  if (txt_ != &::google::protobuf::internal::kEmptyString) {
    delete txt_;
  }
  if (txt) {
    set_has_txt();
    txt_ = txt;
  } else {
    clear_has_txt();
    txt_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.MessageImage img = 3;
inline bool MessageBody::has_img() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageBody::set_has_img() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageBody::clear_has_img() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageBody::clear_img() {
  if (img_ != NULL) img_->::pp::MessageImage::Clear();
  clear_has_img();
}
inline const ::pp::MessageImage& MessageBody::img() const {
  return img_ != NULL ? *img_ : *default_instance_->img_;
}
inline ::pp::MessageImage* MessageBody::mutable_img() {
  set_has_img();
  if (img_ == NULL) img_ = new ::pp::MessageImage;
  return img_;
}
inline ::pp::MessageImage* MessageBody::release_img() {
  clear_has_img();
  ::pp::MessageImage* temp = img_;
  img_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_img(::pp::MessageImage* img) {
  delete img_;
  img_ = img;
  if (img) {
    set_has_img();
  } else {
    clear_has_img();
  }
}

// optional .pp.MessageVoice voice = 4;
inline bool MessageBody::has_voice() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageBody::set_has_voice() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageBody::clear_has_voice() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageBody::clear_voice() {
  if (voice_ != NULL) voice_->::pp::MessageVoice::Clear();
  clear_has_voice();
}
inline const ::pp::MessageVoice& MessageBody::voice() const {
  return voice_ != NULL ? *voice_ : *default_instance_->voice_;
}
inline ::pp::MessageVoice* MessageBody::mutable_voice() {
  set_has_voice();
  if (voice_ == NULL) voice_ = new ::pp::MessageVoice;
  return voice_;
}
inline ::pp::MessageVoice* MessageBody::release_voice() {
  clear_has_voice();
  ::pp::MessageVoice* temp = voice_;
  voice_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_voice(::pp::MessageVoice* voice) {
  delete voice_;
  voice_ = voice;
  if (voice) {
    set_has_voice();
  } else {
    clear_has_voice();
  }
}

// optional .pp.MessageVideo video = 5;
inline bool MessageBody::has_video() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageBody::set_has_video() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageBody::clear_has_video() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageBody::clear_video() {
  if (video_ != NULL) video_->::pp::MessageVideo::Clear();
  clear_has_video();
}
inline const ::pp::MessageVideo& MessageBody::video() const {
  return video_ != NULL ? *video_ : *default_instance_->video_;
}
inline ::pp::MessageVideo* MessageBody::mutable_video() {
  set_has_video();
  if (video_ == NULL) video_ = new ::pp::MessageVideo;
  return video_;
}
inline ::pp::MessageVideo* MessageBody::release_video() {
  clear_has_video();
  ::pp::MessageVideo* temp = video_;
  video_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_video(::pp::MessageVideo* video) {
  delete video_;
  video_ = video;
  if (video) {
    set_has_video();
  } else {
    clear_has_video();
  }
}

// repeated .pp.MessagePub pub = 6;
inline int MessageBody::pub_size() const {
  return pub_.size();
}
inline void MessageBody::clear_pub() {
  pub_.Clear();
}
inline const ::pp::MessagePub& MessageBody::pub(int index) const {
  return pub_.Get(index);
}
inline ::pp::MessagePub* MessageBody::mutable_pub(int index) {
  return pub_.Mutable(index);
}
inline ::pp::MessagePub* MessageBody::add_pub() {
  return pub_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >&
MessageBody::pub() const {
  return pub_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >*
MessageBody::mutable_pub() {
  return &pub_;
}

// optional .pp.MessageGroupNotice gnotice = 7;
inline bool MessageBody::has_gnotice() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MessageBody::set_has_gnotice() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MessageBody::clear_has_gnotice() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MessageBody::clear_gnotice() {
  if (gnotice_ != NULL) gnotice_->::pp::MessageGroupNotice::Clear();
  clear_has_gnotice();
}
inline const ::pp::MessageGroupNotice& MessageBody::gnotice() const {
  return gnotice_ != NULL ? *gnotice_ : *default_instance_->gnotice_;
}
inline ::pp::MessageGroupNotice* MessageBody::mutable_gnotice() {
  set_has_gnotice();
  if (gnotice_ == NULL) gnotice_ = new ::pp::MessageGroupNotice;
  return gnotice_;
}
inline ::pp::MessageGroupNotice* MessageBody::release_gnotice() {
  clear_has_gnotice();
  ::pp::MessageGroupNotice* temp = gnotice_;
  gnotice_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_gnotice(::pp::MessageGroupNotice* gnotice) {
  delete gnotice_;
  gnotice_ = gnotice;
  if (gnotice) {
    set_has_gnotice();
  } else {
    clear_has_gnotice();
  }
}

// repeated .pp.MessagePub ad = 8;
inline int MessageBody::ad_size() const {
  return ad_.size();
}
inline void MessageBody::clear_ad() {
  ad_.Clear();
}
inline const ::pp::MessagePub& MessageBody::ad(int index) const {
  return ad_.Get(index);
}
inline ::pp::MessagePub* MessageBody::mutable_ad(int index) {
  return ad_.Mutable(index);
}
inline ::pp::MessagePub* MessageBody::add_ad() {
  return ad_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >&
MessageBody::ad() const {
  return ad_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::MessagePub >*
MessageBody::mutable_ad() {
  return &ad_;
}

// optional .pp.MessagePub activity = 9;
inline bool MessageBody::has_activity() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void MessageBody::set_has_activity() {
  _has_bits_[0] |= 0x00000100u;
}
inline void MessageBody::clear_has_activity() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void MessageBody::clear_activity() {
  if (activity_ != NULL) activity_->::pp::MessagePub::Clear();
  clear_has_activity();
}
inline const ::pp::MessagePub& MessageBody::activity() const {
  return activity_ != NULL ? *activity_ : *default_instance_->activity_;
}
inline ::pp::MessagePub* MessageBody::mutable_activity() {
  set_has_activity();
  if (activity_ == NULL) activity_ = new ::pp::MessagePub;
  return activity_;
}
inline ::pp::MessagePub* MessageBody::release_activity() {
  clear_has_activity();
  ::pp::MessagePub* temp = activity_;
  activity_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_activity(::pp::MessagePub* activity) {
  delete activity_;
  activity_ = activity;
  if (activity) {
    set_has_activity();
  } else {
    clear_has_activity();
  }
}

// optional .pp.MessageInputStatus inputstatus = 10;
inline bool MessageBody::has_inputstatus() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void MessageBody::set_has_inputstatus() {
  _has_bits_[0] |= 0x00000200u;
}
inline void MessageBody::clear_has_inputstatus() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void MessageBody::clear_inputstatus() {
  if (inputstatus_ != NULL) inputstatus_->::pp::MessageInputStatus::Clear();
  clear_has_inputstatus();
}
inline const ::pp::MessageInputStatus& MessageBody::inputstatus() const {
  return inputstatus_ != NULL ? *inputstatus_ : *default_instance_->inputstatus_;
}
inline ::pp::MessageInputStatus* MessageBody::mutable_inputstatus() {
  set_has_inputstatus();
  if (inputstatus_ == NULL) inputstatus_ = new ::pp::MessageInputStatus;
  return inputstatus_;
}
inline ::pp::MessageInputStatus* MessageBody::release_inputstatus() {
  clear_has_inputstatus();
  ::pp::MessageInputStatus* temp = inputstatus_;
  inputstatus_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_inputstatus(::pp::MessageInputStatus* inputstatus) {
  delete inputstatus_;
  inputstatus_ = inputstatus;
  if (inputstatus) {
    set_has_inputstatus();
  } else {
    clear_has_inputstatus();
  }
}

// optional .pp.MessageTxtlink txtlink = 21;
inline bool MessageBody::has_txtlink() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void MessageBody::set_has_txtlink() {
  _has_bits_[0] |= 0x00000400u;
}
inline void MessageBody::clear_has_txtlink() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void MessageBody::clear_txtlink() {
  if (txtlink_ != NULL) txtlink_->::pp::MessageTxtlink::Clear();
  clear_has_txtlink();
}
inline const ::pp::MessageTxtlink& MessageBody::txtlink() const {
  return txtlink_ != NULL ? *txtlink_ : *default_instance_->txtlink_;
}
inline ::pp::MessageTxtlink* MessageBody::mutable_txtlink() {
  set_has_txtlink();
  if (txtlink_ == NULL) txtlink_ = new ::pp::MessageTxtlink;
  return txtlink_;
}
inline ::pp::MessageTxtlink* MessageBody::release_txtlink() {
  clear_has_txtlink();
  ::pp::MessageTxtlink* temp = txtlink_;
  txtlink_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_txtlink(::pp::MessageTxtlink* txtlink) {
  delete txtlink_;
  txtlink_ = txtlink;
  if (txtlink) {
    set_has_txtlink();
  } else {
    clear_has_txtlink();
  }
}

// optional string html = 33;
inline bool MessageBody::has_html() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void MessageBody::set_has_html() {
  _has_bits_[0] |= 0x00000800u;
}
inline void MessageBody::clear_has_html() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void MessageBody::clear_html() {
  if (html_ != &::google::protobuf::internal::kEmptyString) {
    html_->clear();
  }
  clear_has_html();
}
inline const ::std::string& MessageBody::html() const {
  return *html_;
}
inline void MessageBody::set_html(const ::std::string& value) {
  set_has_html();
  if (html_ == &::google::protobuf::internal::kEmptyString) {
    html_ = new ::std::string;
  }
  html_->assign(value);
}
inline void MessageBody::set_html(const char* value) {
  set_has_html();
  if (html_ == &::google::protobuf::internal::kEmptyString) {
    html_ = new ::std::string;
  }
  html_->assign(value);
}
inline void MessageBody::set_html(const char* value, size_t size) {
  set_has_html();
  if (html_ == &::google::protobuf::internal::kEmptyString) {
    html_ = new ::std::string;
  }
  html_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageBody::mutable_html() {
  set_has_html();
  if (html_ == &::google::protobuf::internal::kEmptyString) {
    html_ = new ::std::string;
  }
  return html_;
}
inline ::std::string* MessageBody::release_html() {
  clear_has_html();
  if (html_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = html_;
    html_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageBody::set_allocated_html(::std::string* html) {
  if (html_ != &::google::protobuf::internal::kEmptyString) {
    delete html_;
  }
  if (html) {
    set_has_html();
    html_ = html;
  } else {
    clear_has_html();
    html_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.MessageUserApply userApply = 34;
inline bool MessageBody::has_userapply() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void MessageBody::set_has_userapply() {
  _has_bits_[0] |= 0x00001000u;
}
inline void MessageBody::clear_has_userapply() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void MessageBody::clear_userapply() {
  if (userapply_ != NULL) userapply_->::pp::MessageUserApply::Clear();
  clear_has_userapply();
}
inline const ::pp::MessageUserApply& MessageBody::userapply() const {
  return userapply_ != NULL ? *userapply_ : *default_instance_->userapply_;
}
inline ::pp::MessageUserApply* MessageBody::mutable_userapply() {
  set_has_userapply();
  if (userapply_ == NULL) userapply_ = new ::pp::MessageUserApply;
  return userapply_;
}
inline ::pp::MessageUserApply* MessageBody::release_userapply() {
  clear_has_userapply();
  ::pp::MessageUserApply* temp = userapply_;
  userapply_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_userapply(::pp::MessageUserApply* userapply) {
  delete userapply_;
  userapply_ = userapply;
  if (userapply) {
    set_has_userapply();
  } else {
    clear_has_userapply();
  }
}

// optional .pp.MessageEvent event = 35;
inline bool MessageBody::has_event() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void MessageBody::set_has_event() {
  _has_bits_[0] |= 0x00002000u;
}
inline void MessageBody::clear_has_event() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void MessageBody::clear_event() {
  if (event_ != NULL) event_->::pp::MessageEvent::Clear();
  clear_has_event();
}
inline const ::pp::MessageEvent& MessageBody::event() const {
  return event_ != NULL ? *event_ : *default_instance_->event_;
}
inline ::pp::MessageEvent* MessageBody::mutable_event() {
  set_has_event();
  if (event_ == NULL) event_ = new ::pp::MessageEvent;
  return event_;
}
inline ::pp::MessageEvent* MessageBody::release_event() {
  clear_has_event();
  ::pp::MessageEvent* temp = event_;
  event_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_event(::pp::MessageEvent* event) {
  delete event_;
  event_ = event;
  if (event) {
    set_has_event();
  } else {
    clear_has_event();
  }
}

// optional .pp.MessageGroupApply groupApply = 36;
inline bool MessageBody::has_groupapply() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void MessageBody::set_has_groupapply() {
  _has_bits_[0] |= 0x00004000u;
}
inline void MessageBody::clear_has_groupapply() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void MessageBody::clear_groupapply() {
  if (groupapply_ != NULL) groupapply_->::pp::MessageGroupApply::Clear();
  clear_has_groupapply();
}
inline const ::pp::MessageGroupApply& MessageBody::groupapply() const {
  return groupapply_ != NULL ? *groupapply_ : *default_instance_->groupapply_;
}
inline ::pp::MessageGroupApply* MessageBody::mutable_groupapply() {
  set_has_groupapply();
  if (groupapply_ == NULL) groupapply_ = new ::pp::MessageGroupApply;
  return groupapply_;
}
inline ::pp::MessageGroupApply* MessageBody::release_groupapply() {
  clear_has_groupapply();
  ::pp::MessageGroupApply* temp = groupapply_;
  groupapply_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_groupapply(::pp::MessageGroupApply* groupapply) {
  delete groupapply_;
  groupapply_ = groupapply;
  if (groupapply) {
    set_has_groupapply();
  } else {
    clear_has_groupapply();
  }
}

// optional .pp.MessageUserTask userTask = 37;
inline bool MessageBody::has_usertask() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void MessageBody::set_has_usertask() {
  _has_bits_[0] |= 0x00008000u;
}
inline void MessageBody::clear_has_usertask() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void MessageBody::clear_usertask() {
  if (usertask_ != NULL) usertask_->::pp::MessageUserTask::Clear();
  clear_has_usertask();
}
inline const ::pp::MessageUserTask& MessageBody::usertask() const {
  return usertask_ != NULL ? *usertask_ : *default_instance_->usertask_;
}
inline ::pp::MessageUserTask* MessageBody::mutable_usertask() {
  set_has_usertask();
  if (usertask_ == NULL) usertask_ = new ::pp::MessageUserTask;
  return usertask_;
}
inline ::pp::MessageUserTask* MessageBody::release_usertask() {
  clear_has_usertask();
  ::pp::MessageUserTask* temp = usertask_;
  usertask_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_usertask(::pp::MessageUserTask* usertask) {
  delete usertask_;
  usertask_ = usertask;
  if (usertask) {
    set_has_usertask();
  } else {
    clear_has_usertask();
  }
}

// optional .pp.UserInfo userinfo = 50;
inline bool MessageBody::has_userinfo() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void MessageBody::set_has_userinfo() {
  _has_bits_[0] |= 0x00010000u;
}
inline void MessageBody::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void MessageBody::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& MessageBody::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* MessageBody::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* MessageBody::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional .pp.GroupInfo groupInfo = 51;
inline bool MessageBody::has_groupinfo() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void MessageBody::set_has_groupinfo() {
  _has_bits_[0] |= 0x00020000u;
}
inline void MessageBody::clear_has_groupinfo() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void MessageBody::clear_groupinfo() {
  if (groupinfo_ != NULL) groupinfo_->::pp::GroupInfo::Clear();
  clear_has_groupinfo();
}
inline const ::pp::GroupInfo& MessageBody::groupinfo() const {
  return groupinfo_ != NULL ? *groupinfo_ : *default_instance_->groupinfo_;
}
inline ::pp::GroupInfo* MessageBody::mutable_groupinfo() {
  set_has_groupinfo();
  if (groupinfo_ == NULL) groupinfo_ = new ::pp::GroupInfo;
  return groupinfo_;
}
inline ::pp::GroupInfo* MessageBody::release_groupinfo() {
  clear_has_groupinfo();
  ::pp::GroupInfo* temp = groupinfo_;
  groupinfo_ = NULL;
  return temp;
}
inline void MessageBody::set_allocated_groupinfo(::pp::GroupInfo* groupinfo) {
  delete groupinfo_;
  groupinfo_ = groupinfo;
  if (groupinfo) {
    set_has_groupinfo();
  } else {
    clear_has_groupinfo();
  }
}

// optional string title = 98;
inline bool MessageBody::has_title() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void MessageBody::set_has_title() {
  _has_bits_[0] |= 0x00040000u;
}
inline void MessageBody::clear_has_title() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void MessageBody::clear_title() {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    title_->clear();
  }
  clear_has_title();
}
inline const ::std::string& MessageBody::title() const {
  return *title_;
}
inline void MessageBody::set_title(const ::std::string& value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MessageBody::set_title(const char* value) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(value);
}
inline void MessageBody::set_title(const char* value, size_t size) {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  title_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MessageBody::mutable_title() {
  set_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    title_ = new ::std::string;
  }
  return title_;
}
inline ::std::string* MessageBody::release_title() {
  clear_has_title();
  if (title_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = title_;
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MessageBody::set_allocated_title(::std::string* title) {
  if (title_ != &::google::protobuf::internal::kEmptyString) {
    delete title_;
  }
  if (title) {
    set_has_title();
    title_ = title;
  } else {
    clear_has_title();
    title_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PresentInfo

// optional uint32 id = 1;
inline bool PresentInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 PresentInfo::id() const {
  return id_;
}
inline void PresentInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool PresentInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PresentInfo::name() const {
  return *name_;
}
inline void PresentInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PresentInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PresentInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PresentInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PresentInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 gameId = 3;
inline bool PresentInfo::has_gameid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PresentInfo::set_has_gameid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PresentInfo::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PresentInfo::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 PresentInfo::gameid() const {
  return gameid_;
}
inline void PresentInfo::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 price = 5;
inline bool PresentInfo::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PresentInfo::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PresentInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PresentInfo::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 PresentInfo::price() const {
  return price_;
}
inline void PresentInfo::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
}

// optional uint32 total = 6;
inline bool PresentInfo::has_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PresentInfo::set_has_total() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PresentInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PresentInfo::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 PresentInfo::total() const {
  return total_;
}
inline void PresentInfo::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 leftNum = 7;
inline bool PresentInfo::has_leftnum() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PresentInfo::set_has_leftnum() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PresentInfo::clear_has_leftnum() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PresentInfo::clear_leftnum() {
  leftnum_ = 0u;
  clear_has_leftnum();
}
inline ::google::protobuf::uint32 PresentInfo::leftnum() const {
  return leftnum_;
}
inline void PresentInfo::set_leftnum(::google::protobuf::uint32 value) {
  set_has_leftnum();
  leftnum_ = value;
}

// optional string content = 8;
inline bool PresentInfo::has_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PresentInfo::set_has_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PresentInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PresentInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& PresentInfo::content() const {
  return *content_;
}
inline void PresentInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void PresentInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void PresentInfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* PresentInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PresentInfo::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string intro = 9;
inline bool PresentInfo::has_intro() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PresentInfo::set_has_intro() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PresentInfo::clear_has_intro() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PresentInfo::clear_intro() {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    intro_->clear();
  }
  clear_has_intro();
}
inline const ::std::string& PresentInfo::intro() const {
  return *intro_;
}
inline void PresentInfo::set_intro(const ::std::string& value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void PresentInfo::set_intro(const char* value) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(value);
}
inline void PresentInfo::set_intro(const char* value, size_t size) {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  intro_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentInfo::mutable_intro() {
  set_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    intro_ = new ::std::string;
  }
  return intro_;
}
inline ::std::string* PresentInfo::release_intro() {
  clear_has_intro();
  if (intro_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = intro_;
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PresentInfo::set_allocated_intro(::std::string* intro) {
  if (intro_ != &::google::protobuf::internal::kEmptyString) {
    delete intro_;
  }
  if (intro) {
    set_has_intro();
    intro_ = intro;
  } else {
    clear_has_intro();
    intro_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 startTime = 10;
inline bool PresentInfo::has_starttime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PresentInfo::set_has_starttime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PresentInfo::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PresentInfo::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 PresentInfo::starttime() const {
  return starttime_;
}
inline void PresentInfo::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional int64 endTime = 11;
inline bool PresentInfo::has_endtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PresentInfo::set_has_endtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PresentInfo::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PresentInfo::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 PresentInfo::endtime() const {
  return endtime_;
}
inline void PresentInfo::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// optional .pp.GameInfo game = 12;
inline bool PresentInfo::has_game() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PresentInfo::set_has_game() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PresentInfo::clear_has_game() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PresentInfo::clear_game() {
  if (game_ != NULL) game_->::pp::GameInfo::Clear();
  clear_has_game();
}
inline const ::pp::GameInfo& PresentInfo::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::pp::GameInfo* PresentInfo::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::pp::GameInfo;
  return game_;
}
inline ::pp::GameInfo* PresentInfo::release_game() {
  clear_has_game();
  ::pp::GameInfo* temp = game_;
  game_ = NULL;
  return temp;
}
inline void PresentInfo::set_allocated_game(::pp::GameInfo* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// optional string label = 18;
inline bool PresentInfo::has_label() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PresentInfo::set_has_label() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PresentInfo::clear_has_label() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PresentInfo::clear_label() {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    label_->clear();
  }
  clear_has_label();
}
inline const ::std::string& PresentInfo::label() const {
  return *label_;
}
inline void PresentInfo::set_label(const ::std::string& value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void PresentInfo::set_label(const char* value) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(value);
}
inline void PresentInfo::set_label(const char* value, size_t size) {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  label_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentInfo::mutable_label() {
  set_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    label_ = new ::std::string;
  }
  return label_;
}
inline ::std::string* PresentInfo::release_label() {
  clear_has_label();
  if (label_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = label_;
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PresentInfo::set_allocated_label(::std::string* label) {
  if (label_ != &::google::protobuf::internal::kEmptyString) {
    delete label_;
  }
  if (label) {
    set_has_label();
    label_ = label;
  } else {
    clear_has_label();
    label_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 40;
inline bool PresentInfo::has_state() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PresentInfo::set_has_state() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PresentInfo::clear_has_state() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PresentInfo::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 PresentInfo::state() const {
  return state_;
}
inline void PresentInfo::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// repeated string codes = 50;
inline int PresentInfo::codes_size() const {
  return codes_.size();
}
inline void PresentInfo::clear_codes() {
  codes_.Clear();
}
inline const ::std::string& PresentInfo::codes(int index) const {
  return codes_.Get(index);
}
inline ::std::string* PresentInfo::mutable_codes(int index) {
  return codes_.Mutable(index);
}
inline void PresentInfo::set_codes(int index, const ::std::string& value) {
  codes_.Mutable(index)->assign(value);
}
inline void PresentInfo::set_codes(int index, const char* value) {
  codes_.Mutable(index)->assign(value);
}
inline void PresentInfo::set_codes(int index, const char* value, size_t size) {
  codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentInfo::add_codes() {
  return codes_.Add();
}
inline void PresentInfo::add_codes(const ::std::string& value) {
  codes_.Add()->assign(value);
}
inline void PresentInfo::add_codes(const char* value) {
  codes_.Add()->assign(value);
}
inline void PresentInfo::add_codes(const char* value, size_t size) {
  codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PresentInfo::codes() const {
  return codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PresentInfo::mutable_codes() {
  return &codes_;
}

// -------------------------------------------------------------------

// PresentInfoReq

// optional uint32 presentId = 1;
inline bool PresentInfoReq::has_presentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentInfoReq::set_has_presentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentInfoReq::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentInfoReq::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 PresentInfoReq::presentid() const {
  return presentid_;
}
inline void PresentInfoReq::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// -------------------------------------------------------------------

// PresentInfoRes

// optional .pp.PresentInfo present = 1;
inline bool PresentInfoRes::has_present() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentInfoRes::set_has_present() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentInfoRes::clear_has_present() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentInfoRes::clear_present() {
  if (present_ != NULL) present_->::pp::PresentInfo::Clear();
  clear_has_present();
}
inline const ::pp::PresentInfo& PresentInfoRes::present() const {
  return present_ != NULL ? *present_ : *default_instance_->present_;
}
inline ::pp::PresentInfo* PresentInfoRes::mutable_present() {
  set_has_present();
  if (present_ == NULL) present_ = new ::pp::PresentInfo;
  return present_;
}
inline ::pp::PresentInfo* PresentInfoRes::release_present() {
  clear_has_present();
  ::pp::PresentInfo* temp = present_;
  present_ = NULL;
  return temp;
}
inline void PresentInfoRes::set_allocated_present(::pp::PresentInfo* present) {
  delete present_;
  present_ = present;
  if (present) {
    set_has_present();
  } else {
    clear_has_present();
  }
}

// -------------------------------------------------------------------

// PresentAddReq

// optional .pp.PresentInfo present = 1;
inline bool PresentAddReq::has_present() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentAddReq::set_has_present() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentAddReq::clear_has_present() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentAddReq::clear_present() {
  if (present_ != NULL) present_->::pp::PresentInfo::Clear();
  clear_has_present();
}
inline const ::pp::PresentInfo& PresentAddReq::present() const {
  return present_ != NULL ? *present_ : *default_instance_->present_;
}
inline ::pp::PresentInfo* PresentAddReq::mutable_present() {
  set_has_present();
  if (present_ == NULL) present_ = new ::pp::PresentInfo;
  return present_;
}
inline ::pp::PresentInfo* PresentAddReq::release_present() {
  clear_has_present();
  ::pp::PresentInfo* temp = present_;
  present_ = NULL;
  return temp;
}
inline void PresentAddReq::set_allocated_present(::pp::PresentInfo* present) {
  delete present_;
  present_ = present;
  if (present) {
    set_has_present();
  } else {
    clear_has_present();
  }
}

// repeated string codes = 2;
inline int PresentAddReq::codes_size() const {
  return codes_.size();
}
inline void PresentAddReq::clear_codes() {
  codes_.Clear();
}
inline const ::std::string& PresentAddReq::codes(int index) const {
  return codes_.Get(index);
}
inline ::std::string* PresentAddReq::mutable_codes(int index) {
  return codes_.Mutable(index);
}
inline void PresentAddReq::set_codes(int index, const ::std::string& value) {
  codes_.Mutable(index)->assign(value);
}
inline void PresentAddReq::set_codes(int index, const char* value) {
  codes_.Mutable(index)->assign(value);
}
inline void PresentAddReq::set_codes(int index, const char* value, size_t size) {
  codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentAddReq::add_codes() {
  return codes_.Add();
}
inline void PresentAddReq::add_codes(const ::std::string& value) {
  codes_.Add()->assign(value);
}
inline void PresentAddReq::add_codes(const char* value) {
  codes_.Add()->assign(value);
}
inline void PresentAddReq::add_codes(const char* value, size_t size) {
  codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PresentAddReq::codes() const {
  return codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PresentAddReq::mutable_codes() {
  return &codes_;
}

// -------------------------------------------------------------------

// PresentModifyReq

// optional .pp.PresentInfo present = 1;
inline bool PresentModifyReq::has_present() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentModifyReq::set_has_present() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentModifyReq::clear_has_present() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentModifyReq::clear_present() {
  if (present_ != NULL) present_->::pp::PresentInfo::Clear();
  clear_has_present();
}
inline const ::pp::PresentInfo& PresentModifyReq::present() const {
  return present_ != NULL ? *present_ : *default_instance_->present_;
}
inline ::pp::PresentInfo* PresentModifyReq::mutable_present() {
  set_has_present();
  if (present_ == NULL) present_ = new ::pp::PresentInfo;
  return present_;
}
inline ::pp::PresentInfo* PresentModifyReq::release_present() {
  clear_has_present();
  ::pp::PresentInfo* temp = present_;
  present_ = NULL;
  return temp;
}
inline void PresentModifyReq::set_allocated_present(::pp::PresentInfo* present) {
  delete present_;
  present_ = present;
  if (present) {
    set_has_present();
  } else {
    clear_has_present();
  }
}

// repeated string codes = 2;
inline int PresentModifyReq::codes_size() const {
  return codes_.size();
}
inline void PresentModifyReq::clear_codes() {
  codes_.Clear();
}
inline const ::std::string& PresentModifyReq::codes(int index) const {
  return codes_.Get(index);
}
inline ::std::string* PresentModifyReq::mutable_codes(int index) {
  return codes_.Mutable(index);
}
inline void PresentModifyReq::set_codes(int index, const ::std::string& value) {
  codes_.Mutable(index)->assign(value);
}
inline void PresentModifyReq::set_codes(int index, const char* value) {
  codes_.Mutable(index)->assign(value);
}
inline void PresentModifyReq::set_codes(int index, const char* value, size_t size) {
  codes_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentModifyReq::add_codes() {
  return codes_.Add();
}
inline void PresentModifyReq::add_codes(const ::std::string& value) {
  codes_.Add()->assign(value);
}
inline void PresentModifyReq::add_codes(const char* value) {
  codes_.Add()->assign(value);
}
inline void PresentModifyReq::add_codes(const char* value, size_t size) {
  codes_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PresentModifyReq::codes() const {
  return codes_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PresentModifyReq::mutable_codes() {
  return &codes_;
}

// -------------------------------------------------------------------

// PresentListReq

// optional uint32 index = 1;
inline bool PresentListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PresentListReq::index() const {
  return index_;
}
inline void PresentListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool PresentListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 PresentListReq::fetchs() const {
  return fetchs_;
}
inline void PresentListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint64 gid = 3;
inline bool PresentListReq::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PresentListReq::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PresentListReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PresentListReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 PresentListReq::gid() const {
  return gid_;
}
inline void PresentListReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// PresentListRes

// optional uint32 index = 1;
inline bool PresentListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PresentListRes::index() const {
  return index_;
}
inline void PresentListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 2;
inline bool PresentListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 PresentListRes::total() const {
  return total_;
}
inline void PresentListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.PresentInfo presents = 3;
inline int PresentListRes::presents_size() const {
  return presents_.size();
}
inline void PresentListRes::clear_presents() {
  presents_.Clear();
}
inline const ::pp::PresentInfo& PresentListRes::presents(int index) const {
  return presents_.Get(index);
}
inline ::pp::PresentInfo* PresentListRes::mutable_presents(int index) {
  return presents_.Mutable(index);
}
inline ::pp::PresentInfo* PresentListRes::add_presents() {
  return presents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >&
PresentListRes::presents() const {
  return presents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >*
PresentListRes::mutable_presents() {
  return &presents_;
}

// -------------------------------------------------------------------

// PresentCountReq

// optional uint64 uid = 1;
inline bool PresentCountReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentCountReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentCountReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentCountReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 PresentCountReq::uid() const {
  return uid_;
}
inline void PresentCountReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 gid = 2;
inline bool PresentCountReq::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentCountReq::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentCountReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentCountReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 PresentCountReq::gid() const {
  return gid_;
}
inline void PresentCountReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// PresentCountRes

// optional uint32 count = 1;
inline bool PresentCountRes::has_count() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentCountRes::set_has_count() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentCountRes::clear_has_count() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentCountRes::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 PresentCountRes::count() const {
  return count_;
}
inline void PresentCountRes::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// UserPresentListReq

// optional uint32 index = 1;
inline bool UserPresentListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPresentListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPresentListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPresentListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserPresentListReq::index() const {
  return index_;
}
inline void UserPresentListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool UserPresentListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPresentListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPresentListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPresentListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserPresentListReq::fetchs() const {
  return fetchs_;
}
inline void UserPresentListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// UserPresent

// optional uint64 uid = 1;
inline bool UserPresent::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPresent::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPresent::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPresent::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserPresent::uid() const {
  return uid_;
}
inline void UserPresent::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 gid = 2;
inline bool UserPresent::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPresent::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPresent::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPresent::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 UserPresent::gid() const {
  return gid_;
}
inline void UserPresent::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.PresentInfo present = 3;
inline bool UserPresent::has_present() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserPresent::set_has_present() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserPresent::clear_has_present() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserPresent::clear_present() {
  if (present_ != NULL) present_->::pp::PresentInfo::Clear();
  clear_has_present();
}
inline const ::pp::PresentInfo& UserPresent::present() const {
  return present_ != NULL ? *present_ : *default_instance_->present_;
}
inline ::pp::PresentInfo* UserPresent::mutable_present() {
  set_has_present();
  if (present_ == NULL) present_ = new ::pp::PresentInfo;
  return present_;
}
inline ::pp::PresentInfo* UserPresent::release_present() {
  clear_has_present();
  ::pp::PresentInfo* temp = present_;
  present_ = NULL;
  return temp;
}
inline void UserPresent::set_allocated_present(::pp::PresentInfo* present) {
  delete present_;
  present_ = present;
  if (present) {
    set_has_present();
  } else {
    clear_has_present();
  }
}

// optional string code = 4;
inline bool UserPresent::has_code() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserPresent::set_has_code() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserPresent::clear_has_code() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserPresent::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& UserPresent::code() const {
  return *code_;
}
inline void UserPresent::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void UserPresent::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void UserPresent::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPresent::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* UserPresent::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPresent::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 createTime = 5;
inline bool UserPresent::has_createtime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserPresent::set_has_createtime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserPresent::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserPresent::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserPresent::createtime() const {
  return createtime_;
}
inline void UserPresent::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 presentId = 6;
inline bool UserPresent::has_presentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserPresent::set_has_presentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserPresent::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserPresent::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 UserPresent::presentid() const {
  return presentid_;
}
inline void UserPresent::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// -------------------------------------------------------------------

// UserPresentListRes

// optional uint32 index = 1;
inline bool UserPresentListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPresentListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPresentListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPresentListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserPresentListRes::index() const {
  return index_;
}
inline void UserPresentListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 2;
inline bool UserPresentListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPresentListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPresentListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPresentListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserPresentListRes::total() const {
  return total_;
}
inline void UserPresentListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.UserPresent userPresents = 3;
inline int UserPresentListRes::userpresents_size() const {
  return userpresents_.size();
}
inline void UserPresentListRes::clear_userpresents() {
  userpresents_.Clear();
}
inline const ::pp::UserPresent& UserPresentListRes::userpresents(int index) const {
  return userpresents_.Get(index);
}
inline ::pp::UserPresent* UserPresentListRes::mutable_userpresents(int index) {
  return userpresents_.Mutable(index);
}
inline ::pp::UserPresent* UserPresentListRes::add_userpresents() {
  return userpresents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserPresent >&
UserPresentListRes::userpresents() const {
  return userpresents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserPresent >*
UserPresentListRes::mutable_userpresents() {
  return &userpresents_;
}

// -------------------------------------------------------------------

// UserPresentReq

// optional uint32 presentId = 1;
inline bool UserPresentReq::has_presentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPresentReq::set_has_presentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPresentReq::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPresentReq::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 UserPresentReq::presentid() const {
  return presentid_;
}
inline void UserPresentReq::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// -------------------------------------------------------------------

// UserPresentRes

// optional .pp.UserPresent userPresent = 1;
inline bool UserPresentRes::has_userpresent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPresentRes::set_has_userpresent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPresentRes::clear_has_userpresent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPresentRes::clear_userpresent() {
  if (userpresent_ != NULL) userpresent_->::pp::UserPresent::Clear();
  clear_has_userpresent();
}
inline const ::pp::UserPresent& UserPresentRes::userpresent() const {
  return userpresent_ != NULL ? *userpresent_ : *default_instance_->userpresent_;
}
inline ::pp::UserPresent* UserPresentRes::mutable_userpresent() {
  set_has_userpresent();
  if (userpresent_ == NULL) userpresent_ = new ::pp::UserPresent;
  return userpresent_;
}
inline ::pp::UserPresent* UserPresentRes::release_userpresent() {
  clear_has_userpresent();
  ::pp::UserPresent* temp = userpresent_;
  userpresent_ = NULL;
  return temp;
}
inline void UserPresentRes::set_allocated_userpresent(::pp::UserPresent* userpresent) {
  delete userpresent_;
  userpresent_ = userpresent;
  if (userpresent) {
    set_has_userpresent();
  } else {
    clear_has_userpresent();
  }
}

// -------------------------------------------------------------------

// PresentGroupListReq

// optional uint64 presentId = 1;
inline bool PresentGroupListReq::has_presentid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentGroupListReq::set_has_presentid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentGroupListReq::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentGroupListReq::clear_presentid() {
  presentid_ = GOOGLE_ULONGLONG(0);
  clear_has_presentid();
}
inline ::google::protobuf::uint64 PresentGroupListReq::presentid() const {
  return presentid_;
}
inline void PresentGroupListReq::set_presentid(::google::protobuf::uint64 value) {
  set_has_presentid();
  presentid_ = value;
}

// optional uint32 index = 2;
inline bool PresentGroupListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentGroupListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentGroupListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentGroupListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PresentGroupListReq::index() const {
  return index_;
}
inline void PresentGroupListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool PresentGroupListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PresentGroupListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PresentGroupListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PresentGroupListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 PresentGroupListReq::fetchs() const {
  return fetchs_;
}
inline void PresentGroupListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// PresentGroupListRes

// optional uint32 index = 1;
inline bool PresentGroupListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentGroupListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentGroupListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentGroupListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PresentGroupListRes::index() const {
  return index_;
}
inline void PresentGroupListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 2;
inline bool PresentGroupListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentGroupListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentGroupListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentGroupListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 PresentGroupListRes::total() const {
  return total_;
}
inline void PresentGroupListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.GroupInfo groups = 3;
inline int PresentGroupListRes::groups_size() const {
  return groups_.size();
}
inline void PresentGroupListRes::clear_groups() {
  groups_.Clear();
}
inline const ::pp::GroupInfo& PresentGroupListRes::groups(int index) const {
  return groups_.Get(index);
}
inline ::pp::GroupInfo* PresentGroupListRes::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::pp::GroupInfo* PresentGroupListRes::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
PresentGroupListRes::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
PresentGroupListRes::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// PresentUserTakeReq

// optional uint64 gid = 1;
inline bool PresentUserTakeReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentUserTakeReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentUserTakeReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentUserTakeReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 PresentUserTakeReq::gid() const {
  return gid_;
}
inline void PresentUserTakeReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 presentId = 2;
inline bool PresentUserTakeReq::has_presentid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentUserTakeReq::set_has_presentid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentUserTakeReq::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentUserTakeReq::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 PresentUserTakeReq::presentid() const {
  return presentid_;
}
inline void PresentUserTakeReq::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// -------------------------------------------------------------------

// PresentUserTakeRes

// optional string code = 1;
inline bool PresentUserTakeRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentUserTakeRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentUserTakeRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentUserTakeRes::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& PresentUserTakeRes::code() const {
  return *code_;
}
inline void PresentUserTakeRes::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void PresentUserTakeRes::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void PresentUserTakeRes::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PresentUserTakeRes::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* PresentUserTakeRes::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PresentUserTakeRes::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupPresent

// optional uint64 gid = 1;
inline bool GroupPresent::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPresent::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPresent::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPresent::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupPresent::gid() const {
  return gid_;
}
inline void GroupPresent::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.PresentInfo present = 2;
inline bool GroupPresent::has_present() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPresent::set_has_present() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPresent::clear_has_present() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPresent::clear_present() {
  if (present_ != NULL) present_->::pp::PresentInfo::Clear();
  clear_has_present();
}
inline const ::pp::PresentInfo& GroupPresent::present() const {
  return present_ != NULL ? *present_ : *default_instance_->present_;
}
inline ::pp::PresentInfo* GroupPresent::mutable_present() {
  set_has_present();
  if (present_ == NULL) present_ = new ::pp::PresentInfo;
  return present_;
}
inline ::pp::PresentInfo* GroupPresent::release_present() {
  clear_has_present();
  ::pp::PresentInfo* temp = present_;
  present_ = NULL;
  return temp;
}
inline void GroupPresent::set_allocated_present(::pp::PresentInfo* present) {
  delete present_;
  present_ = present;
  if (present) {
    set_has_present();
  } else {
    clear_has_present();
  }
}

// optional uint32 total = 3;
inline bool GroupPresent::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPresent::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPresent::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPresent::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GroupPresent::total() const {
  return total_;
}
inline void GroupPresent::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional int32 num = 4;
inline bool GroupPresent::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupPresent::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupPresent::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupPresent::clear_num() {
  num_ = 0;
  clear_has_num();
}
inline ::google::protobuf::int32 GroupPresent::num() const {
  return num_;
}
inline void GroupPresent::set_num(::google::protobuf::int32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 contrib = 5;
inline bool GroupPresent::has_contrib() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupPresent::set_has_contrib() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupPresent::clear_has_contrib() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupPresent::clear_contrib() {
  contrib_ = 0u;
  clear_has_contrib();
}
inline ::google::protobuf::uint32 GroupPresent::contrib() const {
  return contrib_;
}
inline void GroupPresent::set_contrib(::google::protobuf::uint32 value) {
  set_has_contrib();
  contrib_ = value;
}

// optional uint32 presentId = 6;
inline bool GroupPresent::has_presentid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupPresent::set_has_presentid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupPresent::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupPresent::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 GroupPresent::presentid() const {
  return presentid_;
}
inline void GroupPresent::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// optional .pp.GroupPresentApplyType applyType = 7;
inline bool GroupPresent::has_applytype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupPresent::set_has_applytype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupPresent::clear_has_applytype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupPresent::clear_applytype() {
  applytype_ = 0;
  clear_has_applytype();
}
inline ::pp::GroupPresentApplyType GroupPresent::applytype() const {
  return static_cast< ::pp::GroupPresentApplyType >(applytype_);
}
inline void GroupPresent::set_applytype(::pp::GroupPresentApplyType value) {
  assert(::pp::GroupPresentApplyType_IsValid(value));
  set_has_applytype();
  applytype_ = value;
}

// -------------------------------------------------------------------

// GroupPresentOpReq

// optional .pp.GroupPresent groupPresent = 1;
inline bool GroupPresentOpReq::has_grouppresent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPresentOpReq::set_has_grouppresent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPresentOpReq::clear_has_grouppresent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPresentOpReq::clear_grouppresent() {
  if (grouppresent_ != NULL) grouppresent_->::pp::GroupPresent::Clear();
  clear_has_grouppresent();
}
inline const ::pp::GroupPresent& GroupPresentOpReq::grouppresent() const {
  return grouppresent_ != NULL ? *grouppresent_ : *default_instance_->grouppresent_;
}
inline ::pp::GroupPresent* GroupPresentOpReq::mutable_grouppresent() {
  set_has_grouppresent();
  if (grouppresent_ == NULL) grouppresent_ = new ::pp::GroupPresent;
  return grouppresent_;
}
inline ::pp::GroupPresent* GroupPresentOpReq::release_grouppresent() {
  clear_has_grouppresent();
  ::pp::GroupPresent* temp = grouppresent_;
  grouppresent_ = NULL;
  return temp;
}
inline void GroupPresentOpReq::set_allocated_grouppresent(::pp::GroupPresent* grouppresent) {
  delete grouppresent_;
  grouppresent_ = grouppresent;
  if (grouppresent) {
    set_has_grouppresent();
  } else {
    clear_has_grouppresent();
  }
}

// optional .pp.EntityOpType opType = 2;
inline bool GroupPresentOpReq::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPresentOpReq::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPresentOpReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPresentOpReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::EntityOpType GroupPresentOpReq::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void GroupPresentOpReq::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional bool needcode = 3;
inline bool GroupPresentOpReq::has_needcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPresentOpReq::set_has_needcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPresentOpReq::clear_has_needcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPresentOpReq::clear_needcode() {
  needcode_ = false;
  clear_has_needcode();
}
inline bool GroupPresentOpReq::needcode() const {
  return needcode_;
}
inline void GroupPresentOpReq::set_needcode(bool value) {
  set_has_needcode();
  needcode_ = value;
}

// optional bool needmoney = 4;
inline bool GroupPresentOpReq::has_needmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupPresentOpReq::set_has_needmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupPresentOpReq::clear_has_needmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupPresentOpReq::clear_needmoney() {
  needmoney_ = false;
  clear_has_needmoney();
}
inline bool GroupPresentOpReq::needmoney() const {
  return needmoney_;
}
inline void GroupPresentOpReq::set_needmoney(bool value) {
  set_has_needmoney();
  needmoney_ = value;
}

// -------------------------------------------------------------------

// GroupPresentOpRes

// optional .pp.GroupPresent groupPresent = 1;
inline bool GroupPresentOpRes::has_grouppresent() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPresentOpRes::set_has_grouppresent() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPresentOpRes::clear_has_grouppresent() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPresentOpRes::clear_grouppresent() {
  if (grouppresent_ != NULL) grouppresent_->::pp::GroupPresent::Clear();
  clear_has_grouppresent();
}
inline const ::pp::GroupPresent& GroupPresentOpRes::grouppresent() const {
  return grouppresent_ != NULL ? *grouppresent_ : *default_instance_->grouppresent_;
}
inline ::pp::GroupPresent* GroupPresentOpRes::mutable_grouppresent() {
  set_has_grouppresent();
  if (grouppresent_ == NULL) grouppresent_ = new ::pp::GroupPresent;
  return grouppresent_;
}
inline ::pp::GroupPresent* GroupPresentOpRes::release_grouppresent() {
  clear_has_grouppresent();
  ::pp::GroupPresent* temp = grouppresent_;
  grouppresent_ = NULL;
  return temp;
}
inline void GroupPresentOpRes::set_allocated_grouppresent(::pp::GroupPresent* grouppresent) {
  delete grouppresent_;
  grouppresent_ = grouppresent;
  if (grouppresent) {
    set_has_grouppresent();
  } else {
    clear_has_grouppresent();
  }
}

// optional string code = 2;
inline bool GroupPresentOpRes::has_code() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPresentOpRes::set_has_code() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPresentOpRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPresentOpRes::clear_code() {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    code_->clear();
  }
  clear_has_code();
}
inline const ::std::string& GroupPresentOpRes::code() const {
  return *code_;
}
inline void GroupPresentOpRes::set_code(const ::std::string& value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void GroupPresentOpRes::set_code(const char* value) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(value);
}
inline void GroupPresentOpRes::set_code(const char* value, size_t size) {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  code_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupPresentOpRes::mutable_code() {
  set_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    code_ = new ::std::string;
  }
  return code_;
}
inline ::std::string* GroupPresentOpRes::release_code() {
  clear_has_code();
  if (code_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = code_;
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupPresentOpRes::set_allocated_code(::std::string* code) {
  if (code_ != &::google::protobuf::internal::kEmptyString) {
    delete code_;
  }
  if (code) {
    set_has_code();
    code_ = code;
  } else {
    clear_has_code();
    code_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupPresentListReq

// optional uint64 gid = 1;
inline bool GroupPresentListReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPresentListReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPresentListReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPresentListReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupPresentListReq::gid() const {
  return gid_;
}
inline void GroupPresentListReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 index = 2;
inline bool GroupPresentListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPresentListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPresentListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPresentListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GroupPresentListReq::index() const {
  return index_;
}
inline void GroupPresentListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GroupPresentListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupPresentListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupPresentListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupPresentListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GroupPresentListReq::fetchs() const {
  return fetchs_;
}
inline void GroupPresentListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 gameId = 4;
inline bool GroupPresentListReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupPresentListReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupPresentListReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupPresentListReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GroupPresentListReq::gameid() const {
  return gameid_;
}
inline void GroupPresentListReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// -------------------------------------------------------------------

// GroupPresentListRes

// optional uint32 index = 1;
inline bool GroupPresentListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupPresentListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupPresentListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupPresentListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GroupPresentListRes::index() const {
  return index_;
}
inline void GroupPresentListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 2;
inline bool GroupPresentListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupPresentListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupPresentListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupPresentListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GroupPresentListRes::total() const {
  return total_;
}
inline void GroupPresentListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.GroupPresent presents = 3;
inline int GroupPresentListRes::presents_size() const {
  return presents_.size();
}
inline void GroupPresentListRes::clear_presents() {
  presents_.Clear();
}
inline const ::pp::GroupPresent& GroupPresentListRes::presents(int index) const {
  return presents_.Get(index);
}
inline ::pp::GroupPresent* GroupPresentListRes::mutable_presents(int index) {
  return presents_.Mutable(index);
}
inline ::pp::GroupPresent* GroupPresentListRes::add_presents() {
  return presents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupPresent >&
GroupPresentListRes::presents() const {
  return presents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupPresent >*
GroupPresentListRes::mutable_presents() {
  return &presents_;
}

// -------------------------------------------------------------------

// GetPresentsByGameIdReq

// optional uint32 gameId = 1;
inline bool GetPresentsByGameIdReq::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPresentsByGameIdReq::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPresentsByGameIdReq::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPresentsByGameIdReq::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdReq::gameid() const {
  return gameid_;
}
inline void GetPresentsByGameIdReq::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// optional uint32 index = 2;
inline bool GetPresentsByGameIdReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetPresentsByGameIdReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetPresentsByGameIdReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetPresentsByGameIdReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdReq::index() const {
  return index_;
}
inline void GetPresentsByGameIdReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool GetPresentsByGameIdReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPresentsByGameIdReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPresentsByGameIdReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPresentsByGameIdReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdReq::fetchs() const {
  return fetchs_;
}
inline void GetPresentsByGameIdReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint64 gid = 4;
inline bool GetPresentsByGameIdReq::has_gid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPresentsByGameIdReq::set_has_gid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPresentsByGameIdReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPresentsByGameIdReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GetPresentsByGameIdReq::gid() const {
  return gid_;
}
inline void GetPresentsByGameIdReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// GetPresentsByGameIdRes

// optional uint32 gameId = 1;
inline bool GetPresentsByGameIdRes::has_gameid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetPresentsByGameIdRes::set_has_gameid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetPresentsByGameIdRes::clear_has_gameid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetPresentsByGameIdRes::clear_gameid() {
  gameid_ = 0u;
  clear_has_gameid();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdRes::gameid() const {
  return gameid_;
}
inline void GetPresentsByGameIdRes::set_gameid(::google::protobuf::uint32 value) {
  set_has_gameid();
  gameid_ = value;
}

// repeated .pp.PresentInfo presents = 2;
inline int GetPresentsByGameIdRes::presents_size() const {
  return presents_.size();
}
inline void GetPresentsByGameIdRes::clear_presents() {
  presents_.Clear();
}
inline const ::pp::PresentInfo& GetPresentsByGameIdRes::presents(int index) const {
  return presents_.Get(index);
}
inline ::pp::PresentInfo* GetPresentsByGameIdRes::mutable_presents(int index) {
  return presents_.Mutable(index);
}
inline ::pp::PresentInfo* GetPresentsByGameIdRes::add_presents() {
  return presents_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >&
GetPresentsByGameIdRes::presents() const {
  return presents_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::PresentInfo >*
GetPresentsByGameIdRes::mutable_presents() {
  return &presents_;
}

// optional uint32 index = 3;
inline bool GetPresentsByGameIdRes::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GetPresentsByGameIdRes::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GetPresentsByGameIdRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GetPresentsByGameIdRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdRes::index() const {
  return index_;
}
inline void GetPresentsByGameIdRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 4;
inline bool GetPresentsByGameIdRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GetPresentsByGameIdRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GetPresentsByGameIdRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GetPresentsByGameIdRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdRes::fetchs() const {
  return fetchs_;
}
inline void GetPresentsByGameIdRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 total = 5;
inline bool GetPresentsByGameIdRes::has_total() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GetPresentsByGameIdRes::set_has_total() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GetPresentsByGameIdRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GetPresentsByGameIdRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 GetPresentsByGameIdRes::total() const {
  return total_;
}
inline void GetPresentsByGameIdRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// -------------------------------------------------------------------

// PresentUserListReq

// optional uint32 index = 2;
inline bool PresentUserListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentUserListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentUserListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentUserListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PresentUserListReq::index() const {
  return index_;
}
inline void PresentUserListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool PresentUserListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentUserListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentUserListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentUserListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 PresentUserListReq::fetchs() const {
  return fetchs_;
}
inline void PresentUserListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint64 gid = 4;
inline bool PresentUserListReq::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PresentUserListReq::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PresentUserListReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PresentUserListReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 PresentUserListReq::gid() const {
  return gid_;
}
inline void PresentUserListReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 presentId = 5;
inline bool PresentUserListReq::has_presentid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PresentUserListReq::set_has_presentid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PresentUserListReq::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PresentUserListReq::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 PresentUserListReq::presentid() const {
  return presentid_;
}
inline void PresentUserListReq::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// -------------------------------------------------------------------

// PresentUserListRes

// repeated .pp.PresentUser presentUsers = 1;
inline int PresentUserListRes::presentusers_size() const {
  return presentusers_.size();
}
inline void PresentUserListRes::clear_presentusers() {
  presentusers_.Clear();
}
inline const ::pp::PresentUser& PresentUserListRes::presentusers(int index) const {
  return presentusers_.Get(index);
}
inline ::pp::PresentUser* PresentUserListRes::mutable_presentusers(int index) {
  return presentusers_.Mutable(index);
}
inline ::pp::PresentUser* PresentUserListRes::add_presentusers() {
  return presentusers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::PresentUser >&
PresentUserListRes::presentusers() const {
  return presentusers_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::PresentUser >*
PresentUserListRes::mutable_presentusers() {
  return &presentusers_;
}

// optional uint32 index = 2;
inline bool PresentUserListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentUserListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentUserListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentUserListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 PresentUserListRes::index() const {
  return index_;
}
inline void PresentUserListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 3;
inline bool PresentUserListRes::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PresentUserListRes::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PresentUserListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PresentUserListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 PresentUserListRes::total() const {
  return total_;
}
inline void PresentUserListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint64 gid = 4;
inline bool PresentUserListRes::has_gid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PresentUserListRes::set_has_gid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PresentUserListRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PresentUserListRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 PresentUserListRes::gid() const {
  return gid_;
}
inline void PresentUserListRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 presentId = 5;
inline bool PresentUserListRes::has_presentid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PresentUserListRes::set_has_presentid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PresentUserListRes::clear_has_presentid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PresentUserListRes::clear_presentid() {
  presentid_ = 0u;
  clear_has_presentid();
}
inline ::google::protobuf::uint32 PresentUserListRes::presentid() const {
  return presentid_;
}
inline void PresentUserListRes::set_presentid(::google::protobuf::uint32 value) {
  set_has_presentid();
  presentid_ = value;
}

// -------------------------------------------------------------------

// PresentUser

// optional .pp.GroupMember member = 1;
inline bool PresentUser::has_member() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PresentUser::set_has_member() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PresentUser::clear_has_member() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PresentUser::clear_member() {
  if (member_ != NULL) member_->::pp::GroupMember::Clear();
  clear_has_member();
}
inline const ::pp::GroupMember& PresentUser::member() const {
  return member_ != NULL ? *member_ : *default_instance_->member_;
}
inline ::pp::GroupMember* PresentUser::mutable_member() {
  set_has_member();
  if (member_ == NULL) member_ = new ::pp::GroupMember;
  return member_;
}
inline ::pp::GroupMember* PresentUser::release_member() {
  clear_has_member();
  ::pp::GroupMember* temp = member_;
  member_ = NULL;
  return temp;
}
inline void PresentUser::set_allocated_member(::pp::GroupMember* member) {
  delete member_;
  member_ = member;
  if (member) {
    set_has_member();
  } else {
    clear_has_member();
  }
}

// optional int64 createTime = 2;
inline bool PresentUser::has_createtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PresentUser::set_has_createtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PresentUser::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PresentUser::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 PresentUser::createtime() const {
  return createtime_;
}
inline void PresentUser::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// -------------------------------------------------------------------

// MsgPush

// required .pp.MsgPushType pushtype = 1;
inline bool MsgPush::has_pushtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgPush::set_has_pushtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgPush::clear_has_pushtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgPush::clear_pushtype() {
  pushtype_ = 1;
  clear_has_pushtype();
}
inline ::pp::MsgPushType MsgPush::pushtype() const {
  return static_cast< ::pp::MsgPushType >(pushtype_);
}
inline void MsgPush::set_pushtype(::pp::MsgPushType value) {
  assert(::pp::MsgPushType_IsValid(value));
  set_has_pushtype();
  pushtype_ = value;
}

// required uint64 revision = 2;
inline bool MsgPush::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgPush::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgPush::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgPush::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 MsgPush::revision() const {
  return revision_;
}
inline void MsgPush::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 gid = 3;
inline bool MsgPush::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgPush::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgPush::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgPush::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 MsgPush::gid() const {
  return gid_;
}
inline void MsgPush::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 parentgid = 4;
inline bool MsgPush::has_parentgid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgPush::set_has_parentgid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgPush::clear_has_parentgid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgPush::clear_parentgid() {
  parentgid_ = GOOGLE_ULONGLONG(0);
  clear_has_parentgid();
}
inline ::google::protobuf::uint64 MsgPush::parentgid() const {
  return parentgid_;
}
inline void MsgPush::set_parentgid(::google::protobuf::uint64 value) {
  set_has_parentgid();
  parentgid_ = value;
}

// optional uint64 uid = 5;
inline bool MsgPush::has_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MsgPush::set_has_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MsgPush::clear_has_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MsgPush::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 MsgPush::uid() const {
  return uid_;
}
inline void MsgPush::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 peeruid = 6;
inline bool MsgPush::has_peeruid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MsgPush::set_has_peeruid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MsgPush::clear_has_peeruid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MsgPush::clear_peeruid() {
  peeruid_ = GOOGLE_ULONGLONG(0);
  clear_has_peeruid();
}
inline ::google::protobuf::uint64 MsgPush::peeruid() const {
  return peeruid_;
}
inline void MsgPush::set_peeruid(::google::protobuf::uint64 value) {
  set_has_peeruid();
  peeruid_ = value;
}

// -------------------------------------------------------------------

// ForceLogoutPush

// repeated string whitemac = 1;
inline int ForceLogoutPush::whitemac_size() const {
  return whitemac_.size();
}
inline void ForceLogoutPush::clear_whitemac() {
  whitemac_.Clear();
}
inline const ::std::string& ForceLogoutPush::whitemac(int index) const {
  return whitemac_.Get(index);
}
inline ::std::string* ForceLogoutPush::mutable_whitemac(int index) {
  return whitemac_.Mutable(index);
}
inline void ForceLogoutPush::set_whitemac(int index, const ::std::string& value) {
  whitemac_.Mutable(index)->assign(value);
}
inline void ForceLogoutPush::set_whitemac(int index, const char* value) {
  whitemac_.Mutable(index)->assign(value);
}
inline void ForceLogoutPush::set_whitemac(int index, const char* value, size_t size) {
  whitemac_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForceLogoutPush::add_whitemac() {
  return whitemac_.Add();
}
inline void ForceLogoutPush::add_whitemac(const ::std::string& value) {
  whitemac_.Add()->assign(value);
}
inline void ForceLogoutPush::add_whitemac(const char* value) {
  whitemac_.Add()->assign(value);
}
inline void ForceLogoutPush::add_whitemac(const char* value, size_t size) {
  whitemac_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ForceLogoutPush::whitemac() const {
  return whitemac_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ForceLogoutPush::mutable_whitemac() {
  return &whitemac_;
}

// repeated string blackmac = 2;
inline int ForceLogoutPush::blackmac_size() const {
  return blackmac_.size();
}
inline void ForceLogoutPush::clear_blackmac() {
  blackmac_.Clear();
}
inline const ::std::string& ForceLogoutPush::blackmac(int index) const {
  return blackmac_.Get(index);
}
inline ::std::string* ForceLogoutPush::mutable_blackmac(int index) {
  return blackmac_.Mutable(index);
}
inline void ForceLogoutPush::set_blackmac(int index, const ::std::string& value) {
  blackmac_.Mutable(index)->assign(value);
}
inline void ForceLogoutPush::set_blackmac(int index, const char* value) {
  blackmac_.Mutable(index)->assign(value);
}
inline void ForceLogoutPush::set_blackmac(int index, const char* value, size_t size) {
  blackmac_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForceLogoutPush::add_blackmac() {
  return blackmac_.Add();
}
inline void ForceLogoutPush::add_blackmac(const ::std::string& value) {
  blackmac_.Add()->assign(value);
}
inline void ForceLogoutPush::add_blackmac(const char* value) {
  blackmac_.Add()->assign(value);
}
inline void ForceLogoutPush::add_blackmac(const char* value, size_t size) {
  blackmac_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ForceLogoutPush::blackmac() const {
  return blackmac_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ForceLogoutPush::mutable_blackmac() {
  return &blackmac_;
}

// optional string reason = 3;
inline bool ForceLogoutPush::has_reason() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ForceLogoutPush::set_has_reason() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ForceLogoutPush::clear_has_reason() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ForceLogoutPush::clear_reason() {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    reason_->clear();
  }
  clear_has_reason();
}
inline const ::std::string& ForceLogoutPush::reason() const {
  return *reason_;
}
inline void ForceLogoutPush::set_reason(const ::std::string& value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ForceLogoutPush::set_reason(const char* value) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(value);
}
inline void ForceLogoutPush::set_reason(const char* value, size_t size) {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  reason_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ForceLogoutPush::mutable_reason() {
  set_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    reason_ = new ::std::string;
  }
  return reason_;
}
inline ::std::string* ForceLogoutPush::release_reason() {
  clear_has_reason();
  if (reason_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = reason_;
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ForceLogoutPush::set_allocated_reason(::std::string* reason) {
  if (reason_ != &::google::protobuf::internal::kEmptyString) {
    delete reason_;
  }
  if (reason) {
    set_has_reason();
    reason_ = reason;
  } else {
    clear_has_reason();
    reason_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RedPacketInfo

// optional uint32 id = 1;
inline bool RedPacketInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RedPacketInfo::id() const {
  return id_;
}
inline void RedPacketInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional .pp.UserInfo user = 2;
inline bool RedPacketInfo::has_user() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketInfo::set_has_user() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketInfo::clear_user() {
  if (user_ != NULL) user_->::pp::UserInfo::Clear();
  clear_has_user();
}
inline const ::pp::UserInfo& RedPacketInfo::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::pp::UserInfo* RedPacketInfo::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::pp::UserInfo;
  return user_;
}
inline ::pp::UserInfo* RedPacketInfo::release_user() {
  clear_has_user();
  ::pp::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void RedPacketInfo::set_allocated_user(::pp::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional uint64 gid = 3;
inline bool RedPacketInfo::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedPacketInfo::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedPacketInfo::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedPacketInfo::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 RedPacketInfo::gid() const {
  return gid_;
}
inline void RedPacketInfo::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 coins = 4;
inline bool RedPacketInfo::has_coins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedPacketInfo::set_has_coins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedPacketInfo::clear_has_coins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedPacketInfo::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 RedPacketInfo::coins() const {
  return coins_;
}
inline void RedPacketInfo::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint32 num = 5;
inline bool RedPacketInfo::has_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RedPacketInfo::set_has_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RedPacketInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RedPacketInfo::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 RedPacketInfo::num() const {
  return num_;
}
inline void RedPacketInfo::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 itemtype = 6;
inline bool RedPacketInfo::has_itemtype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RedPacketInfo::set_has_itemtype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RedPacketInfo::clear_has_itemtype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RedPacketInfo::clear_itemtype() {
  itemtype_ = 0u;
  clear_has_itemtype();
}
inline ::google::protobuf::uint32 RedPacketInfo::itemtype() const {
  return itemtype_;
}
inline void RedPacketInfo::set_itemtype(::google::protobuf::uint32 value) {
  set_has_itemtype();
  itemtype_ = value;
}

// optional uint32 leftnum = 7;
inline bool RedPacketInfo::has_leftnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RedPacketInfo::set_has_leftnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RedPacketInfo::clear_has_leftnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RedPacketInfo::clear_leftnum() {
  leftnum_ = 0u;
  clear_has_leftnum();
}
inline ::google::protobuf::uint32 RedPacketInfo::leftnum() const {
  return leftnum_;
}
inline void RedPacketInfo::set_leftnum(::google::protobuf::uint32 value) {
  set_has_leftnum();
  leftnum_ = value;
}

// optional uint64 leftcoins = 8;
inline bool RedPacketInfo::has_leftcoins() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RedPacketInfo::set_has_leftcoins() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RedPacketInfo::clear_has_leftcoins() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RedPacketInfo::clear_leftcoins() {
  leftcoins_ = GOOGLE_ULONGLONG(0);
  clear_has_leftcoins();
}
inline ::google::protobuf::uint64 RedPacketInfo::leftcoins() const {
  return leftcoins_;
}
inline void RedPacketInfo::set_leftcoins(::google::protobuf::uint64 value) {
  set_has_leftcoins();
  leftcoins_ = value;
}

// optional int64 createtime = 9;
inline bool RedPacketInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void RedPacketInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void RedPacketInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void RedPacketInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 RedPacketInfo::createtime() const {
  return createtime_;
}
inline void RedPacketInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// -------------------------------------------------------------------

// RedPacketBlessInfo

// optional uint32 id = 1;
inline bool RedPacketBlessInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketBlessInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketBlessInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketBlessInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 RedPacketBlessInfo::id() const {
  return id_;
}
inline void RedPacketBlessInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string icon = 2;
inline bool RedPacketBlessInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketBlessInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketBlessInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketBlessInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& RedPacketBlessInfo::icon() const {
  return *icon_;
}
inline void RedPacketBlessInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void RedPacketBlessInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void RedPacketBlessInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedPacketBlessInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* RedPacketBlessInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RedPacketBlessInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool RedPacketBlessInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedPacketBlessInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedPacketBlessInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedPacketBlessInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RedPacketBlessInfo::name() const {
  return *name_;
}
inline void RedPacketBlessInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RedPacketBlessInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RedPacketBlessInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RedPacketBlessInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RedPacketBlessInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RedPacketBlessInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 num = 4;
inline bool RedPacketBlessInfo::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedPacketBlessInfo::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedPacketBlessInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedPacketBlessInfo::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 RedPacketBlessInfo::num() const {
  return num_;
}
inline void RedPacketBlessInfo::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint64 leftnum = 6;
inline bool RedPacketBlessInfo::has_leftnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RedPacketBlessInfo::set_has_leftnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RedPacketBlessInfo::clear_has_leftnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RedPacketBlessInfo::clear_leftnum() {
  leftnum_ = GOOGLE_ULONGLONG(0);
  clear_has_leftnum();
}
inline ::google::protobuf::uint64 RedPacketBlessInfo::leftnum() const {
  return leftnum_;
}
inline void RedPacketBlessInfo::set_leftnum(::google::protobuf::uint64 value) {
  set_has_leftnum();
  leftnum_ = value;
}

// optional uint32 rate = 7;
inline bool RedPacketBlessInfo::has_rate() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RedPacketBlessInfo::set_has_rate() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RedPacketBlessInfo::clear_has_rate() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RedPacketBlessInfo::clear_rate() {
  rate_ = 0u;
  clear_has_rate();
}
inline ::google::protobuf::uint32 RedPacketBlessInfo::rate() const {
  return rate_;
}
inline void RedPacketBlessInfo::set_rate(::google::protobuf::uint32 value) {
  set_has_rate();
  rate_ = value;
}

// -------------------------------------------------------------------

// RedPacketAddReq

// optional bool disablenotice = 1 [default = false];
inline bool RedPacketAddReq::has_disablenotice() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketAddReq::set_has_disablenotice() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketAddReq::clear_has_disablenotice() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketAddReq::clear_disablenotice() {
  disablenotice_ = false;
  clear_has_disablenotice();
}
inline bool RedPacketAddReq::disablenotice() const {
  return disablenotice_;
}
inline void RedPacketAddReq::set_disablenotice(bool value) {
  set_has_disablenotice();
  disablenotice_ = value;
}

// optional .pp.RedPacketInfo item = 2;
inline bool RedPacketAddReq::has_item() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketAddReq::set_has_item() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketAddReq::clear_has_item() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketAddReq::clear_item() {
  if (item_ != NULL) item_->::pp::RedPacketInfo::Clear();
  clear_has_item();
}
inline const ::pp::RedPacketInfo& RedPacketAddReq::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::pp::RedPacketInfo* RedPacketAddReq::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::pp::RedPacketInfo;
  return item_;
}
inline ::pp::RedPacketInfo* RedPacketAddReq::release_item() {
  clear_has_item();
  ::pp::RedPacketInfo* temp = item_;
  item_ = NULL;
  return temp;
}
inline void RedPacketAddReq::set_allocated_item(::pp::RedPacketInfo* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// RedPacketTakeReq

// optional uint64 gid = 1;
inline bool RedPacketTakeReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketTakeReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketTakeReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketTakeReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 RedPacketTakeReq::gid() const {
  return gid_;
}
inline void RedPacketTakeReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 itemId = 2;
inline bool RedPacketTakeReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketTakeReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketTakeReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketTakeReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 RedPacketTakeReq::itemid() const {
  return itemid_;
}
inline void RedPacketTakeReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// -------------------------------------------------------------------

// RedPacketTakeRes

// optional .pp.UserInfo user = 1;
inline bool RedPacketTakeRes::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketTakeRes::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketTakeRes::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketTakeRes::clear_user() {
  if (user_ != NULL) user_->::pp::UserInfo::Clear();
  clear_has_user();
}
inline const ::pp::UserInfo& RedPacketTakeRes::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::pp::UserInfo* RedPacketTakeRes::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::pp::UserInfo;
  return user_;
}
inline ::pp::UserInfo* RedPacketTakeRes::release_user() {
  clear_has_user();
  ::pp::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void RedPacketTakeRes::set_allocated_user(::pp::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional uint64 coins = 2;
inline bool RedPacketTakeRes::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketTakeRes::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketTakeRes::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketTakeRes::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 RedPacketTakeRes::coins() const {
  return coins_;
}
inline void RedPacketTakeRes::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional .pp.RedPacketBlessInfo bless = 3;
inline bool RedPacketTakeRes::has_bless() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedPacketTakeRes::set_has_bless() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedPacketTakeRes::clear_has_bless() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedPacketTakeRes::clear_bless() {
  if (bless_ != NULL) bless_->::pp::RedPacketBlessInfo::Clear();
  clear_has_bless();
}
inline const ::pp::RedPacketBlessInfo& RedPacketTakeRes::bless() const {
  return bless_ != NULL ? *bless_ : *default_instance_->bless_;
}
inline ::pp::RedPacketBlessInfo* RedPacketTakeRes::mutable_bless() {
  set_has_bless();
  if (bless_ == NULL) bless_ = new ::pp::RedPacketBlessInfo;
  return bless_;
}
inline ::pp::RedPacketBlessInfo* RedPacketTakeRes::release_bless() {
  clear_has_bless();
  ::pp::RedPacketBlessInfo* temp = bless_;
  bless_ = NULL;
  return temp;
}
inline void RedPacketTakeRes::set_allocated_bless(::pp::RedPacketBlessInfo* bless) {
  delete bless_;
  bless_ = bless;
  if (bless) {
    set_has_bless();
  } else {
    clear_has_bless();
  }
}

// -------------------------------------------------------------------

// ShowRedPacketListReq

// optional uint64 gid = 1;
inline bool ShowRedPacketListReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShowRedPacketListReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShowRedPacketListReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShowRedPacketListReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ShowRedPacketListReq::gid() const {
  return gid_;
}
inline void ShowRedPacketListReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 index = 2;
inline bool ShowRedPacketListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShowRedPacketListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShowRedPacketListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShowRedPacketListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ShowRedPacketListReq::index() const {
  return index_;
}
inline void ShowRedPacketListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool ShowRedPacketListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShowRedPacketListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShowRedPacketListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShowRedPacketListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 ShowRedPacketListReq::fetchs() const {
  return fetchs_;
}
inline void ShowRedPacketListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional bool empty = 4;
inline bool ShowRedPacketListReq::has_empty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShowRedPacketListReq::set_has_empty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShowRedPacketListReq::clear_has_empty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShowRedPacketListReq::clear_empty() {
  empty_ = false;
  clear_has_empty();
}
inline bool ShowRedPacketListReq::empty() const {
  return empty_;
}
inline void ShowRedPacketListReq::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// -------------------------------------------------------------------

// ShowRedPacketListRes

// optional uint64 gid = 1;
inline bool ShowRedPacketListRes::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShowRedPacketListRes::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShowRedPacketListRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShowRedPacketListRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ShowRedPacketListRes::gid() const {
  return gid_;
}
inline void ShowRedPacketListRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 index = 2;
inline bool ShowRedPacketListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShowRedPacketListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShowRedPacketListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShowRedPacketListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ShowRedPacketListRes::index() const {
  return index_;
}
inline void ShowRedPacketListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool ShowRedPacketListRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShowRedPacketListRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShowRedPacketListRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShowRedPacketListRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 ShowRedPacketListRes::fetchs() const {
  return fetchs_;
}
inline void ShowRedPacketListRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional bool empty = 4;
inline bool ShowRedPacketListRes::has_empty() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ShowRedPacketListRes::set_has_empty() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ShowRedPacketListRes::clear_has_empty() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ShowRedPacketListRes::clear_empty() {
  empty_ = false;
  clear_has_empty();
}
inline bool ShowRedPacketListRes::empty() const {
  return empty_;
}
inline void ShowRedPacketListRes::set_empty(bool value) {
  set_has_empty();
  empty_ = value;
}

// optional uint32 totalredpacket = 5;
inline bool ShowRedPacketListRes::has_totalredpacket() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ShowRedPacketListRes::set_has_totalredpacket() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ShowRedPacketListRes::clear_has_totalredpacket() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ShowRedPacketListRes::clear_totalredpacket() {
  totalredpacket_ = 0u;
  clear_has_totalredpacket();
}
inline ::google::protobuf::uint32 ShowRedPacketListRes::totalredpacket() const {
  return totalredpacket_;
}
inline void ShowRedPacketListRes::set_totalredpacket(::google::protobuf::uint32 value) {
  set_has_totalredpacket();
  totalredpacket_ = value;
}

// repeated .pp.RedPacketInfo items = 6;
inline int ShowRedPacketListRes::items_size() const {
  return items_.size();
}
inline void ShowRedPacketListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::RedPacketInfo& ShowRedPacketListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::RedPacketInfo* ShowRedPacketListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::RedPacketInfo* ShowRedPacketListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::RedPacketInfo >&
ShowRedPacketListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::RedPacketInfo >*
ShowRedPacketListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// UserRedPacketStatReq

// optional bool detail = 1 [default = true];
inline bool UserRedPacketStatReq::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRedPacketStatReq::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRedPacketStatReq::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRedPacketStatReq::clear_detail() {
  detail_ = true;
  clear_has_detail();
}
inline bool UserRedPacketStatReq::detail() const {
  return detail_;
}
inline void UserRedPacketStatReq::set_detail(bool value) {
  set_has_detail();
  detail_ = value;
}

// -------------------------------------------------------------------

// UserRedPacketStatRes

// optional bool detail = 1 [default = true];
inline bool UserRedPacketStatRes::has_detail() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRedPacketStatRes::set_has_detail() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRedPacketStatRes::clear_has_detail() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRedPacketStatRes::clear_detail() {
  detail_ = true;
  clear_has_detail();
}
inline bool UserRedPacketStatRes::detail() const {
  return detail_;
}
inline void UserRedPacketStatRes::set_detail(bool value) {
  set_has_detail();
  detail_ = value;
}

// optional uint32 sendNum = 11;
inline bool UserRedPacketStatRes::has_sendnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRedPacketStatRes::set_has_sendnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRedPacketStatRes::clear_has_sendnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRedPacketStatRes::clear_sendnum() {
  sendnum_ = 0u;
  clear_has_sendnum();
}
inline ::google::protobuf::uint32 UserRedPacketStatRes::sendnum() const {
  return sendnum_;
}
inline void UserRedPacketStatRes::set_sendnum(::google::protobuf::uint32 value) {
  set_has_sendnum();
  sendnum_ = value;
}

// optional uint64 sendSum = 12;
inline bool UserRedPacketStatRes::has_sendsum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRedPacketStatRes::set_has_sendsum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRedPacketStatRes::clear_has_sendsum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRedPacketStatRes::clear_sendsum() {
  sendsum_ = GOOGLE_ULONGLONG(0);
  clear_has_sendsum();
}
inline ::google::protobuf::uint64 UserRedPacketStatRes::sendsum() const {
  return sendsum_;
}
inline void UserRedPacketStatRes::set_sendsum(::google::protobuf::uint64 value) {
  set_has_sendsum();
  sendsum_ = value;
}

// optional uint32 recvNum = 13;
inline bool UserRedPacketStatRes::has_recvnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRedPacketStatRes::set_has_recvnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRedPacketStatRes::clear_has_recvnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRedPacketStatRes::clear_recvnum() {
  recvnum_ = 0u;
  clear_has_recvnum();
}
inline ::google::protobuf::uint32 UserRedPacketStatRes::recvnum() const {
  return recvnum_;
}
inline void UserRedPacketStatRes::set_recvnum(::google::protobuf::uint32 value) {
  set_has_recvnum();
  recvnum_ = value;
}

// optional uint64 recvSum = 14;
inline bool UserRedPacketStatRes::has_recvsum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserRedPacketStatRes::set_has_recvsum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserRedPacketStatRes::clear_has_recvsum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserRedPacketStatRes::clear_recvsum() {
  recvsum_ = GOOGLE_ULONGLONG(0);
  clear_has_recvsum();
}
inline ::google::protobuf::uint64 UserRedPacketStatRes::recvsum() const {
  return recvsum_;
}
inline void UserRedPacketStatRes::set_recvsum(::google::protobuf::uint64 value) {
  set_has_recvsum();
  recvsum_ = value;
}

// repeated .pp.RedPacketBlessInfo blessList = 15;
inline int UserRedPacketStatRes::blesslist_size() const {
  return blesslist_.size();
}
inline void UserRedPacketStatRes::clear_blesslist() {
  blesslist_.Clear();
}
inline const ::pp::RedPacketBlessInfo& UserRedPacketStatRes::blesslist(int index) const {
  return blesslist_.Get(index);
}
inline ::pp::RedPacketBlessInfo* UserRedPacketStatRes::mutable_blesslist(int index) {
  return blesslist_.Mutable(index);
}
inline ::pp::RedPacketBlessInfo* UserRedPacketStatRes::add_blesslist() {
  return blesslist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::RedPacketBlessInfo >&
UserRedPacketStatRes::blesslist() const {
  return blesslist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::RedPacketBlessInfo >*
UserRedPacketStatRes::mutable_blesslist() {
  return &blesslist_;
}

// -------------------------------------------------------------------

// RedPacketRecord

// optional .pp.UserInfo user = 1;
inline bool RedPacketRecord::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketRecord::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketRecord::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketRecord::clear_user() {
  if (user_ != NULL) user_->::pp::UserInfo::Clear();
  clear_has_user();
}
inline const ::pp::UserInfo& RedPacketRecord::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::pp::UserInfo* RedPacketRecord::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::pp::UserInfo;
  return user_;
}
inline ::pp::UserInfo* RedPacketRecord::release_user() {
  clear_has_user();
  ::pp::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void RedPacketRecord::set_allocated_user(::pp::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional uint64 totalCoin = 2;
inline bool RedPacketRecord::has_totalcoin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketRecord::set_has_totalcoin() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketRecord::clear_has_totalcoin() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketRecord::clear_totalcoin() {
  totalcoin_ = GOOGLE_ULONGLONG(0);
  clear_has_totalcoin();
}
inline ::google::protobuf::uint64 RedPacketRecord::totalcoin() const {
  return totalcoin_;
}
inline void RedPacketRecord::set_totalcoin(::google::protobuf::uint64 value) {
  set_has_totalcoin();
  totalcoin_ = value;
}

// optional uint32 totalNum = 3;
inline bool RedPacketRecord::has_totalnum() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedPacketRecord::set_has_totalnum() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedPacketRecord::clear_has_totalnum() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedPacketRecord::clear_totalnum() {
  totalnum_ = 0u;
  clear_has_totalnum();
}
inline ::google::protobuf::uint32 RedPacketRecord::totalnum() const {
  return totalnum_;
}
inline void RedPacketRecord::set_totalnum(::google::protobuf::uint32 value) {
  set_has_totalnum();
  totalnum_ = value;
}

// -------------------------------------------------------------------

// RedPacketRankListReq

// optional bool sponsor = 1;
inline bool RedPacketRankListReq::has_sponsor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketRankListReq::set_has_sponsor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketRankListReq::clear_has_sponsor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketRankListReq::clear_sponsor() {
  sponsor_ = false;
  clear_has_sponsor();
}
inline bool RedPacketRankListReq::sponsor() const {
  return sponsor_;
}
inline void RedPacketRankListReq::set_sponsor(bool value) {
  set_has_sponsor();
  sponsor_ = value;
}

// optional uint32 index = 2;
inline bool RedPacketRankListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketRankListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketRankListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketRankListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 RedPacketRankListReq::index() const {
  return index_;
}
inline void RedPacketRankListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool RedPacketRankListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedPacketRankListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedPacketRankListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedPacketRankListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 RedPacketRankListReq::fetchs() const {
  return fetchs_;
}
inline void RedPacketRankListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// RedPacketRankListRes

// optional bool sponsor = 1;
inline bool RedPacketRankListRes::has_sponsor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RedPacketRankListRes::set_has_sponsor() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RedPacketRankListRes::clear_has_sponsor() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RedPacketRankListRes::clear_sponsor() {
  sponsor_ = false;
  clear_has_sponsor();
}
inline bool RedPacketRankListRes::sponsor() const {
  return sponsor_;
}
inline void RedPacketRankListRes::set_sponsor(bool value) {
  set_has_sponsor();
  sponsor_ = value;
}

// optional uint32 index = 2;
inline bool RedPacketRankListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RedPacketRankListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RedPacketRankListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RedPacketRankListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 RedPacketRankListRes::index() const {
  return index_;
}
inline void RedPacketRankListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool RedPacketRankListRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RedPacketRankListRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RedPacketRankListRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RedPacketRankListRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 RedPacketRankListRes::fetchs() const {
  return fetchs_;
}
inline void RedPacketRankListRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 totalresults = 4;
inline bool RedPacketRankListRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RedPacketRankListRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RedPacketRankListRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RedPacketRankListRes::clear_totalresults() {
  totalresults_ = 0u;
  clear_has_totalresults();
}
inline ::google::protobuf::uint32 RedPacketRankListRes::totalresults() const {
  return totalresults_;
}
inline void RedPacketRankListRes::set_totalresults(::google::protobuf::uint32 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// repeated .pp.RedPacketRecord records = 5;
inline int RedPacketRankListRes::records_size() const {
  return records_.size();
}
inline void RedPacketRankListRes::clear_records() {
  records_.Clear();
}
inline const ::pp::RedPacketRecord& RedPacketRankListRes::records(int index) const {
  return records_.Get(index);
}
inline ::pp::RedPacketRecord* RedPacketRankListRes::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::pp::RedPacketRecord* RedPacketRankListRes::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::RedPacketRecord >&
RedPacketRankListRes::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::RedPacketRecord >*
RedPacketRankListRes::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// BlessGiftInfo

// optional uint32 id = 1;
inline bool BlessGiftInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlessGiftInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlessGiftInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlessGiftInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 BlessGiftInfo::id() const {
  return id_;
}
inline void BlessGiftInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string icon = 2;
inline bool BlessGiftInfo::has_icon() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BlessGiftInfo::set_has_icon() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BlessGiftInfo::clear_has_icon() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BlessGiftInfo::clear_icon() {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    icon_->clear();
  }
  clear_has_icon();
}
inline const ::std::string& BlessGiftInfo::icon() const {
  return *icon_;
}
inline void BlessGiftInfo::set_icon(const ::std::string& value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void BlessGiftInfo::set_icon(const char* value) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(value);
}
inline void BlessGiftInfo::set_icon(const char* value, size_t size) {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  icon_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlessGiftInfo::mutable_icon() {
  set_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    icon_ = new ::std::string;
  }
  return icon_;
}
inline ::std::string* BlessGiftInfo::release_icon() {
  clear_has_icon();
  if (icon_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = icon_;
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlessGiftInfo::set_allocated_icon(::std::string* icon) {
  if (icon_ != &::google::protobuf::internal::kEmptyString) {
    delete icon_;
  }
  if (icon) {
    set_has_icon();
    icon_ = icon;
  } else {
    clear_has_icon();
    icon_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 3;
inline bool BlessGiftInfo::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BlessGiftInfo::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BlessGiftInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BlessGiftInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& BlessGiftInfo::name() const {
  return *name_;
}
inline void BlessGiftInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BlessGiftInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void BlessGiftInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlessGiftInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* BlessGiftInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlessGiftInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 coins = 4;
inline bool BlessGiftInfo::has_coins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BlessGiftInfo::set_has_coins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BlessGiftInfo::clear_has_coins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BlessGiftInfo::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 BlessGiftInfo::coins() const {
  return coins_;
}
inline void BlessGiftInfo::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint32 leftnum = 5;
inline bool BlessGiftInfo::has_leftnum() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BlessGiftInfo::set_has_leftnum() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BlessGiftInfo::clear_has_leftnum() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BlessGiftInfo::clear_leftnum() {
  leftnum_ = 0u;
  clear_has_leftnum();
}
inline ::google::protobuf::uint32 BlessGiftInfo::leftnum() const {
  return leftnum_;
}
inline void BlessGiftInfo::set_leftnum(::google::protobuf::uint32 value) {
  set_has_leftnum();
  leftnum_ = value;
}

// optional string condition = 6;
inline bool BlessGiftInfo::has_condition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void BlessGiftInfo::set_has_condition() {
  _has_bits_[0] |= 0x00000020u;
}
inline void BlessGiftInfo::clear_has_condition() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void BlessGiftInfo::clear_condition() {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    condition_->clear();
  }
  clear_has_condition();
}
inline const ::std::string& BlessGiftInfo::condition() const {
  return *condition_;
}
inline void BlessGiftInfo::set_condition(const ::std::string& value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void BlessGiftInfo::set_condition(const char* value) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(value);
}
inline void BlessGiftInfo::set_condition(const char* value, size_t size) {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  condition_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BlessGiftInfo::mutable_condition() {
  set_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    condition_ = new ::std::string;
  }
  return condition_;
}
inline ::std::string* BlessGiftInfo::release_condition() {
  clear_has_condition();
  if (condition_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = condition_;
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BlessGiftInfo::set_allocated_condition(::std::string* condition) {
  if (condition_ != &::google::protobuf::internal::kEmptyString) {
    delete condition_;
  }
  if (condition) {
    set_has_condition();
    condition_ = condition;
  } else {
    clear_has_condition();
    condition_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// BlessGiftListReq

// -------------------------------------------------------------------

// BlessGiftListRes

// repeated .pp.BlessGiftInfo items = 1;
inline int BlessGiftListRes::items_size() const {
  return items_.size();
}
inline void BlessGiftListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::BlessGiftInfo& BlessGiftListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::BlessGiftInfo* BlessGiftListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::BlessGiftInfo* BlessGiftListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::BlessGiftInfo >&
BlessGiftListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::BlessGiftInfo >*
BlessGiftListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// BlessGiftExchangeReq

// optional uint32 itemId = 1;
inline bool BlessGiftExchangeReq::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlessGiftExchangeReq::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlessGiftExchangeReq::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlessGiftExchangeReq::clear_itemid() {
  itemid_ = 0u;
  clear_has_itemid();
}
inline ::google::protobuf::uint32 BlessGiftExchangeReq::itemid() const {
  return itemid_;
}
inline void BlessGiftExchangeReq::set_itemid(::google::protobuf::uint32 value) {
  set_has_itemid();
  itemid_ = value;
}

// -------------------------------------------------------------------

// BlessGiftExchangeRes

// optional .pp.BlessGiftInfo item = 1;
inline bool BlessGiftExchangeRes::has_item() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BlessGiftExchangeRes::set_has_item() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BlessGiftExchangeRes::clear_has_item() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BlessGiftExchangeRes::clear_item() {
  if (item_ != NULL) item_->::pp::BlessGiftInfo::Clear();
  clear_has_item();
}
inline const ::pp::BlessGiftInfo& BlessGiftExchangeRes::item() const {
  return item_ != NULL ? *item_ : *default_instance_->item_;
}
inline ::pp::BlessGiftInfo* BlessGiftExchangeRes::mutable_item() {
  set_has_item();
  if (item_ == NULL) item_ = new ::pp::BlessGiftInfo;
  return item_;
}
inline ::pp::BlessGiftInfo* BlessGiftExchangeRes::release_item() {
  clear_has_item();
  ::pp::BlessGiftInfo* temp = item_;
  item_ = NULL;
  return temp;
}
inline void BlessGiftExchangeRes::set_allocated_item(::pp::BlessGiftInfo* item) {
  delete item_;
  item_ = item;
  if (item) {
    set_has_item();
  } else {
    clear_has_item();
  }
}

// -------------------------------------------------------------------

// ReportViolatorReq

// required .pp.ReportViolatorReq.ViolatorType type = 1;
inline bool ReportViolatorReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportViolatorReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportViolatorReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportViolatorReq::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pp::ReportViolatorReq_ViolatorType ReportViolatorReq::type() const {
  return static_cast< ::pp::ReportViolatorReq_ViolatorType >(type_);
}
inline void ReportViolatorReq::set_type(::pp::ReportViolatorReq_ViolatorType value) {
  assert(::pp::ReportViolatorReq_ViolatorType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required .pp.ReportViolatorReq.ViolatorReason reason = 2;
inline bool ReportViolatorReq::has_reason() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReportViolatorReq::set_has_reason() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReportViolatorReq::clear_has_reason() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReportViolatorReq::clear_reason() {
  reason_ = 1;
  clear_has_reason();
}
inline ::pp::ReportViolatorReq_ViolatorReason ReportViolatorReq::reason() const {
  return static_cast< ::pp::ReportViolatorReq_ViolatorReason >(reason_);
}
inline void ReportViolatorReq::set_reason(::pp::ReportViolatorReq_ViolatorReason value) {
  assert(::pp::ReportViolatorReq_ViolatorReason_IsValid(value));
  set_has_reason();
  reason_ = value;
}

// optional string remarks = 3;
inline bool ReportViolatorReq::has_remarks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReportViolatorReq::set_has_remarks() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReportViolatorReq::clear_has_remarks() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReportViolatorReq::clear_remarks() {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    remarks_->clear();
  }
  clear_has_remarks();
}
inline const ::std::string& ReportViolatorReq::remarks() const {
  return *remarks_;
}
inline void ReportViolatorReq::set_remarks(const ::std::string& value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void ReportViolatorReq::set_remarks(const char* value) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(value);
}
inline void ReportViolatorReq::set_remarks(const char* value, size_t size) {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  remarks_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportViolatorReq::mutable_remarks() {
  set_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    remarks_ = new ::std::string;
  }
  return remarks_;
}
inline ::std::string* ReportViolatorReq::release_remarks() {
  clear_has_remarks();
  if (remarks_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remarks_;
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReportViolatorReq::set_allocated_remarks(::std::string* remarks) {
  if (remarks_ != &::google::protobuf::internal::kEmptyString) {
    delete remarks_;
  }
  if (remarks) {
    set_has_remarks();
    remarks_ = remarks;
  } else {
    clear_has_remarks();
    remarks_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 4;
inline bool ReportViolatorReq::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReportViolatorReq::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReportViolatorReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReportViolatorReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ReportViolatorReq::uid() const {
  return uid_;
}
inline void ReportViolatorReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 gid = 5;
inline bool ReportViolatorReq::has_gid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ReportViolatorReq::set_has_gid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ReportViolatorReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ReportViolatorReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ReportViolatorReq::gid() const {
  return gid_;
}
inline void ReportViolatorReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// -------------------------------------------------------------------

// ReportLogReq

// optional string report = 1;
inline bool ReportLogReq::has_report() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReportLogReq::set_has_report() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReportLogReq::clear_has_report() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReportLogReq::clear_report() {
  if (report_ != &::google::protobuf::internal::kEmptyString) {
    report_->clear();
  }
  clear_has_report();
}
inline const ::std::string& ReportLogReq::report() const {
  return *report_;
}
inline void ReportLogReq::set_report(const ::std::string& value) {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  report_->assign(value);
}
inline void ReportLogReq::set_report(const char* value) {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  report_->assign(value);
}
inline void ReportLogReq::set_report(const char* value, size_t size) {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  report_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ReportLogReq::mutable_report() {
  set_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    report_ = new ::std::string;
  }
  return report_;
}
inline ::std::string* ReportLogReq::release_report() {
  clear_has_report();
  if (report_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = report_;
    report_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ReportLogReq::set_allocated_report(::std::string* report) {
  if (report_ != &::google::protobuf::internal::kEmptyString) {
    delete report_;
  }
  if (report) {
    set_has_report();
    report_ = report;
  } else {
    clear_has_report();
    report_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ProductInfo

// required uint32 Id = 1;
inline bool ProductInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductInfo::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ProductInfo::id() const {
  return id_;
}
inline void ProductInfo::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 2;
inline bool ProductInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ProductInfo::name() const {
  return *name_;
}
inline void ProductInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProductInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ProductInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ProductInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string image = 3;
inline bool ProductInfo::has_image() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductInfo::set_has_image() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductInfo::clear_image() {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    image_->clear();
  }
  clear_has_image();
}
inline const ::std::string& ProductInfo::image() const {
  return *image_;
}
inline void ProductInfo::set_image(const ::std::string& value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ProductInfo::set_image(const char* value) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(value);
}
inline void ProductInfo::set_image(const char* value, size_t size) {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  image_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProductInfo::mutable_image() {
  set_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    image_ = new ::std::string;
  }
  return image_;
}
inline ::std::string* ProductInfo::release_image() {
  clear_has_image();
  if (image_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = image_;
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProductInfo::set_allocated_image(::std::string* image) {
  if (image_ != &::google::protobuf::internal::kEmptyString) {
    delete image_;
  }
  if (image) {
    set_has_image();
    image_ = image;
  } else {
    clear_has_image();
    image_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 price = 4;
inline bool ProductInfo::has_price() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProductInfo::set_has_price() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProductInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProductInfo::clear_price() {
  price_ = 0u;
  clear_has_price();
}
inline ::google::protobuf::uint32 ProductInfo::price() const {
  return price_;
}
inline void ProductInfo::set_price(::google::protobuf::uint32 value) {
  set_has_price();
  price_ = value;
}

// optional uint32 num = 5;
inline bool ProductInfo::has_num() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProductInfo::set_has_num() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProductInfo::clear_has_num() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProductInfo::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ProductInfo::num() const {
  return num_;
}
inline void ProductInfo::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional sint64 createTime = 6;
inline bool ProductInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProductInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProductInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProductInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 ProductInfo::createtime() const {
  return createtime_;
}
inline void ProductInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 total = 7;
inline bool ProductInfo::has_total() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProductInfo::set_has_total() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProductInfo::clear_has_total() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProductInfo::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 ProductInfo::total() const {
  return total_;
}
inline void ProductInfo::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional bool available = 8 [default = true];
inline bool ProductInfo::has_available() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProductInfo::set_has_available() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProductInfo::clear_has_available() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProductInfo::clear_available() {
  available_ = true;
  clear_has_available();
}
inline bool ProductInfo::available() const {
  return available_;
}
inline void ProductInfo::set_available(bool value) {
  set_has_available();
  available_ = value;
}

// optional .pp.ProductInfo.Type type = 9;
inline bool ProductInfo::has_type() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProductInfo::set_has_type() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProductInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProductInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pp::ProductInfo_Type ProductInfo::type() const {
  return static_cast< ::pp::ProductInfo_Type >(type_);
}
inline void ProductInfo::set_type(::pp::ProductInfo_Type value) {
  assert(::pp::ProductInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional uint32 prob = 10;
inline bool ProductInfo::has_prob() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProductInfo::set_has_prob() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProductInfo::clear_has_prob() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProductInfo::clear_prob() {
  prob_ = 0u;
  clear_has_prob();
}
inline ::google::protobuf::uint32 ProductInfo::prob() const {
  return prob_;
}
inline void ProductInfo::set_prob(::google::protobuf::uint32 value) {
  set_has_prob();
  prob_ = value;
}

// -------------------------------------------------------------------

// ProductListReq

// required uint32 index = 1;
inline bool ProductListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ProductListReq::index() const {
  return index_;
}
inline void ProductListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool ProductListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 ProductListReq::fetchs() const {
  return fetchs_;
}
inline void ProductListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional bool backend = 3 [default = false];
inline bool ProductListReq::has_backend() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProductListReq::set_has_backend() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProductListReq::clear_has_backend() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProductListReq::clear_backend() {
  backend_ = false;
  clear_has_backend();
}
inline bool ProductListReq::backend() const {
  return backend_;
}
inline void ProductListReq::set_backend(bool value) {
  set_has_backend();
  backend_ = value;
}

// -------------------------------------------------------------------

// ProductListRes

// required uint32 index = 1;
inline bool ProductListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ProductListRes::index() const {
  return index_;
}
inline void ProductListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 total = 2;
inline bool ProductListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 ProductListRes::total() const {
  return total_;
}
inline void ProductListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.ProductInfo products = 3;
inline int ProductListRes::products_size() const {
  return products_.size();
}
inline void ProductListRes::clear_products() {
  products_.Clear();
}
inline const ::pp::ProductInfo& ProductListRes::products(int index) const {
  return products_.Get(index);
}
inline ::pp::ProductInfo* ProductListRes::mutable_products(int index) {
  return products_.Mutable(index);
}
inline ::pp::ProductInfo* ProductListRes::add_products() {
  return products_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ProductInfo >&
ProductListRes::products() const {
  return products_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ProductInfo >*
ProductListRes::mutable_products() {
  return &products_;
}

// -------------------------------------------------------------------

// ProductOpReq

// optional .pp.EntityOpType opType = 1;
inline bool ProductOpReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductOpReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductOpReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductOpReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::EntityOpType ProductOpReq::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void ProductOpReq::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional .pp.ProductInfo entity = 2;
inline bool ProductOpReq::has_entity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductOpReq::set_has_entity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductOpReq::clear_has_entity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductOpReq::clear_entity() {
  if (entity_ != NULL) entity_->::pp::ProductInfo::Clear();
  clear_has_entity();
}
inline const ::pp::ProductInfo& ProductOpReq::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::pp::ProductInfo* ProductOpReq::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::pp::ProductInfo;
  return entity_;
}
inline ::pp::ProductInfo* ProductOpReq::release_entity() {
  clear_has_entity();
  ::pp::ProductInfo* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void ProductOpReq::set_allocated_entity(::pp::ProductInfo* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// -------------------------------------------------------------------

// ProductBuyReq

// required uint32 productId = 1;
inline bool ProductBuyReq::has_productid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProductBuyReq::set_has_productid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProductBuyReq::clear_has_productid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProductBuyReq::clear_productid() {
  productid_ = 0u;
  clear_has_productid();
}
inline ::google::protobuf::uint32 ProductBuyReq::productid() const {
  return productid_;
}
inline void ProductBuyReq::set_productid(::google::protobuf::uint32 value) {
  set_has_productid();
  productid_ = value;
}

// optional uint32 num = 2 [default = 1];
inline bool ProductBuyReq::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProductBuyReq::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProductBuyReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProductBuyReq::clear_num() {
  num_ = 1u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ProductBuyReq::num() const {
  return num_;
}
inline void ProductBuyReq::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// UserTradeRecord

// optional uint64 itemId = 1;
inline bool UserTradeRecord::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTradeRecord::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTradeRecord::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTradeRecord::clear_itemid() {
  itemid_ = GOOGLE_ULONGLONG(0);
  clear_has_itemid();
}
inline ::google::protobuf::uint64 UserTradeRecord::itemid() const {
  return itemid_;
}
inline void UserTradeRecord::set_itemid(::google::protobuf::uint64 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 itemNum = 2;
inline bool UserTradeRecord::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTradeRecord::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTradeRecord::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTradeRecord::clear_itemnum() {
  itemnum_ = 0u;
  clear_has_itemnum();
}
inline ::google::protobuf::uint32 UserTradeRecord::itemnum() const {
  return itemnum_;
}
inline void UserTradeRecord::set_itemnum(::google::protobuf::uint32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional .pp.UserTradeRecord.Type type = 3;
inline bool UserTradeRecord::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTradeRecord::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTradeRecord::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTradeRecord::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pp::UserTradeRecord_Type UserTradeRecord::type() const {
  return static_cast< ::pp::UserTradeRecord_Type >(type_);
}
inline void UserTradeRecord::set_type(::pp::UserTradeRecord_Type value) {
  assert(::pp::UserTradeRecord_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional sint32 money = 4;
inline bool UserTradeRecord::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTradeRecord::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTradeRecord::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTradeRecord::clear_money() {
  money_ = 0;
  clear_has_money();
}
inline ::google::protobuf::int32 UserTradeRecord::money() const {
  return money_;
}
inline void UserTradeRecord::set_money(::google::protobuf::int32 value) {
  set_has_money();
  money_ = value;
}

// optional uint64 targetUid = 5;
inline bool UserTradeRecord::has_targetuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTradeRecord::set_has_targetuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTradeRecord::clear_has_targetuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTradeRecord::clear_targetuid() {
  targetuid_ = GOOGLE_ULONGLONG(0);
  clear_has_targetuid();
}
inline ::google::protobuf::uint64 UserTradeRecord::targetuid() const {
  return targetuid_;
}
inline void UserTradeRecord::set_targetuid(::google::protobuf::uint64 value) {
  set_has_targetuid();
  targetuid_ = value;
}

// optional sint64 createTime = 6;
inline bool UserTradeRecord::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserTradeRecord::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserTradeRecord::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserTradeRecord::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserTradeRecord::createtime() const {
  return createtime_;
}
inline void UserTradeRecord::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// -------------------------------------------------------------------

// UserWithdrawReq

// optional uint32 cash = 1;
inline bool UserWithdrawReq::has_cash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserWithdrawReq::set_has_cash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserWithdrawReq::clear_has_cash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserWithdrawReq::clear_cash() {
  cash_ = 0u;
  clear_has_cash();
}
inline ::google::protobuf::uint32 UserWithdrawReq::cash() const {
  return cash_;
}
inline void UserWithdrawReq::set_cash(::google::protobuf::uint32 value) {
  set_has_cash();
  cash_ = value;
}

// optional bool check = 2 [default = true];
inline bool UserWithdrawReq::has_check() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserWithdrawReq::set_has_check() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserWithdrawReq::clear_has_check() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserWithdrawReq::clear_check() {
  check_ = true;
  clear_has_check();
}
inline bool UserWithdrawReq::check() const {
  return check_;
}
inline void UserWithdrawReq::set_check(bool value) {
  set_has_check();
  check_ = value;
}

// -------------------------------------------------------------------

// UserMoneyStatReq

// -------------------------------------------------------------------

// UserMoneyStatRes

// optional uint32 sysWithdrawTimes = 1;
inline bool UserMoneyStatRes::has_syswithdrawtimes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMoneyStatRes::set_has_syswithdrawtimes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMoneyStatRes::clear_has_syswithdrawtimes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMoneyStatRes::clear_syswithdrawtimes() {
  syswithdrawtimes_ = 0u;
  clear_has_syswithdrawtimes();
}
inline ::google::protobuf::uint32 UserMoneyStatRes::syswithdrawtimes() const {
  return syswithdrawtimes_;
}
inline void UserMoneyStatRes::set_syswithdrawtimes(::google::protobuf::uint32 value) {
  set_has_syswithdrawtimes();
  syswithdrawtimes_ = value;
}

// optional uint32 totalMoney = 2;
inline bool UserMoneyStatRes::has_totalmoney() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMoneyStatRes::set_has_totalmoney() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMoneyStatRes::clear_has_totalmoney() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMoneyStatRes::clear_totalmoney() {
  totalmoney_ = 0u;
  clear_has_totalmoney();
}
inline ::google::protobuf::uint32 UserMoneyStatRes::totalmoney() const {
  return totalmoney_;
}
inline void UserMoneyStatRes::set_totalmoney(::google::protobuf::uint32 value) {
  set_has_totalmoney();
  totalmoney_ = value;
}

// optional uint32 lastMonthMoney = 3;
inline bool UserMoneyStatRes::has_lastmonthmoney() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMoneyStatRes::set_has_lastmonthmoney() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMoneyStatRes::clear_has_lastmonthmoney() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMoneyStatRes::clear_lastmonthmoney() {
  lastmonthmoney_ = 0u;
  clear_has_lastmonthmoney();
}
inline ::google::protobuf::uint32 UserMoneyStatRes::lastmonthmoney() const {
  return lastmonthmoney_;
}
inline void UserMoneyStatRes::set_lastmonthmoney(::google::protobuf::uint32 value) {
  set_has_lastmonthmoney();
  lastmonthmoney_ = value;
}

// optional uint32 thisMonthMoney = 4;
inline bool UserMoneyStatRes::has_thismonthmoney() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMoneyStatRes::set_has_thismonthmoney() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMoneyStatRes::clear_has_thismonthmoney() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMoneyStatRes::clear_thismonthmoney() {
  thismonthmoney_ = 0u;
  clear_has_thismonthmoney();
}
inline ::google::protobuf::uint32 UserMoneyStatRes::thismonthmoney() const {
  return thismonthmoney_;
}
inline void UserMoneyStatRes::set_thismonthmoney(::google::protobuf::uint32 value) {
  set_has_thismonthmoney();
  thismonthmoney_ = value;
}

// optional uint32 cashAvailable = 5;
inline bool UserMoneyStatRes::has_cashavailable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMoneyStatRes::set_has_cashavailable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMoneyStatRes::clear_has_cashavailable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMoneyStatRes::clear_cashavailable() {
  cashavailable_ = 0u;
  clear_has_cashavailable();
}
inline ::google::protobuf::uint32 UserMoneyStatRes::cashavailable() const {
  return cashavailable_;
}
inline void UserMoneyStatRes::set_cashavailable(::google::protobuf::uint32 value) {
  set_has_cashavailable();
  cashavailable_ = value;
}

// optional uint32 totalWithdraw = 6;
inline bool UserMoneyStatRes::has_totalwithdraw() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMoneyStatRes::set_has_totalwithdraw() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMoneyStatRes::clear_has_totalwithdraw() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMoneyStatRes::clear_totalwithdraw() {
  totalwithdraw_ = 0u;
  clear_has_totalwithdraw();
}
inline ::google::protobuf::uint32 UserMoneyStatRes::totalwithdraw() const {
  return totalwithdraw_;
}
inline void UserMoneyStatRes::set_totalwithdraw(::google::protobuf::uint32 value) {
  set_has_totalwithdraw();
  totalwithdraw_ = value;
}

// optional bool isbaby = 7;
inline bool UserMoneyStatRes::has_isbaby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserMoneyStatRes::set_has_isbaby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserMoneyStatRes::clear_has_isbaby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserMoneyStatRes::clear_isbaby() {
  isbaby_ = false;
  clear_has_isbaby();
}
inline bool UserMoneyStatRes::isbaby() const {
  return isbaby_;
}
inline void UserMoneyStatRes::set_isbaby(bool value) {
  set_has_isbaby();
  isbaby_ = value;
}

// -------------------------------------------------------------------

// UserBankInfo

// optional uint64 id = 2;
inline bool UserBankInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBankInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBankInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBankInfo::clear_id() {
  id_ = GOOGLE_ULONGLONG(0);
  clear_has_id();
}
inline ::google::protobuf::uint64 UserBankInfo::id() const {
  return id_;
}
inline void UserBankInfo::set_id(::google::protobuf::uint64 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool UserBankInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBankInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBankInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBankInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& UserBankInfo::name() const {
  return *name_;
}
inline void UserBankInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBankInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void UserBankInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* UserBankInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idcode = 4;
inline bool UserBankInfo::has_idcode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserBankInfo::set_has_idcode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserBankInfo::clear_has_idcode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserBankInfo::clear_idcode() {
  if (idcode_ != &::google::protobuf::internal::kEmptyString) {
    idcode_->clear();
  }
  clear_has_idcode();
}
inline const ::std::string& UserBankInfo::idcode() const {
  return *idcode_;
}
inline void UserBankInfo::set_idcode(const ::std::string& value) {
  set_has_idcode();
  if (idcode_ == &::google::protobuf::internal::kEmptyString) {
    idcode_ = new ::std::string;
  }
  idcode_->assign(value);
}
inline void UserBankInfo::set_idcode(const char* value) {
  set_has_idcode();
  if (idcode_ == &::google::protobuf::internal::kEmptyString) {
    idcode_ = new ::std::string;
  }
  idcode_->assign(value);
}
inline void UserBankInfo::set_idcode(const char* value, size_t size) {
  set_has_idcode();
  if (idcode_ == &::google::protobuf::internal::kEmptyString) {
    idcode_ = new ::std::string;
  }
  idcode_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_idcode() {
  set_has_idcode();
  if (idcode_ == &::google::protobuf::internal::kEmptyString) {
    idcode_ = new ::std::string;
  }
  return idcode_;
}
inline ::std::string* UserBankInfo::release_idcode() {
  clear_has_idcode();
  if (idcode_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idcode_;
    idcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_idcode(::std::string* idcode) {
  if (idcode_ != &::google::protobuf::internal::kEmptyString) {
    delete idcode_;
  }
  if (idcode) {
    set_has_idcode();
    idcode_ = idcode;
  } else {
    clear_has_idcode();
    idcode_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string sex = 5;
inline bool UserBankInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserBankInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserBankInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserBankInfo::clear_sex() {
  if (sex_ != &::google::protobuf::internal::kEmptyString) {
    sex_->clear();
  }
  clear_has_sex();
}
inline const ::std::string& UserBankInfo::sex() const {
  return *sex_;
}
inline void UserBankInfo::set_sex(const ::std::string& value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::kEmptyString) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
}
inline void UserBankInfo::set_sex(const char* value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::kEmptyString) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
}
inline void UserBankInfo::set_sex(const char* value, size_t size) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::kEmptyString) {
    sex_ = new ::std::string;
  }
  sex_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_sex() {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::kEmptyString) {
    sex_ = new ::std::string;
  }
  return sex_;
}
inline ::std::string* UserBankInfo::release_sex() {
  clear_has_sex();
  if (sex_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sex_;
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_sex(::std::string* sex) {
  if (sex_ != &::google::protobuf::internal::kEmptyString) {
    delete sex_;
  }
  if (sex) {
    set_has_sex();
    sex_ = sex;
  } else {
    clear_has_sex();
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string city = 6;
inline bool UserBankInfo::has_city() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserBankInfo::set_has_city() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserBankInfo::clear_has_city() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserBankInfo::clear_city() {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    city_->clear();
  }
  clear_has_city();
}
inline const ::std::string& UserBankInfo::city() const {
  return *city_;
}
inline void UserBankInfo::set_city(const ::std::string& value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void UserBankInfo::set_city(const char* value) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(value);
}
inline void UserBankInfo::set_city(const char* value, size_t size) {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  city_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_city() {
  set_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    city_ = new ::std::string;
  }
  return city_;
}
inline ::std::string* UserBankInfo::release_city() {
  clear_has_city();
  if (city_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = city_;
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_city(::std::string* city) {
  if (city_ != &::google::protobuf::internal::kEmptyString) {
    delete city_;
  }
  if (city) {
    set_has_city();
    city_ = city;
  } else {
    clear_has_city();
    city_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bankName = 7;
inline bool UserBankInfo::has_bankname() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserBankInfo::set_has_bankname() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserBankInfo::clear_has_bankname() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserBankInfo::clear_bankname() {
  if (bankname_ != &::google::protobuf::internal::kEmptyString) {
    bankname_->clear();
  }
  clear_has_bankname();
}
inline const ::std::string& UserBankInfo::bankname() const {
  return *bankname_;
}
inline void UserBankInfo::set_bankname(const ::std::string& value) {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::kEmptyString) {
    bankname_ = new ::std::string;
  }
  bankname_->assign(value);
}
inline void UserBankInfo::set_bankname(const char* value) {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::kEmptyString) {
    bankname_ = new ::std::string;
  }
  bankname_->assign(value);
}
inline void UserBankInfo::set_bankname(const char* value, size_t size) {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::kEmptyString) {
    bankname_ = new ::std::string;
  }
  bankname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_bankname() {
  set_has_bankname();
  if (bankname_ == &::google::protobuf::internal::kEmptyString) {
    bankname_ = new ::std::string;
  }
  return bankname_;
}
inline ::std::string* UserBankInfo::release_bankname() {
  clear_has_bankname();
  if (bankname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bankname_;
    bankname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_bankname(::std::string* bankname) {
  if (bankname_ != &::google::protobuf::internal::kEmptyString) {
    delete bankname_;
  }
  if (bankname) {
    set_has_bankname();
    bankname_ = bankname;
  } else {
    clear_has_bankname();
    bankname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string accountNo = 8;
inline bool UserBankInfo::has_accountno() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserBankInfo::set_has_accountno() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserBankInfo::clear_has_accountno() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserBankInfo::clear_accountno() {
  if (accountno_ != &::google::protobuf::internal::kEmptyString) {
    accountno_->clear();
  }
  clear_has_accountno();
}
inline const ::std::string& UserBankInfo::accountno() const {
  return *accountno_;
}
inline void UserBankInfo::set_accountno(const ::std::string& value) {
  set_has_accountno();
  if (accountno_ == &::google::protobuf::internal::kEmptyString) {
    accountno_ = new ::std::string;
  }
  accountno_->assign(value);
}
inline void UserBankInfo::set_accountno(const char* value) {
  set_has_accountno();
  if (accountno_ == &::google::protobuf::internal::kEmptyString) {
    accountno_ = new ::std::string;
  }
  accountno_->assign(value);
}
inline void UserBankInfo::set_accountno(const char* value, size_t size) {
  set_has_accountno();
  if (accountno_ == &::google::protobuf::internal::kEmptyString) {
    accountno_ = new ::std::string;
  }
  accountno_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_accountno() {
  set_has_accountno();
  if (accountno_ == &::google::protobuf::internal::kEmptyString) {
    accountno_ = new ::std::string;
  }
  return accountno_;
}
inline ::std::string* UserBankInfo::release_accountno() {
  clear_has_accountno();
  if (accountno_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = accountno_;
    accountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_accountno(::std::string* accountno) {
  if (accountno_ != &::google::protobuf::internal::kEmptyString) {
    delete accountno_;
  }
  if (accountno) {
    set_has_accountno();
    accountno_ = accountno;
  } else {
    clear_has_accountno();
    accountno_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string mobile = 9;
inline bool UserBankInfo::has_mobile() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserBankInfo::set_has_mobile() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserBankInfo::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserBankInfo::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& UserBankInfo::mobile() const {
  return *mobile_;
}
inline void UserBankInfo::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void UserBankInfo::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void UserBankInfo::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserBankInfo::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* UserBankInfo::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserBankInfo::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserBankInfoOpReq

// optional .pp.EntityOpType opType = 1;
inline bool UserBankInfoOpReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBankInfoOpReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBankInfoOpReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBankInfoOpReq::clear_optype() {
  optype_ = 0;
  clear_has_optype();
}
inline ::pp::EntityOpType UserBankInfoOpReq::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void UserBankInfoOpReq::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional .pp.UserBankInfo entity = 2;
inline bool UserBankInfoOpReq::has_entity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserBankInfoOpReq::set_has_entity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserBankInfoOpReq::clear_has_entity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserBankInfoOpReq::clear_entity() {
  if (entity_ != NULL) entity_->::pp::UserBankInfo::Clear();
  clear_has_entity();
}
inline const ::pp::UserBankInfo& UserBankInfoOpReq::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::pp::UserBankInfo* UserBankInfoOpReq::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::pp::UserBankInfo;
  return entity_;
}
inline ::pp::UserBankInfo* UserBankInfoOpReq::release_entity() {
  clear_has_entity();
  ::pp::UserBankInfo* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void UserBankInfoOpReq::set_allocated_entity(::pp::UserBankInfo* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// -------------------------------------------------------------------

// UserBankInfoOpRes

// optional .pp.UserBankInfo entity = 1;
inline bool UserBankInfoOpRes::has_entity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserBankInfoOpRes::set_has_entity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserBankInfoOpRes::clear_has_entity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserBankInfoOpRes::clear_entity() {
  if (entity_ != NULL) entity_->::pp::UserBankInfo::Clear();
  clear_has_entity();
}
inline const ::pp::UserBankInfo& UserBankInfoOpRes::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::pp::UserBankInfo* UserBankInfoOpRes::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::pp::UserBankInfo;
  return entity_;
}
inline ::pp::UserBankInfo* UserBankInfoOpRes::release_entity() {
  clear_has_entity();
  ::pp::UserBankInfo* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void UserBankInfoOpRes::set_allocated_entity(::pp::UserBankInfo* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// -------------------------------------------------------------------

// BankListReq

// required string banktype = 1;
inline bool BankListReq::has_banktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankListReq::set_has_banktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankListReq::clear_has_banktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankListReq::clear_banktype() {
  if (banktype_ != &::google::protobuf::internal::kEmptyString) {
    banktype_->clear();
  }
  clear_has_banktype();
}
inline const ::std::string& BankListReq::banktype() const {
  return *banktype_;
}
inline void BankListReq::set_banktype(const ::std::string& value) {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  banktype_->assign(value);
}
inline void BankListReq::set_banktype(const char* value) {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  banktype_->assign(value);
}
inline void BankListReq::set_banktype(const char* value, size_t size) {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  banktype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankListReq::mutable_banktype() {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  return banktype_;
}
inline ::std::string* BankListReq::release_banktype() {
  clear_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = banktype_;
    banktype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankListReq::set_allocated_banktype(::std::string* banktype) {
  if (banktype_ != &::google::protobuf::internal::kEmptyString) {
    delete banktype_;
  }
  if (banktype) {
    set_has_banktype();
    banktype_ = banktype;
  } else {
    clear_has_banktype();
    banktype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 province = 2;
inline bool BankListReq::has_province() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankListReq::set_has_province() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankListReq::clear_has_province() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankListReq::clear_province() {
  province_ = 0u;
  clear_has_province();
}
inline ::google::protobuf::uint32 BankListReq::province() const {
  return province_;
}
inline void BankListReq::set_province(::google::protobuf::uint32 value) {
  set_has_province();
  province_ = value;
}

// optional uint32 city = 3;
inline bool BankListReq::has_city() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankListReq::set_has_city() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankListReq::clear_has_city() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankListReq::clear_city() {
  city_ = 0u;
  clear_has_city();
}
inline ::google::protobuf::uint32 BankListReq::city() const {
  return city_;
}
inline void BankListReq::set_city(::google::protobuf::uint32 value) {
  set_has_city();
  city_ = value;
}

// optional uint32 index = 4;
inline bool BankListReq::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankListReq::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BankListReq::index() const {
  return index_;
}
inline void BankListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 5;
inline bool BankListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BankListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BankListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BankListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 BankListReq::fetchs() const {
  return fetchs_;
}
inline void BankListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// BankListRes

// required string banktype = 1;
inline bool BankListRes::has_banktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BankListRes::set_has_banktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BankListRes::clear_has_banktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BankListRes::clear_banktype() {
  if (banktype_ != &::google::protobuf::internal::kEmptyString) {
    banktype_->clear();
  }
  clear_has_banktype();
}
inline const ::std::string& BankListRes::banktype() const {
  return *banktype_;
}
inline void BankListRes::set_banktype(const ::std::string& value) {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  banktype_->assign(value);
}
inline void BankListRes::set_banktype(const char* value) {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  banktype_->assign(value);
}
inline void BankListRes::set_banktype(const char* value, size_t size) {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  banktype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankListRes::mutable_banktype() {
  set_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    banktype_ = new ::std::string;
  }
  return banktype_;
}
inline ::std::string* BankListRes::release_banktype() {
  clear_has_banktype();
  if (banktype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = banktype_;
    banktype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void BankListRes::set_allocated_banktype(::std::string* banktype) {
  if (banktype_ != &::google::protobuf::internal::kEmptyString) {
    delete banktype_;
  }
  if (banktype) {
    set_has_banktype();
    banktype_ = banktype;
  } else {
    clear_has_banktype();
    banktype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 province = 2;
inline bool BankListRes::has_province() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BankListRes::set_has_province() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BankListRes::clear_has_province() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BankListRes::clear_province() {
  province_ = 0u;
  clear_has_province();
}
inline ::google::protobuf::uint32 BankListRes::province() const {
  return province_;
}
inline void BankListRes::set_province(::google::protobuf::uint32 value) {
  set_has_province();
  province_ = value;
}

// optional uint32 city = 3;
inline bool BankListRes::has_city() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BankListRes::set_has_city() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BankListRes::clear_has_city() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BankListRes::clear_city() {
  city_ = 0u;
  clear_has_city();
}
inline ::google::protobuf::uint32 BankListRes::city() const {
  return city_;
}
inline void BankListRes::set_city(::google::protobuf::uint32 value) {
  set_has_city();
  city_ = value;
}

// optional uint32 index = 4;
inline bool BankListRes::has_index() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BankListRes::set_has_index() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BankListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BankListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 BankListRes::index() const {
  return index_;
}
inline void BankListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 5;
inline bool BankListRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BankListRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BankListRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BankListRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 BankListRes::fetchs() const {
  return fetchs_;
}
inline void BankListRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// repeated string items = 6;
inline int BankListRes::items_size() const {
  return items_.size();
}
inline void BankListRes::clear_items() {
  items_.Clear();
}
inline const ::std::string& BankListRes::items(int index) const {
  return items_.Get(index);
}
inline ::std::string* BankListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline void BankListRes::set_items(int index, const ::std::string& value) {
  items_.Mutable(index)->assign(value);
}
inline void BankListRes::set_items(int index, const char* value) {
  items_.Mutable(index)->assign(value);
}
inline void BankListRes::set_items(int index, const char* value, size_t size) {
  items_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* BankListRes::add_items() {
  return items_.Add();
}
inline void BankListRes::add_items(const ::std::string& value) {
  items_.Add()->assign(value);
}
inline void BankListRes::add_items(const char* value) {
  items_.Add()->assign(value);
}
inline void BankListRes::add_items(const char* value, size_t size) {
  items_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
BankListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
BankListRes::mutable_items() {
  return &items_;
}

// optional uint32 totalresults = 7;
inline bool BankListRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void BankListRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000040u;
}
inline void BankListRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void BankListRes::clear_totalresults() {
  totalresults_ = 0u;
  clear_has_totalresults();
}
inline ::google::protobuf::uint32 BankListRes::totalresults() const {
  return totalresults_;
}
inline void BankListRes::set_totalresults(::google::protobuf::uint32 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// -------------------------------------------------------------------

// UserCoinRecord

// optional uint64 itemId = 1;
inline bool UserCoinRecord::has_itemid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCoinRecord::set_has_itemid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCoinRecord::clear_has_itemid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCoinRecord::clear_itemid() {
  itemid_ = GOOGLE_ULONGLONG(0);
  clear_has_itemid();
}
inline ::google::protobuf::uint64 UserCoinRecord::itemid() const {
  return itemid_;
}
inline void UserCoinRecord::set_itemid(::google::protobuf::uint64 value) {
  set_has_itemid();
  itemid_ = value;
}

// optional uint32 itemNum = 2;
inline bool UserCoinRecord::has_itemnum() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserCoinRecord::set_has_itemnum() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserCoinRecord::clear_has_itemnum() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserCoinRecord::clear_itemnum() {
  itemnum_ = 0u;
  clear_has_itemnum();
}
inline ::google::protobuf::uint32 UserCoinRecord::itemnum() const {
  return itemnum_;
}
inline void UserCoinRecord::set_itemnum(::google::protobuf::uint32 value) {
  set_has_itemnum();
  itemnum_ = value;
}

// optional .pp.UserCoinRecord.Type type = 3;
inline bool UserCoinRecord::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserCoinRecord::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserCoinRecord::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserCoinRecord::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::pp::UserCoinRecord_Type UserCoinRecord::type() const {
  return static_cast< ::pp::UserCoinRecord_Type >(type_);
}
inline void UserCoinRecord::set_type(::pp::UserCoinRecord_Type value) {
  assert(::pp::UserCoinRecord_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional sint32 coins = 4;
inline bool UserCoinRecord::has_coins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserCoinRecord::set_has_coins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserCoinRecord::clear_has_coins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserCoinRecord::clear_coins() {
  coins_ = 0;
  clear_has_coins();
}
inline ::google::protobuf::int32 UserCoinRecord::coins() const {
  return coins_;
}
inline void UserCoinRecord::set_coins(::google::protobuf::int32 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint64 targetUid = 5;
inline bool UserCoinRecord::has_targetuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserCoinRecord::set_has_targetuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserCoinRecord::clear_has_targetuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserCoinRecord::clear_targetuid() {
  targetuid_ = GOOGLE_ULONGLONG(0);
  clear_has_targetuid();
}
inline ::google::protobuf::uint64 UserCoinRecord::targetuid() const {
  return targetuid_;
}
inline void UserCoinRecord::set_targetuid(::google::protobuf::uint64 value) {
  set_has_targetuid();
  targetuid_ = value;
}

// optional sint64 createTime = 6;
inline bool UserCoinRecord::has_createtime() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserCoinRecord::set_has_createtime() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserCoinRecord::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserCoinRecord::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserCoinRecord::createtime() const {
  return createtime_;
}
inline void UserCoinRecord::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// -------------------------------------------------------------------

// YYGiftInfo

// optional string id = 1;
inline bool YYGiftInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftInfo::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& YYGiftInfo::id() const {
  return *id_;
}
inline void YYGiftInfo::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void YYGiftInfo::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void YYGiftInfo::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* YYGiftInfo::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool YYGiftInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& YYGiftInfo::name() const {
  return *name_;
}
inline void YYGiftInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYGiftInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYGiftInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* YYGiftInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float price = 3;
inline bool YYGiftInfo::has_price() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYGiftInfo::set_has_price() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYGiftInfo::clear_has_price() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYGiftInfo::clear_price() {
  price_ = 0;
  clear_has_price();
}
inline float YYGiftInfo::price() const {
  return price_;
}
inline void YYGiftInfo::set_price(float value) {
  set_has_price();
  price_ = value;
}

// optional uint32 position = 4;
inline bool YYGiftInfo::has_position() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYGiftInfo::set_has_position() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYGiftInfo::clear_has_position() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYGiftInfo::clear_position() {
  position_ = 0u;
  clear_has_position();
}
inline ::google::protobuf::uint32 YYGiftInfo::position() const {
  return position_;
}
inline void YYGiftInfo::set_position(::google::protobuf::uint32 value) {
  set_has_position();
  position_ = value;
}

// optional string thumbnailUrl = 6;
inline bool YYGiftInfo::has_thumbnailurl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YYGiftInfo::set_has_thumbnailurl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YYGiftInfo::clear_has_thumbnailurl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YYGiftInfo::clear_thumbnailurl() {
  if (thumbnailurl_ != &::google::protobuf::internal::kEmptyString) {
    thumbnailurl_->clear();
  }
  clear_has_thumbnailurl();
}
inline const ::std::string& YYGiftInfo::thumbnailurl() const {
  return *thumbnailurl_;
}
inline void YYGiftInfo::set_thumbnailurl(const ::std::string& value) {
  set_has_thumbnailurl();
  if (thumbnailurl_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailurl_ = new ::std::string;
  }
  thumbnailurl_->assign(value);
}
inline void YYGiftInfo::set_thumbnailurl(const char* value) {
  set_has_thumbnailurl();
  if (thumbnailurl_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailurl_ = new ::std::string;
  }
  thumbnailurl_->assign(value);
}
inline void YYGiftInfo::set_thumbnailurl(const char* value, size_t size) {
  set_has_thumbnailurl();
  if (thumbnailurl_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailurl_ = new ::std::string;
  }
  thumbnailurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_thumbnailurl() {
  set_has_thumbnailurl();
  if (thumbnailurl_ == &::google::protobuf::internal::kEmptyString) {
    thumbnailurl_ = new ::std::string;
  }
  return thumbnailurl_;
}
inline ::std::string* YYGiftInfo::release_thumbnailurl() {
  clear_has_thumbnailurl();
  if (thumbnailurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = thumbnailurl_;
    thumbnailurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_thumbnailurl(::std::string* thumbnailurl) {
  if (thumbnailurl_ != &::google::protobuf::internal::kEmptyString) {
    delete thumbnailurl_;
  }
  if (thumbnailurl) {
    set_has_thumbnailurl();
    thumbnailurl_ = thumbnailurl;
  } else {
    clear_has_thumbnailurl();
    thumbnailurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string normalUrl = 7;
inline bool YYGiftInfo::has_normalurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YYGiftInfo::set_has_normalurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YYGiftInfo::clear_has_normalurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YYGiftInfo::clear_normalurl() {
  if (normalurl_ != &::google::protobuf::internal::kEmptyString) {
    normalurl_->clear();
  }
  clear_has_normalurl();
}
inline const ::std::string& YYGiftInfo::normalurl() const {
  return *normalurl_;
}
inline void YYGiftInfo::set_normalurl(const ::std::string& value) {
  set_has_normalurl();
  if (normalurl_ == &::google::protobuf::internal::kEmptyString) {
    normalurl_ = new ::std::string;
  }
  normalurl_->assign(value);
}
inline void YYGiftInfo::set_normalurl(const char* value) {
  set_has_normalurl();
  if (normalurl_ == &::google::protobuf::internal::kEmptyString) {
    normalurl_ = new ::std::string;
  }
  normalurl_->assign(value);
}
inline void YYGiftInfo::set_normalurl(const char* value, size_t size) {
  set_has_normalurl();
  if (normalurl_ == &::google::protobuf::internal::kEmptyString) {
    normalurl_ = new ::std::string;
  }
  normalurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_normalurl() {
  set_has_normalurl();
  if (normalurl_ == &::google::protobuf::internal::kEmptyString) {
    normalurl_ = new ::std::string;
  }
  return normalurl_;
}
inline ::std::string* YYGiftInfo::release_normalurl() {
  clear_has_normalurl();
  if (normalurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = normalurl_;
    normalurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_normalurl(::std::string* normalurl) {
  if (normalurl_ != &::google::protobuf::internal::kEmptyString) {
    delete normalurl_;
  }
  if (normalurl) {
    set_has_normalurl();
    normalurl_ = normalurl;
  } else {
    clear_has_normalurl();
    normalurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string dynamicUrl = 8;
inline bool YYGiftInfo::has_dynamicurl() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void YYGiftInfo::set_has_dynamicurl() {
  _has_bits_[0] |= 0x00000040u;
}
inline void YYGiftInfo::clear_has_dynamicurl() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void YYGiftInfo::clear_dynamicurl() {
  if (dynamicurl_ != &::google::protobuf::internal::kEmptyString) {
    dynamicurl_->clear();
  }
  clear_has_dynamicurl();
}
inline const ::std::string& YYGiftInfo::dynamicurl() const {
  return *dynamicurl_;
}
inline void YYGiftInfo::set_dynamicurl(const ::std::string& value) {
  set_has_dynamicurl();
  if (dynamicurl_ == &::google::protobuf::internal::kEmptyString) {
    dynamicurl_ = new ::std::string;
  }
  dynamicurl_->assign(value);
}
inline void YYGiftInfo::set_dynamicurl(const char* value) {
  set_has_dynamicurl();
  if (dynamicurl_ == &::google::protobuf::internal::kEmptyString) {
    dynamicurl_ = new ::std::string;
  }
  dynamicurl_->assign(value);
}
inline void YYGiftInfo::set_dynamicurl(const char* value, size_t size) {
  set_has_dynamicurl();
  if (dynamicurl_ == &::google::protobuf::internal::kEmptyString) {
    dynamicurl_ = new ::std::string;
  }
  dynamicurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_dynamicurl() {
  set_has_dynamicurl();
  if (dynamicurl_ == &::google::protobuf::internal::kEmptyString) {
    dynamicurl_ = new ::std::string;
  }
  return dynamicurl_;
}
inline ::std::string* YYGiftInfo::release_dynamicurl() {
  clear_has_dynamicurl();
  if (dynamicurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dynamicurl_;
    dynamicurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_dynamicurl(::std::string* dynamicurl) {
  if (dynamicurl_ != &::google::protobuf::internal::kEmptyString) {
    delete dynamicurl_;
  }
  if (dynamicurl) {
    set_has_dynamicurl();
    dynamicurl_ = dynamicurl;
  } else {
    clear_has_dynamicurl();
    dynamicurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string description = 9;
inline bool YYGiftInfo::has_description() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void YYGiftInfo::set_has_description() {
  _has_bits_[0] |= 0x00000080u;
}
inline void YYGiftInfo::clear_has_description() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void YYGiftInfo::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& YYGiftInfo::description() const {
  return *description_;
}
inline void YYGiftInfo::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void YYGiftInfo::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void YYGiftInfo::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* YYGiftInfo::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string extJson = 10;
inline bool YYGiftInfo::has_extjson() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void YYGiftInfo::set_has_extjson() {
  _has_bits_[0] |= 0x00000100u;
}
inline void YYGiftInfo::clear_has_extjson() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void YYGiftInfo::clear_extjson() {
  if (extjson_ != &::google::protobuf::internal::kEmptyString) {
    extjson_->clear();
  }
  clear_has_extjson();
}
inline const ::std::string& YYGiftInfo::extjson() const {
  return *extjson_;
}
inline void YYGiftInfo::set_extjson(const ::std::string& value) {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  extjson_->assign(value);
}
inline void YYGiftInfo::set_extjson(const char* value) {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  extjson_->assign(value);
}
inline void YYGiftInfo::set_extjson(const char* value, size_t size) {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  extjson_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftInfo::mutable_extjson() {
  set_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    extjson_ = new ::std::string;
  }
  return extjson_;
}
inline ::std::string* YYGiftInfo::release_extjson() {
  clear_has_extjson();
  if (extjson_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = extjson_;
    extjson_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftInfo::set_allocated_extjson(::std::string* extjson) {
  if (extjson_ != &::google::protobuf::internal::kEmptyString) {
    delete extjson_;
  }
  if (extjson) {
    set_has_extjson();
    extjson_ = extjson;
  } else {
    clear_has_extjson();
    extjson_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// YYGiftListReq

// optional uint32 index = 1;
inline bool YYGiftListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 YYGiftListReq::index() const {
  return index_;
}
inline void YYGiftListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool YYGiftListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 YYGiftListReq::fetchs() const {
  return fetchs_;
}
inline void YYGiftListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// YYGiftListRes

// optional uint32 index = 1;
inline bool YYGiftListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 YYGiftListRes::index() const {
  return index_;
}
inline void YYGiftListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 2;
inline bool YYGiftListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 YYGiftListRes::total() const {
  return total_;
}
inline void YYGiftListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.YYGiftInfo yygifts = 3;
inline int YYGiftListRes::yygifts_size() const {
  return yygifts_.size();
}
inline void YYGiftListRes::clear_yygifts() {
  yygifts_.Clear();
}
inline const ::pp::YYGiftInfo& YYGiftListRes::yygifts(int index) const {
  return yygifts_.Get(index);
}
inline ::pp::YYGiftInfo* YYGiftListRes::mutable_yygifts(int index) {
  return yygifts_.Mutable(index);
}
inline ::pp::YYGiftInfo* YYGiftListRes::add_yygifts() {
  return yygifts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::YYGiftInfo >&
YYGiftListRes::yygifts() const {
  return yygifts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::YYGiftInfo >*
YYGiftListRes::mutable_yygifts() {
  return &yygifts_;
}

// optional uint64 version = 4;
inline bool YYGiftListRes::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYGiftListRes::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYGiftListRes::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYGiftListRes::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 YYGiftListRes::version() const {
  return version_;
}
inline void YYGiftListRes::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// YYGiftDonateReq

// optional uint64 touid = 1;
inline bool YYGiftDonateReq::has_touid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftDonateReq::set_has_touid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftDonateReq::clear_has_touid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftDonateReq::clear_touid() {
  touid_ = GOOGLE_ULONGLONG(0);
  clear_has_touid();
}
inline ::google::protobuf::uint64 YYGiftDonateReq::touid() const {
  return touid_;
}
inline void YYGiftDonateReq::set_touid(::google::protobuf::uint64 value) {
  set_has_touid();
  touid_ = value;
}

// optional uint64 gid = 2;
inline bool YYGiftDonateReq::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftDonateReq::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftDonateReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftDonateReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 YYGiftDonateReq::gid() const {
  return gid_;
}
inline void YYGiftDonateReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional string giftId = 3;
inline bool YYGiftDonateReq::has_giftid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYGiftDonateReq::set_has_giftid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYGiftDonateReq::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYGiftDonateReq::clear_giftid() {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    giftid_->clear();
  }
  clear_has_giftid();
}
inline const ::std::string& YYGiftDonateReq::giftid() const {
  return *giftid_;
}
inline void YYGiftDonateReq::set_giftid(const ::std::string& value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void YYGiftDonateReq::set_giftid(const char* value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void YYGiftDonateReq::set_giftid(const char* value, size_t size) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftDonateReq::mutable_giftid() {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  return giftid_;
}
inline ::std::string* YYGiftDonateReq::release_giftid() {
  clear_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giftid_;
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftDonateReq::set_allocated_giftid(::std::string* giftid) {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    delete giftid_;
  }
  if (giftid) {
    set_has_giftid();
    giftid_ = giftid;
  } else {
    clear_has_giftid();
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 num = 4;
inline bool YYGiftDonateReq::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYGiftDonateReq::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYGiftDonateReq::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYGiftDonateReq::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 YYGiftDonateReq::num() const {
  return num_;
}
inline void YYGiftDonateReq::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// -------------------------------------------------------------------

// YYGiftDonateRes

// optional uint64 touid = 1;
inline bool YYGiftDonateRes::has_touid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftDonateRes::set_has_touid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftDonateRes::clear_has_touid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftDonateRes::clear_touid() {
  touid_ = GOOGLE_ULONGLONG(0);
  clear_has_touid();
}
inline ::google::protobuf::uint64 YYGiftDonateRes::touid() const {
  return touid_;
}
inline void YYGiftDonateRes::set_touid(::google::protobuf::uint64 value) {
  set_has_touid();
  touid_ = value;
}

// optional uint64 gid = 2;
inline bool YYGiftDonateRes::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftDonateRes::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftDonateRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftDonateRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 YYGiftDonateRes::gid() const {
  return gid_;
}
inline void YYGiftDonateRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional string giftId = 3;
inline bool YYGiftDonateRes::has_giftid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYGiftDonateRes::set_has_giftid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYGiftDonateRes::clear_has_giftid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYGiftDonateRes::clear_giftid() {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    giftid_->clear();
  }
  clear_has_giftid();
}
inline const ::std::string& YYGiftDonateRes::giftid() const {
  return *giftid_;
}
inline void YYGiftDonateRes::set_giftid(const ::std::string& value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void YYGiftDonateRes::set_giftid(const char* value) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(value);
}
inline void YYGiftDonateRes::set_giftid(const char* value, size_t size) {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  giftid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftDonateRes::mutable_giftid() {
  set_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    giftid_ = new ::std::string;
  }
  return giftid_;
}
inline ::std::string* YYGiftDonateRes::release_giftid() {
  clear_has_giftid();
  if (giftid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = giftid_;
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftDonateRes::set_allocated_giftid(::std::string* giftid) {
  if (giftid_ != &::google::protobuf::internal::kEmptyString) {
    delete giftid_;
  }
  if (giftid) {
    set_has_giftid();
    giftid_ = giftid;
  } else {
    clear_has_giftid();
    giftid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 Num = 4;
inline bool YYGiftDonateRes::has_num() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYGiftDonateRes::set_has_num() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYGiftDonateRes::clear_has_num() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYGiftDonateRes::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 YYGiftDonateRes::num() const {
  return num_;
}
inline void YYGiftDonateRes::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional string orderId = 5;
inline bool YYGiftDonateRes::has_orderid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YYGiftDonateRes::set_has_orderid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YYGiftDonateRes::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YYGiftDonateRes::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& YYGiftDonateRes::orderid() const {
  return *orderid_;
}
inline void YYGiftDonateRes::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void YYGiftDonateRes::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void YYGiftDonateRes::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftDonateRes::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* YYGiftDonateRes::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftDonateRes::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string authurl = 6;
inline bool YYGiftDonateRes::has_authurl() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YYGiftDonateRes::set_has_authurl() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YYGiftDonateRes::clear_has_authurl() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YYGiftDonateRes::clear_authurl() {
  if (authurl_ != &::google::protobuf::internal::kEmptyString) {
    authurl_->clear();
  }
  clear_has_authurl();
}
inline const ::std::string& YYGiftDonateRes::authurl() const {
  return *authurl_;
}
inline void YYGiftDonateRes::set_authurl(const ::std::string& value) {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  authurl_->assign(value);
}
inline void YYGiftDonateRes::set_authurl(const char* value) {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  authurl_->assign(value);
}
inline void YYGiftDonateRes::set_authurl(const char* value, size_t size) {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  authurl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftDonateRes::mutable_authurl() {
  set_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    authurl_ = new ::std::string;
  }
  return authurl_;
}
inline ::std::string* YYGiftDonateRes::release_authurl() {
  clear_has_authurl();
  if (authurl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = authurl_;
    authurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftDonateRes::set_allocated_authurl(::std::string* authurl) {
  if (authurl_ != &::google::protobuf::internal::kEmptyString) {
    delete authurl_;
  }
  if (authurl) {
    set_has_authurl();
    authurl_ = authurl;
  } else {
    clear_has_authurl();
    authurl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 sid = 7;
inline bool YYGiftDonateRes::has_sid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void YYGiftDonateRes::set_has_sid() {
  _has_bits_[0] |= 0x00000040u;
}
inline void YYGiftDonateRes::clear_has_sid() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void YYGiftDonateRes::clear_sid() {
  sid_ = GOOGLE_LONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::int64 YYGiftDonateRes::sid() const {
  return sid_;
}
inline void YYGiftDonateRes::set_sid(::google::protobuf::int64 value) {
  set_has_sid();
  sid_ = value;
}

// optional int64 ssid = 8;
inline bool YYGiftDonateRes::has_ssid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void YYGiftDonateRes::set_has_ssid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void YYGiftDonateRes::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void YYGiftDonateRes::clear_ssid() {
  ssid_ = GOOGLE_LONGLONG(0);
  clear_has_ssid();
}
inline ::google::protobuf::int64 YYGiftDonateRes::ssid() const {
  return ssid_;
}
inline void YYGiftDonateRes::set_ssid(::google::protobuf::int64 value) {
  set_has_ssid();
  ssid_ = value;
}

// -------------------------------------------------------------------

// YYGiftPayConfirmReq

// optional string orderId = 1;
inline bool YYGiftPayConfirmReq::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftPayConfirmReq::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftPayConfirmReq::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftPayConfirmReq::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& YYGiftPayConfirmReq::orderid() const {
  return *orderid_;
}
inline void YYGiftPayConfirmReq::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void YYGiftPayConfirmReq::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void YYGiftPayConfirmReq::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftPayConfirmReq::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* YYGiftPayConfirmReq::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftPayConfirmReq::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.YYGiftPayConfirmOpType opType = 2;
inline bool YYGiftPayConfirmReq::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftPayConfirmReq::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftPayConfirmReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftPayConfirmReq::clear_optype() {
  optype_ = 1;
  clear_has_optype();
}
inline ::pp::YYGiftPayConfirmOpType YYGiftPayConfirmReq::optype() const {
  return static_cast< ::pp::YYGiftPayConfirmOpType >(optype_);
}
inline void YYGiftPayConfirmReq::set_optype(::pp::YYGiftPayConfirmOpType value) {
  assert(::pp::YYGiftPayConfirmOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional int64 sid = 3;
inline bool YYGiftPayConfirmReq::has_sid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYGiftPayConfirmReq::set_has_sid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYGiftPayConfirmReq::clear_has_sid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYGiftPayConfirmReq::clear_sid() {
  sid_ = GOOGLE_LONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::int64 YYGiftPayConfirmReq::sid() const {
  return sid_;
}
inline void YYGiftPayConfirmReq::set_sid(::google::protobuf::int64 value) {
  set_has_sid();
  sid_ = value;
}

// optional int64 ssid = 4;
inline bool YYGiftPayConfirmReq::has_ssid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYGiftPayConfirmReq::set_has_ssid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYGiftPayConfirmReq::clear_has_ssid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYGiftPayConfirmReq::clear_ssid() {
  ssid_ = GOOGLE_LONGLONG(0);
  clear_has_ssid();
}
inline ::google::protobuf::int64 YYGiftPayConfirmReq::ssid() const {
  return ssid_;
}
inline void YYGiftPayConfirmReq::set_ssid(::google::protobuf::int64 value) {
  set_has_ssid();
  ssid_ = value;
}

// -------------------------------------------------------------------

// YYGiftPayConfirmRes

// optional string orderId = 1;
inline bool YYGiftPayConfirmRes::has_orderid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYGiftPayConfirmRes::set_has_orderid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYGiftPayConfirmRes::clear_has_orderid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYGiftPayConfirmRes::clear_orderid() {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    orderid_->clear();
  }
  clear_has_orderid();
}
inline const ::std::string& YYGiftPayConfirmRes::orderid() const {
  return *orderid_;
}
inline void YYGiftPayConfirmRes::set_orderid(const ::std::string& value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void YYGiftPayConfirmRes::set_orderid(const char* value) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(value);
}
inline void YYGiftPayConfirmRes::set_orderid(const char* value, size_t size) {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  orderid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYGiftPayConfirmRes::mutable_orderid() {
  set_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    orderid_ = new ::std::string;
  }
  return orderid_;
}
inline ::std::string* YYGiftPayConfirmRes::release_orderid() {
  clear_has_orderid();
  if (orderid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = orderid_;
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYGiftPayConfirmRes::set_allocated_orderid(::std::string* orderid) {
  if (orderid_ != &::google::protobuf::internal::kEmptyString) {
    delete orderid_;
  }
  if (orderid) {
    set_has_orderid();
    orderid_ = orderid;
  } else {
    clear_has_orderid();
    orderid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.YYGiftPayConfirmOpType opType = 2;
inline bool YYGiftPayConfirmRes::has_optype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYGiftPayConfirmRes::set_has_optype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYGiftPayConfirmRes::clear_has_optype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYGiftPayConfirmRes::clear_optype() {
  optype_ = 1;
  clear_has_optype();
}
inline ::pp::YYGiftPayConfirmOpType YYGiftPayConfirmRes::optype() const {
  return static_cast< ::pp::YYGiftPayConfirmOpType >(optype_);
}
inline void YYGiftPayConfirmRes::set_optype(::pp::YYGiftPayConfirmOpType value) {
  assert(::pp::YYGiftPayConfirmOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// -------------------------------------------------------------------

// UserTaskState

// optional uint32 taskType = 1;
inline bool UserTaskState::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTaskState::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTaskState::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTaskState::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 UserTaskState::tasktype() const {
  return tasktype_;
}
inline void UserTaskState::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// optional uint32 count = 2;
inline bool UserTaskState::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTaskState::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTaskState::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTaskState::clear_count() {
  count_ = 0u;
  clear_has_count();
}
inline ::google::protobuf::uint32 UserTaskState::count() const {
  return count_;
}
inline void UserTaskState::set_count(::google::protobuf::uint32 value) {
  set_has_count();
  count_ = value;
}

// optional uint32 progress = 3;
inline bool UserTaskState::has_progress() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserTaskState::set_has_progress() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserTaskState::clear_has_progress() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserTaskState::clear_progress() {
  progress_ = 0u;
  clear_has_progress();
}
inline ::google::protobuf::uint32 UserTaskState::progress() const {
  return progress_;
}
inline void UserTaskState::set_progress(::google::protobuf::uint32 value) {
  set_has_progress();
  progress_ = value;
}

// optional bool fetched = 4;
inline bool UserTaskState::has_fetched() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserTaskState::set_has_fetched() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserTaskState::clear_has_fetched() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserTaskState::clear_fetched() {
  fetched_ = false;
  clear_has_fetched();
}
inline bool UserTaskState::fetched() const {
  return fetched_;
}
inline void UserTaskState::set_fetched(bool value) {
  set_has_fetched();
  fetched_ = value;
}

// optional uint32 coins = 5;
inline bool UserTaskState::has_coins() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserTaskState::set_has_coins() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserTaskState::clear_has_coins() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserTaskState::clear_coins() {
  coins_ = 0u;
  clear_has_coins();
}
inline ::google::protobuf::uint32 UserTaskState::coins() const {
  return coins_;
}
inline void UserTaskState::set_coins(::google::protobuf::uint32 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint32 experience = 6;
inline bool UserTaskState::has_experience() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserTaskState::set_has_experience() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserTaskState::clear_has_experience() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserTaskState::clear_experience() {
  experience_ = 0u;
  clear_has_experience();
}
inline ::google::protobuf::uint32 UserTaskState::experience() const {
  return experience_;
}
inline void UserTaskState::set_experience(::google::protobuf::uint32 value) {
  set_has_experience();
  experience_ = value;
}

// optional sint64 updateTime = 7;
inline bool UserTaskState::has_updatetime() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserTaskState::set_has_updatetime() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserTaskState::clear_has_updatetime() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserTaskState::clear_updatetime() {
  updatetime_ = GOOGLE_LONGLONG(0);
  clear_has_updatetime();
}
inline ::google::protobuf::int64 UserTaskState::updatetime() const {
  return updatetime_;
}
inline void UserTaskState::set_updatetime(::google::protobuf::int64 value) {
  set_has_updatetime();
  updatetime_ = value;
}

// optional .pp.UserTaskState.TaskCategory taskCat = 8;
inline bool UserTaskState::has_taskcat() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserTaskState::set_has_taskcat() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserTaskState::clear_has_taskcat() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserTaskState::clear_taskcat() {
  taskcat_ = 0;
  clear_has_taskcat();
}
inline ::pp::UserTaskState_TaskCategory UserTaskState::taskcat() const {
  return static_cast< ::pp::UserTaskState_TaskCategory >(taskcat_);
}
inline void UserTaskState::set_taskcat(::pp::UserTaskState_TaskCategory value) {
  assert(::pp::UserTaskState_TaskCategory_IsValid(value));
  set_has_taskcat();
  taskcat_ = value;
}

// optional string text = 9;
inline bool UserTaskState::has_text() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserTaskState::set_has_text() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserTaskState::clear_has_text() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserTaskState::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& UserTaskState::text() const {
  return *text_;
}
inline void UserTaskState::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void UserTaskState::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void UserTaskState::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTaskState::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* UserTaskState::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTaskState::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserTaskStateReq

// -------------------------------------------------------------------

// UserTaskStateRes

// repeated .pp.UserTaskState taskStates = 1;
inline int UserTaskStateRes::taskstates_size() const {
  return taskstates_.size();
}
inline void UserTaskStateRes::clear_taskstates() {
  taskstates_.Clear();
}
inline const ::pp::UserTaskState& UserTaskStateRes::taskstates(int index) const {
  return taskstates_.Get(index);
}
inline ::pp::UserTaskState* UserTaskStateRes::mutable_taskstates(int index) {
  return taskstates_.Mutable(index);
}
inline ::pp::UserTaskState* UserTaskStateRes::add_taskstates() {
  return taskstates_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserTaskState >&
UserTaskStateRes::taskstates() const {
  return taskstates_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserTaskState >*
UserTaskStateRes::mutable_taskstates() {
  return &taskstates_;
}

// -------------------------------------------------------------------

// UserTaskTakeAwardReq

// optional uint32 taskType = 1;
inline bool UserTaskTakeAwardReq::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTaskTakeAwardReq::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTaskTakeAwardReq::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTaskTakeAwardReq::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 UserTaskTakeAwardReq::tasktype() const {
  return tasktype_;
}
inline void UserTaskTakeAwardReq::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// -------------------------------------------------------------------

// UserTaskTakeAwardRes

// optional uint32 taskType = 1;
inline bool UserTaskTakeAwardRes::has_tasktype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTaskTakeAwardRes::set_has_tasktype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTaskTakeAwardRes::clear_has_tasktype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTaskTakeAwardRes::clear_tasktype() {
  tasktype_ = 0u;
  clear_has_tasktype();
}
inline ::google::protobuf::uint32 UserTaskTakeAwardRes::tasktype() const {
  return tasktype_;
}
inline void UserTaskTakeAwardRes::set_tasktype(::google::protobuf::uint32 value) {
  set_has_tasktype();
  tasktype_ = value;
}

// -------------------------------------------------------------------

// UserTaskCheckReq

// -------------------------------------------------------------------

// UserTaskCheckRes

// optional bool newtask = 1;
inline bool UserTaskCheckRes::has_newtask() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTaskCheckRes::set_has_newtask() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTaskCheckRes::clear_has_newtask() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTaskCheckRes::clear_newtask() {
  newtask_ = false;
  clear_has_newtask();
}
inline bool UserTaskCheckRes::newtask() const {
  return newtask_;
}
inline void UserTaskCheckRes::set_newtask(bool value) {
  set_has_newtask();
  newtask_ = value;
}

// optional uint32 leftTask = 2;
inline bool UserTaskCheckRes::has_lefttask() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTaskCheckRes::set_has_lefttask() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTaskCheckRes::clear_has_lefttask() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTaskCheckRes::clear_lefttask() {
  lefttask_ = 0u;
  clear_has_lefttask();
}
inline ::google::protobuf::uint32 UserTaskCheckRes::lefttask() const {
  return lefttask_;
}
inline void UserTaskCheckRes::set_lefttask(::google::protobuf::uint32 value) {
  set_has_lefttask();
  lefttask_ = value;
}

// -------------------------------------------------------------------

// UserInfo

// required uint64 uid = 1;
inline bool UserInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfo::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserInfo::uid() const {
  return uid_;
}
inline void UserInfo::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string nick = 2;
inline bool UserInfo::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfo::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfo::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfo::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UserInfo::nick() const {
  return *nick_;
}
inline void UserInfo::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfo::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfo::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* UserInfo::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string signature = 3;
inline bool UserInfo::has_signature() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfo::set_has_signature() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfo::clear_has_signature() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfo::clear_signature() {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    signature_->clear();
  }
  clear_has_signature();
}
inline const ::std::string& UserInfo::signature() const {
  return *signature_;
}
inline void UserInfo::set_signature(const ::std::string& value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void UserInfo::set_signature(const char* value) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(value);
}
inline void UserInfo::set_signature(const char* value, size_t size) {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_signature() {
  set_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    signature_ = new ::std::string;
  }
  return signature_;
}
inline ::std::string* UserInfo::release_signature() {
  clear_has_signature();
  if (signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = signature_;
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_signature(::std::string* signature) {
  if (signature_ != &::google::protobuf::internal::kEmptyString) {
    delete signature_;
  }
  if (signature) {
    set_has_signature();
    signature_ = signature;
  } else {
    clear_has_signature();
    signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string logourl = 4;
inline bool UserInfo::has_logourl() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfo::set_has_logourl() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfo::clear_has_logourl() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfo::clear_logourl() {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    logourl_->clear();
  }
  clear_has_logourl();
}
inline const ::std::string& UserInfo::logourl() const {
  return *logourl_;
}
inline void UserInfo::set_logourl(const ::std::string& value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void UserInfo::set_logourl(const char* value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void UserInfo::set_logourl(const char* value, size_t size) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_logourl() {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  return logourl_;
}
inline ::std::string* UserInfo::release_logourl() {
  clear_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logourl_;
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_logourl(::std::string* logourl) {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    delete logourl_;
  }
  if (logourl) {
    set_has_logourl();
    logourl_ = logourl;
  } else {
    clear_has_logourl();
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.SexType sex = 5;
inline bool UserInfo::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserInfo::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserInfo::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserInfo::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::pp::SexType UserInfo::sex() const {
  return static_cast< ::pp::SexType >(sex_);
}
inline void UserInfo::set_sex(::pp::SexType value) {
  assert(::pp::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// optional sint64 birthday = 6;
inline bool UserInfo::has_birthday() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserInfo::set_has_birthday() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserInfo::clear_has_birthday() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserInfo::clear_birthday() {
  birthday_ = GOOGLE_LONGLONG(0);
  clear_has_birthday();
}
inline ::google::protobuf::int64 UserInfo::birthday() const {
  return birthday_;
}
inline void UserInfo::set_birthday(::google::protobuf::int64 value) {
  set_has_birthday();
  birthday_ = value;
}

// optional string location = 8;
inline bool UserInfo::has_location() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserInfo::set_has_location() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserInfo::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& UserInfo::location() const {
  return *location_;
}
inline void UserInfo::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserInfo::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserInfo::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* UserInfo::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 9;
inline bool UserInfo::has_address() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserInfo::set_has_address() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserInfo::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& UserInfo::address() const {
  return *address_;
}
inline void UserInfo::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserInfo::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void UserInfo::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* UserInfo::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.GroupInfo guild = 10;
inline bool UserInfo::has_guild() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserInfo::set_has_guild() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserInfo::clear_has_guild() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserInfo::clear_guild() {
  if (guild_ != NULL) guild_->::pp::GroupInfo::Clear();
  clear_has_guild();
}
inline const ::pp::GroupInfo& UserInfo::guild() const {
  return guild_ != NULL ? *guild_ : *default_instance_->guild_;
}
inline ::pp::GroupInfo* UserInfo::mutable_guild() {
  set_has_guild();
  if (guild_ == NULL) guild_ = new ::pp::GroupInfo;
  return guild_;
}
inline ::pp::GroupInfo* UserInfo::release_guild() {
  clear_has_guild();
  ::pp::GroupInfo* temp = guild_;
  guild_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_guild(::pp::GroupInfo* guild) {
  delete guild_;
  guild_ = guild;
  if (guild) {
    set_has_guild();
  } else {
    clear_has_guild();
  }
}

// optional string mobilephone = 11;
inline bool UserInfo::has_mobilephone() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserInfo::set_has_mobilephone() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserInfo::clear_has_mobilephone() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserInfo::clear_mobilephone() {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    mobilephone_->clear();
  }
  clear_has_mobilephone();
}
inline const ::std::string& UserInfo::mobilephone() const {
  return *mobilephone_;
}
inline void UserInfo::set_mobilephone(const ::std::string& value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void UserInfo::set_mobilephone(const char* value) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(value);
}
inline void UserInfo::set_mobilephone(const char* value, size_t size) {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  mobilephone_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfo::mutable_mobilephone() {
  set_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    mobilephone_ = new ::std::string;
  }
  return mobilephone_;
}
inline ::std::string* UserInfo::release_mobilephone() {
  clear_has_mobilephone();
  if (mobilephone_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobilephone_;
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfo::set_allocated_mobilephone(::std::string* mobilephone) {
  if (mobilephone_ != &::google::protobuf::internal::kEmptyString) {
    delete mobilephone_;
  }
  if (mobilephone) {
    set_has_mobilephone();
    mobilephone_ = mobilephone;
  } else {
    clear_has_mobilephone();
    mobilephone_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserInfoProp prop = 14;
inline bool UserInfo::has_prop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserInfo::set_has_prop() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserInfo::clear_has_prop() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserInfo::clear_prop() {
  if (prop_ != NULL) prop_->::pp::UserInfoProp::Clear();
  clear_has_prop();
}
inline const ::pp::UserInfoProp& UserInfo::prop() const {
  return prop_ != NULL ? *prop_ : *default_instance_->prop_;
}
inline ::pp::UserInfoProp* UserInfo::mutable_prop() {
  set_has_prop();
  if (prop_ == NULL) prop_ = new ::pp::UserInfoProp;
  return prop_;
}
inline ::pp::UserInfoProp* UserInfo::release_prop() {
  clear_has_prop();
  ::pp::UserInfoProp* temp = prop_;
  prop_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_prop(::pp::UserInfoProp* prop) {
  delete prop_;
  prop_ = prop;
  if (prop) {
    set_has_prop();
  } else {
    clear_has_prop();
  }
}

// optional .pp.UserActiveData userActiveData = 20;
inline bool UserInfo::has_useractivedata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserInfo::set_has_useractivedata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserInfo::clear_has_useractivedata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserInfo::clear_useractivedata() {
  if (useractivedata_ != NULL) useractivedata_->::pp::UserActiveData::Clear();
  clear_has_useractivedata();
}
inline const ::pp::UserActiveData& UserInfo::useractivedata() const {
  return useractivedata_ != NULL ? *useractivedata_ : *default_instance_->useractivedata_;
}
inline ::pp::UserActiveData* UserInfo::mutable_useractivedata() {
  set_has_useractivedata();
  if (useractivedata_ == NULL) useractivedata_ = new ::pp::UserActiveData;
  return useractivedata_;
}
inline ::pp::UserActiveData* UserInfo::release_useractivedata() {
  clear_has_useractivedata();
  ::pp::UserActiveData* temp = useractivedata_;
  useractivedata_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_useractivedata(::pp::UserActiveData* useractivedata) {
  delete useractivedata_;
  useractivedata_ = useractivedata;
  if (useractivedata) {
    set_has_useractivedata();
  } else {
    clear_has_useractivedata();
  }
}

// optional uint64 searchResult = 21;
inline bool UserInfo::has_searchresult() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void UserInfo::set_has_searchresult() {
  _has_bits_[0] |= 0x00001000u;
}
inline void UserInfo::clear_has_searchresult() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void UserInfo::clear_searchresult() {
  searchresult_ = GOOGLE_ULONGLONG(0);
  clear_has_searchresult();
}
inline ::google::protobuf::uint64 UserInfo::searchresult() const {
  return searchresult_;
}
inline void UserInfo::set_searchresult(::google::protobuf::uint64 value) {
  set_has_searchresult();
  searchresult_ = value;
}

// optional double searchResultF = 22;
inline bool UserInfo::has_searchresultf() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void UserInfo::set_has_searchresultf() {
  _has_bits_[0] |= 0x00002000u;
}
inline void UserInfo::clear_has_searchresultf() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void UserInfo::clear_searchresultf() {
  searchresultf_ = 0;
  clear_has_searchresultf();
}
inline double UserInfo::searchresultf() const {
  return searchresultf_;
}
inline void UserInfo::set_searchresultf(double value) {
  set_has_searchresultf();
  searchresultf_ = value;
}

// optional int64 createtime = 50;
inline bool UserInfo::has_createtime() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void UserInfo::set_has_createtime() {
  _has_bits_[0] |= 0x00004000u;
}
inline void UserInfo::clear_has_createtime() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void UserInfo::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserInfo::createtime() const {
  return createtime_;
}
inline void UserInfo::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 roletype = 51;
inline bool UserInfo::has_roletype() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void UserInfo::set_has_roletype() {
  _has_bits_[0] |= 0x00008000u;
}
inline void UserInfo::clear_has_roletype() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void UserInfo::clear_roletype() {
  roletype_ = 0u;
  clear_has_roletype();
}
inline ::google::protobuf::uint32 UserInfo::roletype() const {
  return roletype_;
}
inline void UserInfo::set_roletype(::google::protobuf::uint32 value) {
  set_has_roletype();
  roletype_ = value;
}

// optional int64 loginTime = 52;
inline bool UserInfo::has_logintime() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void UserInfo::set_has_logintime() {
  _has_bits_[0] |= 0x00010000u;
}
inline void UserInfo::clear_has_logintime() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void UserInfo::clear_logintime() {
  logintime_ = GOOGLE_LONGLONG(0);
  clear_has_logintime();
}
inline ::google::protobuf::int64 UserInfo::logintime() const {
  return logintime_;
}
inline void UserInfo::set_logintime(::google::protobuf::int64 value) {
  set_has_logintime();
  logintime_ = value;
}

// optional .pp.AccountType accountType = 53;
inline bool UserInfo::has_accounttype() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void UserInfo::set_has_accounttype() {
  _has_bits_[0] |= 0x00020000u;
}
inline void UserInfo::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void UserInfo::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::pp::AccountType UserInfo::accounttype() const {
  return static_cast< ::pp::AccountType >(accounttype_);
}
inline void UserInfo::set_accounttype(::pp::AccountType value) {
  assert(::pp::AccountType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional .pp.UserForbidInfo forbid = 54;
inline bool UserInfo::has_forbid() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void UserInfo::set_has_forbid() {
  _has_bits_[0] |= 0x00040000u;
}
inline void UserInfo::clear_has_forbid() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void UserInfo::clear_forbid() {
  if (forbid_ != NULL) forbid_->::pp::UserForbidInfo::Clear();
  clear_has_forbid();
}
inline const ::pp::UserForbidInfo& UserInfo::forbid() const {
  return forbid_ != NULL ? *forbid_ : *default_instance_->forbid_;
}
inline ::pp::UserForbidInfo* UserInfo::mutable_forbid() {
  set_has_forbid();
  if (forbid_ == NULL) forbid_ = new ::pp::UserForbidInfo;
  return forbid_;
}
inline ::pp::UserForbidInfo* UserInfo::release_forbid() {
  clear_has_forbid();
  ::pp::UserForbidInfo* temp = forbid_;
  forbid_ = NULL;
  return temp;
}
inline void UserInfo::set_allocated_forbid(::pp::UserForbidInfo* forbid) {
  delete forbid_;
  forbid_ = forbid;
  if (forbid) {
    set_has_forbid();
  } else {
    clear_has_forbid();
  }
}

// optional int64 cookieTime = 55;
inline bool UserInfo::has_cookietime() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void UserInfo::set_has_cookietime() {
  _has_bits_[0] |= 0x00080000u;
}
inline void UserInfo::clear_has_cookietime() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void UserInfo::clear_cookietime() {
  cookietime_ = GOOGLE_LONGLONG(0);
  clear_has_cookietime();
}
inline ::google::protobuf::int64 UserInfo::cookietime() const {
  return cookietime_;
}
inline void UserInfo::set_cookietime(::google::protobuf::int64 value) {
  set_has_cookietime();
  cookietime_ = value;
}

// optional uint32 flags = 56;
inline bool UserInfo::has_flags() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void UserInfo::set_has_flags() {
  _has_bits_[0] |= 0x00100000u;
}
inline void UserInfo::clear_has_flags() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void UserInfo::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 UserInfo::flags() const {
  return flags_;
}
inline void UserInfo::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// optional uint64 yyuid = 60;
inline bool UserInfo::has_yyuid() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void UserInfo::set_has_yyuid() {
  _has_bits_[0] |= 0x00200000u;
}
inline void UserInfo::clear_has_yyuid() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void UserInfo::clear_yyuid() {
  yyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_yyuid();
}
inline ::google::protobuf::uint64 UserInfo::yyuid() const {
  return yyuid_;
}
inline void UserInfo::set_yyuid(::google::protobuf::uint64 value) {
  set_has_yyuid();
  yyuid_ = value;
}

// -------------------------------------------------------------------

// UserPasswordModifyReq

// required string newpassword = 1;
inline bool UserPasswordModifyReq::has_newpassword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPasswordModifyReq::set_has_newpassword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPasswordModifyReq::clear_has_newpassword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPasswordModifyReq::clear_newpassword() {
  if (newpassword_ != &::google::protobuf::internal::kEmptyString) {
    newpassword_->clear();
  }
  clear_has_newpassword();
}
inline const ::std::string& UserPasswordModifyReq::newpassword() const {
  return *newpassword_;
}
inline void UserPasswordModifyReq::set_newpassword(const ::std::string& value) {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  newpassword_->assign(value);
}
inline void UserPasswordModifyReq::set_newpassword(const char* value) {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  newpassword_->assign(value);
}
inline void UserPasswordModifyReq::set_newpassword(const char* value, size_t size) {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  newpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPasswordModifyReq::mutable_newpassword() {
  set_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    newpassword_ = new ::std::string;
  }
  return newpassword_;
}
inline ::std::string* UserPasswordModifyReq::release_newpassword() {
  clear_has_newpassword();
  if (newpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newpassword_;
    newpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPasswordModifyReq::set_allocated_newpassword(::std::string* newpassword) {
  if (newpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete newpassword_;
  }
  if (newpassword) {
    set_has_newpassword();
    newpassword_ = newpassword;
  } else {
    clear_has_newpassword();
    newpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string oldpassword = 2;
inline bool UserPasswordModifyReq::has_oldpassword() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPasswordModifyReq::set_has_oldpassword() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPasswordModifyReq::clear_has_oldpassword() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPasswordModifyReq::clear_oldpassword() {
  if (oldpassword_ != &::google::protobuf::internal::kEmptyString) {
    oldpassword_->clear();
  }
  clear_has_oldpassword();
}
inline const ::std::string& UserPasswordModifyReq::oldpassword() const {
  return *oldpassword_;
}
inline void UserPasswordModifyReq::set_oldpassword(const ::std::string& value) {
  set_has_oldpassword();
  if (oldpassword_ == &::google::protobuf::internal::kEmptyString) {
    oldpassword_ = new ::std::string;
  }
  oldpassword_->assign(value);
}
inline void UserPasswordModifyReq::set_oldpassword(const char* value) {
  set_has_oldpassword();
  if (oldpassword_ == &::google::protobuf::internal::kEmptyString) {
    oldpassword_ = new ::std::string;
  }
  oldpassword_->assign(value);
}
inline void UserPasswordModifyReq::set_oldpassword(const char* value, size_t size) {
  set_has_oldpassword();
  if (oldpassword_ == &::google::protobuf::internal::kEmptyString) {
    oldpassword_ = new ::std::string;
  }
  oldpassword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPasswordModifyReq::mutable_oldpassword() {
  set_has_oldpassword();
  if (oldpassword_ == &::google::protobuf::internal::kEmptyString) {
    oldpassword_ = new ::std::string;
  }
  return oldpassword_;
}
inline ::std::string* UserPasswordModifyReq::release_oldpassword() {
  clear_has_oldpassword();
  if (oldpassword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = oldpassword_;
    oldpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPasswordModifyReq::set_allocated_oldpassword(::std::string* oldpassword) {
  if (oldpassword_ != &::google::protobuf::internal::kEmptyString) {
    delete oldpassword_;
  }
  if (oldpassword) {
    set_has_oldpassword();
    oldpassword_ = oldpassword;
  } else {
    clear_has_oldpassword();
    oldpassword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserPasswordModifyRes

// optional string cookie = 1;
inline bool UserPasswordModifyRes::has_cookie() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPasswordModifyRes::set_has_cookie() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPasswordModifyRes::clear_has_cookie() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPasswordModifyRes::clear_cookie() {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    cookie_->clear();
  }
  clear_has_cookie();
}
inline const ::std::string& UserPasswordModifyRes::cookie() const {
  return *cookie_;
}
inline void UserPasswordModifyRes::set_cookie(const ::std::string& value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UserPasswordModifyRes::set_cookie(const char* value) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(value);
}
inline void UserPasswordModifyRes::set_cookie(const char* value, size_t size) {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  cookie_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPasswordModifyRes::mutable_cookie() {
  set_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    cookie_ = new ::std::string;
  }
  return cookie_;
}
inline ::std::string* UserPasswordModifyRes::release_cookie() {
  clear_has_cookie();
  if (cookie_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cookie_;
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPasswordModifyRes::set_allocated_cookie(::std::string* cookie) {
  if (cookie_ != &::google::protobuf::internal::kEmptyString) {
    delete cookie_;
  }
  if (cookie) {
    set_has_cookie();
    cookie_ = cookie;
  } else {
    clear_has_cookie();
    cookie_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserInfoModifyReq

// required .pp.UserInfo userinfo = 1;
inline bool UserInfoModifyReq::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoModifyReq::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoModifyReq::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoModifyReq::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& UserInfoModifyReq::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* UserInfoModifyReq::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* UserInfoModifyReq::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserInfoModifyReq::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// UserInfoModifyRes

// required .pp.UserInfo userinfo = 1;
inline bool UserInfoModifyRes::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoModifyRes::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoModifyRes::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoModifyRes::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& UserInfoModifyRes::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* UserInfoModifyRes::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* UserInfoModifyRes::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserInfoModifyRes::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// UserInfoReq

// required uint64 uid = 1;
inline bool UserInfoReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserInfoReq::uid() const {
  return uid_;
}
inline void UserInfoReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string nick = 2;
inline bool UserInfoReq::has_nick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoReq::set_has_nick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoReq::clear_has_nick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoReq::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& UserInfoReq::nick() const {
  return *nick_;
}
inline void UserInfoReq::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfoReq::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void UserInfoReq::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserInfoReq::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* UserInfoReq::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserInfoReq::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserInfo template = 3;
inline bool UserInfoReq::has_template_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserInfoReq::set_has_template_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserInfoReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserInfoReq::clear_template_() {
  if (template__ != NULL) template__->::pp::UserInfo::Clear();
  clear_has_template_();
}
inline const ::pp::UserInfo& UserInfoReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::UserInfo* UserInfoReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::UserInfo;
  return template__;
}
inline ::pp::UserInfo* UserInfoReq::release_template_() {
  clear_has_template_();
  ::pp::UserInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void UserInfoReq::set_allocated_template_(::pp::UserInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// optional uint64 yyuid = 4;
inline bool UserInfoReq::has_yyuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserInfoReq::set_has_yyuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserInfoReq::clear_has_yyuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserInfoReq::clear_yyuid() {
  yyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_yyuid();
}
inline ::google::protobuf::uint64 UserInfoReq::yyuid() const {
  return yyuid_;
}
inline void UserInfoReq::set_yyuid(::google::protobuf::uint64 value) {
  set_has_yyuid();
  yyuid_ = value;
}

// -------------------------------------------------------------------

// UserInfoRes

// required .pp.UserInfo userinfo = 1;
inline bool UserInfoRes::has_userinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserInfoRes::set_has_userinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserInfoRes::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserInfoRes::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& UserInfoRes::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* UserInfoRes::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* UserInfoRes::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserInfoRes::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// -------------------------------------------------------------------

// UserInfoListReq

// repeated uint64 uids = 1;
inline int UserInfoListReq::uids_size() const {
  return uids_.size();
}
inline void UserInfoListReq::clear_uids() {
  uids_.Clear();
}
inline ::google::protobuf::uint64 UserInfoListReq::uids(int index) const {
  return uids_.Get(index);
}
inline void UserInfoListReq::set_uids(int index, ::google::protobuf::uint64 value) {
  uids_.Set(index, value);
}
inline void UserInfoListReq::add_uids(::google::protobuf::uint64 value) {
  uids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UserInfoListReq::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UserInfoListReq::mutable_uids() {
  return &uids_;
}

// optional .pp.UserInfo template = 3;
inline bool UserInfoListReq::has_template_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserInfoListReq::set_has_template_() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserInfoListReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserInfoListReq::clear_template_() {
  if (template__ != NULL) template__->::pp::UserInfo::Clear();
  clear_has_template_();
}
inline const ::pp::UserInfo& UserInfoListReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::UserInfo* UserInfoListReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::UserInfo;
  return template__;
}
inline ::pp::UserInfo* UserInfoListReq::release_template_() {
  clear_has_template_();
  ::pp::UserInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void UserInfoListReq::set_allocated_template_(::pp::UserInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// -------------------------------------------------------------------

// UserInfoListRes

// repeated .pp.UserInfo users = 1;
inline int UserInfoListRes::users_size() const {
  return users_.size();
}
inline void UserInfoListRes::clear_users() {
  users_.Clear();
}
inline const ::pp::UserInfo& UserInfoListRes::users(int index) const {
  return users_.Get(index);
}
inline ::pp::UserInfo* UserInfoListRes::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::pp::UserInfo* UserInfoListRes::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
UserInfoListRes::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
UserInfoListRes::mutable_users() {
  return &users_;
}

// -------------------------------------------------------------------

// UserActiveDataReq

// optional uint64 userId = 1;
inline bool UserActiveDataReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserActiveDataReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserActiveDataReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserActiveDataReq::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UserActiveDataReq::userid() const {
  return userid_;
}
inline void UserActiveDataReq::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// UserActiveDataRes

// optional .pp.UserActiveData activeData = 1;
inline bool UserActiveDataRes::has_activedata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserActiveDataRes::set_has_activedata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserActiveDataRes::clear_has_activedata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserActiveDataRes::clear_activedata() {
  if (activedata_ != NULL) activedata_->::pp::UserActiveData::Clear();
  clear_has_activedata();
}
inline const ::pp::UserActiveData& UserActiveDataRes::activedata() const {
  return activedata_ != NULL ? *activedata_ : *default_instance_->activedata_;
}
inline ::pp::UserActiveData* UserActiveDataRes::mutable_activedata() {
  set_has_activedata();
  if (activedata_ == NULL) activedata_ = new ::pp::UserActiveData;
  return activedata_;
}
inline ::pp::UserActiveData* UserActiveDataRes::release_activedata() {
  clear_has_activedata();
  ::pp::UserActiveData* temp = activedata_;
  activedata_ = NULL;
  return temp;
}
inline void UserActiveDataRes::set_allocated_activedata(::pp::UserActiveData* activedata) {
  delete activedata_;
  activedata_ = activedata;
  if (activedata) {
    set_has_activedata();
  } else {
    clear_has_activedata();
  }
}

// -------------------------------------------------------------------

// UserActiveDataListReq

// repeated uint64 uids = 1;
inline int UserActiveDataListReq::uids_size() const {
  return uids_.size();
}
inline void UserActiveDataListReq::clear_uids() {
  uids_.Clear();
}
inline ::google::protobuf::uint64 UserActiveDataListReq::uids(int index) const {
  return uids_.Get(index);
}
inline void UserActiveDataListReq::set_uids(int index, ::google::protobuf::uint64 value) {
  uids_.Set(index, value);
}
inline void UserActiveDataListReq::add_uids(::google::protobuf::uint64 value) {
  uids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UserActiveDataListReq::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UserActiveDataListReq::mutable_uids() {
  return &uids_;
}

// -------------------------------------------------------------------

// UserActiveDataListRes

// repeated .pp.UserActiveData activeDataList = 1;
inline int UserActiveDataListRes::activedatalist_size() const {
  return activedatalist_.size();
}
inline void UserActiveDataListRes::clear_activedatalist() {
  activedatalist_.Clear();
}
inline const ::pp::UserActiveData& UserActiveDataListRes::activedatalist(int index) const {
  return activedatalist_.Get(index);
}
inline ::pp::UserActiveData* UserActiveDataListRes::mutable_activedatalist(int index) {
  return activedatalist_.Mutable(index);
}
inline ::pp::UserActiveData* UserActiveDataListRes::add_activedatalist() {
  return activedatalist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserActiveData >&
UserActiveDataListRes::activedatalist() const {
  return activedatalist_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserActiveData >*
UserActiveDataListRes::mutable_activedatalist() {
  return &activedatalist_;
}

// -------------------------------------------------------------------

// UserSearchReq

// optional string keyword = 1;
inline bool UserSearchReq::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSearchReq::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSearchReq::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSearchReq::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& UserSearchReq::keyword() const {
  return *keyword_;
}
inline void UserSearchReq::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void UserSearchReq::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void UserSearchReq::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSearchReq::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* UserSearchReq::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSearchReq::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 index = 2;
inline bool UserSearchReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSearchReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSearchReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSearchReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserSearchReq::index() const {
  return index_;
}
inline void UserSearchReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool UserSearchReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserSearchReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserSearchReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserSearchReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserSearchReq::fetchs() const {
  return fetchs_;
}
inline void UserSearchReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.SexType sex = 5;
inline bool UserSearchReq::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserSearchReq::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserSearchReq::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserSearchReq::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::pp::SexType UserSearchReq::sex() const {
  return static_cast< ::pp::SexType >(sex_);
}
inline void UserSearchReq::set_sex(::pp::SexType value) {
  assert(::pp::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// optional .pp.UserSearchBy searchby = 6;
inline bool UserSearchReq::has_searchby() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserSearchReq::set_has_searchby() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserSearchReq::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserSearchReq::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::UserSearchBy UserSearchReq::searchby() const {
  return static_cast< ::pp::UserSearchBy >(searchby_);
}
inline void UserSearchReq::set_searchby(::pp::UserSearchBy value) {
  assert(::pp::UserSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional .pp.UserSearchOrderBy orderby = 7;
inline bool UserSearchReq::has_orderby() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserSearchReq::set_has_orderby() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserSearchReq::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserSearchReq::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::UserSearchOrderBy UserSearchReq::orderby() const {
  return static_cast< ::pp::UserSearchOrderBy >(orderby_);
}
inline void UserSearchReq::set_orderby(::pp::UserSearchOrderBy value) {
  assert(::pp::UserSearchOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional string location = 8;
inline bool UserSearchReq::has_location() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserSearchReq::set_has_location() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserSearchReq::clear_has_location() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserSearchReq::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& UserSearchReq::location() const {
  return *location_;
}
inline void UserSearchReq::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserSearchReq::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserSearchReq::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSearchReq::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* UserSearchReq::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSearchReq::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool online = 9;
inline bool UserSearchReq::has_online() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserSearchReq::set_has_online() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserSearchReq::clear_has_online() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserSearchReq::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool UserSearchReq::online() const {
  return online_;
}
inline void UserSearchReq::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional bool showing = 10;
inline bool UserSearchReq::has_showing() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserSearchReq::set_has_showing() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserSearchReq::clear_has_showing() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserSearchReq::clear_showing() {
  showing_ = false;
  clear_has_showing();
}
inline bool UserSearchReq::showing() const {
  return showing_;
}
inline void UserSearchReq::set_showing(bool value) {
  set_has_showing();
  showing_ = value;
}

// optional int64 sortkey = 11;
inline bool UserSearchReq::has_sortkey() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserSearchReq::set_has_sortkey() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserSearchReq::clear_has_sortkey() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserSearchReq::clear_sortkey() {
  sortkey_ = GOOGLE_LONGLONG(0);
  clear_has_sortkey();
}
inline ::google::protobuf::int64 UserSearchReq::sortkey() const {
  return sortkey_;
}
inline void UserSearchReq::set_sortkey(::google::protobuf::int64 value) {
  set_has_sortkey();
  sortkey_ = value;
}

// optional .pp.UserInfo template = 20;
inline bool UserSearchReq::has_template_() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserSearchReq::set_has_template_() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserSearchReq::clear_has_template_() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserSearchReq::clear_template_() {
  if (template__ != NULL) template__->::pp::UserInfo::Clear();
  clear_has_template_();
}
inline const ::pp::UserInfo& UserSearchReq::template_() const {
  return template__ != NULL ? *template__ : *default_instance_->template__;
}
inline ::pp::UserInfo* UserSearchReq::mutable_template_() {
  set_has_template_();
  if (template__ == NULL) template__ = new ::pp::UserInfo;
  return template__;
}
inline ::pp::UserInfo* UserSearchReq::release_template_() {
  clear_has_template_();
  ::pp::UserInfo* temp = template__;
  template__ = NULL;
  return temp;
}
inline void UserSearchReq::set_allocated_template_(::pp::UserInfo* template_) {
  delete template__;
  template__ = template_;
  if (template_) {
    set_has_template_();
  } else {
    clear_has_template_();
  }
}

// -------------------------------------------------------------------

// UserSearchRes

// optional string keyword = 1;
inline bool UserSearchRes::has_keyword() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserSearchRes::set_has_keyword() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserSearchRes::clear_has_keyword() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserSearchRes::clear_keyword() {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    keyword_->clear();
  }
  clear_has_keyword();
}
inline const ::std::string& UserSearchRes::keyword() const {
  return *keyword_;
}
inline void UserSearchRes::set_keyword(const ::std::string& value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void UserSearchRes::set_keyword(const char* value) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(value);
}
inline void UserSearchRes::set_keyword(const char* value, size_t size) {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  keyword_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSearchRes::mutable_keyword() {
  set_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    keyword_ = new ::std::string;
  }
  return keyword_;
}
inline ::std::string* UserSearchRes::release_keyword() {
  clear_has_keyword();
  if (keyword_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = keyword_;
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSearchRes::set_allocated_keyword(::std::string* keyword) {
  if (keyword_ != &::google::protobuf::internal::kEmptyString) {
    delete keyword_;
  }
  if (keyword) {
    set_has_keyword();
    keyword_ = keyword;
  } else {
    clear_has_keyword();
    keyword_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 totalresults = 2;
inline bool UserSearchRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserSearchRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserSearchRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserSearchRes::clear_totalresults() {
  totalresults_ = 0u;
  clear_has_totalresults();
}
inline ::google::protobuf::uint32 UserSearchRes::totalresults() const {
  return totalresults_;
}
inline void UserSearchRes::set_totalresults(::google::protobuf::uint32 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// optional uint32 index = 3;
inline bool UserSearchRes::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserSearchRes::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserSearchRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserSearchRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserSearchRes::index() const {
  return index_;
}
inline void UserSearchRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// repeated .pp.UserInfo users = 4;
inline int UserSearchRes::users_size() const {
  return users_.size();
}
inline void UserSearchRes::clear_users() {
  users_.Clear();
}
inline const ::pp::UserInfo& UserSearchRes::users(int index) const {
  return users_.Get(index);
}
inline ::pp::UserInfo* UserSearchRes::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::pp::UserInfo* UserSearchRes::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
UserSearchRes::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
UserSearchRes::mutable_users() {
  return &users_;
}

// optional .pp.SexType sex = 5;
inline bool UserSearchRes::has_sex() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserSearchRes::set_has_sex() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserSearchRes::clear_has_sex() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserSearchRes::clear_sex() {
  sex_ = 0;
  clear_has_sex();
}
inline ::pp::SexType UserSearchRes::sex() const {
  return static_cast< ::pp::SexType >(sex_);
}
inline void UserSearchRes::set_sex(::pp::SexType value) {
  assert(::pp::SexType_IsValid(value));
  set_has_sex();
  sex_ = value;
}

// optional .pp.UserSearchBy searchby = 6;
inline bool UserSearchRes::has_searchby() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserSearchRes::set_has_searchby() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserSearchRes::clear_has_searchby() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserSearchRes::clear_searchby() {
  searchby_ = 0;
  clear_has_searchby();
}
inline ::pp::UserSearchBy UserSearchRes::searchby() const {
  return static_cast< ::pp::UserSearchBy >(searchby_);
}
inline void UserSearchRes::set_searchby(::pp::UserSearchBy value) {
  assert(::pp::UserSearchBy_IsValid(value));
  set_has_searchby();
  searchby_ = value;
}

// optional .pp.UserSearchOrderBy orderby = 7;
inline bool UserSearchRes::has_orderby() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserSearchRes::set_has_orderby() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserSearchRes::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserSearchRes::clear_orderby() {
  orderby_ = 0;
  clear_has_orderby();
}
inline ::pp::UserSearchOrderBy UserSearchRes::orderby() const {
  return static_cast< ::pp::UserSearchOrderBy >(orderby_);
}
inline void UserSearchRes::set_orderby(::pp::UserSearchOrderBy value) {
  assert(::pp::UserSearchOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional string location = 8;
inline bool UserSearchRes::has_location() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserSearchRes::set_has_location() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserSearchRes::clear_has_location() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserSearchRes::clear_location() {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    location_->clear();
  }
  clear_has_location();
}
inline const ::std::string& UserSearchRes::location() const {
  return *location_;
}
inline void UserSearchRes::set_location(const ::std::string& value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserSearchRes::set_location(const char* value) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(value);
}
inline void UserSearchRes::set_location(const char* value, size_t size) {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  location_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserSearchRes::mutable_location() {
  set_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    location_ = new ::std::string;
  }
  return location_;
}
inline ::std::string* UserSearchRes::release_location() {
  clear_has_location();
  if (location_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = location_;
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserSearchRes::set_allocated_location(::std::string* location) {
  if (location_ != &::google::protobuf::internal::kEmptyString) {
    delete location_;
  }
  if (location) {
    set_has_location();
    location_ = location;
  } else {
    clear_has_location();
    location_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool online = 9;
inline bool UserSearchRes::has_online() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserSearchRes::set_has_online() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserSearchRes::clear_has_online() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserSearchRes::clear_online() {
  online_ = false;
  clear_has_online();
}
inline bool UserSearchRes::online() const {
  return online_;
}
inline void UserSearchRes::set_online(bool value) {
  set_has_online();
  online_ = value;
}

// optional bool showing = 10;
inline bool UserSearchRes::has_showing() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void UserSearchRes::set_has_showing() {
  _has_bits_[0] |= 0x00000200u;
}
inline void UserSearchRes::clear_has_showing() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void UserSearchRes::clear_showing() {
  showing_ = false;
  clear_has_showing();
}
inline bool UserSearchRes::showing() const {
  return showing_;
}
inline void UserSearchRes::set_showing(bool value) {
  set_has_showing();
  showing_ = value;
}

// optional uint32 fetchs = 11;
inline bool UserSearchRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void UserSearchRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000400u;
}
inline void UserSearchRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void UserSearchRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserSearchRes::fetchs() const {
  return fetchs_;
}
inline void UserSearchRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional int64 sortkey = 12;
inline bool UserSearchRes::has_sortkey() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void UserSearchRes::set_has_sortkey() {
  _has_bits_[0] |= 0x00000800u;
}
inline void UserSearchRes::clear_has_sortkey() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void UserSearchRes::clear_sortkey() {
  sortkey_ = GOOGLE_LONGLONG(0);
  clear_has_sortkey();
}
inline ::google::protobuf::int64 UserSearchRes::sortkey() const {
  return sortkey_;
}
inline void UserSearchRes::set_sortkey(::google::protobuf::int64 value) {
  set_has_sortkey();
  sortkey_ = value;
}

// -------------------------------------------------------------------

// UserImageListReq

// required uint64 userId = 1;
inline bool UserImageListReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserImageListReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserImageListReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserImageListReq::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UserImageListReq::userid() const {
  return userid_;
}
inline void UserImageListReq::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional uint32 index = 2;
inline bool UserImageListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserImageListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserImageListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserImageListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserImageListReq::index() const {
  return index_;
}
inline void UserImageListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 3;
inline bool UserImageListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserImageListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserImageListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserImageListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserImageListReq::fetchs() const {
  return fetchs_;
}
inline void UserImageListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.UserImageOrderBy orderBy = 4 [default = UserImageOrderBy_Default];
inline bool UserImageListReq::has_orderby() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserImageListReq::set_has_orderby() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserImageListReq::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserImageListReq::clear_orderby() {
  orderby_ = 1;
  clear_has_orderby();
}
inline ::pp::UserImageOrderBy UserImageListReq::orderby() const {
  return static_cast< ::pp::UserImageOrderBy >(orderby_);
}
inline void UserImageListReq::set_orderby(::pp::UserImageOrderBy value) {
  assert(::pp::UserImageOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional .pp.UserImageType imageType = 5 [default = UserImageType_Default];
inline bool UserImageListReq::has_imagetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserImageListReq::set_has_imagetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserImageListReq::clear_has_imagetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserImageListReq::clear_imagetype() {
  imagetype_ = 0;
  clear_has_imagetype();
}
inline ::pp::UserImageType UserImageListReq::imagetype() const {
  return static_cast< ::pp::UserImageType >(imagetype_);
}
inline void UserImageListReq::set_imagetype(::pp::UserImageType value) {
  assert(::pp::UserImageType_IsValid(value));
  set_has_imagetype();
  imagetype_ = value;
}

// -------------------------------------------------------------------

// UserImageListRes

// required uint64 userId = 1;
inline bool UserImageListRes::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserImageListRes::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserImageListRes::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserImageListRes::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UserImageListRes::userid() const {
  return userid_;
}
inline void UserImageListRes::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional uint32 index = 2;
inline bool UserImageListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserImageListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserImageListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserImageListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserImageListRes::index() const {
  return index_;
}
inline void UserImageListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 3;
inline bool UserImageListRes::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserImageListRes::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserImageListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserImageListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserImageListRes::total() const {
  return total_;
}
inline void UserImageListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.UserImage images = 4;
inline int UserImageListRes::images_size() const {
  return images_.size();
}
inline void UserImageListRes::clear_images() {
  images_.Clear();
}
inline const ::pp::UserImage& UserImageListRes::images(int index) const {
  return images_.Get(index);
}
inline ::pp::UserImage* UserImageListRes::mutable_images(int index) {
  return images_.Mutable(index);
}
inline ::pp::UserImage* UserImageListRes::add_images() {
  return images_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserImage >&
UserImageListRes::images() const {
  return images_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserImage >*
UserImageListRes::mutable_images() {
  return &images_;
}

// optional .pp.UserImageOrderBy orderBy = 5 [default = UserImageOrderBy_Default];
inline bool UserImageListRes::has_orderby() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserImageListRes::set_has_orderby() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserImageListRes::clear_has_orderby() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserImageListRes::clear_orderby() {
  orderby_ = 1;
  clear_has_orderby();
}
inline ::pp::UserImageOrderBy UserImageListRes::orderby() const {
  return static_cast< ::pp::UserImageOrderBy >(orderby_);
}
inline void UserImageListRes::set_orderby(::pp::UserImageOrderBy value) {
  assert(::pp::UserImageOrderBy_IsValid(value));
  set_has_orderby();
  orderby_ = value;
}

// optional .pp.UserImageType imageType = 6 [default = UserImageType_Default];
inline bool UserImageListRes::has_imagetype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserImageListRes::set_has_imagetype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserImageListRes::clear_has_imagetype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserImageListRes::clear_imagetype() {
  imagetype_ = 0;
  clear_has_imagetype();
}
inline ::pp::UserImageType UserImageListRes::imagetype() const {
  return static_cast< ::pp::UserImageType >(imagetype_);
}
inline void UserImageListRes::set_imagetype(::pp::UserImageType value) {
  assert(::pp::UserImageType_IsValid(value));
  set_has_imagetype();
  imagetype_ = value;
}

// -------------------------------------------------------------------

// UserImage

// optional uint32 id = 1;
inline bool UserImage::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserImage::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserImage::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserImage::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 UserImage::id() const {
  return id_;
}
inline void UserImage::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 uid = 5;
inline bool UserImage::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserImage::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserImage::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserImage::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserImage::uid() const {
  return uid_;
}
inline void UserImage::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string url = 2;
inline bool UserImage::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserImage::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserImage::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserImage::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& UserImage::url() const {
  return *url_;
}
inline void UserImage::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void UserImage::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void UserImage::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserImage::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* UserImage::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserImage::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 likes = 3;
inline bool UserImage::has_likes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserImage::set_has_likes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserImage::clear_has_likes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserImage::clear_likes() {
  likes_ = 0u;
  clear_has_likes();
}
inline ::google::protobuf::uint32 UserImage::likes() const {
  return likes_;
}
inline void UserImage::set_likes(::google::protobuf::uint32 value) {
  set_has_likes();
  likes_ = value;
}

// optional bool mylike = 4;
inline bool UserImage::has_mylike() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserImage::set_has_mylike() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserImage::clear_has_mylike() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserImage::clear_mylike() {
  mylike_ = false;
  clear_has_mylike();
}
inline bool UserImage::mylike() const {
  return mylike_;
}
inline void UserImage::set_mylike(bool value) {
  set_has_mylike();
  mylike_ = value;
}

// -------------------------------------------------------------------

// UserImageOpReq

// optional .pp.UserImageOpReq.Type type = 1;
inline bool UserImageOpReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserImageOpReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserImageOpReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserImageOpReq::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pp::UserImageOpReq_Type UserImageOpReq::type() const {
  return static_cast< ::pp::UserImageOpReq_Type >(type_);
}
inline void UserImageOpReq::set_type(::pp::UserImageOpReq_Type value) {
  assert(::pp::UserImageOpReq_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated uint32 ids = 2;
inline int UserImageOpReq::ids_size() const {
  return ids_.size();
}
inline void UserImageOpReq::clear_ids() {
  ids_.Clear();
}
inline ::google::protobuf::uint32 UserImageOpReq::ids(int index) const {
  return ids_.Get(index);
}
inline void UserImageOpReq::set_ids(int index, ::google::protobuf::uint32 value) {
  ids_.Set(index, value);
}
inline void UserImageOpReq::add_ids(::google::protobuf::uint32 value) {
  ids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
UserImageOpReq::ids() const {
  return ids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
UserImageOpReq::mutable_ids() {
  return &ids_;
}

// repeated string urls = 3;
inline int UserImageOpReq::urls_size() const {
  return urls_.size();
}
inline void UserImageOpReq::clear_urls() {
  urls_.Clear();
}
inline const ::std::string& UserImageOpReq::urls(int index) const {
  return urls_.Get(index);
}
inline ::std::string* UserImageOpReq::mutable_urls(int index) {
  return urls_.Mutable(index);
}
inline void UserImageOpReq::set_urls(int index, const ::std::string& value) {
  urls_.Mutable(index)->assign(value);
}
inline void UserImageOpReq::set_urls(int index, const char* value) {
  urls_.Mutable(index)->assign(value);
}
inline void UserImageOpReq::set_urls(int index, const char* value, size_t size) {
  urls_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserImageOpReq::add_urls() {
  return urls_.Add();
}
inline void UserImageOpReq::add_urls(const ::std::string& value) {
  urls_.Add()->assign(value);
}
inline void UserImageOpReq::add_urls(const char* value) {
  urls_.Add()->assign(value);
}
inline void UserImageOpReq::add_urls(const char* value, size_t size) {
  urls_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserImageOpReq::urls() const {
  return urls_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserImageOpReq::mutable_urls() {
  return &urls_;
}

// optional uint64 uid = 4;
inline bool UserImageOpReq::has_uid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserImageOpReq::set_has_uid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserImageOpReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserImageOpReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserImageOpReq::uid() const {
  return uid_;
}
inline void UserImageOpReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional .pp.UserImageType imageType = 5 [default = UserImageType_Default];
inline bool UserImageOpReq::has_imagetype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserImageOpReq::set_has_imagetype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserImageOpReq::clear_has_imagetype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserImageOpReq::clear_imagetype() {
  imagetype_ = 0;
  clear_has_imagetype();
}
inline ::pp::UserImageType UserImageOpReq::imagetype() const {
  return static_cast< ::pp::UserImageType >(imagetype_);
}
inline void UserImageOpReq::set_imagetype(::pp::UserImageType value) {
  assert(::pp::UserImageType_IsValid(value));
  set_has_imagetype();
  imagetype_ = value;
}

// -------------------------------------------------------------------

// UserImageOpRes

// -------------------------------------------------------------------

// UserImageLikeReq

// required uint64 likeUserId = 1;
inline bool UserImageLikeReq::has_likeuserid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserImageLikeReq::set_has_likeuserid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserImageLikeReq::clear_has_likeuserid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserImageLikeReq::clear_likeuserid() {
  likeuserid_ = GOOGLE_ULONGLONG(0);
  clear_has_likeuserid();
}
inline ::google::protobuf::uint64 UserImageLikeReq::likeuserid() const {
  return likeuserid_;
}
inline void UserImageLikeReq::set_likeuserid(::google::protobuf::uint64 value) {
  set_has_likeuserid();
  likeuserid_ = value;
}

// required uint32 imageId = 2;
inline bool UserImageLikeReq::has_imageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserImageLikeReq::set_has_imageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserImageLikeReq::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserImageLikeReq::clear_imageid() {
  imageid_ = 0u;
  clear_has_imageid();
}
inline ::google::protobuf::uint32 UserImageLikeReq::imageid() const {
  return imageid_;
}
inline void UserImageLikeReq::set_imageid(::google::protobuf::uint32 value) {
  set_has_imageid();
  imageid_ = value;
}

// -------------------------------------------------------------------

// UserImageLikeRes

// required uint64 likeUserId = 1;
inline bool UserImageLikeRes::has_likeuserid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserImageLikeRes::set_has_likeuserid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserImageLikeRes::clear_has_likeuserid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserImageLikeRes::clear_likeuserid() {
  likeuserid_ = GOOGLE_ULONGLONG(0);
  clear_has_likeuserid();
}
inline ::google::protobuf::uint64 UserImageLikeRes::likeuserid() const {
  return likeuserid_;
}
inline void UserImageLikeRes::set_likeuserid(::google::protobuf::uint64 value) {
  set_has_likeuserid();
  likeuserid_ = value;
}

// required uint32 imageId = 2;
inline bool UserImageLikeRes::has_imageid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserImageLikeRes::set_has_imageid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserImageLikeRes::clear_has_imageid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserImageLikeRes::clear_imageid() {
  imageid_ = 0u;
  clear_has_imageid();
}
inline ::google::protobuf::uint32 UserImageLikeRes::imageid() const {
  return imageid_;
}
inline void UserImageLikeRes::set_imageid(::google::protobuf::uint32 value) {
  set_has_imageid();
  imageid_ = value;
}

// optional uint32 total = 3;
inline bool UserImageLikeRes::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserImageLikeRes::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserImageLikeRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserImageLikeRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserImageLikeRes::total() const {
  return total_;
}
inline void UserImageLikeRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// -------------------------------------------------------------------

// UserShowShareReq

// optional string shareinfo = 1;
inline bool UserShowShareReq::has_shareinfo() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserShowShareReq::set_has_shareinfo() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserShowShareReq::clear_has_shareinfo() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserShowShareReq::clear_shareinfo() {
  if (shareinfo_ != &::google::protobuf::internal::kEmptyString) {
    shareinfo_->clear();
  }
  clear_has_shareinfo();
}
inline const ::std::string& UserShowShareReq::shareinfo() const {
  return *shareinfo_;
}
inline void UserShowShareReq::set_shareinfo(const ::std::string& value) {
  set_has_shareinfo();
  if (shareinfo_ == &::google::protobuf::internal::kEmptyString) {
    shareinfo_ = new ::std::string;
  }
  shareinfo_->assign(value);
}
inline void UserShowShareReq::set_shareinfo(const char* value) {
  set_has_shareinfo();
  if (shareinfo_ == &::google::protobuf::internal::kEmptyString) {
    shareinfo_ = new ::std::string;
  }
  shareinfo_->assign(value);
}
inline void UserShowShareReq::set_shareinfo(const char* value, size_t size) {
  set_has_shareinfo();
  if (shareinfo_ == &::google::protobuf::internal::kEmptyString) {
    shareinfo_ = new ::std::string;
  }
  shareinfo_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserShowShareReq::mutable_shareinfo() {
  set_has_shareinfo();
  if (shareinfo_ == &::google::protobuf::internal::kEmptyString) {
    shareinfo_ = new ::std::string;
  }
  return shareinfo_;
}
inline ::std::string* UserShowShareReq::release_shareinfo() {
  clear_has_shareinfo();
  if (shareinfo_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = shareinfo_;
    shareinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserShowShareReq::set_allocated_shareinfo(::std::string* shareinfo) {
  if (shareinfo_ != &::google::protobuf::internal::kEmptyString) {
    delete shareinfo_;
  }
  if (shareinfo) {
    set_has_shareinfo();
    shareinfo_ = shareinfo;
  } else {
    clear_has_shareinfo();
    shareinfo_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserShowShareRes

// -------------------------------------------------------------------

// UserRecommendRegisterReq

// required uint64 ruid = 1;
inline bool UserRecommendRegisterReq::has_ruid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRecommendRegisterReq::set_has_ruid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRecommendRegisterReq::clear_has_ruid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRecommendRegisterReq::clear_ruid() {
  ruid_ = GOOGLE_ULONGLONG(0);
  clear_has_ruid();
}
inline ::google::protobuf::uint64 UserRecommendRegisterReq::ruid() const {
  return ruid_;
}
inline void UserRecommendRegisterReq::set_ruid(::google::protobuf::uint64 value) {
  set_has_ruid();
  ruid_ = value;
}

// -------------------------------------------------------------------

// UserRecommendRegisterRes

// required uint64 ruid = 1;
inline bool UserRecommendRegisterRes::has_ruid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRecommendRegisterRes::set_has_ruid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRecommendRegisterRes::clear_has_ruid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRecommendRegisterRes::clear_ruid() {
  ruid_ = GOOGLE_ULONGLONG(0);
  clear_has_ruid();
}
inline ::google::protobuf::uint64 UserRecommendRegisterRes::ruid() const {
  return ruid_;
}
inline void UserRecommendRegisterRes::set_ruid(::google::protobuf::uint64 value) {
  set_has_ruid();
  ruid_ = value;
}

// -------------------------------------------------------------------

// UserRefererListReq

// optional uint32 index = 1;
inline bool UserRefererListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserRefererListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserRefererListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserRefererListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserRefererListReq::index() const {
  return index_;
}
inline void UserRefererListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 2;
inline bool UserRefererListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRefererListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRefererListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRefererListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserRefererListReq::fetchs() const {
  return fetchs_;
}
inline void UserRefererListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// UserRefererListRes

// repeated .pp.UserInfo users = 1;
inline int UserRefererListRes::users_size() const {
  return users_.size();
}
inline void UserRefererListRes::clear_users() {
  users_.Clear();
}
inline const ::pp::UserInfo& UserRefererListRes::users(int index) const {
  return users_.Get(index);
}
inline ::pp::UserInfo* UserRefererListRes::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::pp::UserInfo* UserRefererListRes::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >&
UserRefererListRes::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserInfo >*
UserRefererListRes::mutable_users() {
  return &users_;
}

// optional uint32 index = 2;
inline bool UserRefererListRes::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserRefererListRes::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserRefererListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserRefererListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserRefererListRes::index() const {
  return index_;
}
inline void UserRefererListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 total = 3;
inline bool UserRefererListRes::has_total() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserRefererListRes::set_has_total() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserRefererListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserRefererListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserRefererListRes::total() const {
  return total_;
}
inline void UserRefererListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// optional uint32 totalCoins = 4;
inline bool UserRefererListRes::has_totalcoins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserRefererListRes::set_has_totalcoins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserRefererListRes::clear_has_totalcoins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserRefererListRes::clear_totalcoins() {
  totalcoins_ = 0u;
  clear_has_totalcoins();
}
inline ::google::protobuf::uint32 UserRefererListRes::totalcoins() const {
  return totalcoins_;
}
inline void UserRefererListRes::set_totalcoins(::google::protobuf::uint32 value) {
  set_has_totalcoins();
  totalcoins_ = value;
}

// -------------------------------------------------------------------

// UserProductListReq

// required uint32 index = 1;
inline bool UserProductListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserProductListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserProductListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserProductListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserProductListReq::index() const {
  return index_;
}
inline void UserProductListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool UserProductListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserProductListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserProductListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserProductListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserProductListReq::fetchs() const {
  return fetchs_;
}
inline void UserProductListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// UserProductListRes

// required uint32 index = 1;
inline bool UserProductListRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserProductListRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserProductListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserProductListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 UserProductListRes::index() const {
  return index_;
}
inline void UserProductListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 total = 2;
inline bool UserProductListRes::has_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserProductListRes::set_has_total() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserProductListRes::clear_has_total() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserProductListRes::clear_total() {
  total_ = 0u;
  clear_has_total();
}
inline ::google::protobuf::uint32 UserProductListRes::total() const {
  return total_;
}
inline void UserProductListRes::set_total(::google::protobuf::uint32 value) {
  set_has_total();
  total_ = value;
}

// repeated .pp.UserProduct userProducts = 3;
inline int UserProductListRes::userproducts_size() const {
  return userproducts_.size();
}
inline void UserProductListRes::clear_userproducts() {
  userproducts_.Clear();
}
inline const ::pp::UserProduct& UserProductListRes::userproducts(int index) const {
  return userproducts_.Get(index);
}
inline ::pp::UserProduct* UserProductListRes::mutable_userproducts(int index) {
  return userproducts_.Mutable(index);
}
inline ::pp::UserProduct* UserProductListRes::add_userproducts() {
  return userproducts_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserProduct >&
UserProductListRes::userproducts() const {
  return userproducts_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserProduct >*
UserProductListRes::mutable_userproducts() {
  return &userproducts_;
}

// -------------------------------------------------------------------

// UserProduct

// optional .pp.ProductInfo product = 1;
inline bool UserProduct::has_product() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserProduct::set_has_product() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserProduct::clear_has_product() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserProduct::clear_product() {
  if (product_ != NULL) product_->::pp::ProductInfo::Clear();
  clear_has_product();
}
inline const ::pp::ProductInfo& UserProduct::product() const {
  return product_ != NULL ? *product_ : *default_instance_->product_;
}
inline ::pp::ProductInfo* UserProduct::mutable_product() {
  set_has_product();
  if (product_ == NULL) product_ = new ::pp::ProductInfo;
  return product_;
}
inline ::pp::ProductInfo* UserProduct::release_product() {
  clear_has_product();
  ::pp::ProductInfo* temp = product_;
  product_ = NULL;
  return temp;
}
inline void UserProduct::set_allocated_product(::pp::ProductInfo* product) {
  delete product_;
  product_ = product;
  if (product) {
    set_has_product();
  } else {
    clear_has_product();
  }
}

// optional uint32 num = 2;
inline bool UserProduct::has_num() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserProduct::set_has_num() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserProduct::clear_has_num() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserProduct::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 UserProduct::num() const {
  return num_;
}
inline void UserProduct::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional sint64 createTime = 3;
inline bool UserProduct::has_createtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserProduct::set_has_createtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserProduct::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserProduct::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 UserProduct::createtime() const {
  return createtime_;
}
inline void UserProduct::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 money = 4;
inline bool UserProduct::has_money() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserProduct::set_has_money() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserProduct::clear_has_money() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserProduct::clear_money() {
  money_ = 0u;
  clear_has_money();
}
inline ::google::protobuf::uint32 UserProduct::money() const {
  return money_;
}
inline void UserProduct::set_money(::google::protobuf::uint32 value) {
  set_has_money();
  money_ = value;
}

// optional .pp.UserTradeRecord.Type type = 5;
inline bool UserProduct::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserProduct::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserProduct::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserProduct::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::pp::UserTradeRecord_Type UserProduct::type() const {
  return static_cast< ::pp::UserTradeRecord_Type >(type_);
}
inline void UserProduct::set_type(::pp::UserTradeRecord_Type value) {
  assert(::pp::UserTradeRecord_Type_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// UserStatDataReq

// required uint64 userId = 1;
inline bool UserStatDataReq::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatDataReq::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatDataReq::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatDataReq::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UserStatDataReq::userid() const {
  return userid_;
}
inline void UserStatDataReq::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// -------------------------------------------------------------------

// UserStatDataRes

// required uint64 userId = 1;
inline bool UserStatDataRes::has_userid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserStatDataRes::set_has_userid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserStatDataRes::clear_has_userid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserStatDataRes::clear_userid() {
  userid_ = GOOGLE_ULONGLONG(0);
  clear_has_userid();
}
inline ::google::protobuf::uint64 UserStatDataRes::userid() const {
  return userid_;
}
inline void UserStatDataRes::set_userid(::google::protobuf::uint64 value) {
  set_has_userid();
  userid_ = value;
}

// optional uint32 fans = 2;
inline bool UserStatDataRes::has_fans() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserStatDataRes::set_has_fans() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserStatDataRes::clear_has_fans() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserStatDataRes::clear_fans() {
  fans_ = 0u;
  clear_has_fans();
}
inline ::google::protobuf::uint32 UserStatDataRes::fans() const {
  return fans_;
}
inline void UserStatDataRes::set_fans(::google::protobuf::uint32 value) {
  set_has_fans();
  fans_ = value;
}

// optional uint32 giftTotal = 3;
inline bool UserStatDataRes::has_gifttotal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserStatDataRes::set_has_gifttotal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserStatDataRes::clear_has_gifttotal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserStatDataRes::clear_gifttotal() {
  gifttotal_ = 0u;
  clear_has_gifttotal();
}
inline ::google::protobuf::uint32 UserStatDataRes::gifttotal() const {
  return gifttotal_;
}
inline void UserStatDataRes::set_gifttotal(::google::protobuf::uint32 value) {
  set_has_gifttotal();
  gifttotal_ = value;
}

// optional uint32 imageLikes = 4;
inline bool UserStatDataRes::has_imagelikes() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserStatDataRes::set_has_imagelikes() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserStatDataRes::clear_has_imagelikes() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserStatDataRes::clear_imagelikes() {
  imagelikes_ = 0u;
  clear_has_imagelikes();
}
inline ::google::protobuf::uint32 UserStatDataRes::imagelikes() const {
  return imagelikes_;
}
inline void UserStatDataRes::set_imagelikes(::google::protobuf::uint32 value) {
  set_has_imagelikes();
  imagelikes_ = value;
}

// optional uint32 imageTotal = 5;
inline bool UserStatDataRes::has_imagetotal() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserStatDataRes::set_has_imagetotal() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserStatDataRes::clear_has_imagetotal() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserStatDataRes::clear_imagetotal() {
  imagetotal_ = 0u;
  clear_has_imagetotal();
}
inline ::google::protobuf::uint32 UserStatDataRes::imagetotal() const {
  return imagetotal_;
}
inline void UserStatDataRes::set_imagetotal(::google::protobuf::uint32 value) {
  set_has_imagetotal();
  imagetotal_ = value;
}

// optional uint32 follows = 6;
inline bool UserStatDataRes::has_follows() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserStatDataRes::set_has_follows() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserStatDataRes::clear_has_follows() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserStatDataRes::clear_follows() {
  follows_ = 0u;
  clear_has_follows();
}
inline ::google::protobuf::uint32 UserStatDataRes::follows() const {
  return follows_;
}
inline void UserStatDataRes::set_follows(::google::protobuf::uint32 value) {
  set_has_follows();
  follows_ = value;
}

// optional uint32 Songs = 7;
inline bool UserStatDataRes::has_songs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserStatDataRes::set_has_songs() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserStatDataRes::clear_has_songs() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserStatDataRes::clear_songs() {
  songs_ = 0u;
  clear_has_songs();
}
inline ::google::protobuf::uint32 UserStatDataRes::songs() const {
  return songs_;
}
inline void UserStatDataRes::set_songs(::google::protobuf::uint32 value) {
  set_has_songs();
  songs_ = value;
}

// -------------------------------------------------------------------

// UserProfileViewReq

// required uint64 uid = 1;
inline bool UserProfileViewReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserProfileViewReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserProfileViewReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserProfileViewReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserProfileViewReq::uid() const {
  return uid_;
}
inline void UserProfileViewReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// UserProfileViewRes

// required uint64 uid = 1;
inline bool UserProfileViewRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserProfileViewRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserProfileViewRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserProfileViewRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserProfileViewRes::uid() const {
  return uid_;
}
inline void UserProfileViewRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// AutoTaskUserListReq

// -------------------------------------------------------------------

// AutoTaskUserListRes

// repeated uint64 uids = 1;
inline int AutoTaskUserListRes::uids_size() const {
  return uids_.size();
}
inline void AutoTaskUserListRes::clear_uids() {
  uids_.Clear();
}
inline ::google::protobuf::uint64 AutoTaskUserListRes::uids(int index) const {
  return uids_.Get(index);
}
inline void AutoTaskUserListRes::set_uids(int index, ::google::protobuf::uint64 value) {
  uids_.Set(index, value);
}
inline void AutoTaskUserListRes::add_uids(::google::protobuf::uint64 value) {
  uids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
AutoTaskUserListRes::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
AutoTaskUserListRes::mutable_uids() {
  return &uids_;
}

// -------------------------------------------------------------------

// UserAppRateReq

// -------------------------------------------------------------------

// UserAppRateRes

// -------------------------------------------------------------------

// UserExpressAddrOpReq

// optional .pp.EntityOpType opType = 1 [default = EntityOpType_Add];
inline bool UserExpressAddrOpReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserExpressAddrOpReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserExpressAddrOpReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserExpressAddrOpReq::clear_optype() {
  optype_ = 1;
  clear_has_optype();
}
inline ::pp::EntityOpType UserExpressAddrOpReq::optype() const {
  return static_cast< ::pp::EntityOpType >(optype_);
}
inline void UserExpressAddrOpReq::set_optype(::pp::EntityOpType value) {
  assert(::pp::EntityOpType_IsValid(value));
  set_has_optype();
  optype_ = value;
}

// optional .pp.ExpressAddr entity = 2;
inline bool UserExpressAddrOpReq::has_entity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserExpressAddrOpReq::set_has_entity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserExpressAddrOpReq::clear_has_entity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserExpressAddrOpReq::clear_entity() {
  if (entity_ != NULL) entity_->::pp::ExpressAddr::Clear();
  clear_has_entity();
}
inline const ::pp::ExpressAddr& UserExpressAddrOpReq::entity() const {
  return entity_ != NULL ? *entity_ : *default_instance_->entity_;
}
inline ::pp::ExpressAddr* UserExpressAddrOpReq::mutable_entity() {
  set_has_entity();
  if (entity_ == NULL) entity_ = new ::pp::ExpressAddr;
  return entity_;
}
inline ::pp::ExpressAddr* UserExpressAddrOpReq::release_entity() {
  clear_has_entity();
  ::pp::ExpressAddr* temp = entity_;
  entity_ = NULL;
  return temp;
}
inline void UserExpressAddrOpReq::set_allocated_entity(::pp::ExpressAddr* entity) {
  delete entity_;
  entity_ = entity;
  if (entity) {
    set_has_entity();
  } else {
    clear_has_entity();
  }
}

// optional uint32 productId = 3;
inline bool UserExpressAddrOpReq::has_productid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserExpressAddrOpReq::set_has_productid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserExpressAddrOpReq::clear_has_productid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserExpressAddrOpReq::clear_productid() {
  productid_ = 0u;
  clear_has_productid();
}
inline ::google::protobuf::uint32 UserExpressAddrOpReq::productid() const {
  return productid_;
}
inline void UserExpressAddrOpReq::set_productid(::google::protobuf::uint32 value) {
  set_has_productid();
  productid_ = value;
}

// -------------------------------------------------------------------

// ExpressAddr

// optional uint32 id = 1;
inline bool ExpressAddr::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExpressAddr::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ExpressAddr::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ExpressAddr::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 ExpressAddr::id() const {
  return id_;
}
inline void ExpressAddr::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
}

// optional uint64 uid = 2;
inline bool ExpressAddr::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExpressAddr::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ExpressAddr::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ExpressAddr::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ExpressAddr::uid() const {
  return uid_;
}
inline void ExpressAddr::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string mobile = 3;
inline bool ExpressAddr::has_mobile() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExpressAddr::set_has_mobile() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ExpressAddr::clear_has_mobile() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ExpressAddr::clear_mobile() {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    mobile_->clear();
  }
  clear_has_mobile();
}
inline const ::std::string& ExpressAddr::mobile() const {
  return *mobile_;
}
inline void ExpressAddr::set_mobile(const ::std::string& value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void ExpressAddr::set_mobile(const char* value) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(value);
}
inline void ExpressAddr::set_mobile(const char* value, size_t size) {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  mobile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpressAddr::mutable_mobile() {
  set_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    mobile_ = new ::std::string;
  }
  return mobile_;
}
inline ::std::string* ExpressAddr::release_mobile() {
  clear_has_mobile();
  if (mobile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = mobile_;
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExpressAddr::set_allocated_mobile(::std::string* mobile) {
  if (mobile_ != &::google::protobuf::internal::kEmptyString) {
    delete mobile_;
  }
  if (mobile) {
    set_has_mobile();
    mobile_ = mobile;
  } else {
    clear_has_mobile();
    mobile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string QQ = 4;
inline bool ExpressAddr::has_qq() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExpressAddr::set_has_qq() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ExpressAddr::clear_has_qq() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ExpressAddr::clear_qq() {
  if (qq_ != &::google::protobuf::internal::kEmptyString) {
    qq_->clear();
  }
  clear_has_qq();
}
inline const ::std::string& ExpressAddr::qq() const {
  return *qq_;
}
inline void ExpressAddr::set_qq(const ::std::string& value) {
  set_has_qq();
  if (qq_ == &::google::protobuf::internal::kEmptyString) {
    qq_ = new ::std::string;
  }
  qq_->assign(value);
}
inline void ExpressAddr::set_qq(const char* value) {
  set_has_qq();
  if (qq_ == &::google::protobuf::internal::kEmptyString) {
    qq_ = new ::std::string;
  }
  qq_->assign(value);
}
inline void ExpressAddr::set_qq(const char* value, size_t size) {
  set_has_qq();
  if (qq_ == &::google::protobuf::internal::kEmptyString) {
    qq_ = new ::std::string;
  }
  qq_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpressAddr::mutable_qq() {
  set_has_qq();
  if (qq_ == &::google::protobuf::internal::kEmptyString) {
    qq_ = new ::std::string;
  }
  return qq_;
}
inline ::std::string* ExpressAddr::release_qq() {
  clear_has_qq();
  if (qq_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = qq_;
    qq_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExpressAddr::set_allocated_qq(::std::string* qq) {
  if (qq_ != &::google::protobuf::internal::kEmptyString) {
    delete qq_;
  }
  if (qq) {
    set_has_qq();
    qq_ = qq;
  } else {
    clear_has_qq();
    qq_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string address = 5;
inline bool ExpressAddr::has_address() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExpressAddr::set_has_address() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ExpressAddr::clear_has_address() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ExpressAddr::clear_address() {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    address_->clear();
  }
  clear_has_address();
}
inline const ::std::string& ExpressAddr::address() const {
  return *address_;
}
inline void ExpressAddr::set_address(const ::std::string& value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ExpressAddr::set_address(const char* value) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(value);
}
inline void ExpressAddr::set_address(const char* value, size_t size) {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  address_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ExpressAddr::mutable_address() {
  set_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    address_ = new ::std::string;
  }
  return address_;
}
inline ::std::string* ExpressAddr::release_address() {
  clear_has_address();
  if (address_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = address_;
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ExpressAddr::set_allocated_address(::std::string* address) {
  if (address_ != &::google::protobuf::internal::kEmptyString) {
    delete address_;
  }
  if (address) {
    set_has_address();
    address_ = address;
  } else {
    clear_has_address();
    address_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserExpressAddrOpRes

// -------------------------------------------------------------------

// UserThirdPartyAccountReq

// required uint64 uid = 1;
inline bool UserThirdPartyAccountReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserThirdPartyAccountReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserThirdPartyAccountReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserThirdPartyAccountReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserThirdPartyAccountReq::uid() const {
  return uid_;
}
inline void UserThirdPartyAccountReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// UserThirdPartyAccountRes

// required uint64 uid = 1;
inline bool UserThirdPartyAccountRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserThirdPartyAccountRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserThirdPartyAccountRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserThirdPartyAccountRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserThirdPartyAccountRes::uid() const {
  return uid_;
}
inline void UserThirdPartyAccountRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional .pp.AccountType accountType = 2;
inline bool UserThirdPartyAccountRes::has_accounttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserThirdPartyAccountRes::set_has_accounttype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserThirdPartyAccountRes::clear_has_accounttype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserThirdPartyAccountRes::clear_accounttype() {
  accounttype_ = 0;
  clear_has_accounttype();
}
inline ::pp::AccountType UserThirdPartyAccountRes::accounttype() const {
  return static_cast< ::pp::AccountType >(accounttype_);
}
inline void UserThirdPartyAccountRes::set_accounttype(::pp::AccountType value) {
  assert(::pp::AccountType_IsValid(value));
  set_has_accounttype();
  accounttype_ = value;
}

// optional uint64 thridPartyUid = 3;
inline bool UserThirdPartyAccountRes::has_thridpartyuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserThirdPartyAccountRes::set_has_thridpartyuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserThirdPartyAccountRes::clear_has_thridpartyuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserThirdPartyAccountRes::clear_thridpartyuid() {
  thridpartyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_thridpartyuid();
}
inline ::google::protobuf::uint64 UserThirdPartyAccountRes::thridpartyuid() const {
  return thridpartyuid_;
}
inline void UserThirdPartyAccountRes::set_thridpartyuid(::google::protobuf::uint64 value) {
  set_has_thridpartyuid();
  thridpartyuid_ = value;
}

// -------------------------------------------------------------------

// UserMsgReq

// optional uint64 uid = 1;
inline bool UserMsgReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserMsgReq::uid() const {
  return uid_;
}
inline void UserMsgReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 revision = 2;
inline bool UserMsgReq::has_revision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsgReq::set_has_revision() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsgReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsgReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 UserMsgReq::revision() const {
  return revision_;
}
inline void UserMsgReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint32 fetchs = 3;
inline bool UserMsgReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMsgReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMsgReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMsgReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 UserMsgReq::fetchs() const {
  return fetchs_;
}
inline void UserMsgReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional uint32 topn = 4;
inline bool UserMsgReq::has_topn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMsgReq::set_has_topn() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMsgReq::clear_has_topn() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMsgReq::clear_topn() {
  topn_ = 0u;
  clear_has_topn();
}
inline ::google::protobuf::uint32 UserMsgReq::topn() const {
  return topn_;
}
inline void UserMsgReq::set_topn(::google::protobuf::uint32 value) {
  set_has_topn();
  topn_ = value;
}

// -------------------------------------------------------------------

// UserMsgListReq

// repeated .pp.UserMsgReq users = 1;
inline int UserMsgListReq::users_size() const {
  return users_.size();
}
inline void UserMsgListReq::clear_users() {
  users_.Clear();
}
inline const ::pp::UserMsgReq& UserMsgListReq::users(int index) const {
  return users_.Get(index);
}
inline ::pp::UserMsgReq* UserMsgListReq::mutable_users(int index) {
  return users_.Mutable(index);
}
inline ::pp::UserMsgReq* UserMsgListReq::add_users() {
  return users_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserMsgReq >&
UserMsgListReq::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserMsgReq >*
UserMsgListReq::mutable_users() {
  return &users_;
}

// optional bool newmsg = 2;
inline bool UserMsgListReq::has_newmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsgListReq::set_has_newmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsgListReq::clear_has_newmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsgListReq::clear_newmsg() {
  newmsg_ = false;
  clear_has_newmsg();
}
inline bool UserMsgListReq::newmsg() const {
  return newmsg_;
}
inline void UserMsgListReq::set_newmsg(bool value) {
  set_has_newmsg();
  newmsg_ = value;
}

// -------------------------------------------------------------------

// UserMsg

// optional uint64 revision = 1;
inline bool UserMsg::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsg::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsg::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsg::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 UserMsg::revision() const {
  return revision_;
}
inline void UserMsg::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional string message = 2;
inline bool UserMsg::has_message() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsg::set_has_message() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsg::clear_has_message() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsg::clear_message() {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    message_->clear();
  }
  clear_has_message();
}
inline const ::std::string& UserMsg::message() const {
  return *message_;
}
inline void UserMsg::set_message(const ::std::string& value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void UserMsg::set_message(const char* value) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(value);
}
inline void UserMsg::set_message(const char* value, size_t size) {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserMsg::mutable_message() {
  set_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    message_ = new ::std::string;
  }
  return message_;
}
inline ::std::string* UserMsg::release_message() {
  clear_has_message();
  if (message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = message_;
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserMsg::set_allocated_message(::std::string* message) {
  if (message_ != &::google::protobuf::internal::kEmptyString) {
    delete message_;
  }
  if (message) {
    set_has_message();
    message_ = message;
  } else {
    clear_has_message();
    message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int64 timestamp = 3;
inline bool UserMsg::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMsg::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMsg::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMsg::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 UserMsg::timestamp() const {
  return timestamp_;
}
inline void UserMsg::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional .pp.UserMsgType msgtype = 5;
inline bool UserMsg::has_msgtype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMsg::set_has_msgtype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMsg::clear_has_msgtype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMsg::clear_msgtype() {
  msgtype_ = 0;
  clear_has_msgtype();
}
inline ::pp::UserMsgType UserMsg::msgtype() const {
  return static_cast< ::pp::UserMsgType >(msgtype_);
}
inline void UserMsg::set_msgtype(::pp::UserMsgType value) {
  assert(::pp::UserMsgType_IsValid(value));
  set_has_msgtype();
  msgtype_ = value;
}

// optional .pp.UserInfo userinfo = 6;
inline bool UserMsg::has_userinfo() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMsg::set_has_userinfo() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMsg::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMsg::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& UserMsg::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* UserMsg::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* UserMsg::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void UserMsg::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional uint64 gid = 9;
inline bool UserMsg::has_gid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMsg::set_has_gid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMsg::clear_has_gid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMsg::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 UserMsg::gid() const {
  return gid_;
}
inline void UserMsg::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional .pp.MessageContentType contentType = 10;
inline bool UserMsg::has_contenttype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserMsg::set_has_contenttype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserMsg::clear_has_contenttype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserMsg::clear_contenttype() {
  contenttype_ = 0;
  clear_has_contenttype();
}
inline ::pp::MessageContentType UserMsg::contenttype() const {
  return static_cast< ::pp::MessageContentType >(contenttype_);
}
inline void UserMsg::set_contenttype(::pp::MessageContentType value) {
  assert(::pp::MessageContentType_IsValid(value));
  set_has_contenttype();
  contenttype_ = value;
}

// optional int64 storetime = 11;
inline bool UserMsg::has_storetime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserMsg::set_has_storetime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserMsg::clear_has_storetime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserMsg::clear_storetime() {
  storetime_ = GOOGLE_LONGLONG(0);
  clear_has_storetime();
}
inline ::google::protobuf::int64 UserMsg::storetime() const {
  return storetime_;
}
inline void UserMsg::set_storetime(::google::protobuf::int64 value) {
  set_has_storetime();
  storetime_ = value;
}

// optional uint64 destuid = 12;
inline bool UserMsg::has_destuid() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserMsg::set_has_destuid() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserMsg::clear_has_destuid() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserMsg::clear_destuid() {
  destuid_ = GOOGLE_ULONGLONG(0);
  clear_has_destuid();
}
inline ::google::protobuf::uint64 UserMsg::destuid() const {
  return destuid_;
}
inline void UserMsg::set_destuid(::google::protobuf::uint64 value) {
  set_has_destuid();
  destuid_ = value;
}

// -------------------------------------------------------------------

// UserMsgList

// optional uint64 revision = 1;
inline bool UserMsgList::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgList::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgList::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgList::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 UserMsgList::revision() const {
  return revision_;
}
inline void UserMsgList::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 uid = 2;
inline bool UserMsgList::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsgList::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsgList::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsgList::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserMsgList::uid() const {
  return uid_;
}
inline void UserMsgList::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// repeated .pp.UserMsg msgs = 3;
inline int UserMsgList::msgs_size() const {
  return msgs_.size();
}
inline void UserMsgList::clear_msgs() {
  msgs_.Clear();
}
inline const ::pp::UserMsg& UserMsgList::msgs(int index) const {
  return msgs_.Get(index);
}
inline ::pp::UserMsg* UserMsgList::mutable_msgs(int index) {
  return msgs_.Mutable(index);
}
inline ::pp::UserMsg* UserMsgList::add_msgs() {
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserMsg >&
UserMsgList::msgs() const {
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserMsg >*
UserMsgList::mutable_msgs() {
  return &msgs_;
}

// optional uint64 msgread = 4;
inline bool UserMsgList::has_msgread() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMsgList::set_has_msgread() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMsgList::clear_has_msgread() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMsgList::clear_msgread() {
  msgread_ = GOOGLE_ULONGLONG(0);
  clear_has_msgread();
}
inline ::google::protobuf::uint64 UserMsgList::msgread() const {
  return msgread_;
}
inline void UserMsgList::set_msgread(::google::protobuf::uint64 value) {
  set_has_msgread();
  msgread_ = value;
}

// -------------------------------------------------------------------

// UserMsgListRes

// repeated .pp.UserMsgList msglists = 1;
inline int UserMsgListRes::msglists_size() const {
  return msglists_.size();
}
inline void UserMsgListRes::clear_msglists() {
  msglists_.Clear();
}
inline const ::pp::UserMsgList& UserMsgListRes::msglists(int index) const {
  return msglists_.Get(index);
}
inline ::pp::UserMsgList* UserMsgListRes::mutable_msglists(int index) {
  return msglists_.Mutable(index);
}
inline ::pp::UserMsgList* UserMsgListRes::add_msglists() {
  return msglists_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserMsgList >&
UserMsgListRes::msglists() const {
  return msglists_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserMsgList >*
UserMsgListRes::mutable_msglists() {
  return &msglists_;
}

// optional bool newmsg = 2;
inline bool UserMsgListRes::has_newmsg() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsgListRes::set_has_newmsg() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsgListRes::clear_has_newmsg() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsgListRes::clear_newmsg() {
  newmsg_ = false;
  clear_has_newmsg();
}
inline bool UserMsgListRes::newmsg() const {
  return newmsg_;
}
inline void UserMsgListRes::set_newmsg(bool value) {
  set_has_newmsg();
  newmsg_ = value;
}

// -------------------------------------------------------------------

// UidRange

// optional uint64 startValue = 1;
inline bool UidRange::has_startvalue() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UidRange::set_has_startvalue() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UidRange::clear_has_startvalue() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UidRange::clear_startvalue() {
  startvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_startvalue();
}
inline ::google::protobuf::uint64 UidRange::startvalue() const {
  return startvalue_;
}
inline void UidRange::set_startvalue(::google::protobuf::uint64 value) {
  set_has_startvalue();
  startvalue_ = value;
}

// optional uint64 stopValue = 2;
inline bool UidRange::has_stopvalue() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UidRange::set_has_stopvalue() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UidRange::clear_has_stopvalue() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UidRange::clear_stopvalue() {
  stopvalue_ = GOOGLE_ULONGLONG(0);
  clear_has_stopvalue();
}
inline ::google::protobuf::uint64 UidRange::stopvalue() const {
  return stopvalue_;
}
inline void UidRange::set_stopvalue(::google::protobuf::uint64 value) {
  set_has_stopvalue();
  stopvalue_ = value;
}

// -------------------------------------------------------------------

// UserMsgBroadcastReq

// optional .pp.UserMsg msg = 1;
inline bool UserMsgBroadcastReq::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgBroadcastReq::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgBroadcastReq::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgBroadcastReq::clear_msg() {
  if (msg_ != NULL) msg_->::pp::UserMsg::Clear();
  clear_has_msg();
}
inline const ::pp::UserMsg& UserMsgBroadcastReq::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::pp::UserMsg* UserMsgBroadcastReq::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::pp::UserMsg;
  return msg_;
}
inline ::pp::UserMsg* UserMsgBroadcastReq::release_msg() {
  clear_has_msg();
  ::pp::UserMsg* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void UserMsgBroadcastReq::set_allocated_msg(::pp::UserMsg* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// optional uint64 gid = 2;
inline bool UserMsgBroadcastReq::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsgBroadcastReq::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsgBroadcastReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsgBroadcastReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 UserMsgBroadcastReq::gid() const {
  return gid_;
}
inline void UserMsgBroadcastReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated .pp.UidRange uids = 3;
inline int UserMsgBroadcastReq::uids_size() const {
  return uids_.size();
}
inline void UserMsgBroadcastReq::clear_uids() {
  uids_.Clear();
}
inline const ::pp::UidRange& UserMsgBroadcastReq::uids(int index) const {
  return uids_.Get(index);
}
inline ::pp::UidRange* UserMsgBroadcastReq::mutable_uids(int index) {
  return uids_.Mutable(index);
}
inline ::pp::UidRange* UserMsgBroadcastReq::add_uids() {
  return uids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UidRange >&
UserMsgBroadcastReq::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UidRange >*
UserMsgBroadcastReq::mutable_uids() {
  return &uids_;
}

// optional .pp.BroadcastRange brange = 4;
inline bool UserMsgBroadcastReq::has_brange() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMsgBroadcastReq::set_has_brange() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMsgBroadcastReq::clear_has_brange() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMsgBroadcastReq::clear_brange() {
  brange_ = 0;
  clear_has_brange();
}
inline ::pp::BroadcastRange UserMsgBroadcastReq::brange() const {
  return static_cast< ::pp::BroadcastRange >(brange_);
}
inline void UserMsgBroadcastReq::set_brange(::pp::BroadcastRange value) {
  assert(::pp::BroadcastRange_IsValid(value));
  set_has_brange();
  brange_ = value;
}

// optional uint64 pushUid = 8;
inline bool UserMsgBroadcastReq::has_pushuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserMsgBroadcastReq::set_has_pushuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserMsgBroadcastReq::clear_has_pushuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserMsgBroadcastReq::clear_pushuid() {
  pushuid_ = GOOGLE_ULONGLONG(0);
  clear_has_pushuid();
}
inline ::google::protobuf::uint64 UserMsgBroadcastReq::pushuid() const {
  return pushuid_;
}
inline void UserMsgBroadcastReq::set_pushuid(::google::protobuf::uint64 value) {
  set_has_pushuid();
  pushuid_ = value;
}

// optional uint32 event = 9;
inline bool UserMsgBroadcastReq::has_event() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserMsgBroadcastReq::set_has_event() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserMsgBroadcastReq::clear_has_event() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserMsgBroadcastReq::clear_event() {
  event_ = 0u;
  clear_has_event();
}
inline ::google::protobuf::uint32 UserMsgBroadcastReq::event() const {
  return event_;
}
inline void UserMsgBroadcastReq::set_event(::google::protobuf::uint32 value) {
  set_has_event();
  event_ = value;
}

// optional int64 timelimit = 10;
inline bool UserMsgBroadcastReq::has_timelimit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserMsgBroadcastReq::set_has_timelimit() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserMsgBroadcastReq::clear_has_timelimit() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserMsgBroadcastReq::clear_timelimit() {
  timelimit_ = GOOGLE_LONGLONG(0);
  clear_has_timelimit();
}
inline ::google::protobuf::int64 UserMsgBroadcastReq::timelimit() const {
  return timelimit_;
}
inline void UserMsgBroadcastReq::set_timelimit(::google::protobuf::int64 value) {
  set_has_timelimit();
  timelimit_ = value;
}

// optional uint64 bid = 20;
inline bool UserMsgBroadcastReq::has_bid() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserMsgBroadcastReq::set_has_bid() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserMsgBroadcastReq::clear_has_bid() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserMsgBroadcastReq::clear_bid() {
  bid_ = GOOGLE_ULONGLONG(0);
  clear_has_bid();
}
inline ::google::protobuf::uint64 UserMsgBroadcastReq::bid() const {
  return bid_;
}
inline void UserMsgBroadcastReq::set_bid(::google::protobuf::uint64 value) {
  set_has_bid();
  bid_ = value;
}

// optional bool realtime = 30;
inline bool UserMsgBroadcastReq::has_realtime() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void UserMsgBroadcastReq::set_has_realtime() {
  _has_bits_[0] |= 0x00000100u;
}
inline void UserMsgBroadcastReq::clear_has_realtime() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void UserMsgBroadcastReq::clear_realtime() {
  realtime_ = false;
  clear_has_realtime();
}
inline bool UserMsgBroadcastReq::realtime() const {
  return realtime_;
}
inline void UserMsgBroadcastReq::set_realtime(bool value) {
  set_has_realtime();
  realtime_ = value;
}

// -------------------------------------------------------------------

// UserMsgRejectList

// optional bool all = 1;
inline bool UserMsgRejectList::has_all() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgRejectList::set_has_all() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgRejectList::clear_has_all() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgRejectList::clear_all() {
  all_ = false;
  clear_has_all();
}
inline bool UserMsgRejectList::all() const {
  return all_;
}
inline void UserMsgRejectList::set_all(bool value) {
  set_has_all();
  all_ = value;
}

// optional bool stranger = 2;
inline bool UserMsgRejectList::has_stranger() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserMsgRejectList::set_has_stranger() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserMsgRejectList::clear_has_stranger() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserMsgRejectList::clear_stranger() {
  stranger_ = false;
  clear_has_stranger();
}
inline bool UserMsgRejectList::stranger() const {
  return stranger_;
}
inline void UserMsgRejectList::set_stranger(bool value) {
  set_has_stranger();
  stranger_ = value;
}

// optional bool newfan = 3;
inline bool UserMsgRejectList::has_newfan() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserMsgRejectList::set_has_newfan() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserMsgRejectList::clear_has_newfan() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserMsgRejectList::clear_newfan() {
  newfan_ = false;
  clear_has_newfan();
}
inline bool UserMsgRejectList::newfan() const {
  return newfan_;
}
inline void UserMsgRejectList::set_newfan(bool value) {
  set_has_newfan();
  newfan_ = value;
}

// optional bool newgift = 4;
inline bool UserMsgRejectList::has_newgift() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserMsgRejectList::set_has_newgift() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserMsgRejectList::clear_has_newgift() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserMsgRejectList::clear_newgift() {
  newgift_ = false;
  clear_has_newgift();
}
inline bool UserMsgRejectList::newgift() const {
  return newgift_;
}
inline void UserMsgRejectList::set_newgift(bool value) {
  set_has_newgift();
  newgift_ = value;
}

// -------------------------------------------------------------------

// UserMsgRejectListSetReq

// optional .pp.UserMsgRejectList rejectlist = 1;
inline bool UserMsgRejectListSetReq::has_rejectlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgRejectListSetReq::set_has_rejectlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgRejectListSetReq::clear_has_rejectlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgRejectListSetReq::clear_rejectlist() {
  if (rejectlist_ != NULL) rejectlist_->::pp::UserMsgRejectList::Clear();
  clear_has_rejectlist();
}
inline const ::pp::UserMsgRejectList& UserMsgRejectListSetReq::rejectlist() const {
  return rejectlist_ != NULL ? *rejectlist_ : *default_instance_->rejectlist_;
}
inline ::pp::UserMsgRejectList* UserMsgRejectListSetReq::mutable_rejectlist() {
  set_has_rejectlist();
  if (rejectlist_ == NULL) rejectlist_ = new ::pp::UserMsgRejectList;
  return rejectlist_;
}
inline ::pp::UserMsgRejectList* UserMsgRejectListSetReq::release_rejectlist() {
  clear_has_rejectlist();
  ::pp::UserMsgRejectList* temp = rejectlist_;
  rejectlist_ = NULL;
  return temp;
}
inline void UserMsgRejectListSetReq::set_allocated_rejectlist(::pp::UserMsgRejectList* rejectlist) {
  delete rejectlist_;
  rejectlist_ = rejectlist;
  if (rejectlist) {
    set_has_rejectlist();
  } else {
    clear_has_rejectlist();
  }
}

// -------------------------------------------------------------------

// UserMsgRejectListSetRes

// optional .pp.UserMsgRejectList rejectlist = 1;
inline bool UserMsgRejectListSetRes::has_rejectlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgRejectListSetRes::set_has_rejectlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgRejectListSetRes::clear_has_rejectlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgRejectListSetRes::clear_rejectlist() {
  if (rejectlist_ != NULL) rejectlist_->::pp::UserMsgRejectList::Clear();
  clear_has_rejectlist();
}
inline const ::pp::UserMsgRejectList& UserMsgRejectListSetRes::rejectlist() const {
  return rejectlist_ != NULL ? *rejectlist_ : *default_instance_->rejectlist_;
}
inline ::pp::UserMsgRejectList* UserMsgRejectListSetRes::mutable_rejectlist() {
  set_has_rejectlist();
  if (rejectlist_ == NULL) rejectlist_ = new ::pp::UserMsgRejectList;
  return rejectlist_;
}
inline ::pp::UserMsgRejectList* UserMsgRejectListSetRes::release_rejectlist() {
  clear_has_rejectlist();
  ::pp::UserMsgRejectList* temp = rejectlist_;
  rejectlist_ = NULL;
  return temp;
}
inline void UserMsgRejectListSetRes::set_allocated_rejectlist(::pp::UserMsgRejectList* rejectlist) {
  delete rejectlist_;
  rejectlist_ = rejectlist;
  if (rejectlist) {
    set_has_rejectlist();
  } else {
    clear_has_rejectlist();
  }
}

// -------------------------------------------------------------------

// UserMsgRejectListGetReq

// -------------------------------------------------------------------

// UserMsgRejectListGetRes

// optional .pp.UserMsgRejectList rejectlist = 1;
inline bool UserMsgRejectListGetRes::has_rejectlist() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserMsgRejectListGetRes::set_has_rejectlist() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserMsgRejectListGetRes::clear_has_rejectlist() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserMsgRejectListGetRes::clear_rejectlist() {
  if (rejectlist_ != NULL) rejectlist_->::pp::UserMsgRejectList::Clear();
  clear_has_rejectlist();
}
inline const ::pp::UserMsgRejectList& UserMsgRejectListGetRes::rejectlist() const {
  return rejectlist_ != NULL ? *rejectlist_ : *default_instance_->rejectlist_;
}
inline ::pp::UserMsgRejectList* UserMsgRejectListGetRes::mutable_rejectlist() {
  set_has_rejectlist();
  if (rejectlist_ == NULL) rejectlist_ = new ::pp::UserMsgRejectList;
  return rejectlist_;
}
inline ::pp::UserMsgRejectList* UserMsgRejectListGetRes::release_rejectlist() {
  clear_has_rejectlist();
  ::pp::UserMsgRejectList* temp = rejectlist_;
  rejectlist_ = NULL;
  return temp;
}
inline void UserMsgRejectListGetRes::set_allocated_rejectlist(::pp::UserMsgRejectList* rejectlist) {
  delete rejectlist_;
  rejectlist_ = rejectlist;
  if (rejectlist) {
    set_has_rejectlist();
  } else {
    clear_has_rejectlist();
  }
}

// -------------------------------------------------------------------

// MsgReadItem

// optional uint64 gid = 1;
inline bool MsgReadItem::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReadItem::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReadItem::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgReadItem::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 MsgReadItem::gid() const {
  return gid_;
}
inline void MsgReadItem::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 uid = 2;
inline bool MsgReadItem::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgReadItem::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgReadItem::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgReadItem::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 MsgReadItem::uid() const {
  return uid_;
}
inline void MsgReadItem::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint64 revision = 3;
inline bool MsgReadItem::has_revision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgReadItem::set_has_revision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgReadItem::clear_has_revision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgReadItem::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 MsgReadItem::revision() const {
  return revision_;
}
inline void MsgReadItem::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// -------------------------------------------------------------------

// MsgReadRevisionSetReq

// repeated .pp.MsgReadItem items = 1;
inline int MsgReadRevisionSetReq::items_size() const {
  return items_.size();
}
inline void MsgReadRevisionSetReq::clear_items() {
  items_.Clear();
}
inline const ::pp::MsgReadItem& MsgReadRevisionSetReq::items(int index) const {
  return items_.Get(index);
}
inline ::pp::MsgReadItem* MsgReadRevisionSetReq::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::MsgReadItem* MsgReadRevisionSetReq::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >&
MsgReadRevisionSetReq::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >*
MsgReadRevisionSetReq::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// MsgReadRevisionSetRes

// repeated .pp.MsgReadItem items = 1;
inline int MsgReadRevisionSetRes::items_size() const {
  return items_.size();
}
inline void MsgReadRevisionSetRes::clear_items() {
  items_.Clear();
}
inline const ::pp::MsgReadItem& MsgReadRevisionSetRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::MsgReadItem* MsgReadRevisionSetRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::MsgReadItem* MsgReadRevisionSetRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >&
MsgReadRevisionSetRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >*
MsgReadRevisionSetRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// MsgReadRevisionGetReq

// optional bool contact = 1 [default = true];
inline bool MsgReadRevisionGetReq::has_contact() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReadRevisionGetReq::set_has_contact() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReadRevisionGetReq::clear_has_contact() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgReadRevisionGetReq::clear_contact() {
  contact_ = true;
  clear_has_contact();
}
inline bool MsgReadRevisionGetReq::contact() const {
  return contact_;
}
inline void MsgReadRevisionGetReq::set_contact(bool value) {
  set_has_contact();
  contact_ = value;
}

// optional bool group = 2 [default = true];
inline bool MsgReadRevisionGetReq::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgReadRevisionGetReq::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgReadRevisionGetReq::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgReadRevisionGetReq::clear_group() {
  group_ = true;
  clear_has_group();
}
inline bool MsgReadRevisionGetReq::group() const {
  return group_;
}
inline void MsgReadRevisionGetReq::set_group(bool value) {
  set_has_group();
  group_ = value;
}

// optional bool simple = 4 [default = false];
inline bool MsgReadRevisionGetReq::has_simple() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MsgReadRevisionGetReq::set_has_simple() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MsgReadRevisionGetReq::clear_has_simple() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MsgReadRevisionGetReq::clear_simple() {
  simple_ = false;
  clear_has_simple();
}
inline bool MsgReadRevisionGetReq::simple() const {
  return simple_;
}
inline void MsgReadRevisionGetReq::set_simple(bool value) {
  set_has_simple();
  simple_ = value;
}

// -------------------------------------------------------------------

// MsgReadRevisionGetRes

// optional bool contact = 1 [default = true];
inline bool MsgReadRevisionGetRes::has_contact() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgReadRevisionGetRes::set_has_contact() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgReadRevisionGetRes::clear_has_contact() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgReadRevisionGetRes::clear_contact() {
  contact_ = true;
  clear_has_contact();
}
inline bool MsgReadRevisionGetRes::contact() const {
  return contact_;
}
inline void MsgReadRevisionGetRes::set_contact(bool value) {
  set_has_contact();
  contact_ = value;
}

// optional bool group = 2 [default = true];
inline bool MsgReadRevisionGetRes::has_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgReadRevisionGetRes::set_has_group() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgReadRevisionGetRes::clear_has_group() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgReadRevisionGetRes::clear_group() {
  group_ = true;
  clear_has_group();
}
inline bool MsgReadRevisionGetRes::group() const {
  return group_;
}
inline void MsgReadRevisionGetRes::set_group(bool value) {
  set_has_group();
  group_ = value;
}

// repeated .pp.MsgReadItem items = 3;
inline int MsgReadRevisionGetRes::items_size() const {
  return items_.size();
}
inline void MsgReadRevisionGetRes::clear_items() {
  items_.Clear();
}
inline const ::pp::MsgReadItem& MsgReadRevisionGetRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::MsgReadItem* MsgReadRevisionGetRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::MsgReadItem* MsgReadRevisionGetRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >&
MsgReadRevisionGetRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::MsgReadItem >*
MsgReadRevisionGetRes::mutable_items() {
  return &items_;
}

// optional bool simple = 4 [default = false];
inline bool MsgReadRevisionGetRes::has_simple() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MsgReadRevisionGetRes::set_has_simple() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MsgReadRevisionGetRes::clear_has_simple() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MsgReadRevisionGetRes::clear_simple() {
  simple_ = false;
  clear_has_simple();
}
inline bool MsgReadRevisionGetRes::simple() const {
  return simple_;
}
inline void MsgReadRevisionGetRes::set_simple(bool value) {
  set_has_simple();
  simple_ = value;
}

// -------------------------------------------------------------------

// MsgBroadcastQueryReq

// required uint32 index = 1;
inline bool MsgBroadcastQueryReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBroadcastQueryReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBroadcastQueryReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBroadcastQueryReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 MsgBroadcastQueryReq::index() const {
  return index_;
}
inline void MsgBroadcastQueryReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool MsgBroadcastQueryReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBroadcastQueryReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBroadcastQueryReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBroadcastQueryReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 MsgBroadcastQueryReq::fetchs() const {
  return fetchs_;
}
inline void MsgBroadcastQueryReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// MsgBroadcastQuery

// required .pp.UserMsgBroadcastReq msg = 1;
inline bool MsgBroadcastQuery::has_msg() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBroadcastQuery::set_has_msg() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBroadcastQuery::clear_has_msg() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBroadcastQuery::clear_msg() {
  if (msg_ != NULL) msg_->::pp::UserMsgBroadcastReq::Clear();
  clear_has_msg();
}
inline const ::pp::UserMsgBroadcastReq& MsgBroadcastQuery::msg() const {
  return msg_ != NULL ? *msg_ : *default_instance_->msg_;
}
inline ::pp::UserMsgBroadcastReq* MsgBroadcastQuery::mutable_msg() {
  set_has_msg();
  if (msg_ == NULL) msg_ = new ::pp::UserMsgBroadcastReq;
  return msg_;
}
inline ::pp::UserMsgBroadcastReq* MsgBroadcastQuery::release_msg() {
  clear_has_msg();
  ::pp::UserMsgBroadcastReq* temp = msg_;
  msg_ = NULL;
  return temp;
}
inline void MsgBroadcastQuery::set_allocated_msg(::pp::UserMsgBroadcastReq* msg) {
  delete msg_;
  msg_ = msg;
  if (msg) {
    set_has_msg();
  } else {
    clear_has_msg();
  }
}

// required string msgTime = 2;
inline bool MsgBroadcastQuery::has_msgtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBroadcastQuery::set_has_msgtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBroadcastQuery::clear_has_msgtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBroadcastQuery::clear_msgtime() {
  if (msgtime_ != &::google::protobuf::internal::kEmptyString) {
    msgtime_->clear();
  }
  clear_has_msgtime();
}
inline const ::std::string& MsgBroadcastQuery::msgtime() const {
  return *msgtime_;
}
inline void MsgBroadcastQuery::set_msgtime(const ::std::string& value) {
  set_has_msgtime();
  if (msgtime_ == &::google::protobuf::internal::kEmptyString) {
    msgtime_ = new ::std::string;
  }
  msgtime_->assign(value);
}
inline void MsgBroadcastQuery::set_msgtime(const char* value) {
  set_has_msgtime();
  if (msgtime_ == &::google::protobuf::internal::kEmptyString) {
    msgtime_ = new ::std::string;
  }
  msgtime_->assign(value);
}
inline void MsgBroadcastQuery::set_msgtime(const char* value, size_t size) {
  set_has_msgtime();
  if (msgtime_ == &::google::protobuf::internal::kEmptyString) {
    msgtime_ = new ::std::string;
  }
  msgtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MsgBroadcastQuery::mutable_msgtime() {
  set_has_msgtime();
  if (msgtime_ == &::google::protobuf::internal::kEmptyString) {
    msgtime_ = new ::std::string;
  }
  return msgtime_;
}
inline ::std::string* MsgBroadcastQuery::release_msgtime() {
  clear_has_msgtime();
  if (msgtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = msgtime_;
    msgtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MsgBroadcastQuery::set_allocated_msgtime(::std::string* msgtime) {
  if (msgtime_ != &::google::protobuf::internal::kEmptyString) {
    delete msgtime_;
  }
  if (msgtime) {
    set_has_msgtime();
    msgtime_ = msgtime;
  } else {
    clear_has_msgtime();
    msgtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// MsgBroadcastQueryRes

// required uint32 index = 1;
inline bool MsgBroadcastQueryRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MsgBroadcastQueryRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MsgBroadcastQueryRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MsgBroadcastQueryRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 MsgBroadcastQueryRes::index() const {
  return index_;
}
inline void MsgBroadcastQueryRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool MsgBroadcastQueryRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MsgBroadcastQueryRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MsgBroadcastQueryRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MsgBroadcastQueryRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 MsgBroadcastQueryRes::fetchs() const {
  return fetchs_;
}
inline void MsgBroadcastQueryRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// repeated .pp.MsgBroadcastQuery msgs = 3;
inline int MsgBroadcastQueryRes::msgs_size() const {
  return msgs_.size();
}
inline void MsgBroadcastQueryRes::clear_msgs() {
  msgs_.Clear();
}
inline const ::pp::MsgBroadcastQuery& MsgBroadcastQueryRes::msgs(int index) const {
  return msgs_.Get(index);
}
inline ::pp::MsgBroadcastQuery* MsgBroadcastQueryRes::mutable_msgs(int index) {
  return msgs_.Mutable(index);
}
inline ::pp::MsgBroadcastQuery* MsgBroadcastQueryRes::add_msgs() {
  return msgs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::MsgBroadcastQuery >&
MsgBroadcastQueryRes::msgs() const {
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::MsgBroadcastQuery >*
MsgBroadcastQueryRes::mutable_msgs() {
  return &msgs_;
}

// -------------------------------------------------------------------

// WeiLianJoinReq

// required uint32 req = 1;
inline bool WeiLianJoinReq::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianJoinReq::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianJoinReq::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianJoinReq::clear_req() {
  req_ = 0u;
  clear_has_req();
}
inline ::google::protobuf::uint32 WeiLianJoinReq::req() const {
  return req_;
}
inline void WeiLianJoinReq::set_req(::google::protobuf::uint32 value) {
  set_has_req();
  req_ = value;
}

// -------------------------------------------------------------------

// WeiLianJoinRes

// required uint32 res = 1;
inline bool WeiLianJoinRes::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianJoinRes::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianJoinRes::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianJoinRes::clear_res() {
  res_ = 0u;
  clear_has_res();
}
inline ::google::protobuf::uint32 WeiLianJoinRes::res() const {
  return res_;
}
inline void WeiLianJoinRes::set_res(::google::protobuf::uint32 value) {
  set_has_res();
  res_ = value;
}

// required uint32 resType = 2;
inline bool WeiLianJoinRes::has_restype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeiLianJoinRes::set_has_restype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeiLianJoinRes::clear_has_restype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeiLianJoinRes::clear_restype() {
  restype_ = 0u;
  clear_has_restype();
}
inline ::google::protobuf::uint32 WeiLianJoinRes::restype() const {
  return restype_;
}
inline void WeiLianJoinRes::set_restype(::google::protobuf::uint32 value) {
  set_has_restype();
  restype_ = value;
}

// -------------------------------------------------------------------

// WeiLianGoddessRankReq

// required uint32 index = 1;
inline bool WeiLianGoddessRankReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianGoddessRankReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianGoddessRankReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianGoddessRankReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 WeiLianGoddessRankReq::index() const {
  return index_;
}
inline void WeiLianGoddessRankReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool WeiLianGoddessRankReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeiLianGoddessRankReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeiLianGoddessRankReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeiLianGoddessRankReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 WeiLianGoddessRankReq::fetchs() const {
  return fetchs_;
}
inline void WeiLianGoddessRankReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// WeiLianGoddess

// required uint64 uid = 1;
inline bool WeiLianGoddess::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianGoddess::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianGoddess::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianGoddess::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 WeiLianGoddess::uid() const {
  return uid_;
}
inline void WeiLianGoddess::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required string name = 2;
inline bool WeiLianGoddess::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeiLianGoddess::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeiLianGoddess::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeiLianGoddess::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WeiLianGoddess::name() const {
  return *name_;
}
inline void WeiLianGoddess::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WeiLianGoddess::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WeiLianGoddess::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeiLianGoddess::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WeiLianGoddess::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeiLianGoddess::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string url = 3;
inline bool WeiLianGoddess::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeiLianGoddess::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeiLianGoddess::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeiLianGoddess::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& WeiLianGoddess::url() const {
  return *url_;
}
inline void WeiLianGoddess::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void WeiLianGoddess::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void WeiLianGoddess::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeiLianGoddess::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* WeiLianGoddess::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeiLianGoddess::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ticketNum = 4;
inline bool WeiLianGoddess::has_ticketnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeiLianGoddess::set_has_ticketnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeiLianGoddess::clear_has_ticketnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeiLianGoddess::clear_ticketnum() {
  ticketnum_ = 0u;
  clear_has_ticketnum();
}
inline ::google::protobuf::uint32 WeiLianGoddess::ticketnum() const {
  return ticketnum_;
}
inline void WeiLianGoddess::set_ticketnum(::google::protobuf::uint32 value) {
  set_has_ticketnum();
  ticketnum_ = value;
}

// required uint32 myVote = 5;
inline bool WeiLianGoddess::has_myvote() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeiLianGoddess::set_has_myvote() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeiLianGoddess::clear_has_myvote() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeiLianGoddess::clear_myvote() {
  myvote_ = 0u;
  clear_has_myvote();
}
inline ::google::protobuf::uint32 WeiLianGoddess::myvote() const {
  return myvote_;
}
inline void WeiLianGoddess::set_myvote(::google::protobuf::uint32 value) {
  set_has_myvote();
  myvote_ = value;
}

// -------------------------------------------------------------------

// WeiLianGoddessRankRes

// required uint32 index = 1;
inline bool WeiLianGoddessRankRes::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianGoddessRankRes::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianGoddessRankRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianGoddessRankRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 WeiLianGoddessRankRes::index() const {
  return index_;
}
inline void WeiLianGoddessRankRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool WeiLianGoddessRankRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeiLianGoddessRankRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeiLianGoddessRankRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeiLianGoddessRankRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 WeiLianGoddessRankRes::fetchs() const {
  return fetchs_;
}
inline void WeiLianGoddessRankRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// repeated .pp.WeiLianGoddess res = 3;
inline int WeiLianGoddessRankRes::res_size() const {
  return res_.size();
}
inline void WeiLianGoddessRankRes::clear_res() {
  res_.Clear();
}
inline const ::pp::WeiLianGoddess& WeiLianGoddessRankRes::res(int index) const {
  return res_.Get(index);
}
inline ::pp::WeiLianGoddess* WeiLianGoddessRankRes::mutable_res(int index) {
  return res_.Mutable(index);
}
inline ::pp::WeiLianGoddess* WeiLianGoddessRankRes::add_res() {
  return res_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::WeiLianGoddess >&
WeiLianGoddessRankRes::res() const {
  return res_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::WeiLianGoddess >*
WeiLianGoddessRankRes::mutable_res() {
  return &res_;
}

// -------------------------------------------------------------------

// WeiLianSearchReq

// required uint64 uid = 1;
inline bool WeiLianSearchReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianSearchReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianSearchReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianSearchReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 WeiLianSearchReq::uid() const {
  return uid_;
}
inline void WeiLianSearchReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// WeiLianSearchRes

// required .pp.WeiLianGoddess res = 1;
inline bool WeiLianSearchRes::has_res() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianSearchRes::set_has_res() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianSearchRes::clear_has_res() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianSearchRes::clear_res() {
  if (res_ != NULL) res_->::pp::WeiLianGoddess::Clear();
  clear_has_res();
}
inline const ::pp::WeiLianGoddess& WeiLianSearchRes::res() const {
  return res_ != NULL ? *res_ : *default_instance_->res_;
}
inline ::pp::WeiLianGoddess* WeiLianSearchRes::mutable_res() {
  set_has_res();
  if (res_ == NULL) res_ = new ::pp::WeiLianGoddess;
  return res_;
}
inline ::pp::WeiLianGoddess* WeiLianSearchRes::release_res() {
  clear_has_res();
  ::pp::WeiLianGoddess* temp = res_;
  res_ = NULL;
  return temp;
}
inline void WeiLianSearchRes::set_allocated_res(::pp::WeiLianGoddess* res) {
  delete res_;
  res_ = res;
  if (res) {
    set_has_res();
  } else {
    clear_has_res();
  }
}

// -------------------------------------------------------------------

// WeiLianVoteReq

// required uint64 uid = 1;
inline bool WeiLianVoteReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianVoteReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianVoteReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianVoteReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 WeiLianVoteReq::uid() const {
  return uid_;
}
inline void WeiLianVoteReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// WeiLianVoteRes

// required uint64 uid = 1;
inline bool WeiLianVoteRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianVoteRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianVoteRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianVoteRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 WeiLianVoteRes::uid() const {
  return uid_;
}
inline void WeiLianVoteRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 res = 2;
inline bool WeiLianVoteRes::has_res() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeiLianVoteRes::set_has_res() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeiLianVoteRes::clear_has_res() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeiLianVoteRes::clear_res() {
  res_ = 0u;
  clear_has_res();
}
inline ::google::protobuf::uint32 WeiLianVoteRes::res() const {
  return res_;
}
inline void WeiLianVoteRes::set_res(::google::protobuf::uint32 value) {
  set_has_res();
  res_ = value;
}

// -------------------------------------------------------------------

// WeiLianMyRankReq

// required uint64 req = 1;
inline bool WeiLianMyRankReq::has_req() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianMyRankReq::set_has_req() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianMyRankReq::clear_has_req() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianMyRankReq::clear_req() {
  req_ = GOOGLE_ULONGLONG(0);
  clear_has_req();
}
inline ::google::protobuf::uint64 WeiLianMyRankReq::req() const {
  return req_;
}
inline void WeiLianMyRankReq::set_req(::google::protobuf::uint64 value) {
  set_has_req();
  req_ = value;
}

// -------------------------------------------------------------------

// WeiLianMyRankRes

// required uint64 uid = 1;
inline bool WeiLianMyRankRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WeiLianMyRankRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WeiLianMyRankRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WeiLianMyRankRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 WeiLianMyRankRes::uid() const {
  return uid_;
}
inline void WeiLianMyRankRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required string name = 2;
inline bool WeiLianMyRankRes::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WeiLianMyRankRes::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WeiLianMyRankRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WeiLianMyRankRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WeiLianMyRankRes::name() const {
  return *name_;
}
inline void WeiLianMyRankRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WeiLianMyRankRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WeiLianMyRankRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeiLianMyRankRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WeiLianMyRankRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeiLianMyRankRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string url = 3;
inline bool WeiLianMyRankRes::has_url() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WeiLianMyRankRes::set_has_url() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WeiLianMyRankRes::clear_has_url() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WeiLianMyRankRes::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& WeiLianMyRankRes::url() const {
  return *url_;
}
inline void WeiLianMyRankRes::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void WeiLianMyRankRes::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void WeiLianMyRankRes::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WeiLianMyRankRes::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* WeiLianMyRankRes::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WeiLianMyRankRes::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 ticketNum = 4;
inline bool WeiLianMyRankRes::has_ticketnum() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WeiLianMyRankRes::set_has_ticketnum() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WeiLianMyRankRes::clear_has_ticketnum() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WeiLianMyRankRes::clear_ticketnum() {
  ticketnum_ = 0u;
  clear_has_ticketnum();
}
inline ::google::protobuf::uint32 WeiLianMyRankRes::ticketnum() const {
  return ticketnum_;
}
inline void WeiLianMyRankRes::set_ticketnum(::google::protobuf::uint32 value) {
  set_has_ticketnum();
  ticketnum_ = value;
}

// required uint32 myRank = 5;
inline bool WeiLianMyRankRes::has_myrank() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WeiLianMyRankRes::set_has_myrank() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WeiLianMyRankRes::clear_has_myrank() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WeiLianMyRankRes::clear_myrank() {
  myrank_ = 0u;
  clear_has_myrank();
}
inline ::google::protobuf::uint32 WeiLianMyRankRes::myrank() const {
  return myrank_;
}
inline void WeiLianMyRankRes::set_myrank(::google::protobuf::uint32 value) {
  set_has_myrank();
  myrank_ = value;
}

// -------------------------------------------------------------------

// GroupOwnerTransferReq

// required uint64 gid = 1;
inline bool GroupOwnerTransferReq::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupOwnerTransferReq::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupOwnerTransferReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupOwnerTransferReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupOwnerTransferReq::gid() const {
  return gid_;
}
inline void GroupOwnerTransferReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 newUid = 2;
inline bool GroupOwnerTransferReq::has_newuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupOwnerTransferReq::set_has_newuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupOwnerTransferReq::clear_has_newuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupOwnerTransferReq::clear_newuid() {
  newuid_ = GOOGLE_ULONGLONG(0);
  clear_has_newuid();
}
inline ::google::protobuf::uint64 GroupOwnerTransferReq::newuid() const {
  return newuid_;
}
inline void GroupOwnerTransferReq::set_newuid(::google::protobuf::uint64 value) {
  set_has_newuid();
  newuid_ = value;
}

// optional string newNick = 3;
inline bool GroupOwnerTransferReq::has_newnick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupOwnerTransferReq::set_has_newnick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupOwnerTransferReq::clear_has_newnick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupOwnerTransferReq::clear_newnick() {
  if (newnick_ != &::google::protobuf::internal::kEmptyString) {
    newnick_->clear();
  }
  clear_has_newnick();
}
inline const ::std::string& GroupOwnerTransferReq::newnick() const {
  return *newnick_;
}
inline void GroupOwnerTransferReq::set_newnick(const ::std::string& value) {
  set_has_newnick();
  if (newnick_ == &::google::protobuf::internal::kEmptyString) {
    newnick_ = new ::std::string;
  }
  newnick_->assign(value);
}
inline void GroupOwnerTransferReq::set_newnick(const char* value) {
  set_has_newnick();
  if (newnick_ == &::google::protobuf::internal::kEmptyString) {
    newnick_ = new ::std::string;
  }
  newnick_->assign(value);
}
inline void GroupOwnerTransferReq::set_newnick(const char* value, size_t size) {
  set_has_newnick();
  if (newnick_ == &::google::protobuf::internal::kEmptyString) {
    newnick_ = new ::std::string;
  }
  newnick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupOwnerTransferReq::mutable_newnick() {
  set_has_newnick();
  if (newnick_ == &::google::protobuf::internal::kEmptyString) {
    newnick_ = new ::std::string;
  }
  return newnick_;
}
inline ::std::string* GroupOwnerTransferReq::release_newnick() {
  clear_has_newnick();
  if (newnick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = newnick_;
    newnick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupOwnerTransferReq::set_allocated_newnick(::std::string* newnick) {
  if (newnick_ != &::google::protobuf::internal::kEmptyString) {
    delete newnick_;
  }
  if (newnick) {
    set_has_newnick();
    newnick_ = newnick;
  } else {
    clear_has_newnick();
    newnick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TopicListReq

// required uint64 uid = 1;
inline bool TopicListReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicListReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicListReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicListReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 TopicListReq::uid() const {
  return uid_;
}
inline void TopicListReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 index = 2;
inline bool TopicListReq::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicListReq::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TopicListReq::index() const {
  return index_;
}
inline void TopicListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// optional uint32 fetchs = 3;
inline bool TopicListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 TopicListReq::fetchs() const {
  return fetchs_;
}
inline void TopicListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// optional .pp.GroupMemberRoler roler = 5;
inline bool TopicListReq::has_roler() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TopicListReq::set_has_roler() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TopicListReq::clear_has_roler() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TopicListReq::clear_roler() {
  roler_ = 0;
  clear_has_roler();
}
inline ::pp::GroupMemberRoler TopicListReq::roler() const {
  return static_cast< ::pp::GroupMemberRoler >(roler_);
}
inline void TopicListReq::set_roler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_roler();
  roler_ = value;
}

// optional .pp.GroupType grouptype = 6;
inline bool TopicListReq::has_grouptype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopicListReq::set_has_grouptype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopicListReq::clear_has_grouptype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopicListReq::clear_grouptype() {
  grouptype_ = 0;
  clear_has_grouptype();
}
inline ::pp::GroupType TopicListReq::grouptype() const {
  return static_cast< ::pp::GroupType >(grouptype_);
}
inline void TopicListReq::set_grouptype(::pp::GroupType value) {
  assert(::pp::GroupType_IsValid(value));
  set_has_grouptype();
  grouptype_ = value;
}

// optional bool latest = 7;
inline bool TopicListReq::has_latest() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopicListReq::set_has_latest() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopicListReq::clear_has_latest() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopicListReq::clear_latest() {
  latest_ = false;
  clear_has_latest();
}
inline bool TopicListReq::latest() const {
  return latest_;
}
inline void TopicListReq::set_latest(bool value) {
  set_has_latest();
  latest_ = value;
}

// -------------------------------------------------------------------

// TopicListRes

// required uint64 uid = 1;
inline bool TopicListRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopicListRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopicListRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopicListRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 TopicListRes::uid() const {
  return uid_;
}
inline void TopicListRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 totalresults = 2;
inline bool TopicListRes::has_totalresults() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopicListRes::set_has_totalresults() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopicListRes::clear_has_totalresults() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopicListRes::clear_totalresults() {
  totalresults_ = 0u;
  clear_has_totalresults();
}
inline ::google::protobuf::uint32 TopicListRes::totalresults() const {
  return totalresults_;
}
inline void TopicListRes::set_totalresults(::google::protobuf::uint32 value) {
  set_has_totalresults();
  totalresults_ = value;
}

// required uint32 index = 3;
inline bool TopicListRes::has_index() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopicListRes::set_has_index() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopicListRes::clear_has_index() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopicListRes::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 TopicListRes::index() const {
  return index_;
}
inline void TopicListRes::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// repeated .pp.GroupInfo groups = 4;
inline int TopicListRes::groups_size() const {
  return groups_.size();
}
inline void TopicListRes::clear_groups() {
  groups_.Clear();
}
inline const ::pp::GroupInfo& TopicListRes::groups(int index) const {
  return groups_.Get(index);
}
inline ::pp::GroupInfo* TopicListRes::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline ::pp::GroupInfo* TopicListRes::add_groups() {
  return groups_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >&
TopicListRes::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupInfo >*
TopicListRes::mutable_groups() {
  return &groups_;
}

// optional .pp.GroupMemberRoler roler = 5;
inline bool TopicListRes::has_roler() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TopicListRes::set_has_roler() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TopicListRes::clear_has_roler() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TopicListRes::clear_roler() {
  roler_ = 0;
  clear_has_roler();
}
inline ::pp::GroupMemberRoler TopicListRes::roler() const {
  return static_cast< ::pp::GroupMemberRoler >(roler_);
}
inline void TopicListRes::set_roler(::pp::GroupMemberRoler value) {
  assert(::pp::GroupMemberRoler_IsValid(value));
  set_has_roler();
  roler_ = value;
}

// optional .pp.GroupType grouptype = 6;
inline bool TopicListRes::has_grouptype() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TopicListRes::set_has_grouptype() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TopicListRes::clear_has_grouptype() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TopicListRes::clear_grouptype() {
  grouptype_ = 0;
  clear_has_grouptype();
}
inline ::pp::GroupType TopicListRes::grouptype() const {
  return static_cast< ::pp::GroupType >(grouptype_);
}
inline void TopicListRes::set_grouptype(::pp::GroupType value) {
  assert(::pp::GroupType_IsValid(value));
  set_has_grouptype();
  grouptype_ = value;
}

// optional uint32 latestNum = 8;
inline bool TopicListRes::has_latestnum() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TopicListRes::set_has_latestnum() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TopicListRes::clear_has_latestnum() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TopicListRes::clear_latestnum() {
  latestnum_ = 0u;
  clear_has_latestnum();
}
inline ::google::protobuf::uint32 TopicListRes::latestnum() const {
  return latestnum_;
}
inline void TopicListRes::set_latestnum(::google::protobuf::uint32 value) {
  set_has_latestnum();
  latestnum_ = value;
}

// optional uint32 fetchs = 9;
inline bool TopicListRes::has_fetchs() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TopicListRes::set_has_fetchs() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TopicListRes::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TopicListRes::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 TopicListRes::fetchs() const {
  return fetchs_;
}
inline void TopicListRes::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// WebQRCodeScanReq

// required string url = 1;
inline bool WebQRCodeScanReq::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebQRCodeScanReq::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebQRCodeScanReq::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebQRCodeScanReq::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& WebQRCodeScanReq::url() const {
  return *url_;
}
inline void WebQRCodeScanReq::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void WebQRCodeScanReq::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void WebQRCodeScanReq::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebQRCodeScanReq::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* WebQRCodeScanReq::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebQRCodeScanReq::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// WebTokenVerifyReq

// optional string token = 1;
inline bool WebTokenVerifyReq::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebTokenVerifyReq::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebTokenVerifyReq::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebTokenVerifyReq::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& WebTokenVerifyReq::token() const {
  return *token_;
}
inline void WebTokenVerifyReq::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void WebTokenVerifyReq::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void WebTokenVerifyReq::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WebTokenVerifyReq::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* WebTokenVerifyReq::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WebTokenVerifyReq::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// SysParamSetReq

// optional string name = 1;
inline bool SysParamSetReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SysParamSetReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SysParamSetReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SysParamSetReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SysParamSetReq::name() const {
  return *name_;
}
inline void SysParamSetReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SysParamSetReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SysParamSetReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysParamSetReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SysParamSetReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SysParamSetReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool SysParamSetReq::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SysParamSetReq::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SysParamSetReq::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SysParamSetReq::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& SysParamSetReq::value() const {
  return *value_;
}
inline void SysParamSetReq::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SysParamSetReq::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void SysParamSetReq::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SysParamSetReq::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* SysParamSetReq::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SysParamSetReq::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CoinStatItem

// optional string name = 1;
inline bool CoinStatItem::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinStatItem::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinStatItem::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinStatItem::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CoinStatItem::name() const {
  return *name_;
}
inline void CoinStatItem::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CoinStatItem::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CoinStatItem::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinStatItem::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CoinStatItem::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinStatItem::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 coins = 2;
inline bool CoinStatItem::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinStatItem::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinStatItem::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinStatItem::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 CoinStatItem::coins() const {
  return coins_;
}
inline void CoinStatItem::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional int64 timestamp = 3;
inline bool CoinStatItem::has_timestamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoinStatItem::set_has_timestamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoinStatItem::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoinStatItem::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 CoinStatItem::timestamp() const {
  return timestamp_;
}
inline void CoinStatItem::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}

// optional string ext = 4;
inline bool CoinStatItem::has_ext() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoinStatItem::set_has_ext() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoinStatItem::clear_has_ext() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoinStatItem::clear_ext() {
  if (ext_ != &::google::protobuf::internal::kEmptyString) {
    ext_->clear();
  }
  clear_has_ext();
}
inline const ::std::string& CoinStatItem::ext() const {
  return *ext_;
}
inline void CoinStatItem::set_ext(const ::std::string& value) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(value);
}
inline void CoinStatItem::set_ext(const char* value) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(value);
}
inline void CoinStatItem::set_ext(const char* value, size_t size) {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  ext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinStatItem::mutable_ext() {
  set_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    ext_ = new ::std::string;
  }
  return ext_;
}
inline ::std::string* CoinStatItem::release_ext() {
  clear_has_ext();
  if (ext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ext_;
    ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinStatItem::set_allocated_ext(::std::string* ext) {
  if (ext_ != &::google::protobuf::internal::kEmptyString) {
    delete ext_;
  }
  if (ext) {
    set_has_ext();
    ext_ = ext;
  } else {
    clear_has_ext();
    ext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserCoinStatReq

// optional uint64 uid = 1;
inline bool UserCoinStatReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCoinStatReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCoinStatReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCoinStatReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserCoinStatReq::uid() const {
  return uid_;
}
inline void UserCoinStatReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 seconds = 2;
inline bool UserCoinStatReq::has_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserCoinStatReq::set_has_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserCoinStatReq::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserCoinStatReq::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 UserCoinStatReq::seconds() const {
  return seconds_;
}
inline void UserCoinStatReq::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// -------------------------------------------------------------------

// UserCoinStatRes

// optional uint64 uid = 1;
inline bool UserCoinStatRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCoinStatRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCoinStatRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCoinStatRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserCoinStatRes::uid() const {
  return uid_;
}
inline void UserCoinStatRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 seconds = 2;
inline bool UserCoinStatRes::has_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserCoinStatRes::set_has_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserCoinStatRes::clear_has_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserCoinStatRes::clear_seconds() {
  seconds_ = 0u;
  clear_has_seconds();
}
inline ::google::protobuf::uint32 UserCoinStatRes::seconds() const {
  return seconds_;
}
inline void UserCoinStatRes::set_seconds(::google::protobuf::uint32 value) {
  set_has_seconds();
  seconds_ = value;
}

// repeated .pp.CoinStatItem incomeItems = 5;
inline int UserCoinStatRes::incomeitems_size() const {
  return incomeitems_.size();
}
inline void UserCoinStatRes::clear_incomeitems() {
  incomeitems_.Clear();
}
inline const ::pp::CoinStatItem& UserCoinStatRes::incomeitems(int index) const {
  return incomeitems_.Get(index);
}
inline ::pp::CoinStatItem* UserCoinStatRes::mutable_incomeitems(int index) {
  return incomeitems_.Mutable(index);
}
inline ::pp::CoinStatItem* UserCoinStatRes::add_incomeitems() {
  return incomeitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >&
UserCoinStatRes::incomeitems() const {
  return incomeitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >*
UserCoinStatRes::mutable_incomeitems() {
  return &incomeitems_;
}

// repeated .pp.CoinStatItem consumeItems = 6;
inline int UserCoinStatRes::consumeitems_size() const {
  return consumeitems_.size();
}
inline void UserCoinStatRes::clear_consumeitems() {
  consumeitems_.Clear();
}
inline const ::pp::CoinStatItem& UserCoinStatRes::consumeitems(int index) const {
  return consumeitems_.Get(index);
}
inline ::pp::CoinStatItem* UserCoinStatRes::mutable_consumeitems(int index) {
  return consumeitems_.Mutable(index);
}
inline ::pp::CoinStatItem* UserCoinStatRes::add_consumeitems() {
  return consumeitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >&
UserCoinStatRes::consumeitems() const {
  return consumeitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >*
UserCoinStatRes::mutable_consumeitems() {
  return &consumeitems_;
}

// repeated .pp.CoinStatItem topupItems = 7;
inline int UserCoinStatRes::topupitems_size() const {
  return topupitems_.size();
}
inline void UserCoinStatRes::clear_topupitems() {
  topupitems_.Clear();
}
inline const ::pp::CoinStatItem& UserCoinStatRes::topupitems(int index) const {
  return topupitems_.Get(index);
}
inline ::pp::CoinStatItem* UserCoinStatRes::mutable_topupitems(int index) {
  return topupitems_.Mutable(index);
}
inline ::pp::CoinStatItem* UserCoinStatRes::add_topupitems() {
  return topupitems_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >&
UserCoinStatRes::topupitems() const {
  return topupitems_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::CoinStatItem >*
UserCoinStatRes::mutable_topupitems() {
  return &topupitems_;
}

// -------------------------------------------------------------------

// UserAllStatReq

// optional sint64 time = 1;
inline bool UserAllStatReq::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAllStatReq::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAllStatReq::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAllStatReq::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 UserAllStatReq::time() const {
  return time_;
}
inline void UserAllStatReq::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// UserAllStatRes

// optional sint64 time = 1;
inline bool UserAllStatRes::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserAllStatRes::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserAllStatRes::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserAllStatRes::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 UserAllStatRes::time() const {
  return time_;
}
inline void UserAllStatRes::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// repeated .pp.FromStoreItems items = 2;
inline int UserAllStatRes::items_size() const {
  return items_.size();
}
inline void UserAllStatRes::clear_items() {
  items_.Clear();
}
inline const ::pp::FromStoreItems& UserAllStatRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::FromStoreItems* UserAllStatRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::FromStoreItems* UserAllStatRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >&
UserAllStatRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >*
UserAllStatRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// GroupMembersStat

// optional string statTime = 1;
inline bool GroupMembersStat::has_stattime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMembersStat::set_has_stattime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMembersStat::clear_has_stattime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMembersStat::clear_stattime() {
  if (stattime_ != &::google::protobuf::internal::kEmptyString) {
    stattime_->clear();
  }
  clear_has_stattime();
}
inline const ::std::string& GroupMembersStat::stattime() const {
  return *stattime_;
}
inline void GroupMembersStat::set_stattime(const ::std::string& value) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(value);
}
inline void GroupMembersStat::set_stattime(const char* value) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(value);
}
inline void GroupMembersStat::set_stattime(const char* value, size_t size) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMembersStat::mutable_stattime() {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  return stattime_;
}
inline ::std::string* GroupMembersStat::release_stattime() {
  clear_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stattime_;
    stattime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMembersStat::set_allocated_stattime(::std::string* stattime) {
  if (stattime_ != &::google::protobuf::internal::kEmptyString) {
    delete stattime_;
  }
  if (stattime) {
    set_has_stattime();
    stattime_ = stattime;
  } else {
    clear_has_stattime();
    stattime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 uid = 2;
inline bool GroupMembersStat::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMembersStat::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMembersStat::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMembersStat::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 GroupMembersStat::uid() const {
  return uid_;
}
inline void GroupMembersStat::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 gid = 3;
inline bool GroupMembersStat::has_gid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GroupMembersStat::set_has_gid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GroupMembersStat::clear_has_gid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GroupMembersStat::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 GroupMembersStat::gid() const {
  return gid_;
}
inline void GroupMembersStat::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 categoryid = 4;
inline bool GroupMembersStat::has_categoryid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GroupMembersStat::set_has_categoryid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GroupMembersStat::clear_has_categoryid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GroupMembersStat::clear_categoryid() {
  categoryid_ = GOOGLE_ULONGLONG(0);
  clear_has_categoryid();
}
inline ::google::protobuf::uint64 GroupMembersStat::categoryid() const {
  return categoryid_;
}
inline void GroupMembersStat::set_categoryid(::google::protobuf::uint64 value) {
  set_has_categoryid();
  categoryid_ = value;
}

// optional uint64 locked = 5;
inline bool GroupMembersStat::has_locked() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GroupMembersStat::set_has_locked() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GroupMembersStat::clear_has_locked() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GroupMembersStat::clear_locked() {
  locked_ = GOOGLE_ULONGLONG(0);
  clear_has_locked();
}
inline ::google::protobuf::uint64 GroupMembersStat::locked() const {
  return locked_;
}
inline void GroupMembersStat::set_locked(::google::protobuf::uint64 value) {
  set_has_locked();
  locked_ = value;
}

// optional uint64 sortorder = 6;
inline bool GroupMembersStat::has_sortorder() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void GroupMembersStat::set_has_sortorder() {
  _has_bits_[0] |= 0x00000020u;
}
inline void GroupMembersStat::clear_has_sortorder() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void GroupMembersStat::clear_sortorder() {
  sortorder_ = GOOGLE_ULONGLONG(0);
  clear_has_sortorder();
}
inline ::google::protobuf::uint64 GroupMembersStat::sortorder() const {
  return sortorder_;
}
inline void GroupMembersStat::set_sortorder(::google::protobuf::uint64 value) {
  set_has_sortorder();
  sortorder_ = value;
}

// optional string members = 7;
inline bool GroupMembersStat::has_members() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void GroupMembersStat::set_has_members() {
  _has_bits_[0] |= 0x00000040u;
}
inline void GroupMembersStat::clear_has_members() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void GroupMembersStat::clear_members() {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    members_->clear();
  }
  clear_has_members();
}
inline const ::std::string& GroupMembersStat::members() const {
  return *members_;
}
inline void GroupMembersStat::set_members(const ::std::string& value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void GroupMembersStat::set_members(const char* value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void GroupMembersStat::set_members(const char* value, size_t size) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GroupMembersStat::mutable_members() {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  return members_;
}
inline ::std::string* GroupMembersStat::release_members() {
  clear_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = members_;
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GroupMembersStat::set_allocated_members(::std::string* members) {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    delete members_;
  }
  if (members) {
    set_has_members();
    members_ = members;
  } else {
    clear_has_members();
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// GroupMembersStatReq

// optional sint64 startTime = 1;
inline bool GroupMembersStatReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroupMembersStatReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroupMembersStatReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroupMembersStatReq::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 GroupMembersStatReq::starttime() const {
  return starttime_;
}
inline void GroupMembersStatReq::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional sint64 endTime = 2;
inline bool GroupMembersStatReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroupMembersStatReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroupMembersStatReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroupMembersStatReq::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 GroupMembersStatReq::endtime() const {
  return endtime_;
}
inline void GroupMembersStatReq::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// GroupMembersStatRes

// repeated .pp.GroupMembersStat items = 2;
inline int GroupMembersStatRes::items_size() const {
  return items_.size();
}
inline void GroupMembersStatRes::clear_items() {
  items_.Clear();
}
inline const ::pp::GroupMembersStat& GroupMembersStatRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::GroupMembersStat* GroupMembersStatRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::GroupMembersStat* GroupMembersStatRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::GroupMembersStat >&
GroupMembersStatRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::GroupMembersStat >*
GroupMembersStatRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// DailyTaskList

// required uint32 type = 1;
inline bool DailyTaskList::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyTaskList::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyTaskList::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyTaskList::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 DailyTaskList::type() const {
  return type_;
}
inline void DailyTaskList::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// required uint32 countComplete = 2;
inline bool DailyTaskList::has_countcomplete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyTaskList::set_has_countcomplete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyTaskList::clear_has_countcomplete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyTaskList::clear_countcomplete() {
  countcomplete_ = 0u;
  clear_has_countcomplete();
}
inline ::google::protobuf::uint32 DailyTaskList::countcomplete() const {
  return countcomplete_;
}
inline void DailyTaskList::set_countcomplete(::google::protobuf::uint32 value) {
  set_has_countcomplete();
  countcomplete_ = value;
}

// required uint32 countMembers = 3;
inline bool DailyTaskList::has_countmembers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyTaskList::set_has_countmembers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyTaskList::clear_has_countmembers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyTaskList::clear_countmembers() {
  countmembers_ = 0u;
  clear_has_countmembers();
}
inline ::google::protobuf::uint32 DailyTaskList::countmembers() const {
  return countmembers_;
}
inline void DailyTaskList::set_countmembers(::google::protobuf::uint32 value) {
  set_has_countmembers();
  countmembers_ = value;
}

// -------------------------------------------------------------------

// UserTaskCompleteStatReq

// optional sint64 startTime = 1;
inline bool UserTaskCompleteStatReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTaskCompleteStatReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTaskCompleteStatReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTaskCompleteStatReq::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 UserTaskCompleteStatReq::starttime() const {
  return starttime_;
}
inline void UserTaskCompleteStatReq::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional sint64 endTime = 2;
inline bool UserTaskCompleteStatReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTaskCompleteStatReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTaskCompleteStatReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTaskCompleteStatReq::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 UserTaskCompleteStatReq::endtime() const {
  return endtime_;
}
inline void UserTaskCompleteStatReq::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// UserTaskCompleteStatRes

// optional string startDate = 1;
inline bool UserTaskCompleteStatRes::has_startdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTaskCompleteStatRes::set_has_startdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTaskCompleteStatRes::clear_has_startdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTaskCompleteStatRes::clear_startdate() {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    startdate_->clear();
  }
  clear_has_startdate();
}
inline const ::std::string& UserTaskCompleteStatRes::startdate() const {
  return *startdate_;
}
inline void UserTaskCompleteStatRes::set_startdate(const ::std::string& value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void UserTaskCompleteStatRes::set_startdate(const char* value) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(value);
}
inline void UserTaskCompleteStatRes::set_startdate(const char* value, size_t size) {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  startdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTaskCompleteStatRes::mutable_startdate() {
  set_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    startdate_ = new ::std::string;
  }
  return startdate_;
}
inline ::std::string* UserTaskCompleteStatRes::release_startdate() {
  clear_has_startdate();
  if (startdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startdate_;
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTaskCompleteStatRes::set_allocated_startdate(::std::string* startdate) {
  if (startdate_ != &::google::protobuf::internal::kEmptyString) {
    delete startdate_;
  }
  if (startdate) {
    set_has_startdate();
    startdate_ = startdate;
  } else {
    clear_has_startdate();
    startdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endDate = 2;
inline bool UserTaskCompleteStatRes::has_enddate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTaskCompleteStatRes::set_has_enddate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTaskCompleteStatRes::clear_has_enddate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTaskCompleteStatRes::clear_enddate() {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    enddate_->clear();
  }
  clear_has_enddate();
}
inline const ::std::string& UserTaskCompleteStatRes::enddate() const {
  return *enddate_;
}
inline void UserTaskCompleteStatRes::set_enddate(const ::std::string& value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void UserTaskCompleteStatRes::set_enddate(const char* value) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(value);
}
inline void UserTaskCompleteStatRes::set_enddate(const char* value, size_t size) {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  enddate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTaskCompleteStatRes::mutable_enddate() {
  set_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    enddate_ = new ::std::string;
  }
  return enddate_;
}
inline ::std::string* UserTaskCompleteStatRes::release_enddate() {
  clear_has_enddate();
  if (enddate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = enddate_;
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTaskCompleteStatRes::set_allocated_enddate(::std::string* enddate) {
  if (enddate_ != &::google::protobuf::internal::kEmptyString) {
    delete enddate_;
  }
  if (enddate) {
    set_has_enddate();
    enddate_ = enddate;
  } else {
    clear_has_enddate();
    enddate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.DailyTaskList items = 3;
inline int UserTaskCompleteStatRes::items_size() const {
  return items_.size();
}
inline void UserTaskCompleteStatRes::clear_items() {
  items_.Clear();
}
inline const ::pp::DailyTaskList& UserTaskCompleteStatRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::DailyTaskList* UserTaskCompleteStatRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::DailyTaskList* UserTaskCompleteStatRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskList >&
UserTaskCompleteStatRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskList >*
UserTaskCompleteStatRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// FromStoreItems

// required string fromStore = 1;
inline bool FromStoreItems::has_fromstore() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FromStoreItems::set_has_fromstore() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FromStoreItems::clear_has_fromstore() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FromStoreItems::clear_fromstore() {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    fromstore_->clear();
  }
  clear_has_fromstore();
}
inline const ::std::string& FromStoreItems::fromstore() const {
  return *fromstore_;
}
inline void FromStoreItems::set_fromstore(const ::std::string& value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void FromStoreItems::set_fromstore(const char* value) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(value);
}
inline void FromStoreItems::set_fromstore(const char* value, size_t size) {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  fromstore_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FromStoreItems::mutable_fromstore() {
  set_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    fromstore_ = new ::std::string;
  }
  return fromstore_;
}
inline ::std::string* FromStoreItems::release_fromstore() {
  clear_has_fromstore();
  if (fromstore_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fromstore_;
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void FromStoreItems::set_allocated_fromstore(::std::string* fromstore) {
  if (fromstore_ != &::google::protobuf::internal::kEmptyString) {
    delete fromstore_;
  }
  if (fromstore) {
    set_has_fromstore();
    fromstore_ = fromstore;
  } else {
    clear_has_fromstore();
    fromstore_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 number = 2;
inline bool FromStoreItems::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FromStoreItems::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FromStoreItems::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FromStoreItems::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 FromStoreItems::number() const {
  return number_;
}
inline void FromStoreItems::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// UserNewStatReq

// optional sint64 startTime = 1;
inline bool UserNewStatReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserNewStatReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserNewStatReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserNewStatReq::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 UserNewStatReq::starttime() const {
  return starttime_;
}
inline void UserNewStatReq::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional sint64 endTime = 2;
inline bool UserNewStatReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserNewStatReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserNewStatReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserNewStatReq::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 UserNewStatReq::endtime() const {
  return endtime_;
}
inline void UserNewStatReq::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// UserNewStatRes

// optional sint64 startTime = 1;
inline bool UserNewStatRes::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserNewStatRes::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserNewStatRes::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserNewStatRes::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 UserNewStatRes::starttime() const {
  return starttime_;
}
inline void UserNewStatRes::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional sint64 endTime = 2;
inline bool UserNewStatRes::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserNewStatRes::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserNewStatRes::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserNewStatRes::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 UserNewStatRes::endtime() const {
  return endtime_;
}
inline void UserNewStatRes::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// repeated .pp.FromStoreItems items = 3;
inline int UserNewStatRes::items_size() const {
  return items_.size();
}
inline void UserNewStatRes::clear_items() {
  items_.Clear();
}
inline const ::pp::FromStoreItems& UserNewStatRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::FromStoreItems* UserNewStatRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::FromStoreItems* UserNewStatRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >&
UserNewStatRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::FromStoreItems >*
UserNewStatRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// UserLevelStatReq

// -------------------------------------------------------------------

// UserLevelStatRes

// repeated .pp.LevelNumberItems charmLevel = 1;
inline int UserLevelStatRes::charmlevel_size() const {
  return charmlevel_.size();
}
inline void UserLevelStatRes::clear_charmlevel() {
  charmlevel_.Clear();
}
inline const ::pp::LevelNumberItems& UserLevelStatRes::charmlevel(int index) const {
  return charmlevel_.Get(index);
}
inline ::pp::LevelNumberItems* UserLevelStatRes::mutable_charmlevel(int index) {
  return charmlevel_.Mutable(index);
}
inline ::pp::LevelNumberItems* UserLevelStatRes::add_charmlevel() {
  return charmlevel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >&
UserLevelStatRes::charmlevel() const {
  return charmlevel_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >*
UserLevelStatRes::mutable_charmlevel() {
  return &charmlevel_;
}

// repeated .pp.LevelNumberItems worthLevel = 2;
inline int UserLevelStatRes::worthlevel_size() const {
  return worthlevel_.size();
}
inline void UserLevelStatRes::clear_worthlevel() {
  worthlevel_.Clear();
}
inline const ::pp::LevelNumberItems& UserLevelStatRes::worthlevel(int index) const {
  return worthlevel_.Get(index);
}
inline ::pp::LevelNumberItems* UserLevelStatRes::mutable_worthlevel(int index) {
  return worthlevel_.Mutable(index);
}
inline ::pp::LevelNumberItems* UserLevelStatRes::add_worthlevel() {
  return worthlevel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >&
UserLevelStatRes::worthlevel() const {
  return worthlevel_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >*
UserLevelStatRes::mutable_worthlevel() {
  return &worthlevel_;
}

// repeated .pp.LevelNumberItems passionLevel = 3;
inline int UserLevelStatRes::passionlevel_size() const {
  return passionlevel_.size();
}
inline void UserLevelStatRes::clear_passionlevel() {
  passionlevel_.Clear();
}
inline const ::pp::LevelNumberItems& UserLevelStatRes::passionlevel(int index) const {
  return passionlevel_.Get(index);
}
inline ::pp::LevelNumberItems* UserLevelStatRes::mutable_passionlevel(int index) {
  return passionlevel_.Mutable(index);
}
inline ::pp::LevelNumberItems* UserLevelStatRes::add_passionlevel() {
  return passionlevel_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >&
UserLevelStatRes::passionlevel() const {
  return passionlevel_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::LevelNumberItems >*
UserLevelStatRes::mutable_passionlevel() {
  return &passionlevel_;
}

// -------------------------------------------------------------------

// LevelNumberItems

// required uint32 level = 1;
inline bool LevelNumberItems::has_level() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LevelNumberItems::set_has_level() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LevelNumberItems::clear_has_level() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LevelNumberItems::clear_level() {
  level_ = 0u;
  clear_has_level();
}
inline ::google::protobuf::uint32 LevelNumberItems::level() const {
  return level_;
}
inline void LevelNumberItems::set_level(::google::protobuf::uint32 value) {
  set_has_level();
  level_ = value;
}

// required uint32 number = 2;
inline bool LevelNumberItems::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LevelNumberItems::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LevelNumberItems::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LevelNumberItems::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 LevelNumberItems::number() const {
  return number_;
}
inline void LevelNumberItems::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// UserTradeNumReq

// required sint64 time = 1;
inline bool UserTradeNumReq::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTradeNumReq::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTradeNumReq::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTradeNumReq::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 UserTradeNumReq::time() const {
  return time_;
}
inline void UserTradeNumReq::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// -------------------------------------------------------------------

// UserTradeNumRes

// required sint64 time = 1;
inline bool UserTradeNumRes::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserTradeNumRes::set_has_time() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserTradeNumRes::clear_has_time() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserTradeNumRes::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  clear_has_time();
}
inline ::google::protobuf::int64 UserTradeNumRes::time() const {
  return time_;
}
inline void UserTradeNumRes::set_time(::google::protobuf::int64 value) {
  set_has_time();
  time_ = value;
}

// required string trade = 2;
inline bool UserTradeNumRes::has_trade() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserTradeNumRes::set_has_trade() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserTradeNumRes::clear_has_trade() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserTradeNumRes::clear_trade() {
  if (trade_ != &::google::protobuf::internal::kEmptyString) {
    trade_->clear();
  }
  clear_has_trade();
}
inline const ::std::string& UserTradeNumRes::trade() const {
  return *trade_;
}
inline void UserTradeNumRes::set_trade(const ::std::string& value) {
  set_has_trade();
  if (trade_ == &::google::protobuf::internal::kEmptyString) {
    trade_ = new ::std::string;
  }
  trade_->assign(value);
}
inline void UserTradeNumRes::set_trade(const char* value) {
  set_has_trade();
  if (trade_ == &::google::protobuf::internal::kEmptyString) {
    trade_ = new ::std::string;
  }
  trade_->assign(value);
}
inline void UserTradeNumRes::set_trade(const char* value, size_t size) {
  set_has_trade();
  if (trade_ == &::google::protobuf::internal::kEmptyString) {
    trade_ = new ::std::string;
  }
  trade_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserTradeNumRes::mutable_trade() {
  set_has_trade();
  if (trade_ == &::google::protobuf::internal::kEmptyString) {
    trade_ = new ::std::string;
  }
  return trade_;
}
inline ::std::string* UserTradeNumRes::release_trade() {
  clear_has_trade();
  if (trade_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = trade_;
    trade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserTradeNumRes::set_allocated_trade(::std::string* trade) {
  if (trade_ != &::google::protobuf::internal::kEmptyString) {
    delete trade_;
  }
  if (trade) {
    set_has_trade();
    trade_ = trade;
  } else {
    clear_has_trade();
    trade_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserPaymentReq

// required string statDate = 1;
inline bool UserPaymentReq::has_statdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPaymentReq::set_has_statdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPaymentReq::clear_has_statdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPaymentReq::clear_statdate() {
  if (statdate_ != &::google::protobuf::internal::kEmptyString) {
    statdate_->clear();
  }
  clear_has_statdate();
}
inline const ::std::string& UserPaymentReq::statdate() const {
  return *statdate_;
}
inline void UserPaymentReq::set_statdate(const ::std::string& value) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(value);
}
inline void UserPaymentReq::set_statdate(const char* value) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(value);
}
inline void UserPaymentReq::set_statdate(const char* value, size_t size) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPaymentReq::mutable_statdate() {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  return statdate_;
}
inline ::std::string* UserPaymentReq::release_statdate() {
  clear_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statdate_;
    statdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPaymentReq::set_allocated_statdate(::std::string* statdate) {
  if (statdate_ != &::google::protobuf::internal::kEmptyString) {
    delete statdate_;
  }
  if (statdate) {
    set_has_statdate();
    statdate_ = statdate;
  } else {
    clear_has_statdate();
    statdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserPaymentRes

// required string statDate = 1;
inline bool UserPaymentRes::has_statdate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserPaymentRes::set_has_statdate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserPaymentRes::clear_has_statdate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserPaymentRes::clear_statdate() {
  if (statdate_ != &::google::protobuf::internal::kEmptyString) {
    statdate_->clear();
  }
  clear_has_statdate();
}
inline const ::std::string& UserPaymentRes::statdate() const {
  return *statdate_;
}
inline void UserPaymentRes::set_statdate(const ::std::string& value) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(value);
}
inline void UserPaymentRes::set_statdate(const char* value) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(value);
}
inline void UserPaymentRes::set_statdate(const char* value, size_t size) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPaymentRes::mutable_statdate() {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  return statdate_;
}
inline ::std::string* UserPaymentRes::release_statdate() {
  clear_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statdate_;
    statdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPaymentRes::set_allocated_statdate(::std::string* statdate) {
  if (statdate_ != &::google::protobuf::internal::kEmptyString) {
    delete statdate_;
  }
  if (statdate) {
    set_has_statdate();
    statdate_ = statdate;
  } else {
    clear_has_statdate();
    statdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string paydata = 2;
inline bool UserPaymentRes::has_paydata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserPaymentRes::set_has_paydata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserPaymentRes::clear_has_paydata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserPaymentRes::clear_paydata() {
  if (paydata_ != &::google::protobuf::internal::kEmptyString) {
    paydata_->clear();
  }
  clear_has_paydata();
}
inline const ::std::string& UserPaymentRes::paydata() const {
  return *paydata_;
}
inline void UserPaymentRes::set_paydata(const ::std::string& value) {
  set_has_paydata();
  if (paydata_ == &::google::protobuf::internal::kEmptyString) {
    paydata_ = new ::std::string;
  }
  paydata_->assign(value);
}
inline void UserPaymentRes::set_paydata(const char* value) {
  set_has_paydata();
  if (paydata_ == &::google::protobuf::internal::kEmptyString) {
    paydata_ = new ::std::string;
  }
  paydata_->assign(value);
}
inline void UserPaymentRes::set_paydata(const char* value, size_t size) {
  set_has_paydata();
  if (paydata_ == &::google::protobuf::internal::kEmptyString) {
    paydata_ = new ::std::string;
  }
  paydata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserPaymentRes::mutable_paydata() {
  set_has_paydata();
  if (paydata_ == &::google::protobuf::internal::kEmptyString) {
    paydata_ = new ::std::string;
  }
  return paydata_;
}
inline ::std::string* UserPaymentRes::release_paydata() {
  clear_has_paydata();
  if (paydata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = paydata_;
    paydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserPaymentRes::set_allocated_paydata(::std::string* paydata) {
  if (paydata_ != &::google::protobuf::internal::kEmptyString) {
    delete paydata_;
  }
  if (paydata) {
    set_has_paydata();
    paydata_ = paydata;
  } else {
    clear_has_paydata();
    paydata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CreamFamilyReq

// required sint64 startTime = 1;
inline bool CreamFamilyReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreamFamilyReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreamFamilyReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreamFamilyReq::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 CreamFamilyReq::starttime() const {
  return starttime_;
}
inline void CreamFamilyReq::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// required sint64 endTime = 2;
inline bool CreamFamilyReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreamFamilyReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreamFamilyReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreamFamilyReq::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 CreamFamilyReq::endtime() const {
  return endtime_;
}
inline void CreamFamilyReq::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// repeated string wsids = 3;
inline int CreamFamilyReq::wsids_size() const {
  return wsids_.size();
}
inline void CreamFamilyReq::clear_wsids() {
  wsids_.Clear();
}
inline const ::std::string& CreamFamilyReq::wsids(int index) const {
  return wsids_.Get(index);
}
inline ::std::string* CreamFamilyReq::mutable_wsids(int index) {
  return wsids_.Mutable(index);
}
inline void CreamFamilyReq::set_wsids(int index, const ::std::string& value) {
  wsids_.Mutable(index)->assign(value);
}
inline void CreamFamilyReq::set_wsids(int index, const char* value) {
  wsids_.Mutable(index)->assign(value);
}
inline void CreamFamilyReq::set_wsids(int index, const char* value, size_t size) {
  wsids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CreamFamilyReq::add_wsids() {
  return wsids_.Add();
}
inline void CreamFamilyReq::add_wsids(const ::std::string& value) {
  wsids_.Add()->assign(value);
}
inline void CreamFamilyReq::add_wsids(const char* value) {
  wsids_.Add()->assign(value);
}
inline void CreamFamilyReq::add_wsids(const char* value, size_t size) {
  wsids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CreamFamilyReq::wsids() const {
  return wsids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CreamFamilyReq::mutable_wsids() {
  return &wsids_;
}

// -------------------------------------------------------------------

// CreamFamilyRes

// optional sint64 startTime = 1;
inline bool CreamFamilyRes::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CreamFamilyRes::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CreamFamilyRes::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CreamFamilyRes::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 CreamFamilyRes::starttime() const {
  return starttime_;
}
inline void CreamFamilyRes::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional sint64 endTime = 2;
inline bool CreamFamilyRes::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CreamFamilyRes::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CreamFamilyRes::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CreamFamilyRes::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 CreamFamilyRes::endtime() const {
  return endtime_;
}
inline void CreamFamilyRes::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// repeated .pp.YYuserList items = 3;
inline int CreamFamilyRes::items_size() const {
  return items_.size();
}
inline void CreamFamilyRes::clear_items() {
  items_.Clear();
}
inline const ::pp::YYuserList& CreamFamilyRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::YYuserList* CreamFamilyRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::YYuserList* CreamFamilyRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::YYuserList >&
CreamFamilyRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::YYuserList >*
CreamFamilyRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// YYuserList

// optional uint32 wsid = 1;
inline bool YYuserList::has_wsid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYuserList::set_has_wsid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYuserList::clear_has_wsid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYuserList::clear_wsid() {
  wsid_ = 0u;
  clear_has_wsid();
}
inline ::google::protobuf::uint32 YYuserList::wsid() const {
  return wsid_;
}
inline void YYuserList::set_wsid(::google::protobuf::uint32 value) {
  set_has_wsid();
  wsid_ = value;
}

// optional string name = 2;
inline bool YYuserList::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYuserList::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYuserList::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYuserList::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& YYuserList::name() const {
  return *name_;
}
inline void YYuserList::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYuserList::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYuserList::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYuserList::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* YYuserList::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYuserList::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint64 createTime = 3;
inline bool YYuserList::has_createtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYuserList::set_has_createtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYuserList::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYuserList::clear_createtime() {
  createtime_ = GOOGLE_LONGLONG(0);
  clear_has_createtime();
}
inline ::google::protobuf::int64 YYuserList::createtime() const {
  return createtime_;
}
inline void YYuserList::set_createtime(::google::protobuf::int64 value) {
  set_has_createtime();
  createtime_ = value;
}

// optional uint32 FamilyNumAll = 4;
inline bool YYuserList::has_familynumall() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYuserList::set_has_familynumall() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYuserList::clear_has_familynumall() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYuserList::clear_familynumall() {
  familynumall_ = 0u;
  clear_has_familynumall();
}
inline ::google::protobuf::uint32 YYuserList::familynumall() const {
  return familynumall_;
}
inline void YYuserList::set_familynumall(::google::protobuf::uint32 value) {
  set_has_familynumall();
  familynumall_ = value;
}

// optional uint32 FamilyNumLv2 = 5;
inline bool YYuserList::has_familynumlv2() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YYuserList::set_has_familynumlv2() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YYuserList::clear_has_familynumlv2() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YYuserList::clear_familynumlv2() {
  familynumlv2_ = 0u;
  clear_has_familynumlv2();
}
inline ::google::protobuf::uint32 YYuserList::familynumlv2() const {
  return familynumlv2_;
}
inline void YYuserList::set_familynumlv2(::google::protobuf::uint32 value) {
  set_has_familynumlv2();
  familynumlv2_ = value;
}

// optional uint32 FamilyNumNew = 6;
inline bool YYuserList::has_familynumnew() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YYuserList::set_has_familynumnew() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YYuserList::clear_has_familynumnew() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YYuserList::clear_familynumnew() {
  familynumnew_ = 0u;
  clear_has_familynumnew();
}
inline ::google::protobuf::uint32 YYuserList::familynumnew() const {
  return familynumnew_;
}
inline void YYuserList::set_familynumnew(::google::protobuf::uint32 value) {
  set_has_familynumnew();
  familynumnew_ = value;
}

// optional uint32 RepeatIp = 7;
inline bool YYuserList::has_repeatip() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void YYuserList::set_has_repeatip() {
  _has_bits_[0] |= 0x00000040u;
}
inline void YYuserList::clear_has_repeatip() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void YYuserList::clear_repeatip() {
  repeatip_ = 0u;
  clear_has_repeatip();
}
inline ::google::protobuf::uint32 YYuserList::repeatip() const {
  return repeatip_;
}
inline void YYuserList::set_repeatip(::google::protobuf::uint32 value) {
  set_has_repeatip();
  repeatip_ = value;
}

// optional uint32 RepeatMac = 8;
inline bool YYuserList::has_repeatmac() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void YYuserList::set_has_repeatmac() {
  _has_bits_[0] |= 0x00000080u;
}
inline void YYuserList::clear_has_repeatmac() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void YYuserList::clear_repeatmac() {
  repeatmac_ = 0u;
  clear_has_repeatmac();
}
inline ::google::protobuf::uint32 YYuserList::repeatmac() const {
  return repeatmac_;
}
inline void YYuserList::set_repeatmac(::google::protobuf::uint32 value) {
  set_has_repeatmac();
  repeatmac_ = value;
}

// optional uint32 FamilyNumNewLv1 = 9;
inline bool YYuserList::has_familynumnewlv1() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void YYuserList::set_has_familynumnewlv1() {
  _has_bits_[0] |= 0x00000100u;
}
inline void YYuserList::clear_has_familynumnewlv1() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void YYuserList::clear_familynumnewlv1() {
  familynumnewlv1_ = 0u;
  clear_has_familynumnewlv1();
}
inline ::google::protobuf::uint32 YYuserList::familynumnewlv1() const {
  return familynumnewlv1_;
}
inline void YYuserList::set_familynumnewlv1(::google::protobuf::uint32 value) {
  set_has_familynumnewlv1();
  familynumnewlv1_ = value;
}

// -------------------------------------------------------------------

// TopCharmReq

// -------------------------------------------------------------------

// TopCharmRes

// repeated .pp.TopCharm items = 1;
inline int TopCharmRes::items_size() const {
  return items_.size();
}
inline void TopCharmRes::clear_items() {
  items_.Clear();
}
inline const ::pp::TopCharm& TopCharmRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::TopCharm* TopCharmRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::TopCharm* TopCharmRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::TopCharm >&
TopCharmRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::TopCharm >*
TopCharmRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// TopCharm

// optional uint32 month = 1;
inline bool TopCharm::has_month() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TopCharm::set_has_month() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TopCharm::clear_has_month() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TopCharm::clear_month() {
  month_ = 0u;
  clear_has_month();
}
inline ::google::protobuf::uint32 TopCharm::month() const {
  return month_;
}
inline void TopCharm::set_month(::google::protobuf::uint32 value) {
  set_has_month();
  month_ = value;
}

// optional uint32 uid = 2;
inline bool TopCharm::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TopCharm::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TopCharm::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TopCharm::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 TopCharm::uid() const {
  return uid_;
}
inline void TopCharm::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 charmLevel = 3;
inline bool TopCharm::has_charmlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TopCharm::set_has_charmlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TopCharm::clear_has_charmlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TopCharm::clear_charmlevel() {
  charmlevel_ = 0u;
  clear_has_charmlevel();
}
inline ::google::protobuf::uint32 TopCharm::charmlevel() const {
  return charmlevel_;
}
inline void TopCharm::set_charmlevel(::google::protobuf::uint32 value) {
  set_has_charmlevel();
  charmlevel_ = value;
}

// -------------------------------------------------------------------

// UserLoginStatItems

// optional string date = 1;
inline bool UserLoginStatItems::has_date() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginStatItems::set_has_date() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginStatItems::clear_has_date() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginStatItems::clear_date() {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    date_->clear();
  }
  clear_has_date();
}
inline const ::std::string& UserLoginStatItems::date() const {
  return *date_;
}
inline void UserLoginStatItems::set_date(const ::std::string& value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void UserLoginStatItems::set_date(const char* value) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(value);
}
inline void UserLoginStatItems::set_date(const char* value, size_t size) {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  date_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginStatItems::mutable_date() {
  set_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    date_ = new ::std::string;
  }
  return date_;
}
inline ::std::string* UserLoginStatItems::release_date() {
  clear_has_date();
  if (date_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = date_;
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginStatItems::set_allocated_date(::std::string* date) {
  if (date_ != &::google::protobuf::internal::kEmptyString) {
    delete date_;
  }
  if (date) {
    set_has_date();
    date_ = date;
  } else {
    clear_has_date();
    date_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string StatDate = 2;
inline bool UserLoginStatItems::has_statdate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginStatItems::set_has_statdate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginStatItems::clear_has_statdate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginStatItems::clear_statdate() {
  if (statdate_ != &::google::protobuf::internal::kEmptyString) {
    statdate_->clear();
  }
  clear_has_statdate();
}
inline const ::std::string& UserLoginStatItems::statdate() const {
  return *statdate_;
}
inline void UserLoginStatItems::set_statdate(const ::std::string& value) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(value);
}
inline void UserLoginStatItems::set_statdate(const char* value) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(value);
}
inline void UserLoginStatItems::set_statdate(const char* value, size_t size) {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  statdate_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginStatItems::mutable_statdate() {
  set_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    statdate_ = new ::std::string;
  }
  return statdate_;
}
inline ::std::string* UserLoginStatItems::release_statdate() {
  clear_has_statdate();
  if (statdate_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = statdate_;
    statdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginStatItems::set_allocated_statdate(::std::string* statdate) {
  if (statdate_ != &::google::protobuf::internal::kEmptyString) {
    delete statdate_;
  }
  if (statdate) {
    set_has_statdate();
    statdate_ = statdate;
  } else {
    clear_has_statdate();
    statdate_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 LoginUsers = 3;
inline bool UserLoginStatItems::has_loginusers() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserLoginStatItems::set_has_loginusers() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserLoginStatItems::clear_has_loginusers() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserLoginStatItems::clear_loginusers() {
  loginusers_ = 0u;
  clear_has_loginusers();
}
inline ::google::protobuf::uint32 UserLoginStatItems::loginusers() const {
  return loginusers_;
}
inline void UserLoginStatItems::set_loginusers(::google::protobuf::uint32 value) {
  set_has_loginusers();
  loginusers_ = value;
}

// optional uint32 AndroidLoginUsers = 4;
inline bool UserLoginStatItems::has_androidloginusers() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UserLoginStatItems::set_has_androidloginusers() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UserLoginStatItems::clear_has_androidloginusers() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UserLoginStatItems::clear_androidloginusers() {
  androidloginusers_ = 0u;
  clear_has_androidloginusers();
}
inline ::google::protobuf::uint32 UserLoginStatItems::androidloginusers() const {
  return androidloginusers_;
}
inline void UserLoginStatItems::set_androidloginusers(::google::protobuf::uint32 value) {
  set_has_androidloginusers();
  androidloginusers_ = value;
}

// optional uint32 IosLoginUsers = 5;
inline bool UserLoginStatItems::has_iosloginusers() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void UserLoginStatItems::set_has_iosloginusers() {
  _has_bits_[0] |= 0x00000010u;
}
inline void UserLoginStatItems::clear_has_iosloginusers() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void UserLoginStatItems::clear_iosloginusers() {
  iosloginusers_ = 0u;
  clear_has_iosloginusers();
}
inline ::google::protobuf::uint32 UserLoginStatItems::iosloginusers() const {
  return iosloginusers_;
}
inline void UserLoginStatItems::set_iosloginusers(::google::protobuf::uint32 value) {
  set_has_iosloginusers();
  iosloginusers_ = value;
}

// optional uint32 YYLoginUsers = 6;
inline bool UserLoginStatItems::has_yyloginusers() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void UserLoginStatItems::set_has_yyloginusers() {
  _has_bits_[0] |= 0x00000020u;
}
inline void UserLoginStatItems::clear_has_yyloginusers() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void UserLoginStatItems::clear_yyloginusers() {
  yyloginusers_ = 0u;
  clear_has_yyloginusers();
}
inline ::google::protobuf::uint32 UserLoginStatItems::yyloginusers() const {
  return yyloginusers_;
}
inline void UserLoginStatItems::set_yyloginusers(::google::protobuf::uint32 value) {
  set_has_yyloginusers();
  yyloginusers_ = value;
}

// optional uint32 ShowLikes = 7;
inline bool UserLoginStatItems::has_showlikes() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void UserLoginStatItems::set_has_showlikes() {
  _has_bits_[0] |= 0x00000040u;
}
inline void UserLoginStatItems::clear_has_showlikes() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void UserLoginStatItems::clear_showlikes() {
  showlikes_ = 0u;
  clear_has_showlikes();
}
inline ::google::protobuf::uint32 UserLoginStatItems::showlikes() const {
  return showlikes_;
}
inline void UserLoginStatItems::set_showlikes(::google::protobuf::uint32 value) {
  set_has_showlikes();
  showlikes_ = value;
}

// optional uint32 ShowLikeUsers = 8;
inline bool UserLoginStatItems::has_showlikeusers() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void UserLoginStatItems::set_has_showlikeusers() {
  _has_bits_[0] |= 0x00000080u;
}
inline void UserLoginStatItems::clear_has_showlikeusers() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void UserLoginStatItems::clear_showlikeusers() {
  showlikeusers_ = 0u;
  clear_has_showlikeusers();
}
inline ::google::protobuf::uint32 UserLoginStatItems::showlikeusers() const {
  return showlikeusers_;
}
inline void UserLoginStatItems::set_showlikeusers(::google::protobuf::uint32 value) {
  set_has_showlikeusers();
  showlikeusers_ = value;
}

// -------------------------------------------------------------------

// UserLoginStatReq

// optional string startTime = 1;
inline bool UserLoginStatReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginStatReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginStatReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginStatReq::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& UserLoginStatReq::starttime() const {
  return *starttime_;
}
inline void UserLoginStatReq::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void UserLoginStatReq::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void UserLoginStatReq::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginStatReq::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* UserLoginStatReq::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginStatReq::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 2;
inline bool UserLoginStatReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginStatReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginStatReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginStatReq::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& UserLoginStatReq::endtime() const {
  return *endtime_;
}
inline void UserLoginStatReq::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void UserLoginStatReq::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void UserLoginStatReq::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginStatReq::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* UserLoginStatReq::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginStatReq::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UserLoginStatRes

// optional string startTime = 1;
inline bool UserLoginStatRes::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserLoginStatRes::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserLoginStatRes::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserLoginStatRes::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& UserLoginStatRes::starttime() const {
  return *starttime_;
}
inline void UserLoginStatRes::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void UserLoginStatRes::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void UserLoginStatRes::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginStatRes::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* UserLoginStatRes::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginStatRes::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 2;
inline bool UserLoginStatRes::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserLoginStatRes::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserLoginStatRes::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserLoginStatRes::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& UserLoginStatRes::endtime() const {
  return *endtime_;
}
inline void UserLoginStatRes::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void UserLoginStatRes::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void UserLoginStatRes::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserLoginStatRes::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* UserLoginStatRes::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserLoginStatRes::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.UserLoginStatItems items = 3;
inline int UserLoginStatRes::items_size() const {
  return items_.size();
}
inline void UserLoginStatRes::clear_items() {
  items_.Clear();
}
inline const ::pp::UserLoginStatItems& UserLoginStatRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::UserLoginStatItems* UserLoginStatRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::UserLoginStatItems* UserLoginStatRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::UserLoginStatItems >&
UserLoginStatRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::UserLoginStatItems >*
UserLoginStatRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ConfigJsonActData

// optional string name = 1;
inline bool ConfigJsonActData::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigJsonActData::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigJsonActData::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigJsonActData::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConfigJsonActData::name() const {
  return *name_;
}
inline void ConfigJsonActData::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigJsonActData::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigJsonActData::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonActData::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConfigJsonActData::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonActData::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string jsondata = 2;
inline bool ConfigJsonActData::has_jsondata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigJsonActData::set_has_jsondata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigJsonActData::clear_has_jsondata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigJsonActData::clear_jsondata() {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    jsondata_->clear();
  }
  clear_has_jsondata();
}
inline const ::std::string& ConfigJsonActData::jsondata() const {
  return *jsondata_;
}
inline void ConfigJsonActData::set_jsondata(const ::std::string& value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonActData::set_jsondata(const char* value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonActData::set_jsondata(const char* value, size_t size) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonActData::mutable_jsondata() {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  return jsondata_;
}
inline ::std::string* ConfigJsonActData::release_jsondata() {
  clear_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsondata_;
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonActData::set_allocated_jsondata(::std::string* jsondata) {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    delete jsondata_;
  }
  if (jsondata) {
    set_has_jsondata();
    jsondata_ = jsondata;
  } else {
    clear_has_jsondata();
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigJsonActListReq

// optional string name = 1;
inline bool ConfigJsonActListReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigJsonActListReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigJsonActListReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigJsonActListReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConfigJsonActListReq::name() const {
  return *name_;
}
inline void ConfigJsonActListReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigJsonActListReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigJsonActListReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonActListReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConfigJsonActListReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonActListReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigJsonActListRes

// repeated .pp.ConfigJsonActData items = 1;
inline int ConfigJsonActListRes::items_size() const {
  return items_.size();
}
inline void ConfigJsonActListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::ConfigJsonActData& ConfigJsonActListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::ConfigJsonActData* ConfigJsonActListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::ConfigJsonActData* ConfigJsonActListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonActData >&
ConfigJsonActListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ConfigJsonActData >*
ConfigJsonActListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ConfigJsonActStarReq

// -------------------------------------------------------------------

// ConfigJsonActRes

// optional string jsondata = 1;
inline bool ConfigJsonActRes::has_jsondata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigJsonActRes::set_has_jsondata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigJsonActRes::clear_has_jsondata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigJsonActRes::clear_jsondata() {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    jsondata_->clear();
  }
  clear_has_jsondata();
}
inline const ::std::string& ConfigJsonActRes::jsondata() const {
  return *jsondata_;
}
inline void ConfigJsonActRes::set_jsondata(const ::std::string& value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonActRes::set_jsondata(const char* value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonActRes::set_jsondata(const char* value, size_t size) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonActRes::mutable_jsondata() {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  return jsondata_;
}
inline ::std::string* ConfigJsonActRes::release_jsondata() {
  clear_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsondata_;
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonActRes::set_allocated_jsondata(::std::string* jsondata) {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    delete jsondata_;
  }
  if (jsondata) {
    set_has_jsondata();
    jsondata_ = jsondata;
  } else {
    clear_has_jsondata();
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ConfigJsonActModifyReq

// required string name = 1;
inline bool ConfigJsonActModifyReq::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigJsonActModifyReq::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigJsonActModifyReq::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigJsonActModifyReq::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ConfigJsonActModifyReq::name() const {
  return *name_;
}
inline void ConfigJsonActModifyReq::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigJsonActModifyReq::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ConfigJsonActModifyReq::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonActModifyReq::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ConfigJsonActModifyReq::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonActModifyReq::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string jsondata = 2;
inline bool ConfigJsonActModifyReq::has_jsondata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConfigJsonActModifyReq::set_has_jsondata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConfigJsonActModifyReq::clear_has_jsondata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConfigJsonActModifyReq::clear_jsondata() {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    jsondata_->clear();
  }
  clear_has_jsondata();
}
inline const ::std::string& ConfigJsonActModifyReq::jsondata() const {
  return *jsondata_;
}
inline void ConfigJsonActModifyReq::set_jsondata(const ::std::string& value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonActModifyReq::set_jsondata(const char* value) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(value);
}
inline void ConfigJsonActModifyReq::set_jsondata(const char* value, size_t size) {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  jsondata_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ConfigJsonActModifyReq::mutable_jsondata() {
  set_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    jsondata_ = new ::std::string;
  }
  return jsondata_;
}
inline ::std::string* ConfigJsonActModifyReq::release_jsondata() {
  clear_has_jsondata();
  if (jsondata_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = jsondata_;
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ConfigJsonActModifyReq::set_allocated_jsondata(::std::string* jsondata) {
  if (jsondata_ != &::google::protobuf::internal::kEmptyString) {
    delete jsondata_;
  }
  if (jsondata) {
    set_has_jsondata();
    jsondata_ = jsondata;
  } else {
    clear_has_jsondata();
    jsondata_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActStarFormReq

// required uint32 signType = 1;
inline bool ActStarFormReq::has_signtype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActStarFormReq::set_has_signtype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActStarFormReq::clear_has_signtype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActStarFormReq::clear_signtype() {
  signtype_ = 0u;
  clear_has_signtype();
}
inline ::google::protobuf::uint32 ActStarFormReq::signtype() const {
  return signtype_;
}
inline void ActStarFormReq::set_signtype(::google::protobuf::uint32 value) {
  set_has_signtype();
  signtype_ = value;
}

// required uint32 joinType = 2;
inline bool ActStarFormReq::has_jointype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActStarFormReq::set_has_jointype() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActStarFormReq::clear_has_jointype() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActStarFormReq::clear_jointype() {
  jointype_ = 0u;
  clear_has_jointype();
}
inline ::google::protobuf::uint32 ActStarFormReq::jointype() const {
  return jointype_;
}
inline void ActStarFormReq::set_jointype(::google::protobuf::uint32 value) {
  set_has_jointype();
  jointype_ = value;
}

// -------------------------------------------------------------------

// ActMsgListReq

// required uint32 index = 1;
inline bool ActMsgListReq::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActMsgListReq::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActMsgListReq::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActMsgListReq::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 ActMsgListReq::index() const {
  return index_;
}
inline void ActMsgListReq::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
}

// required uint32 fetchs = 2;
inline bool ActMsgListReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActMsgListReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActMsgListReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActMsgListReq::clear_fetchs() {
  fetchs_ = 0u;
  clear_has_fetchs();
}
inline ::google::protobuf::uint32 ActMsgListReq::fetchs() const {
  return fetchs_;
}
inline void ActMsgListReq::set_fetchs(::google::protobuf::uint32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// required uint32 act = 3;
inline bool ActMsgListReq::has_act() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActMsgListReq::set_has_act() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActMsgListReq::clear_has_act() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActMsgListReq::clear_act() {
  act_ = 0u;
  clear_has_act();
}
inline ::google::protobuf::uint32 ActMsgListReq::act() const {
  return act_;
}
inline void ActMsgListReq::set_act(::google::protobuf::uint32 value) {
  set_has_act();
  act_ = value;
}

// -------------------------------------------------------------------

// ActMsgListRes

// repeated .pp.ActMsgList items = 1;
inline int ActMsgListRes::items_size() const {
  return items_.size();
}
inline void ActMsgListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::ActMsgList& ActMsgListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::ActMsgList* ActMsgListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::ActMsgList* ActMsgListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ActMsgList >&
ActMsgListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ActMsgList >*
ActMsgListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// ActMsgList

// optional uint32 revision = 1;
inline bool ActMsgList::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActMsgList::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActMsgList::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActMsgList::clear_revision() {
  revision_ = 0u;
  clear_has_revision();
}
inline ::google::protobuf::uint32 ActMsgList::revision() const {
  return revision_;
}
inline void ActMsgList::set_revision(::google::protobuf::uint32 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint32 gid = 2;
inline bool ActMsgList::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActMsgList::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActMsgList::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActMsgList::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 ActMsgList::gid() const {
  return gid_;
}
inline void ActMsgList::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 uid = 3;
inline bool ActMsgList::has_uid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActMsgList::set_has_uid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActMsgList::clear_has_uid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActMsgList::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 ActMsgList::uid() const {
  return uid_;
}
inline void ActMsgList::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// optional string url = 4;
inline bool ActMsgList::has_url() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActMsgList::set_has_url() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActMsgList::clear_has_url() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActMsgList::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& ActMsgList::url() const {
  return *url_;
}
inline void ActMsgList::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ActMsgList::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void ActMsgList::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActMsgList::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* ActMsgList::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActMsgList::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 type = 5;
inline bool ActMsgList::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActMsgList::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActMsgList::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActMsgList::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 ActMsgList::type() const {
  return type_;
}
inline void ActMsgList::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string description = 6;
inline bool ActMsgList::has_description() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActMsgList::set_has_description() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActMsgList::clear_has_description() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActMsgList::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ActMsgList::description() const {
  return *description_;
}
inline void ActMsgList::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ActMsgList::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ActMsgList::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActMsgList::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ActMsgList::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActMsgList::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 act = 7;
inline bool ActMsgList::has_act() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ActMsgList::set_has_act() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ActMsgList::clear_has_act() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ActMsgList::clear_act() {
  act_ = 0u;
  clear_has_act();
}
inline ::google::protobuf::uint32 ActMsgList::act() const {
  return act_;
}
inline void ActMsgList::set_act(::google::protobuf::uint32 value) {
  set_has_act();
  act_ = value;
}

// optional string createTime = 8;
inline bool ActMsgList::has_createtime() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ActMsgList::set_has_createtime() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ActMsgList::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ActMsgList::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& ActMsgList::createtime() const {
  return *createtime_;
}
inline void ActMsgList::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void ActMsgList::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void ActMsgList::set_createtime(const char* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActMsgList::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  return createtime_;
}
inline ::std::string* ActMsgList::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActMsgList::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActMsgModifyReq

// optional uint64 revision = 1;
inline bool ActMsgModifyReq::has_revision() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActMsgModifyReq::set_has_revision() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActMsgModifyReq::clear_has_revision() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActMsgModifyReq::clear_revision() {
  revision_ = GOOGLE_ULONGLONG(0);
  clear_has_revision();
}
inline ::google::protobuf::uint64 ActMsgModifyReq::revision() const {
  return revision_;
}
inline void ActMsgModifyReq::set_revision(::google::protobuf::uint64 value) {
  set_has_revision();
  revision_ = value;
}

// optional uint64 gid = 2;
inline bool ActMsgModifyReq::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActMsgModifyReq::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActMsgModifyReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActMsgModifyReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ActMsgModifyReq::gid() const {
  return gid_;
}
inline void ActMsgModifyReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 act = 3;
inline bool ActMsgModifyReq::has_act() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActMsgModifyReq::set_has_act() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActMsgModifyReq::clear_has_act() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActMsgModifyReq::clear_act() {
  act_ = 0u;
  clear_has_act();
}
inline ::google::protobuf::uint32 ActMsgModifyReq::act() const {
  return act_;
}
inline void ActMsgModifyReq::set_act(::google::protobuf::uint32 value) {
  set_has_act();
  act_ = value;
}

// optional string description = 4;
inline bool ActMsgModifyReq::has_description() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActMsgModifyReq::set_has_description() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActMsgModifyReq::clear_has_description() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActMsgModifyReq::clear_description() {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    description_->clear();
  }
  clear_has_description();
}
inline const ::std::string& ActMsgModifyReq::description() const {
  return *description_;
}
inline void ActMsgModifyReq::set_description(const ::std::string& value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ActMsgModifyReq::set_description(const char* value) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(value);
}
inline void ActMsgModifyReq::set_description(const char* value, size_t size) {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  description_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActMsgModifyReq::mutable_description() {
  set_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    description_ = new ::std::string;
  }
  return description_;
}
inline ::std::string* ActMsgModifyReq::release_description() {
  clear_has_description();
  if (description_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = description_;
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActMsgModifyReq::set_allocated_description(::std::string* description) {
  if (description_ != &::google::protobuf::internal::kEmptyString) {
    delete description_;
  }
  if (description) {
    set_has_description();
    description_ = description;
  } else {
    clear_has_description();
    description_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 5;
inline bool ActMsgModifyReq::has_state() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActMsgModifyReq::set_has_state() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActMsgModifyReq::clear_has_state() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActMsgModifyReq::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 ActMsgModifyReq::state() const {
  return state_;
}
inline void ActMsgModifyReq::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ActRegMemberAddReq

// required string act = 1;
inline bool ActRegMemberAddReq::has_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberAddReq::set_has_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberAddReq::clear_has_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberAddReq::clear_act() {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    act_->clear();
  }
  clear_has_act();
}
inline const ::std::string& ActRegMemberAddReq::act() const {
  return *act_;
}
inline void ActRegMemberAddReq::set_act(const ::std::string& value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberAddReq::set_act(const char* value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberAddReq::set_act(const char* value, size_t size) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberAddReq::mutable_act() {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  return act_;
}
inline ::std::string* ActRegMemberAddReq::release_act() {
  clear_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = act_;
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberAddReq::set_allocated_act(::std::string* act) {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    delete act_;
  }
  if (act) {
    set_has_act();
    act_ = act;
  } else {
    clear_has_act();
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 uid = 2;
inline bool ActRegMemberAddReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberAddReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberAddReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberAddReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ActRegMemberAddReq::uid() const {
  return uid_;
}
inline void ActRegMemberAddReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional bool check = 3;
inline bool ActRegMemberAddReq::has_check() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegMemberAddReq::set_has_check() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegMemberAddReq::clear_has_check() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegMemberAddReq::clear_check() {
  check_ = false;
  clear_has_check();
}
inline bool ActRegMemberAddReq::check() const {
  return check_;
}
inline void ActRegMemberAddReq::set_check(bool value) {
  set_has_check();
  check_ = value;
}

// -------------------------------------------------------------------

// ActRegMemberModifyReq

// required string act = 1;
inline bool ActRegMemberModifyReq::has_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberModifyReq::set_has_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberModifyReq::clear_has_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberModifyReq::clear_act() {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    act_->clear();
  }
  clear_has_act();
}
inline const ::std::string& ActRegMemberModifyReq::act() const {
  return *act_;
}
inline void ActRegMemberModifyReq::set_act(const ::std::string& value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberModifyReq::set_act(const char* value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberModifyReq::set_act(const char* value, size_t size) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberModifyReq::mutable_act() {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  return act_;
}
inline ::std::string* ActRegMemberModifyReq::release_act() {
  clear_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = act_;
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberModifyReq::set_allocated_act(::std::string* act) {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    delete act_;
  }
  if (act) {
    set_has_act();
    act_ = act;
  } else {
    clear_has_act();
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint64 uid = 2;
inline bool ActRegMemberModifyReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberModifyReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberModifyReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberModifyReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ActRegMemberModifyReq::uid() const {
  return uid_;
}
inline void ActRegMemberModifyReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint32 state = 3;
inline bool ActRegMemberModifyReq::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegMemberModifyReq::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegMemberModifyReq::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegMemberModifyReq::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 ActRegMemberModifyReq::state() const {
  return state_;
}
inline void ActRegMemberModifyReq::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ActRegMemberStateReq

// required uint64 uid = 1;
inline bool ActRegMemberStateReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberStateReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberStateReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberStateReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ActRegMemberStateReq::uid() const {
  return uid_;
}
inline void ActRegMemberStateReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// required uint64 gid = 2;
inline bool ActRegMemberStateReq::has_gid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberStateReq::set_has_gid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberStateReq::clear_has_gid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberStateReq::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 ActRegMemberStateReq::gid() const {
  return gid_;
}
inline void ActRegMemberStateReq::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// required string act = 3;
inline bool ActRegMemberStateReq::has_act() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegMemberStateReq::set_has_act() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegMemberStateReq::clear_has_act() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegMemberStateReq::clear_act() {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    act_->clear();
  }
  clear_has_act();
}
inline const ::std::string& ActRegMemberStateReq::act() const {
  return *act_;
}
inline void ActRegMemberStateReq::set_act(const ::std::string& value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberStateReq::set_act(const char* value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberStateReq::set_act(const char* value, size_t size) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberStateReq::mutable_act() {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  return act_;
}
inline ::std::string* ActRegMemberStateReq::release_act() {
  clear_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = act_;
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberStateReq::set_allocated_act(::std::string* act) {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    delete act_;
  }
  if (act) {
    set_has_act();
    act_ = act;
  } else {
    clear_has_act();
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActRegMemberStateRes

// optional uint64 uid = 1;
inline bool ActRegMemberStateRes::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberStateRes::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberStateRes::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberStateRes::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ActRegMemberStateRes::uid() const {
  return uid_;
}
inline void ActRegMemberStateRes::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string act = 2;
inline bool ActRegMemberStateRes::has_act() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberStateRes::set_has_act() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberStateRes::clear_has_act() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberStateRes::clear_act() {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    act_->clear();
  }
  clear_has_act();
}
inline const ::std::string& ActRegMemberStateRes::act() const {
  return *act_;
}
inline void ActRegMemberStateRes::set_act(const ::std::string& value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberStateRes::set_act(const char* value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberStateRes::set_act(const char* value, size_t size) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberStateRes::mutable_act() {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  return act_;
}
inline ::std::string* ActRegMemberStateRes::release_act() {
  clear_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = act_;
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberStateRes::set_allocated_act(::std::string* act) {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    delete act_;
  }
  if (act) {
    set_has_act();
    act_ = act;
  } else {
    clear_has_act();
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.ActRegMemberState weekReport = 3;
inline int ActRegMemberStateRes::weekreport_size() const {
  return weekreport_.size();
}
inline void ActRegMemberStateRes::clear_weekreport() {
  weekreport_.Clear();
}
inline const ::pp::ActRegMemberState& ActRegMemberStateRes::weekreport(int index) const {
  return weekreport_.Get(index);
}
inline ::pp::ActRegMemberState* ActRegMemberStateRes::mutable_weekreport(int index) {
  return weekreport_.Mutable(index);
}
inline ::pp::ActRegMemberState* ActRegMemberStateRes::add_weekreport() {
  return weekreport_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberState >&
ActRegMemberStateRes::weekreport() const {
  return weekreport_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberState >*
ActRegMemberStateRes::mutable_weekreport() {
  return &weekreport_;
}

// repeated .pp.ActRegMembers members = 4;
inline int ActRegMemberStateRes::members_size() const {
  return members_.size();
}
inline void ActRegMemberStateRes::clear_members() {
  members_.Clear();
}
inline const ::pp::ActRegMembers& ActRegMemberStateRes::members(int index) const {
  return members_.Get(index);
}
inline ::pp::ActRegMembers* ActRegMemberStateRes::mutable_members(int index) {
  return members_.Mutable(index);
}
inline ::pp::ActRegMembers* ActRegMemberStateRes::add_members() {
  return members_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegMembers >&
ActRegMemberStateRes::members() const {
  return members_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegMembers >*
ActRegMemberStateRes::mutable_members() {
  return &members_;
}

// repeated .pp.ActRegVoice voice = 5;
inline int ActRegMemberStateRes::voice_size() const {
  return voice_.size();
}
inline void ActRegMemberStateRes::clear_voice() {
  voice_.Clear();
}
inline const ::pp::ActRegVoice& ActRegMemberStateRes::voice(int index) const {
  return voice_.Get(index);
}
inline ::pp::ActRegVoice* ActRegMemberStateRes::mutable_voice(int index) {
  return voice_.Mutable(index);
}
inline ::pp::ActRegVoice* ActRegMemberStateRes::add_voice() {
  return voice_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegVoice >&
ActRegMemberStateRes::voice() const {
  return voice_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegVoice >*
ActRegMemberStateRes::mutable_voice() {
  return &voice_;
}

// -------------------------------------------------------------------

// ActRegMemberListReq

// required string act = 1;
inline bool ActRegMemberListReq::has_act() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberListReq::set_has_act() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberListReq::clear_has_act() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberListReq::clear_act() {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    act_->clear();
  }
  clear_has_act();
}
inline const ::std::string& ActRegMemberListReq::act() const {
  return *act_;
}
inline void ActRegMemberListReq::set_act(const ::std::string& value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberListReq::set_act(const char* value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberListReq::set_act(const char* value, size_t size) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberListReq::mutable_act() {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  return act_;
}
inline ::std::string* ActRegMemberListReq::release_act() {
  clear_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = act_;
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberListReq::set_allocated_act(::std::string* act) {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    delete act_;
  }
  if (act) {
    set_has_act();
    act_ = act;
  } else {
    clear_has_act();
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string startTime = 2;
inline bool ActRegMemberListReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberListReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberListReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberListReq::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& ActRegMemberListReq::starttime() const {
  return *starttime_;
}
inline void ActRegMemberListReq::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void ActRegMemberListReq::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void ActRegMemberListReq::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberListReq::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* ActRegMemberListReq::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberListReq::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string endTime = 3;
inline bool ActRegMemberListReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegMemberListReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegMemberListReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegMemberListReq::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& ActRegMemberListReq::endtime() const {
  return *endtime_;
}
inline void ActRegMemberListReq::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void ActRegMemberListReq::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void ActRegMemberListReq::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberListReq::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* ActRegMemberListReq::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberListReq::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required uint32 type1 = 4;
inline bool ActRegMemberListReq::has_type1() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActRegMemberListReq::set_has_type1() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActRegMemberListReq::clear_has_type1() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActRegMemberListReq::clear_type1() {
  type1_ = 0u;
  clear_has_type1();
}
inline ::google::protobuf::uint32 ActRegMemberListReq::type1() const {
  return type1_;
}
inline void ActRegMemberListReq::set_type1(::google::protobuf::uint32 value) {
  set_has_type1();
  type1_ = value;
}

// -------------------------------------------------------------------

// ActRegMemberListRes

// repeated .pp.ActRegMemberList uids = 1;
inline int ActRegMemberListRes::uids_size() const {
  return uids_.size();
}
inline void ActRegMemberListRes::clear_uids() {
  uids_.Clear();
}
inline const ::pp::ActRegMemberList& ActRegMemberListRes::uids(int index) const {
  return uids_.Get(index);
}
inline ::pp::ActRegMemberList* ActRegMemberListRes::mutable_uids(int index) {
  return uids_.Mutable(index);
}
inline ::pp::ActRegMemberList* ActRegMemberListRes::add_uids() {
  return uids_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberList >&
ActRegMemberListRes::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::ActRegMemberList >*
ActRegMemberListRes::mutable_uids() {
  return &uids_;
}

// -------------------------------------------------------------------

// ActRegMemberList

// optional uint64 uid = 1;
inline bool ActRegMemberList::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberList::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberList::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberList::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 ActRegMemberList::uid() const {
  return uid_;
}
inline void ActRegMemberList::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional string act = 2;
inline bool ActRegMemberList::has_act() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberList::set_has_act() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberList::clear_has_act() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberList::clear_act() {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    act_->clear();
  }
  clear_has_act();
}
inline const ::std::string& ActRegMemberList::act() const {
  return *act_;
}
inline void ActRegMemberList::set_act(const ::std::string& value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberList::set_act(const char* value) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(value);
}
inline void ActRegMemberList::set_act(const char* value, size_t size) {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  act_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberList::mutable_act() {
  set_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    act_ = new ::std::string;
  }
  return act_;
}
inline ::std::string* ActRegMemberList::release_act() {
  clear_has_act();
  if (act_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = act_;
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberList::set_allocated_act(::std::string* act) {
  if (act_ != &::google::protobuf::internal::kEmptyString) {
    delete act_;
  }
  if (act) {
    set_has_act();
    act_ = act;
  } else {
    clear_has_act();
    act_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 3;
inline bool ActRegMemberList::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegMemberList::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegMemberList::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegMemberList::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 ActRegMemberList::state() const {
  return state_;
}
inline void ActRegMemberList::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// optional uint32 charmLv = 4;
inline bool ActRegMemberList::has_charmlv() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActRegMemberList::set_has_charmlv() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActRegMemberList::clear_has_charmlv() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActRegMemberList::clear_charmlv() {
  charmlv_ = 0u;
  clear_has_charmlv();
}
inline ::google::protobuf::uint32 ActRegMemberList::charmlv() const {
  return charmlv_;
}
inline void ActRegMemberList::set_charmlv(::google::protobuf::uint32 value) {
  set_has_charmlv();
  charmlv_ = value;
}

// optional string dateTime = 5;
inline bool ActRegMemberList::has_datetime() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActRegMemberList::set_has_datetime() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActRegMemberList::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActRegMemberList::clear_datetime() {
  if (datetime_ != &::google::protobuf::internal::kEmptyString) {
    datetime_->clear();
  }
  clear_has_datetime();
}
inline const ::std::string& ActRegMemberList::datetime() const {
  return *datetime_;
}
inline void ActRegMemberList::set_datetime(const ::std::string& value) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(value);
}
inline void ActRegMemberList::set_datetime(const char* value) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(value);
}
inline void ActRegMemberList::set_datetime(const char* value, size_t size) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberList::mutable_datetime() {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  return datetime_;
}
inline ::std::string* ActRegMemberList::release_datetime() {
  clear_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datetime_;
    datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberList::set_allocated_datetime(::std::string* datetime) {
  if (datetime_ != &::google::protobuf::internal::kEmptyString) {
    delete datetime_;
  }
  if (datetime) {
    set_has_datetime();
    datetime_ = datetime;
  } else {
    clear_has_datetime();
    datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nick = 6;
inline bool ActRegMemberList::has_nick() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ActRegMemberList::set_has_nick() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ActRegMemberList::clear_has_nick() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ActRegMemberList::clear_nick() {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    nick_->clear();
  }
  clear_has_nick();
}
inline const ::std::string& ActRegMemberList::nick() const {
  return *nick_;
}
inline void ActRegMemberList::set_nick(const ::std::string& value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void ActRegMemberList::set_nick(const char* value) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(value);
}
inline void ActRegMemberList::set_nick(const char* value, size_t size) {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  nick_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberList::mutable_nick() {
  set_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    nick_ = new ::std::string;
  }
  return nick_;
}
inline ::std::string* ActRegMemberList::release_nick() {
  clear_has_nick();
  if (nick_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nick_;
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberList::set_allocated_nick(::std::string* nick) {
  if (nick_ != &::google::protobuf::internal::kEmptyString) {
    delete nick_;
  }
  if (nick) {
    set_has_nick();
    nick_ = nick;
  } else {
    clear_has_nick();
    nick_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CoinAwardRecordReq

// optional uint64 uid = 1;
inline bool CoinAwardRecordReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinAwardRecordReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinAwardRecordReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinAwardRecordReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CoinAwardRecordReq::uid() const {
  return uid_;
}
inline void CoinAwardRecordReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 opuid = 2;
inline bool CoinAwardRecordReq::has_opuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinAwardRecordReq::set_has_opuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinAwardRecordReq::clear_has_opuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinAwardRecordReq::clear_opuid() {
  opuid_ = GOOGLE_ULONGLONG(0);
  clear_has_opuid();
}
inline ::google::protobuf::uint64 CoinAwardRecordReq::opuid() const {
  return opuid_;
}
inline void CoinAwardRecordReq::set_opuid(::google::protobuf::uint64 value) {
  set_has_opuid();
  opuid_ = value;
}

// optional string startTime = 3;
inline bool CoinAwardRecordReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoinAwardRecordReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoinAwardRecordReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoinAwardRecordReq::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& CoinAwardRecordReq::starttime() const {
  return *starttime_;
}
inline void CoinAwardRecordReq::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void CoinAwardRecordReq::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void CoinAwardRecordReq::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinAwardRecordReq::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* CoinAwardRecordReq::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinAwardRecordReq::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 4;
inline bool CoinAwardRecordReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoinAwardRecordReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoinAwardRecordReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoinAwardRecordReq::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& CoinAwardRecordReq::endtime() const {
  return *endtime_;
}
inline void CoinAwardRecordReq::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CoinAwardRecordReq::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CoinAwardRecordReq::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinAwardRecordReq::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* CoinAwardRecordReq::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinAwardRecordReq::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// CoinAwardRecordRes

// optional string startTime = 1;
inline bool CoinAwardRecordRes::has_starttime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinAwardRecordRes::set_has_starttime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinAwardRecordRes::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinAwardRecordRes::clear_starttime() {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    starttime_->clear();
  }
  clear_has_starttime();
}
inline const ::std::string& CoinAwardRecordRes::starttime() const {
  return *starttime_;
}
inline void CoinAwardRecordRes::set_starttime(const ::std::string& value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void CoinAwardRecordRes::set_starttime(const char* value) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(value);
}
inline void CoinAwardRecordRes::set_starttime(const char* value, size_t size) {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  starttime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinAwardRecordRes::mutable_starttime() {
  set_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    starttime_ = new ::std::string;
  }
  return starttime_;
}
inline ::std::string* CoinAwardRecordRes::release_starttime() {
  clear_has_starttime();
  if (starttime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = starttime_;
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinAwardRecordRes::set_allocated_starttime(::std::string* starttime) {
  if (starttime_ != &::google::protobuf::internal::kEmptyString) {
    delete starttime_;
  }
  if (starttime) {
    set_has_starttime();
    starttime_ = starttime;
  } else {
    clear_has_starttime();
    starttime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string endTime = 2;
inline bool CoinAwardRecordRes::has_endtime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinAwardRecordRes::set_has_endtime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinAwardRecordRes::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinAwardRecordRes::clear_endtime() {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    endtime_->clear();
  }
  clear_has_endtime();
}
inline const ::std::string& CoinAwardRecordRes::endtime() const {
  return *endtime_;
}
inline void CoinAwardRecordRes::set_endtime(const ::std::string& value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CoinAwardRecordRes::set_endtime(const char* value) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(value);
}
inline void CoinAwardRecordRes::set_endtime(const char* value, size_t size) {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  endtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinAwardRecordRes::mutable_endtime() {
  set_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    endtime_ = new ::std::string;
  }
  return endtime_;
}
inline ::std::string* CoinAwardRecordRes::release_endtime() {
  clear_has_endtime();
  if (endtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = endtime_;
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinAwardRecordRes::set_allocated_endtime(::std::string* endtime) {
  if (endtime_ != &::google::protobuf::internal::kEmptyString) {
    delete endtime_;
  }
  if (endtime) {
    set_has_endtime();
    endtime_ = endtime;
  } else {
    clear_has_endtime();
    endtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.CoinAwardRecord items = 3;
inline int CoinAwardRecordRes::items_size() const {
  return items_.size();
}
inline void CoinAwardRecordRes::clear_items() {
  items_.Clear();
}
inline const ::pp::CoinAwardRecord& CoinAwardRecordRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::CoinAwardRecord* CoinAwardRecordRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::CoinAwardRecord* CoinAwardRecordRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::CoinAwardRecord >&
CoinAwardRecordRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::CoinAwardRecord >*
CoinAwardRecordRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// CoreUserListReq

// -------------------------------------------------------------------

// CoreUserListRes

// repeated .pp.CoreUser items = 1;
inline int CoreUserListRes::items_size() const {
  return items_.size();
}
inline void CoreUserListRes::clear_items() {
  items_.Clear();
}
inline const ::pp::CoreUser& CoreUserListRes::items(int index) const {
  return items_.Get(index);
}
inline ::pp::CoreUser* CoreUserListRes::mutable_items(int index) {
  return items_.Mutable(index);
}
inline ::pp::CoreUser* CoreUserListRes::add_items() {
  return items_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::CoreUser >&
CoreUserListRes::items() const {
  return items_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::CoreUser >*
CoreUserListRes::mutable_items() {
  return &items_;
}

// -------------------------------------------------------------------

// CoreUser

// optional uint64 uid = 1;
inline bool CoreUser::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoreUser::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoreUser::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoreUser::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CoreUser::uid() const {
  return uid_;
}
inline void CoreUser::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 type = 2;
inline bool CoreUser::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoreUser::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoreUser::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoreUser::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CoreUser::type() const {
  return type_;
}
inline void CoreUser::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CoreUserModifyReq

// optional uint32 optype = 1;
inline bool CoreUserModifyReq::has_optype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoreUserModifyReq::set_has_optype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoreUserModifyReq::clear_has_optype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoreUserModifyReq::clear_optype() {
  optype_ = 0u;
  clear_has_optype();
}
inline ::google::protobuf::uint32 CoreUserModifyReq::optype() const {
  return optype_;
}
inline void CoreUserModifyReq::set_optype(::google::protobuf::uint32 value) {
  set_has_optype();
  optype_ = value;
}

// optional uint64 uid = 2;
inline bool CoreUserModifyReq::has_uid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoreUserModifyReq::set_has_uid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoreUserModifyReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoreUserModifyReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CoreUserModifyReq::uid() const {
  return uid_;
}
inline void CoreUserModifyReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint32 type = 3;
inline bool CoreUserModifyReq::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoreUserModifyReq::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoreUserModifyReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoreUserModifyReq::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 CoreUserModifyReq::type() const {
  return type_;
}
inline void CoreUserModifyReq::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// CoinAwardRecord

// optional uint64 uid = 1;
inline bool CoinAwardRecord::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CoinAwardRecord::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CoinAwardRecord::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CoinAwardRecord::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 CoinAwardRecord::uid() const {
  return uid_;
}
inline void CoinAwardRecord::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional uint64 opuid = 2;
inline bool CoinAwardRecord::has_opuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CoinAwardRecord::set_has_opuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CoinAwardRecord::clear_has_opuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CoinAwardRecord::clear_opuid() {
  opuid_ = GOOGLE_ULONGLONG(0);
  clear_has_opuid();
}
inline ::google::protobuf::uint64 CoinAwardRecord::opuid() const {
  return opuid_;
}
inline void CoinAwardRecord::set_opuid(::google::protobuf::uint64 value) {
  set_has_opuid();
  opuid_ = value;
}

// optional uint64 coins = 3;
inline bool CoinAwardRecord::has_coins() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CoinAwardRecord::set_has_coins() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CoinAwardRecord::clear_has_coins() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CoinAwardRecord::clear_coins() {
  coins_ = GOOGLE_ULONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::uint64 CoinAwardRecord::coins() const {
  return coins_;
}
inline void CoinAwardRecord::set_coins(::google::protobuf::uint64 value) {
  set_has_coins();
  coins_ = value;
}

// optional string createTime = 4;
inline bool CoinAwardRecord::has_createtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CoinAwardRecord::set_has_createtime() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CoinAwardRecord::clear_has_createtime() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CoinAwardRecord::clear_createtime() {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    createtime_->clear();
  }
  clear_has_createtime();
}
inline const ::std::string& CoinAwardRecord::createtime() const {
  return *createtime_;
}
inline void CoinAwardRecord::set_createtime(const ::std::string& value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void CoinAwardRecord::set_createtime(const char* value) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(value);
}
inline void CoinAwardRecord::set_createtime(const char* value, size_t size) {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  createtime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CoinAwardRecord::mutable_createtime() {
  set_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    createtime_ = new ::std::string;
  }
  return createtime_;
}
inline ::std::string* CoinAwardRecord::release_createtime() {
  clear_has_createtime();
  if (createtime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = createtime_;
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CoinAwardRecord::set_allocated_createtime(::std::string* createtime) {
  if (createtime_ != &::google::protobuf::internal::kEmptyString) {
    delete createtime_;
  }
  if (createtime) {
    set_has_createtime();
    createtime_ = createtime;
  } else {
    clear_has_createtime();
    createtime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActRegMemberState

// optional string dateTime = 1;
inline bool ActRegMemberState::has_datetime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMemberState::set_has_datetime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMemberState::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMemberState::clear_datetime() {
  if (datetime_ != &::google::protobuf::internal::kEmptyString) {
    datetime_->clear();
  }
  clear_has_datetime();
}
inline const ::std::string& ActRegMemberState::datetime() const {
  return *datetime_;
}
inline void ActRegMemberState::set_datetime(const ::std::string& value) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(value);
}
inline void ActRegMemberState::set_datetime(const char* value) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(value);
}
inline void ActRegMemberState::set_datetime(const char* value, size_t size) {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  datetime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMemberState::mutable_datetime() {
  set_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    datetime_ = new ::std::string;
  }
  return datetime_;
}
inline ::std::string* ActRegMemberState::release_datetime() {
  clear_has_datetime();
  if (datetime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = datetime_;
    datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMemberState::set_allocated_datetime(::std::string* datetime) {
  if (datetime_ != &::google::protobuf::internal::kEmptyString) {
    delete datetime_;
  }
  if (datetime) {
    set_has_datetime();
    datetime_ = datetime;
  } else {
    clear_has_datetime();
    datetime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 state = 2;
inline bool ActRegMemberState::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMemberState::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMemberState::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMemberState::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 ActRegMemberState::state() const {
  return state_;
}
inline void ActRegMemberState::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
}

// -------------------------------------------------------------------

// ActRegMembers

// optional string statTime = 1;
inline bool ActRegMembers::has_stattime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegMembers::set_has_stattime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegMembers::clear_has_stattime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegMembers::clear_stattime() {
  if (stattime_ != &::google::protobuf::internal::kEmptyString) {
    stattime_->clear();
  }
  clear_has_stattime();
}
inline const ::std::string& ActRegMembers::stattime() const {
  return *stattime_;
}
inline void ActRegMembers::set_stattime(const ::std::string& value) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(value);
}
inline void ActRegMembers::set_stattime(const char* value) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(value);
}
inline void ActRegMembers::set_stattime(const char* value, size_t size) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMembers::mutable_stattime() {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  return stattime_;
}
inline ::std::string* ActRegMembers::release_stattime() {
  clear_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stattime_;
    stattime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMembers::set_allocated_stattime(::std::string* stattime) {
  if (stattime_ != &::google::protobuf::internal::kEmptyString) {
    delete stattime_;
  }
  if (stattime) {
    set_has_stattime();
    stattime_ = stattime;
  } else {
    clear_has_stattime();
    stattime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 categoryid = 2;
inline bool ActRegMembers::has_categoryid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegMembers::set_has_categoryid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegMembers::clear_has_categoryid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegMembers::clear_categoryid() {
  categoryid_ = 0u;
  clear_has_categoryid();
}
inline ::google::protobuf::uint32 ActRegMembers::categoryid() const {
  return categoryid_;
}
inline void ActRegMembers::set_categoryid(::google::protobuf::uint32 value) {
  set_has_categoryid();
  categoryid_ = value;
}

// optional uint32 password = 3;
inline bool ActRegMembers::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegMembers::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegMembers::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegMembers::clear_password() {
  password_ = 0u;
  clear_has_password();
}
inline ::google::protobuf::uint32 ActRegMembers::password() const {
  return password_;
}
inline void ActRegMembers::set_password(::google::protobuf::uint32 value) {
  set_has_password();
  password_ = value;
}

// optional uint32 sortOrder = 4;
inline bool ActRegMembers::has_sortorder() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActRegMembers::set_has_sortorder() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActRegMembers::clear_has_sortorder() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActRegMembers::clear_sortorder() {
  sortorder_ = 0u;
  clear_has_sortorder();
}
inline ::google::protobuf::uint32 ActRegMembers::sortorder() const {
  return sortorder_;
}
inline void ActRegMembers::set_sortorder(::google::protobuf::uint32 value) {
  set_has_sortorder();
  sortorder_ = value;
}

// optional string members = 5;
inline bool ActRegMembers::has_members() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActRegMembers::set_has_members() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActRegMembers::clear_has_members() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActRegMembers::clear_members() {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    members_->clear();
  }
  clear_has_members();
}
inline const ::std::string& ActRegMembers::members() const {
  return *members_;
}
inline void ActRegMembers::set_members(const ::std::string& value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void ActRegMembers::set_members(const char* value) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(value);
}
inline void ActRegMembers::set_members(const char* value, size_t size) {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  members_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegMembers::mutable_members() {
  set_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    members_ = new ::std::string;
  }
  return members_;
}
inline ::std::string* ActRegMembers::release_members() {
  clear_has_members();
  if (members_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = members_;
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegMembers::set_allocated_members(::std::string* members) {
  if (members_ != &::google::protobuf::internal::kEmptyString) {
    delete members_;
  }
  if (members) {
    set_has_members();
    members_ = members;
  } else {
    clear_has_members();
    members_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActRegVoice

// optional string statTime = 1;
inline bool ActRegVoice::has_stattime() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRegVoice::set_has_stattime() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRegVoice::clear_has_stattime() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRegVoice::clear_stattime() {
  if (stattime_ != &::google::protobuf::internal::kEmptyString) {
    stattime_->clear();
  }
  clear_has_stattime();
}
inline const ::std::string& ActRegVoice::stattime() const {
  return *stattime_;
}
inline void ActRegVoice::set_stattime(const ::std::string& value) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(value);
}
inline void ActRegVoice::set_stattime(const char* value) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(value);
}
inline void ActRegVoice::set_stattime(const char* value, size_t size) {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  stattime_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRegVoice::mutable_stattime() {
  set_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    stattime_ = new ::std::string;
  }
  return stattime_;
}
inline ::std::string* ActRegVoice::release_stattime() {
  clear_has_stattime();
  if (stattime_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stattime_;
    stattime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActRegVoice::set_allocated_stattime(::std::string* stattime) {
  if (stattime_ != &::google::protobuf::internal::kEmptyString) {
    delete stattime_;
  }
  if (stattime) {
    set_has_stattime();
    stattime_ = stattime;
  } else {
    clear_has_stattime();
    stattime_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 timeLen = 2;
inline bool ActRegVoice::has_timelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRegVoice::set_has_timelen() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRegVoice::clear_has_timelen() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRegVoice::clear_timelen() {
  timelen_ = 0u;
  clear_has_timelen();
}
inline ::google::protobuf::uint32 ActRegVoice::timelen() const {
  return timelen_;
}
inline void ActRegVoice::set_timelen(::google::protobuf::uint32 value) {
  set_has_timelen();
  timelen_ = value;
}

// optional uint32 Num = 3;
inline bool ActRegVoice::has_num() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ActRegVoice::set_has_num() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ActRegVoice::clear_has_num() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ActRegVoice::clear_num() {
  num_ = 0u;
  clear_has_num();
}
inline ::google::protobuf::uint32 ActRegVoice::num() const {
  return num_;
}
inline void ActRegVoice::set_num(::google::protobuf::uint32 value) {
  set_has_num();
  num_ = value;
}

// optional uint32 gid = 4;
inline bool ActRegVoice::has_gid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ActRegVoice::set_has_gid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ActRegVoice::clear_has_gid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ActRegVoice::clear_gid() {
  gid_ = 0u;
  clear_has_gid();
}
inline ::google::protobuf::uint32 ActRegVoice::gid() const {
  return gid_;
}
inline void ActRegVoice::set_gid(::google::protobuf::uint32 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint32 uid = 5;
inline bool ActRegVoice::has_uid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ActRegVoice::set_has_uid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ActRegVoice::clear_has_uid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ActRegVoice::clear_uid() {
  uid_ = 0u;
  clear_has_uid();
}
inline ::google::protobuf::uint32 ActRegVoice::uid() const {
  return uid_;
}
inline void ActRegVoice::set_uid(::google::protobuf::uint32 value) {
  set_has_uid();
  uid_ = value;
}

// -------------------------------------------------------------------

// InvitationReq

// required sint64 timeMonthStart = 2;
inline bool InvitationReq::has_timemonthstart() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitationReq::set_has_timemonthstart() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitationReq::clear_has_timemonthstart() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitationReq::clear_timemonthstart() {
  timemonthstart_ = GOOGLE_LONGLONG(0);
  clear_has_timemonthstart();
}
inline ::google::protobuf::int64 InvitationReq::timemonthstart() const {
  return timemonthstart_;
}
inline void InvitationReq::set_timemonthstart(::google::protobuf::int64 value) {
  set_has_timemonthstart();
  timemonthstart_ = value;
}

// required sint64 timeMonthEnd = 3;
inline bool InvitationReq::has_timemonthend() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitationReq::set_has_timemonthend() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitationReq::clear_has_timemonthend() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitationReq::clear_timemonthend() {
  timemonthend_ = GOOGLE_LONGLONG(0);
  clear_has_timemonthend();
}
inline ::google::protobuf::int64 InvitationReq::timemonthend() const {
  return timemonthend_;
}
inline void InvitationReq::set_timemonthend(::google::protobuf::int64 value) {
  set_has_timemonthend();
  timemonthend_ = value;
}

// required sint64 timeWeekStart = 4;
inline bool InvitationReq::has_timeweekstart() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvitationReq::set_has_timeweekstart() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvitationReq::clear_has_timeweekstart() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvitationReq::clear_timeweekstart() {
  timeweekstart_ = GOOGLE_LONGLONG(0);
  clear_has_timeweekstart();
}
inline ::google::protobuf::int64 InvitationReq::timeweekstart() const {
  return timeweekstart_;
}
inline void InvitationReq::set_timeweekstart(::google::protobuf::int64 value) {
  set_has_timeweekstart();
  timeweekstart_ = value;
}

// required sint64 timeWeekEnd = 5;
inline bool InvitationReq::has_timeweekend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvitationReq::set_has_timeweekend() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvitationReq::clear_has_timeweekend() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvitationReq::clear_timeweekend() {
  timeweekend_ = GOOGLE_LONGLONG(0);
  clear_has_timeweekend();
}
inline ::google::protobuf::int64 InvitationReq::timeweekend() const {
  return timeweekend_;
}
inline void InvitationReq::set_timeweekend(::google::protobuf::int64 value) {
  set_has_timeweekend();
  timeweekend_ = value;
}

// required sint64 timeTodayStart = 6;
inline bool InvitationReq::has_timetodaystart() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InvitationReq::set_has_timetodaystart() {
  _has_bits_[0] |= 0x00000010u;
}
inline void InvitationReq::clear_has_timetodaystart() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void InvitationReq::clear_timetodaystart() {
  timetodaystart_ = GOOGLE_LONGLONG(0);
  clear_has_timetodaystart();
}
inline ::google::protobuf::int64 InvitationReq::timetodaystart() const {
  return timetodaystart_;
}
inline void InvitationReq::set_timetodaystart(::google::protobuf::int64 value) {
  set_has_timetodaystart();
  timetodaystart_ = value;
}

// required sint64 timeTodayEnd = 7;
inline bool InvitationReq::has_timetodayend() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void InvitationReq::set_has_timetodayend() {
  _has_bits_[0] |= 0x00000020u;
}
inline void InvitationReq::clear_has_timetodayend() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void InvitationReq::clear_timetodayend() {
  timetodayend_ = GOOGLE_LONGLONG(0);
  clear_has_timetodayend();
}
inline ::google::protobuf::int64 InvitationReq::timetodayend() const {
  return timetodayend_;
}
inline void InvitationReq::set_timetodayend(::google::protobuf::int64 value) {
  set_has_timetodayend();
  timetodayend_ = value;
}

// -------------------------------------------------------------------

// InvitationRes

// optional uint32 inviteTotal = 1;
inline bool InvitationRes::has_invitetotal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitationRes::set_has_invitetotal() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitationRes::clear_has_invitetotal() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitationRes::clear_invitetotal() {
  invitetotal_ = 0u;
  clear_has_invitetotal();
}
inline ::google::protobuf::uint32 InvitationRes::invitetotal() const {
  return invitetotal_;
}
inline void InvitationRes::set_invitetotal(::google::protobuf::uint32 value) {
  set_has_invitetotal();
  invitetotal_ = value;
}

// optional uint32 inviteMonth = 2;
inline bool InvitationRes::has_invitemonth() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitationRes::set_has_invitemonth() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitationRes::clear_has_invitemonth() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitationRes::clear_invitemonth() {
  invitemonth_ = 0u;
  clear_has_invitemonth();
}
inline ::google::protobuf::uint32 InvitationRes::invitemonth() const {
  return invitemonth_;
}
inline void InvitationRes::set_invitemonth(::google::protobuf::uint32 value) {
  set_has_invitemonth();
  invitemonth_ = value;
}

// optional uint32 inviteWeek = 3;
inline bool InvitationRes::has_inviteweek() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InvitationRes::set_has_inviteweek() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InvitationRes::clear_has_inviteweek() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InvitationRes::clear_inviteweek() {
  inviteweek_ = 0u;
  clear_has_inviteweek();
}
inline ::google::protobuf::uint32 InvitationRes::inviteweek() const {
  return inviteweek_;
}
inline void InvitationRes::set_inviteweek(::google::protobuf::uint32 value) {
  set_has_inviteweek();
  inviteweek_ = value;
}

// optional uint32 inviteToday = 4;
inline bool InvitationRes::has_invitetoday() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InvitationRes::set_has_invitetoday() {
  _has_bits_[0] |= 0x00000008u;
}
inline void InvitationRes::clear_has_invitetoday() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void InvitationRes::clear_invitetoday() {
  invitetoday_ = 0u;
  clear_has_invitetoday();
}
inline ::google::protobuf::uint32 InvitationRes::invitetoday() const {
  return invitetoday_;
}
inline void InvitationRes::set_invitetoday(::google::protobuf::uint32 value) {
  set_has_invitetoday();
  invitetoday_ = value;
}

// repeated .pp.InvitationLv itemsCharm = 5;
inline int InvitationRes::itemscharm_size() const {
  return itemscharm_.size();
}
inline void InvitationRes::clear_itemscharm() {
  itemscharm_.Clear();
}
inline const ::pp::InvitationLv& InvitationRes::itemscharm(int index) const {
  return itemscharm_.Get(index);
}
inline ::pp::InvitationLv* InvitationRes::mutable_itemscharm(int index) {
  return itemscharm_.Mutable(index);
}
inline ::pp::InvitationLv* InvitationRes::add_itemscharm() {
  return itemscharm_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >&
InvitationRes::itemscharm() const {
  return itemscharm_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >*
InvitationRes::mutable_itemscharm() {
  return &itemscharm_;
}

// repeated .pp.InvitationLv itemsPassion = 6;
inline int InvitationRes::itemspassion_size() const {
  return itemspassion_.size();
}
inline void InvitationRes::clear_itemspassion() {
  itemspassion_.Clear();
}
inline const ::pp::InvitationLv& InvitationRes::itemspassion(int index) const {
  return itemspassion_.Get(index);
}
inline ::pp::InvitationLv* InvitationRes::mutable_itemspassion(int index) {
  return itemspassion_.Mutable(index);
}
inline ::pp::InvitationLv* InvitationRes::add_itemspassion() {
  return itemspassion_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >&
InvitationRes::itemspassion() const {
  return itemspassion_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::InvitationLv >*
InvitationRes::mutable_itemspassion() {
  return &itemspassion_;
}

// -------------------------------------------------------------------

// InvitationLv

// optional uint32 lv = 1;
inline bool InvitationLv::has_lv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InvitationLv::set_has_lv() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InvitationLv::clear_has_lv() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InvitationLv::clear_lv() {
  lv_ = 0u;
  clear_has_lv();
}
inline ::google::protobuf::uint32 InvitationLv::lv() const {
  return lv_;
}
inline void InvitationLv::set_lv(::google::protobuf::uint32 value) {
  set_has_lv();
  lv_ = value;
}

// optional uint32 number = 2;
inline bool InvitationLv::has_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InvitationLv::set_has_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InvitationLv::clear_has_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InvitationLv::clear_number() {
  number_ = 0u;
  clear_has_number();
}
inline ::google::protobuf::uint32 InvitationLv::number() const {
  return number_;
}
inline void InvitationLv::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
}

// -------------------------------------------------------------------

// UserDataAdjustReq

// optional uint64 uid = 1;
inline bool UserDataAdjustReq::has_uid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserDataAdjustReq::set_has_uid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserDataAdjustReq::clear_has_uid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserDataAdjustReq::clear_uid() {
  uid_ = GOOGLE_ULONGLONG(0);
  clear_has_uid();
}
inline ::google::protobuf::uint64 UserDataAdjustReq::uid() const {
  return uid_;
}
inline void UserDataAdjustReq::set_uid(::google::protobuf::uint64 value) {
  set_has_uid();
  uid_ = value;
}

// optional int64 coins = 2;
inline bool UserDataAdjustReq::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UserDataAdjustReq::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UserDataAdjustReq::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UserDataAdjustReq::clear_coins() {
  coins_ = GOOGLE_LONGLONG(0);
  clear_has_coins();
}
inline ::google::protobuf::int64 UserDataAdjustReq::coins() const {
  return coins_;
}
inline void UserDataAdjustReq::set_coins(::google::protobuf::int64 value) {
  set_has_coins();
  coins_ = value;
}

// optional uint32 newCharmLevel = 3;
inline bool UserDataAdjustReq::has_newcharmlevel() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UserDataAdjustReq::set_has_newcharmlevel() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UserDataAdjustReq::clear_has_newcharmlevel() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UserDataAdjustReq::clear_newcharmlevel() {
  newcharmlevel_ = 0u;
  clear_has_newcharmlevel();
}
inline ::google::protobuf::uint32 UserDataAdjustReq::newcharmlevel() const {
  return newcharmlevel_;
}
inline void UserDataAdjustReq::set_newcharmlevel(::google::protobuf::uint32 value) {
  set_has_newcharmlevel();
  newcharmlevel_ = value;
}

// repeated uint64 uids = 4;
inline int UserDataAdjustReq::uids_size() const {
  return uids_.size();
}
inline void UserDataAdjustReq::clear_uids() {
  uids_.Clear();
}
inline ::google::protobuf::uint64 UserDataAdjustReq::uids(int index) const {
  return uids_.Get(index);
}
inline void UserDataAdjustReq::set_uids(int index, ::google::protobuf::uint64 value) {
  uids_.Set(index, value);
}
inline void UserDataAdjustReq::add_uids(::google::protobuf::uint64 value) {
  uids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
UserDataAdjustReq::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
UserDataAdjustReq::mutable_uids() {
  return &uids_;
}

// -------------------------------------------------------------------

// PCGiftNotifyRecord

// optional uint64 yyuid = 1;
inline bool PCGiftNotifyRecord::has_yyuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PCGiftNotifyRecord::set_has_yyuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PCGiftNotifyRecord::clear_has_yyuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PCGiftNotifyRecord::clear_yyuid() {
  yyuid_ = GOOGLE_ULONGLONG(0);
  clear_has_yyuid();
}
inline ::google::protobuf::uint64 PCGiftNotifyRecord::yyuid() const {
  return yyuid_;
}
inline void PCGiftNotifyRecord::set_yyuid(::google::protobuf::uint64 value) {
  set_has_yyuid();
  yyuid_ = value;
}

// optional string gift_id = 2;
inline bool PCGiftNotifyRecord::has_gift_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PCGiftNotifyRecord::set_has_gift_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PCGiftNotifyRecord::clear_has_gift_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PCGiftNotifyRecord::clear_gift_id() {
  if (gift_id_ != &::google::protobuf::internal::kEmptyString) {
    gift_id_->clear();
  }
  clear_has_gift_id();
}
inline const ::std::string& PCGiftNotifyRecord::gift_id() const {
  return *gift_id_;
}
inline void PCGiftNotifyRecord::set_gift_id(const ::std::string& value) {
  set_has_gift_id();
  if (gift_id_ == &::google::protobuf::internal::kEmptyString) {
    gift_id_ = new ::std::string;
  }
  gift_id_->assign(value);
}
inline void PCGiftNotifyRecord::set_gift_id(const char* value) {
  set_has_gift_id();
  if (gift_id_ == &::google::protobuf::internal::kEmptyString) {
    gift_id_ = new ::std::string;
  }
  gift_id_->assign(value);
}
inline void PCGiftNotifyRecord::set_gift_id(const char* value, size_t size) {
  set_has_gift_id();
  if (gift_id_ == &::google::protobuf::internal::kEmptyString) {
    gift_id_ = new ::std::string;
  }
  gift_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PCGiftNotifyRecord::mutable_gift_id() {
  set_has_gift_id();
  if (gift_id_ == &::google::protobuf::internal::kEmptyString) {
    gift_id_ = new ::std::string;
  }
  return gift_id_;
}
inline ::std::string* PCGiftNotifyRecord::release_gift_id() {
  clear_has_gift_id();
  if (gift_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = gift_id_;
    gift_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PCGiftNotifyRecord::set_allocated_gift_id(::std::string* gift_id) {
  if (gift_id_ != &::google::protobuf::internal::kEmptyString) {
    delete gift_id_;
  }
  if (gift_id) {
    set_has_gift_id();
    gift_id_ = gift_id;
  } else {
    clear_has_gift_id();
    gift_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional sint64 datetime = 3;
inline bool PCGiftNotifyRecord::has_datetime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PCGiftNotifyRecord::set_has_datetime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PCGiftNotifyRecord::clear_has_datetime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PCGiftNotifyRecord::clear_datetime() {
  datetime_ = GOOGLE_LONGLONG(0);
  clear_has_datetime();
}
inline ::google::protobuf::int64 PCGiftNotifyRecord::datetime() const {
  return datetime_;
}
inline void PCGiftNotifyRecord::set_datetime(::google::protobuf::int64 value) {
  set_has_datetime();
  datetime_ = value;
}

// -------------------------------------------------------------------

// PCGiftNotifyReq

// repeated .pp.PCGiftNotifyRecord records = 1;
inline int PCGiftNotifyReq::records_size() const {
  return records_.size();
}
inline void PCGiftNotifyReq::clear_records() {
  records_.Clear();
}
inline const ::pp::PCGiftNotifyRecord& PCGiftNotifyReq::records(int index) const {
  return records_.Get(index);
}
inline ::pp::PCGiftNotifyRecord* PCGiftNotifyReq::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::pp::PCGiftNotifyRecord* PCGiftNotifyReq::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::PCGiftNotifyRecord >&
PCGiftNotifyReq::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::PCGiftNotifyRecord >*
PCGiftNotifyReq::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// ConfigDataReq

// -------------------------------------------------------------------

// TradeConfigData

// repeated string productOpenDays = 1;
inline int TradeConfigData::productopendays_size() const {
  return productopendays_.size();
}
inline void TradeConfigData::clear_productopendays() {
  productopendays_.Clear();
}
inline const ::std::string& TradeConfigData::productopendays(int index) const {
  return productopendays_.Get(index);
}
inline ::std::string* TradeConfigData::mutable_productopendays(int index) {
  return productopendays_.Mutable(index);
}
inline void TradeConfigData::set_productopendays(int index, const ::std::string& value) {
  productopendays_.Mutable(index)->assign(value);
}
inline void TradeConfigData::set_productopendays(int index, const char* value) {
  productopendays_.Mutable(index)->assign(value);
}
inline void TradeConfigData::set_productopendays(int index, const char* value, size_t size) {
  productopendays_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TradeConfigData::add_productopendays() {
  return productopendays_.Add();
}
inline void TradeConfigData::add_productopendays(const ::std::string& value) {
  productopendays_.Add()->assign(value);
}
inline void TradeConfigData::add_productopendays(const char* value) {
  productopendays_.Add()->assign(value);
}
inline void TradeConfigData::add_productopendays(const char* value, size_t size) {
  productopendays_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
TradeConfigData::productopendays() const {
  return productopendays_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
TradeConfigData::mutable_productopendays() {
  return &productopendays_;
}

// optional uint32 tradeRate = 2;
inline bool TradeConfigData::has_traderate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TradeConfigData::set_has_traderate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TradeConfigData::clear_has_traderate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TradeConfigData::clear_traderate() {
  traderate_ = 0u;
  clear_has_traderate();
}
inline ::google::protobuf::uint32 TradeConfigData::traderate() const {
  return traderate_;
}
inline void TradeConfigData::set_traderate(::google::protobuf::uint32 value) {
  set_has_traderate();
  traderate_ = value;
}

// repeated uint32 tradeOpenDays = 3;
inline int TradeConfigData::tradeopendays_size() const {
  return tradeopendays_.size();
}
inline void TradeConfigData::clear_tradeopendays() {
  tradeopendays_.Clear();
}
inline ::google::protobuf::uint32 TradeConfigData::tradeopendays(int index) const {
  return tradeopendays_.Get(index);
}
inline void TradeConfigData::set_tradeopendays(int index, ::google::protobuf::uint32 value) {
  tradeopendays_.Set(index, value);
}
inline void TradeConfigData::add_tradeopendays(::google::protobuf::uint32 value) {
  tradeopendays_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
TradeConfigData::tradeopendays() const {
  return tradeopendays_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
TradeConfigData::mutable_tradeopendays() {
  return &tradeopendays_;
}

// optional uint32 minTradeLevel = 4;
inline bool TradeConfigData::has_mintradelevel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TradeConfigData::set_has_mintradelevel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TradeConfigData::clear_has_mintradelevel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TradeConfigData::clear_mintradelevel() {
  mintradelevel_ = 0u;
  clear_has_mintradelevel();
}
inline ::google::protobuf::uint32 TradeConfigData::mintradelevel() const {
  return mintradelevel_;
}
inline void TradeConfigData::set_mintradelevel(::google::protobuf::uint32 value) {
  set_has_mintradelevel();
  mintradelevel_ = value;
}

// optional uint32 cashArrivingDay = 5;
inline bool TradeConfigData::has_casharrivingday() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TradeConfigData::set_has_casharrivingday() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TradeConfigData::clear_has_casharrivingday() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TradeConfigData::clear_casharrivingday() {
  casharrivingday_ = 0u;
  clear_has_casharrivingday();
}
inline ::google::protobuf::uint32 TradeConfigData::casharrivingday() const {
  return casharrivingday_;
}
inline void TradeConfigData::set_casharrivingday(::google::protobuf::uint32 value) {
  set_has_casharrivingday();
  casharrivingday_ = value;
}

// -------------------------------------------------------------------

// ConfigDataRes

// optional .pp.TradeConfigData tradeConfigData = 1;
inline bool ConfigDataRes::has_tradeconfigdata() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConfigDataRes::set_has_tradeconfigdata() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConfigDataRes::clear_has_tradeconfigdata() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConfigDataRes::clear_tradeconfigdata() {
  if (tradeconfigdata_ != NULL) tradeconfigdata_->::pp::TradeConfigData::Clear();
  clear_has_tradeconfigdata();
}
inline const ::pp::TradeConfigData& ConfigDataRes::tradeconfigdata() const {
  return tradeconfigdata_ != NULL ? *tradeconfigdata_ : *default_instance_->tradeconfigdata_;
}
inline ::pp::TradeConfigData* ConfigDataRes::mutable_tradeconfigdata() {
  set_has_tradeconfigdata();
  if (tradeconfigdata_ == NULL) tradeconfigdata_ = new ::pp::TradeConfigData;
  return tradeconfigdata_;
}
inline ::pp::TradeConfigData* ConfigDataRes::release_tradeconfigdata() {
  clear_has_tradeconfigdata();
  ::pp::TradeConfigData* temp = tradeconfigdata_;
  tradeconfigdata_ = NULL;
  return temp;
}
inline void ConfigDataRes::set_allocated_tradeconfigdata(::pp::TradeConfigData* tradeconfigdata) {
  delete tradeconfigdata_;
  tradeconfigdata_ = tradeconfigdata;
  if (tradeconfigdata) {
    set_has_tradeconfigdata();
  } else {
    clear_has_tradeconfigdata();
  }
}

// -------------------------------------------------------------------

// DailyTaskStatReq

// repeated uint64 uids = 1;
inline int DailyTaskStatReq::uids_size() const {
  return uids_.size();
}
inline void DailyTaskStatReq::clear_uids() {
  uids_.Clear();
}
inline ::google::protobuf::uint64 DailyTaskStatReq::uids(int index) const {
  return uids_.Get(index);
}
inline void DailyTaskStatReq::set_uids(int index, ::google::protobuf::uint64 value) {
  uids_.Set(index, value);
}
inline void DailyTaskStatReq::add_uids(::google::protobuf::uint64 value) {
  uids_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
DailyTaskStatReq::uids() const {
  return uids_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
DailyTaskStatReq::mutable_uids() {
  return &uids_;
}

// optional sint64 startTime = 2;
inline bool DailyTaskStatReq::has_starttime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyTaskStatReq::set_has_starttime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyTaskStatReq::clear_has_starttime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyTaskStatReq::clear_starttime() {
  starttime_ = GOOGLE_LONGLONG(0);
  clear_has_starttime();
}
inline ::google::protobuf::int64 DailyTaskStatReq::starttime() const {
  return starttime_;
}
inline void DailyTaskStatReq::set_starttime(::google::protobuf::int64 value) {
  set_has_starttime();
  starttime_ = value;
}

// optional sint64 endTime = 3;
inline bool DailyTaskStatReq::has_endtime() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyTaskStatReq::set_has_endtime() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyTaskStatReq::clear_has_endtime() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyTaskStatReq::clear_endtime() {
  endtime_ = GOOGLE_LONGLONG(0);
  clear_has_endtime();
}
inline ::google::protobuf::int64 DailyTaskStatReq::endtime() const {
  return endtime_;
}
inline void DailyTaskStatReq::set_endtime(::google::protobuf::int64 value) {
  set_has_endtime();
  endtime_ = value;
}

// -------------------------------------------------------------------

// DailyTaskStat

// optional .pp.UserInfo user = 1;
inline bool DailyTaskStat::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DailyTaskStat::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DailyTaskStat::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DailyTaskStat::clear_user() {
  if (user_ != NULL) user_->::pp::UserInfo::Clear();
  clear_has_user();
}
inline const ::pp::UserInfo& DailyTaskStat::user() const {
  return user_ != NULL ? *user_ : *default_instance_->user_;
}
inline ::pp::UserInfo* DailyTaskStat::mutable_user() {
  set_has_user();
  if (user_ == NULL) user_ = new ::pp::UserInfo;
  return user_;
}
inline ::pp::UserInfo* DailyTaskStat::release_user() {
  clear_has_user();
  ::pp::UserInfo* temp = user_;
  user_ = NULL;
  return temp;
}
inline void DailyTaskStat::set_allocated_user(::pp::UserInfo* user) {
  delete user_;
  user_ = user;
  if (user) {
    set_has_user();
  } else {
    clear_has_user();
  }
}

// optional uint32 coins = 2;
inline bool DailyTaskStat::has_coins() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DailyTaskStat::set_has_coins() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DailyTaskStat::clear_has_coins() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DailyTaskStat::clear_coins() {
  coins_ = 0u;
  clear_has_coins();
}
inline ::google::protobuf::uint32 DailyTaskStat::coins() const {
  return coins_;
}
inline void DailyTaskStat::set_coins(::google::protobuf::uint32 value) {
  set_has_coins();
  coins_ = value;
}

// optional float achieveRate = 3;
inline bool DailyTaskStat::has_achieverate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DailyTaskStat::set_has_achieverate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DailyTaskStat::clear_has_achieverate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DailyTaskStat::clear_achieverate() {
  achieverate_ = 0;
  clear_has_achieverate();
}
inline float DailyTaskStat::achieverate() const {
  return achieverate_;
}
inline void DailyTaskStat::set_achieverate(float value) {
  set_has_achieverate();
  achieverate_ = value;
}

// optional sint64 date = 4;
inline bool DailyTaskStat::has_date() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DailyTaskStat::set_has_date() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DailyTaskStat::clear_has_date() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DailyTaskStat::clear_date() {
  date_ = GOOGLE_LONGLONG(0);
  clear_has_date();
}
inline ::google::protobuf::int64 DailyTaskStat::date() const {
  return date_;
}
inline void DailyTaskStat::set_date(::google::protobuf::int64 value) {
  set_has_date();
  date_ = value;
}

// -------------------------------------------------------------------

// DailyTaskStatRes

// repeated .pp.DailyTaskStat records = 1;
inline int DailyTaskStatRes::records_size() const {
  return records_.size();
}
inline void DailyTaskStatRes::clear_records() {
  records_.Clear();
}
inline const ::pp::DailyTaskStat& DailyTaskStatRes::records(int index) const {
  return records_.Get(index);
}
inline ::pp::DailyTaskStat* DailyTaskStatRes::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::pp::DailyTaskStat* DailyTaskStatRes::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskStat >&
DailyTaskStatRes::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::DailyTaskStat >*
DailyTaskStatRes::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// BabyDataStatReq

// -------------------------------------------------------------------

// BabyDataStatRes

// optional uint32 rmb = 1;
inline bool BabyDataStatRes::has_rmb() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BabyDataStatRes::set_has_rmb() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BabyDataStatRes::clear_has_rmb() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BabyDataStatRes::clear_rmb() {
  rmb_ = 0u;
  clear_has_rmb();
}
inline ::google::protobuf::uint32 BabyDataStatRes::rmb() const {
  return rmb_;
}
inline void BabyDataStatRes::set_rmb(::google::protobuf::uint32 value) {
  set_has_rmb();
  rmb_ = value;
}

// optional uint32 yyscore = 2;
inline bool BabyDataStatRes::has_yyscore() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BabyDataStatRes::set_has_yyscore() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BabyDataStatRes::clear_has_yyscore() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BabyDataStatRes::clear_yyscore() {
  yyscore_ = 0u;
  clear_has_yyscore();
}
inline ::google::protobuf::uint32 BabyDataStatRes::yyscore() const {
  return yyscore_;
}
inline void BabyDataStatRes::set_yyscore(::google::protobuf::uint32 value) {
  set_has_yyscore();
  yyscore_ = value;
}

// optional uint32 lolskin = 3;
inline bool BabyDataStatRes::has_lolskin() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BabyDataStatRes::set_has_lolskin() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BabyDataStatRes::clear_has_lolskin() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BabyDataStatRes::clear_lolskin() {
  lolskin_ = 0u;
  clear_has_lolskin();
}
inline ::google::protobuf::uint32 BabyDataStatRes::lolskin() const {
  return lolskin_;
}
inline void BabyDataStatRes::set_lolskin(::google::protobuf::uint32 value) {
  set_has_lolskin();
  lolskin_ = value;
}

// optional uint32 movein = 4;
inline bool BabyDataStatRes::has_movein() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BabyDataStatRes::set_has_movein() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BabyDataStatRes::clear_has_movein() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BabyDataStatRes::clear_movein() {
  movein_ = 0u;
  clear_has_movein();
}
inline ::google::protobuf::uint32 BabyDataStatRes::movein() const {
  return movein_;
}
inline void BabyDataStatRes::set_movein(::google::protobuf::uint32 value) {
  set_has_movein();
  movein_ = value;
}

// optional uint32 showing = 5;
inline bool BabyDataStatRes::has_showing() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void BabyDataStatRes::set_has_showing() {
  _has_bits_[0] |= 0x00000010u;
}
inline void BabyDataStatRes::clear_has_showing() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void BabyDataStatRes::clear_showing() {
  showing_ = 0u;
  clear_has_showing();
}
inline ::google::protobuf::uint32 BabyDataStatRes::showing() const {
  return showing_;
}
inline void BabyDataStatRes::set_showing(::google::protobuf::uint32 value) {
  set_has_showing();
  showing_ = value;
}

// -------------------------------------------------------------------

// PageDataExchangeReq

// optional string key = 1;
inline bool PageDataExchangeReq::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PageDataExchangeReq::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PageDataExchangeReq::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PageDataExchangeReq::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& PageDataExchangeReq::key() const {
  return *key_;
}
inline void PageDataExchangeReq::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void PageDataExchangeReq::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void PageDataExchangeReq::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PageDataExchangeReq::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* PageDataExchangeReq::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PageDataExchangeReq::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// PageDataExchangeRes

// optional string url = 1;
inline bool PageDataExchangeRes::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PageDataExchangeRes::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PageDataExchangeRes::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PageDataExchangeRes::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& PageDataExchangeRes::url() const {
  return *url_;
}
inline void PageDataExchangeRes::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void PageDataExchangeRes::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void PageDataExchangeRes::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PageDataExchangeRes::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* PageDataExchangeRes::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PageDataExchangeRes::set_allocated_url(::std::string* url) {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (url) {
    set_has_url();
    url_ = url;
  } else {
    clear_has_url();
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string param = 2;
inline bool PageDataExchangeRes::has_param() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PageDataExchangeRes::set_has_param() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PageDataExchangeRes::clear_has_param() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PageDataExchangeRes::clear_param() {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    param_->clear();
  }
  clear_has_param();
}
inline const ::std::string& PageDataExchangeRes::param() const {
  return *param_;
}
inline void PageDataExchangeRes::set_param(const ::std::string& value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void PageDataExchangeRes::set_param(const char* value) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(value);
}
inline void PageDataExchangeRes::set_param(const char* value, size_t size) {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  param_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PageDataExchangeRes::mutable_param() {
  set_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    param_ = new ::std::string;
  }
  return param_;
}
inline ::std::string* PageDataExchangeRes::release_param() {
  clear_has_param();
  if (param_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = param_;
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PageDataExchangeRes::set_allocated_param(::std::string* param) {
  if (param_ != &::google::protobuf::internal::kEmptyString) {
    delete param_;
  }
  if (param) {
    set_has_param();
    param_ = param;
  } else {
    clear_has_param();
    param_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActLuckyTryReq

// optional bool try = 1;
inline bool ActLuckyTryReq::has_try_() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActLuckyTryReq::set_has_try_() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActLuckyTryReq::clear_has_try_() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActLuckyTryReq::clear_try_() {
  try__ = false;
  clear_has_try_();
}
inline bool ActLuckyTryReq::try_() const {
  return try__;
}
inline void ActLuckyTryReq::set_try_(bool value) {
  set_has_try_();
  try__ = value;
}

// optional string actName = 2;
inline bool ActLuckyTryReq::has_actname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActLuckyTryReq::set_has_actname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActLuckyTryReq::clear_has_actname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActLuckyTryReq::clear_actname() {
  if (actname_ != &::google::protobuf::internal::kEmptyString) {
    actname_->clear();
  }
  clear_has_actname();
}
inline const ::std::string& ActLuckyTryReq::actname() const {
  return *actname_;
}
inline void ActLuckyTryReq::set_actname(const ::std::string& value) {
  set_has_actname();
  if (actname_ == &::google::protobuf::internal::kEmptyString) {
    actname_ = new ::std::string;
  }
  actname_->assign(value);
}
inline void ActLuckyTryReq::set_actname(const char* value) {
  set_has_actname();
  if (actname_ == &::google::protobuf::internal::kEmptyString) {
    actname_ = new ::std::string;
  }
  actname_->assign(value);
}
inline void ActLuckyTryReq::set_actname(const char* value, size_t size) {
  set_has_actname();
  if (actname_ == &::google::protobuf::internal::kEmptyString) {
    actname_ = new ::std::string;
  }
  actname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActLuckyTryReq::mutable_actname() {
  set_has_actname();
  if (actname_ == &::google::protobuf::internal::kEmptyString) {
    actname_ = new ::std::string;
  }
  return actname_;
}
inline ::std::string* ActLuckyTryReq::release_actname() {
  clear_has_actname();
  if (actname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = actname_;
    actname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActLuckyTryReq::set_allocated_actname(::std::string* actname) {
  if (actname_ != &::google::protobuf::internal::kEmptyString) {
    delete actname_;
  }
  if (actname) {
    set_has_actname();
    actname_ = actname;
  } else {
    clear_has_actname();
    actname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActLuckyTryRes

// optional string name = 1;
inline bool ActLuckyTryRes::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActLuckyTryRes::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActLuckyTryRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActLuckyTryRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ActLuckyTryRes::name() const {
  return *name_;
}
inline void ActLuckyTryRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActLuckyTryRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ActLuckyTryRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActLuckyTryRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ActLuckyTryRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ActLuckyTryRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ActRecvDynamicReq

// optional uint32 actId = 1;
inline bool ActRecvDynamicReq::has_actid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRecvDynamicReq::set_has_actid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRecvDynamicReq::clear_has_actid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRecvDynamicReq::clear_actid() {
  actid_ = 0u;
  clear_has_actid();
}
inline ::google::protobuf::uint32 ActRecvDynamicReq::actid() const {
  return actid_;
}
inline void ActRecvDynamicReq::set_actid(::google::protobuf::uint32 value) {
  set_has_actid();
  actid_ = value;
}

// optional int32 fetchs = 2;
inline bool ActRecvDynamicReq::has_fetchs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ActRecvDynamicReq::set_has_fetchs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ActRecvDynamicReq::clear_has_fetchs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ActRecvDynamicReq::clear_fetchs() {
  fetchs_ = 0;
  clear_has_fetchs();
}
inline ::google::protobuf::int32 ActRecvDynamicReq::fetchs() const {
  return fetchs_;
}
inline void ActRecvDynamicReq::set_fetchs(::google::protobuf::int32 value) {
  set_has_fetchs();
  fetchs_ = value;
}

// -------------------------------------------------------------------

// ActRecvDynamicRes

// optional uint32 actId = 1;
inline bool ActRecvDynamicRes::has_actid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ActRecvDynamicRes::set_has_actid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ActRecvDynamicRes::clear_has_actid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ActRecvDynamicRes::clear_actid() {
  actid_ = 0u;
  clear_has_actid();
}
inline ::google::protobuf::uint32 ActRecvDynamicRes::actid() const {
  return actid_;
}
inline void ActRecvDynamicRes::set_actid(::google::protobuf::uint32 value) {
  set_has_actid();
  actid_ = value;
}

// repeated string msgs = 2;
inline int ActRecvDynamicRes::msgs_size() const {
  return msgs_.size();
}
inline void ActRecvDynamicRes::clear_msgs() {
  msgs_.Clear();
}
inline const ::std::string& ActRecvDynamicRes::msgs(int index) const {
  return msgs_.Get(index);
}
inline ::std::string* ActRecvDynamicRes::mutable_msgs(int index) {
  return msgs_.Mutable(index);
}
inline void ActRecvDynamicRes::set_msgs(int index, const ::std::string& value) {
  msgs_.Mutable(index)->assign(value);
}
inline void ActRecvDynamicRes::set_msgs(int index, const char* value) {
  msgs_.Mutable(index)->assign(value);
}
inline void ActRecvDynamicRes::set_msgs(int index, const char* value, size_t size) {
  msgs_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ActRecvDynamicRes::add_msgs() {
  return msgs_.Add();
}
inline void ActRecvDynamicRes::add_msgs(const ::std::string& value) {
  msgs_.Add()->assign(value);
}
inline void ActRecvDynamicRes::add_msgs(const char* value) {
  msgs_.Add()->assign(value);
}
inline void ActRecvDynamicRes::add_msgs(const char* value, size_t size) {
  msgs_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ActRecvDynamicRes::msgs() const {
  return msgs_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ActRecvDynamicRes::mutable_msgs() {
  return &msgs_;
}

// -------------------------------------------------------------------

// DevFinger

// optional uint32 type = 1;
inline bool DevFinger::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DevFinger::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DevFinger::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DevFinger::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 DevFinger::type() const {
  return type_;
}
inline void DevFinger::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
}

// optional string imei = 2;
inline bool DevFinger::has_imei() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DevFinger::set_has_imei() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DevFinger::clear_has_imei() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DevFinger::clear_imei() {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    imei_->clear();
  }
  clear_has_imei();
}
inline const ::std::string& DevFinger::imei() const {
  return *imei_;
}
inline void DevFinger::set_imei(const ::std::string& value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void DevFinger::set_imei(const char* value) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(value);
}
inline void DevFinger::set_imei(const char* value, size_t size) {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  imei_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DevFinger::mutable_imei() {
  set_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    imei_ = new ::std::string;
  }
  return imei_;
}
inline ::std::string* DevFinger::release_imei() {
  clear_has_imei();
  if (imei_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = imei_;
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DevFinger::set_allocated_imei(::std::string* imei) {
  if (imei_ != &::google::protobuf::internal::kEmptyString) {
    delete imei_;
  }
  if (imei) {
    set_has_imei();
    imei_ = imei;
  } else {
    clear_has_imei();
    imei_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string wlan_mac = 3;
inline bool DevFinger::has_wlan_mac() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DevFinger::set_has_wlan_mac() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DevFinger::clear_has_wlan_mac() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DevFinger::clear_wlan_mac() {
  if (wlan_mac_ != &::google::protobuf::internal::kEmptyString) {
    wlan_mac_->clear();
  }
  clear_has_wlan_mac();
}
inline const ::std::string& DevFinger::wlan_mac() const {
  return *wlan_mac_;
}
inline void DevFinger::set_wlan_mac(const ::std::string& value) {
  set_has_wlan_mac();
  if (wlan_mac_ == &::google::protobuf::internal::kEmptyString) {
    wlan_mac_ = new ::std::string;
  }
  wlan_mac_->assign(value);
}
inline void DevFinger::set_wlan_mac(const char* value) {
  set_has_wlan_mac();
  if (wlan_mac_ == &::google::protobuf::internal::kEmptyString) {
    wlan_mac_ = new ::std::string;
  }
  wlan_mac_->assign(value);
}
inline void DevFinger::set_wlan_mac(const char* value, size_t size) {
  set_has_wlan_mac();
  if (wlan_mac_ == &::google::protobuf::internal::kEmptyString) {
    wlan_mac_ = new ::std::string;
  }
  wlan_mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DevFinger::mutable_wlan_mac() {
  set_has_wlan_mac();
  if (wlan_mac_ == &::google::protobuf::internal::kEmptyString) {
    wlan_mac_ = new ::std::string;
  }
  return wlan_mac_;
}
inline ::std::string* DevFinger::release_wlan_mac() {
  clear_has_wlan_mac();
  if (wlan_mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = wlan_mac_;
    wlan_mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DevFinger::set_allocated_wlan_mac(::std::string* wlan_mac) {
  if (wlan_mac_ != &::google::protobuf::internal::kEmptyString) {
    delete wlan_mac_;
  }
  if (wlan_mac) {
    set_has_wlan_mac();
    wlan_mac_ = wlan_mac;
  } else {
    clear_has_wlan_mac();
    wlan_mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string android_id = 4;
inline bool DevFinger::has_android_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DevFinger::set_has_android_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DevFinger::clear_has_android_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DevFinger::clear_android_id() {
  if (android_id_ != &::google::protobuf::internal::kEmptyString) {
    android_id_->clear();
  }
  clear_has_android_id();
}
inline const ::std::string& DevFinger::android_id() const {
  return *android_id_;
}
inline void DevFinger::set_android_id(const ::std::string& value) {
  set_has_android_id();
  if (android_id_ == &::google::protobuf::internal::kEmptyString) {
    android_id_ = new ::std::string;
  }
  android_id_->assign(value);
}
inline void DevFinger::set_android_id(const char* value) {
  set_has_android_id();
  if (android_id_ == &::google::protobuf::internal::kEmptyString) {
    android_id_ = new ::std::string;
  }
  android_id_->assign(value);
}
inline void DevFinger::set_android_id(const char* value, size_t size) {
  set_has_android_id();
  if (android_id_ == &::google::protobuf::internal::kEmptyString) {
    android_id_ = new ::std::string;
  }
  android_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DevFinger::mutable_android_id() {
  set_has_android_id();
  if (android_id_ == &::google::protobuf::internal::kEmptyString) {
    android_id_ = new ::std::string;
  }
  return android_id_;
}
inline ::std::string* DevFinger::release_android_id() {
  clear_has_android_id();
  if (android_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = android_id_;
    android_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DevFinger::set_allocated_android_id(::std::string* android_id) {
  if (android_id_ != &::google::protobuf::internal::kEmptyString) {
    delete android_id_;
  }
  if (android_id) {
    set_has_android_id();
    android_id_ = android_id;
  } else {
    clear_has_android_id();
    android_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string bt_mac = 5;
inline bool DevFinger::has_bt_mac() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void DevFinger::set_has_bt_mac() {
  _has_bits_[0] |= 0x00000010u;
}
inline void DevFinger::clear_has_bt_mac() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void DevFinger::clear_bt_mac() {
  if (bt_mac_ != &::google::protobuf::internal::kEmptyString) {
    bt_mac_->clear();
  }
  clear_has_bt_mac();
}
inline const ::std::string& DevFinger::bt_mac() const {
  return *bt_mac_;
}
inline void DevFinger::set_bt_mac(const ::std::string& value) {
  set_has_bt_mac();
  if (bt_mac_ == &::google::protobuf::internal::kEmptyString) {
    bt_mac_ = new ::std::string;
  }
  bt_mac_->assign(value);
}
inline void DevFinger::set_bt_mac(const char* value) {
  set_has_bt_mac();
  if (bt_mac_ == &::google::protobuf::internal::kEmptyString) {
    bt_mac_ = new ::std::string;
  }
  bt_mac_->assign(value);
}
inline void DevFinger::set_bt_mac(const char* value, size_t size) {
  set_has_bt_mac();
  if (bt_mac_ == &::google::protobuf::internal::kEmptyString) {
    bt_mac_ = new ::std::string;
  }
  bt_mac_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DevFinger::mutable_bt_mac() {
  set_has_bt_mac();
  if (bt_mac_ == &::google::protobuf::internal::kEmptyString) {
    bt_mac_ = new ::std::string;
  }
  return bt_mac_;
}
inline ::std::string* DevFinger::release_bt_mac() {
  clear_has_bt_mac();
  if (bt_mac_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bt_mac_;
    bt_mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DevFinger::set_allocated_bt_mac(::std::string* bt_mac) {
  if (bt_mac_ != &::google::protobuf::internal::kEmptyString) {
    delete bt_mac_;
  }
  if (bt_mac) {
    set_has_bt_mac();
    bt_mac_ = bt_mac;
  } else {
    clear_has_bt_mac();
    bt_mac_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string idfa = 6;
inline bool DevFinger::has_idfa() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void DevFinger::set_has_idfa() {
  _has_bits_[0] |= 0x00000020u;
}
inline void DevFinger::clear_has_idfa() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void DevFinger::clear_idfa() {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    idfa_->clear();
  }
  clear_has_idfa();
}
inline const ::std::string& DevFinger::idfa() const {
  return *idfa_;
}
inline void DevFinger::set_idfa(const ::std::string& value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void DevFinger::set_idfa(const char* value) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(value);
}
inline void DevFinger::set_idfa(const char* value, size_t size) {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  idfa_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DevFinger::mutable_idfa() {
  set_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    idfa_ = new ::std::string;
  }
  return idfa_;
}
inline ::std::string* DevFinger::release_idfa() {
  clear_has_idfa();
  if (idfa_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = idfa_;
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DevFinger::set_allocated_idfa(::std::string* idfa) {
  if (idfa_ != &::google::protobuf::internal::kEmptyString) {
    delete idfa_;
  }
  if (idfa) {
    set_has_idfa();
    idfa_ = idfa;
  } else {
    clear_has_idfa();
    idfa_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// YYChannelTreeInfoReq

// optional uint64 sid = 1;
inline bool YYChannelTreeInfoReq::has_sid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYChannelTreeInfoReq::set_has_sid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYChannelTreeInfoReq::clear_has_sid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYChannelTreeInfoReq::clear_sid() {
  sid_ = GOOGLE_ULONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::uint64 YYChannelTreeInfoReq::sid() const {
  return sid_;
}
inline void YYChannelTreeInfoReq::set_sid(::google::protobuf::uint64 value) {
  set_has_sid();
  sid_ = value;
}

// -------------------------------------------------------------------

// YYChannelBranch

// optional uint64 gid = 1;
inline bool YYChannelBranch::has_gid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYChannelBranch::set_has_gid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYChannelBranch::clear_has_gid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYChannelBranch::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 YYChannelBranch::gid() const {
  return gid_;
}
inline void YYChannelBranch::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// optional uint64 sid = 2;
inline bool YYChannelBranch::has_sid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYChannelBranch::set_has_sid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYChannelBranch::clear_has_sid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYChannelBranch::clear_sid() {
  sid_ = GOOGLE_ULONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::uint64 YYChannelBranch::sid() const {
  return sid_;
}
inline void YYChannelBranch::set_sid(::google::protobuf::uint64 value) {
  set_has_sid();
  sid_ = value;
}

// optional uint64 pid = 3;
inline bool YYChannelBranch::has_pid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYChannelBranch::set_has_pid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYChannelBranch::clear_has_pid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYChannelBranch::clear_pid() {
  pid_ = GOOGLE_ULONGLONG(0);
  clear_has_pid();
}
inline ::google::protobuf::uint64 YYChannelBranch::pid() const {
  return pid_;
}
inline void YYChannelBranch::set_pid(::google::protobuf::uint64 value) {
  set_has_pid();
  pid_ = value;
}

// optional uint64 tid = 4;
inline bool YYChannelBranch::has_tid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYChannelBranch::set_has_tid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYChannelBranch::clear_has_tid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYChannelBranch::clear_tid() {
  tid_ = GOOGLE_ULONGLONG(0);
  clear_has_tid();
}
inline ::google::protobuf::uint64 YYChannelBranch::tid() const {
  return tid_;
}
inline void YYChannelBranch::set_tid(::google::protobuf::uint64 value) {
  set_has_tid();
  tid_ = value;
}

// optional string name = 5;
inline bool YYChannelBranch::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YYChannelBranch::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YYChannelBranch::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YYChannelBranch::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& YYChannelBranch::name() const {
  return *name_;
}
inline void YYChannelBranch::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYChannelBranch::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYChannelBranch::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYChannelBranch::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* YYChannelBranch::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYChannelBranch::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isPassWdSet = 6;
inline bool YYChannelBranch::has_ispasswdset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YYChannelBranch::set_has_ispasswdset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YYChannelBranch::clear_has_ispasswdset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YYChannelBranch::clear_ispasswdset() {
  ispasswdset_ = false;
  clear_has_ispasswdset();
}
inline bool YYChannelBranch::ispasswdset() const {
  return ispasswdset_;
}
inline void YYChannelBranch::set_ispasswdset(bool value) {
  set_has_ispasswdset();
  ispasswdset_ = value;
}

// optional string passwd = 7;
inline bool YYChannelBranch::has_passwd() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void YYChannelBranch::set_has_passwd() {
  _has_bits_[0] |= 0x00000040u;
}
inline void YYChannelBranch::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void YYChannelBranch::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& YYChannelBranch::passwd() const {
  return *passwd_;
}
inline void YYChannelBranch::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void YYChannelBranch::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void YYChannelBranch::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYChannelBranch::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* YYChannelBranch::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYChannelBranch::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool isGuestAccessLimit = 8;
inline bool YYChannelBranch::has_isguestaccesslimit() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void YYChannelBranch::set_has_isguestaccesslimit() {
  _has_bits_[0] |= 0x00000080u;
}
inline void YYChannelBranch::clear_has_isguestaccesslimit() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void YYChannelBranch::clear_isguestaccesslimit() {
  isguestaccesslimit_ = false;
  clear_has_isguestaccesslimit();
}
inline bool YYChannelBranch::isguestaccesslimit() const {
  return isguestaccesslimit_;
}
inline void YYChannelBranch::set_isguestaccesslimit(bool value) {
  set_has_isguestaccesslimit();
  isguestaccesslimit_ = value;
}

// optional uint64 members = 9;
inline bool YYChannelBranch::has_members() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void YYChannelBranch::set_has_members() {
  _has_bits_[0] |= 0x00000100u;
}
inline void YYChannelBranch::clear_has_members() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void YYChannelBranch::clear_members() {
  members_ = GOOGLE_ULONGLONG(0);
  clear_has_members();
}
inline ::google::protobuf::uint64 YYChannelBranch::members() const {
  return members_;
}
inline void YYChannelBranch::set_members(::google::protobuf::uint64 value) {
  set_has_members();
  members_ = value;
}

// optional uint32 orderNum = 10;
inline bool YYChannelBranch::has_ordernum() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void YYChannelBranch::set_has_ordernum() {
  _has_bits_[0] |= 0x00000200u;
}
inline void YYChannelBranch::clear_has_ordernum() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void YYChannelBranch::clear_ordernum() {
  ordernum_ = 0u;
  clear_has_ordernum();
}
inline ::google::protobuf::uint32 YYChannelBranch::ordernum() const {
  return ordernum_;
}
inline void YYChannelBranch::set_ordernum(::google::protobuf::uint32 value) {
  set_has_ordernum();
  ordernum_ = value;
}

// optional string logoUrl = 11;
inline bool YYChannelBranch::has_logourl() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void YYChannelBranch::set_has_logourl() {
  _has_bits_[0] |= 0x00000400u;
}
inline void YYChannelBranch::clear_has_logourl() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void YYChannelBranch::clear_logourl() {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    logourl_->clear();
  }
  clear_has_logourl();
}
inline const ::std::string& YYChannelBranch::logourl() const {
  return *logourl_;
}
inline void YYChannelBranch::set_logourl(const ::std::string& value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void YYChannelBranch::set_logourl(const char* value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void YYChannelBranch::set_logourl(const char* value, size_t size) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYChannelBranch::mutable_logourl() {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  return logourl_;
}
inline ::std::string* YYChannelBranch::release_logourl() {
  clear_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logourl_;
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYChannelBranch::set_allocated_logourl(::std::string* logourl) {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    delete logourl_;
  }
  if (logourl) {
    set_has_logourl();
    logourl_ = logourl;
  } else {
    clear_has_logourl();
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .pp.YYChannelBranch subCh = 12;
inline int YYChannelBranch::subch_size() const {
  return subch_.size();
}
inline void YYChannelBranch::clear_subch() {
  subch_.Clear();
}
inline const ::pp::YYChannelBranch& YYChannelBranch::subch(int index) const {
  return subch_.Get(index);
}
inline ::pp::YYChannelBranch* YYChannelBranch::mutable_subch(int index) {
  return subch_.Mutable(index);
}
inline ::pp::YYChannelBranch* YYChannelBranch::add_subch() {
  return subch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >&
YYChannelBranch::subch() const {
  return subch_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >*
YYChannelBranch::mutable_subch() {
  return &subch_;
}

// -------------------------------------------------------------------

// YYChannelTreeInfoRes

// optional string name = 1;
inline bool YYChannelTreeInfoRes::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void YYChannelTreeInfoRes::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void YYChannelTreeInfoRes::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void YYChannelTreeInfoRes::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& YYChannelTreeInfoRes::name() const {
  return *name_;
}
inline void YYChannelTreeInfoRes::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYChannelTreeInfoRes::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void YYChannelTreeInfoRes::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYChannelTreeInfoRes::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* YYChannelTreeInfoRes::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYChannelTreeInfoRes::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 asid = 2;
inline bool YYChannelTreeInfoRes::has_asid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void YYChannelTreeInfoRes::set_has_asid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void YYChannelTreeInfoRes::clear_has_asid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void YYChannelTreeInfoRes::clear_asid() {
  asid_ = GOOGLE_ULONGLONG(0);
  clear_has_asid();
}
inline ::google::protobuf::uint64 YYChannelTreeInfoRes::asid() const {
  return asid_;
}
inline void YYChannelTreeInfoRes::set_asid(::google::protobuf::uint64 value) {
  set_has_asid();
  asid_ = value;
}

// optional uint64 sid = 3;
inline bool YYChannelTreeInfoRes::has_sid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void YYChannelTreeInfoRes::set_has_sid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void YYChannelTreeInfoRes::clear_has_sid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void YYChannelTreeInfoRes::clear_sid() {
  sid_ = GOOGLE_ULONGLONG(0);
  clear_has_sid();
}
inline ::google::protobuf::uint64 YYChannelTreeInfoRes::sid() const {
  return sid_;
}
inline void YYChannelTreeInfoRes::set_sid(::google::protobuf::uint64 value) {
  set_has_sid();
  sid_ = value;
}

// optional uint64 members = 4;
inline bool YYChannelTreeInfoRes::has_members() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void YYChannelTreeInfoRes::set_has_members() {
  _has_bits_[0] |= 0x00000008u;
}
inline void YYChannelTreeInfoRes::clear_has_members() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void YYChannelTreeInfoRes::clear_members() {
  members_ = GOOGLE_ULONGLONG(0);
  clear_has_members();
}
inline ::google::protobuf::uint64 YYChannelTreeInfoRes::members() const {
  return members_;
}
inline void YYChannelTreeInfoRes::set_members(::google::protobuf::uint64 value) {
  set_has_members();
  members_ = value;
}

// optional string logoUrl = 5;
inline bool YYChannelTreeInfoRes::has_logourl() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void YYChannelTreeInfoRes::set_has_logourl() {
  _has_bits_[0] |= 0x00000010u;
}
inline void YYChannelTreeInfoRes::clear_has_logourl() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void YYChannelTreeInfoRes::clear_logourl() {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    logourl_->clear();
  }
  clear_has_logourl();
}
inline const ::std::string& YYChannelTreeInfoRes::logourl() const {
  return *logourl_;
}
inline void YYChannelTreeInfoRes::set_logourl(const ::std::string& value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void YYChannelTreeInfoRes::set_logourl(const char* value) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(value);
}
inline void YYChannelTreeInfoRes::set_logourl(const char* value, size_t size) {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  logourl_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* YYChannelTreeInfoRes::mutable_logourl() {
  set_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    logourl_ = new ::std::string;
  }
  return logourl_;
}
inline ::std::string* YYChannelTreeInfoRes::release_logourl() {
  clear_has_logourl();
  if (logourl_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = logourl_;
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void YYChannelTreeInfoRes::set_allocated_logourl(::std::string* logourl) {
  if (logourl_ != &::google::protobuf::internal::kEmptyString) {
    delete logourl_;
  }
  if (logourl) {
    set_has_logourl();
    logourl_ = logourl;
  } else {
    clear_has_logourl();
    logourl_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint64 gid = 6;
inline bool YYChannelTreeInfoRes::has_gid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void YYChannelTreeInfoRes::set_has_gid() {
  _has_bits_[0] |= 0x00000020u;
}
inline void YYChannelTreeInfoRes::clear_has_gid() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void YYChannelTreeInfoRes::clear_gid() {
  gid_ = GOOGLE_ULONGLONG(0);
  clear_has_gid();
}
inline ::google::protobuf::uint64 YYChannelTreeInfoRes::gid() const {
  return gid_;
}
inline void YYChannelTreeInfoRes::set_gid(::google::protobuf::uint64 value) {
  set_has_gid();
  gid_ = value;
}

// repeated .pp.YYChannelBranch treeInfo = 7;
inline int YYChannelTreeInfoRes::treeinfo_size() const {
  return treeinfo_.size();
}
inline void YYChannelTreeInfoRes::clear_treeinfo() {
  treeinfo_.Clear();
}
inline const ::pp::YYChannelBranch& YYChannelTreeInfoRes::treeinfo(int index) const {
  return treeinfo_.Get(index);
}
inline ::pp::YYChannelBranch* YYChannelTreeInfoRes::mutable_treeinfo(int index) {
  return treeinfo_.Mutable(index);
}
inline ::pp::YYChannelBranch* YYChannelTreeInfoRes::add_treeinfo() {
  return treeinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >&
YYChannelTreeInfoRes::treeinfo() const {
  return treeinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::pp::YYChannelBranch >*
YYChannelTreeInfoRes::mutable_treeinfo() {
  return &treeinfo_;
}

// -------------------------------------------------------------------

// ProtoBody

// optional string remoteAddr = 1;
inline bool ProtoBody::has_remoteaddr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_remoteaddr() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProtoBody::clear_has_remoteaddr() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProtoBody::clear_remoteaddr() {
  if (remoteaddr_ != &::google::protobuf::internal::kEmptyString) {
    remoteaddr_->clear();
  }
  clear_has_remoteaddr();
}
inline const ::std::string& ProtoBody::remoteaddr() const {
  return *remoteaddr_;
}
inline void ProtoBody::set_remoteaddr(const ::std::string& value) {
  set_has_remoteaddr();
  if (remoteaddr_ == &::google::protobuf::internal::kEmptyString) {
    remoteaddr_ = new ::std::string;
  }
  remoteaddr_->assign(value);
}
inline void ProtoBody::set_remoteaddr(const char* value) {
  set_has_remoteaddr();
  if (remoteaddr_ == &::google::protobuf::internal::kEmptyString) {
    remoteaddr_ = new ::std::string;
  }
  remoteaddr_->assign(value);
}
inline void ProtoBody::set_remoteaddr(const char* value, size_t size) {
  set_has_remoteaddr();
  if (remoteaddr_ == &::google::protobuf::internal::kEmptyString) {
    remoteaddr_ = new ::std::string;
  }
  remoteaddr_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBody::mutable_remoteaddr() {
  set_has_remoteaddr();
  if (remoteaddr_ == &::google::protobuf::internal::kEmptyString) {
    remoteaddr_ = new ::std::string;
  }
  return remoteaddr_;
}
inline ::std::string* ProtoBody::release_remoteaddr() {
  clear_has_remoteaddr();
  if (remoteaddr_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = remoteaddr_;
    remoteaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoBody::set_allocated_remoteaddr(::std::string* remoteaddr) {
  if (remoteaddr_ != &::google::protobuf::internal::kEmptyString) {
    delete remoteaddr_;
  }
  if (remoteaddr) {
    set_has_remoteaddr();
    remoteaddr_ = remoteaddr;
  } else {
    clear_has_remoteaddr();
    remoteaddr_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional uint32 clientVersion = 4;
inline bool ProtoBody::has_clientversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_clientversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ProtoBody::clear_has_clientversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ProtoBody::clear_clientversion() {
  clientversion_ = 0u;
  clear_has_clientversion();
}
inline ::google::protobuf::uint32 ProtoBody::clientversion() const {
  return clientversion_;
}
inline void ProtoBody::set_clientversion(::google::protobuf::uint32 value) {
  set_has_clientversion();
  clientversion_ = value;
}

// optional .pp.ForceLogoutPush forceLogoutPush = 5;
inline bool ProtoBody::has_forcelogoutpush() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_forcelogoutpush() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ProtoBody::clear_has_forcelogoutpush() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ProtoBody::clear_forcelogoutpush() {
  if (forcelogoutpush_ != NULL) forcelogoutpush_->::pp::ForceLogoutPush::Clear();
  clear_has_forcelogoutpush();
}
inline const ::pp::ForceLogoutPush& ProtoBody::forcelogoutpush() const {
  return forcelogoutpush_ != NULL ? *forcelogoutpush_ : *default_instance_->forcelogoutpush_;
}
inline ::pp::ForceLogoutPush* ProtoBody::mutable_forcelogoutpush() {
  set_has_forcelogoutpush();
  if (forcelogoutpush_ == NULL) forcelogoutpush_ = new ::pp::ForceLogoutPush;
  return forcelogoutpush_;
}
inline ::pp::ForceLogoutPush* ProtoBody::release_forcelogoutpush() {
  clear_has_forcelogoutpush();
  ::pp::ForceLogoutPush* temp = forcelogoutpush_;
  forcelogoutpush_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_forcelogoutpush(::pp::ForceLogoutPush* forcelogoutpush) {
  delete forcelogoutpush_;
  forcelogoutpush_ = forcelogoutpush;
  if (forcelogoutpush) {
    set_has_forcelogoutpush();
  } else {
    clear_has_forcelogoutpush();
  }
}

// optional .pp.MsgPush msgPush = 6;
inline bool ProtoBody::has_msgpush() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_msgpush() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ProtoBody::clear_has_msgpush() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ProtoBody::clear_msgpush() {
  if (msgpush_ != NULL) msgpush_->::pp::MsgPush::Clear();
  clear_has_msgpush();
}
inline const ::pp::MsgPush& ProtoBody::msgpush() const {
  return msgpush_ != NULL ? *msgpush_ : *default_instance_->msgpush_;
}
inline ::pp::MsgPush* ProtoBody::mutable_msgpush() {
  set_has_msgpush();
  if (msgpush_ == NULL) msgpush_ = new ::pp::MsgPush;
  return msgpush_;
}
inline ::pp::MsgPush* ProtoBody::release_msgpush() {
  clear_has_msgpush();
  ::pp::MsgPush* temp = msgpush_;
  msgpush_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgpush(::pp::MsgPush* msgpush) {
  delete msgpush_;
  msgpush_ = msgpush;
  if (msgpush) {
    set_has_msgpush();
  } else {
    clear_has_msgpush();
  }
}

// optional string iosPushMsg = 7;
inline bool ProtoBody::has_iospushmsg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_iospushmsg() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ProtoBody::clear_has_iospushmsg() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ProtoBody::clear_iospushmsg() {
  if (iospushmsg_ != &::google::protobuf::internal::kEmptyString) {
    iospushmsg_->clear();
  }
  clear_has_iospushmsg();
}
inline const ::std::string& ProtoBody::iospushmsg() const {
  return *iospushmsg_;
}
inline void ProtoBody::set_iospushmsg(const ::std::string& value) {
  set_has_iospushmsg();
  if (iospushmsg_ == &::google::protobuf::internal::kEmptyString) {
    iospushmsg_ = new ::std::string;
  }
  iospushmsg_->assign(value);
}
inline void ProtoBody::set_iospushmsg(const char* value) {
  set_has_iospushmsg();
  if (iospushmsg_ == &::google::protobuf::internal::kEmptyString) {
    iospushmsg_ = new ::std::string;
  }
  iospushmsg_->assign(value);
}
inline void ProtoBody::set_iospushmsg(const char* value, size_t size) {
  set_has_iospushmsg();
  if (iospushmsg_ == &::google::protobuf::internal::kEmptyString) {
    iospushmsg_ = new ::std::string;
  }
  iospushmsg_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProtoBody::mutable_iospushmsg() {
  set_has_iospushmsg();
  if (iospushmsg_ == &::google::protobuf::internal::kEmptyString) {
    iospushmsg_ = new ::std::string;
  }
  return iospushmsg_;
}
inline ::std::string* ProtoBody::release_iospushmsg() {
  clear_has_iospushmsg();
  if (iospushmsg_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = iospushmsg_;
    iospushmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProtoBody::set_allocated_iospushmsg(::std::string* iospushmsg) {
  if (iospushmsg_ != &::google::protobuf::internal::kEmptyString) {
    delete iospushmsg_;
  }
  if (iospushmsg) {
    set_has_iospushmsg();
    iospushmsg_ = iospushmsg;
  } else {
    clear_has_iospushmsg();
    iospushmsg_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .pp.UserMsg userMsg = 8;
inline bool ProtoBody::has_usermsg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_usermsg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ProtoBody::clear_has_usermsg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ProtoBody::clear_usermsg() {
  if (usermsg_ != NULL) usermsg_->::pp::UserMsg::Clear();
  clear_has_usermsg();
}
inline const ::pp::UserMsg& ProtoBody::usermsg() const {
  return usermsg_ != NULL ? *usermsg_ : *default_instance_->usermsg_;
}
inline ::pp::UserMsg* ProtoBody::mutable_usermsg() {
  set_has_usermsg();
  if (usermsg_ == NULL) usermsg_ = new ::pp::UserMsg;
  return usermsg_;
}
inline ::pp::UserMsg* ProtoBody::release_usermsg() {
  clear_has_usermsg();
  ::pp::UserMsg* temp = usermsg_;
  usermsg_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsg(::pp::UserMsg* usermsg) {
  delete usermsg_;
  usermsg_ = usermsg;
  if (usermsg) {
    set_has_usermsg();
  } else {
    clear_has_usermsg();
  }
}

// optional .pp.GroupMsg groupMsg = 9;
inline bool ProtoBody::has_groupmsg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_groupmsg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ProtoBody::clear_has_groupmsg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ProtoBody::clear_groupmsg() {
  if (groupmsg_ != NULL) groupmsg_->::pp::GroupMsg::Clear();
  clear_has_groupmsg();
}
inline const ::pp::GroupMsg& ProtoBody::groupmsg() const {
  return groupmsg_ != NULL ? *groupmsg_ : *default_instance_->groupmsg_;
}
inline ::pp::GroupMsg* ProtoBody::mutable_groupmsg() {
  set_has_groupmsg();
  if (groupmsg_ == NULL) groupmsg_ = new ::pp::GroupMsg;
  return groupmsg_;
}
inline ::pp::GroupMsg* ProtoBody::release_groupmsg() {
  clear_has_groupmsg();
  ::pp::GroupMsg* temp = groupmsg_;
  groupmsg_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsg(::pp::GroupMsg* groupmsg) {
  delete groupmsg_;
  groupmsg_ = groupmsg;
  if (groupmsg) {
    set_has_groupmsg();
  } else {
    clear_has_groupmsg();
  }
}

// optional .pp.Result result = 16;
inline bool ProtoBody::has_result() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_result() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ProtoBody::clear_has_result() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ProtoBody::clear_result() {
  if (result_ != NULL) result_->::pp::Result::Clear();
  clear_has_result();
}
inline const ::pp::Result& ProtoBody::result() const {
  return result_ != NULL ? *result_ : *default_instance_->result_;
}
inline ::pp::Result* ProtoBody::mutable_result() {
  set_has_result();
  if (result_ == NULL) result_ = new ::pp::Result;
  return result_;
}
inline ::pp::Result* ProtoBody::release_result() {
  clear_has_result();
  ::pp::Result* temp = result_;
  result_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_result(::pp::Result* result) {
  delete result_;
  result_ = result;
  if (result) {
    set_has_result();
  } else {
    clear_has_result();
  }
}

// optional .pp.UserInfo userInfo = 32;
inline bool ProtoBody::has_userinfo() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_userinfo() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ProtoBody::clear_has_userinfo() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ProtoBody::clear_userinfo() {
  if (userinfo_ != NULL) userinfo_->::pp::UserInfo::Clear();
  clear_has_userinfo();
}
inline const ::pp::UserInfo& ProtoBody::userinfo() const {
  return userinfo_ != NULL ? *userinfo_ : *default_instance_->userinfo_;
}
inline ::pp::UserInfo* ProtoBody::mutable_userinfo() {
  set_has_userinfo();
  if (userinfo_ == NULL) userinfo_ = new ::pp::UserInfo;
  return userinfo_;
}
inline ::pp::UserInfo* ProtoBody::release_userinfo() {
  clear_has_userinfo();
  ::pp::UserInfo* temp = userinfo_;
  userinfo_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinfo(::pp::UserInfo* userinfo) {
  delete userinfo_;
  userinfo_ = userinfo;
  if (userinfo) {
    set_has_userinfo();
  } else {
    clear_has_userinfo();
  }
}

// optional .pp.GroupInfo groupInfo = 33;
inline bool ProtoBody::has_groupinfo() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_groupinfo() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ProtoBody::clear_has_groupinfo() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ProtoBody::clear_groupinfo() {
  if (groupinfo_ != NULL) groupinfo_->::pp::GroupInfo::Clear();
  clear_has_groupinfo();
}
inline const ::pp::GroupInfo& ProtoBody::groupinfo() const {
  return groupinfo_ != NULL ? *groupinfo_ : *default_instance_->groupinfo_;
}
inline ::pp::GroupInfo* ProtoBody::mutable_groupinfo() {
  set_has_groupinfo();
  if (groupinfo_ == NULL) groupinfo_ = new ::pp::GroupInfo;
  return groupinfo_;
}
inline ::pp::GroupInfo* ProtoBody::release_groupinfo() {
  clear_has_groupinfo();
  ::pp::GroupInfo* temp = groupinfo_;
  groupinfo_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupinfo(::pp::GroupInfo* groupinfo) {
  delete groupinfo_;
  groupinfo_ = groupinfo;
  if (groupinfo) {
    set_has_groupinfo();
  } else {
    clear_has_groupinfo();
  }
}

// optional .pp.GroupIncrement groupIncrement = 48;
inline bool ProtoBody::has_groupincrement() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_groupincrement() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ProtoBody::clear_has_groupincrement() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ProtoBody::clear_groupincrement() {
  if (groupincrement_ != NULL) groupincrement_->::pp::GroupIncrement::Clear();
  clear_has_groupincrement();
}
inline const ::pp::GroupIncrement& ProtoBody::groupincrement() const {
  return groupincrement_ != NULL ? *groupincrement_ : *default_instance_->groupincrement_;
}
inline ::pp::GroupIncrement* ProtoBody::mutable_groupincrement() {
  set_has_groupincrement();
  if (groupincrement_ == NULL) groupincrement_ = new ::pp::GroupIncrement;
  return groupincrement_;
}
inline ::pp::GroupIncrement* ProtoBody::release_groupincrement() {
  clear_has_groupincrement();
  ::pp::GroupIncrement* temp = groupincrement_;
  groupincrement_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupincrement(::pp::GroupIncrement* groupincrement) {
  delete groupincrement_;
  groupincrement_ = groupincrement;
  if (groupincrement) {
    set_has_groupincrement();
  } else {
    clear_has_groupincrement();
  }
}

// optional .pp.ContactIncrement contactIncrement = 64;
inline bool ProtoBody::has_contactincrement() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_contactincrement() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ProtoBody::clear_has_contactincrement() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ProtoBody::clear_contactincrement() {
  if (contactincrement_ != NULL) contactincrement_->::pp::ContactIncrement::Clear();
  clear_has_contactincrement();
}
inline const ::pp::ContactIncrement& ProtoBody::contactincrement() const {
  return contactincrement_ != NULL ? *contactincrement_ : *default_instance_->contactincrement_;
}
inline ::pp::ContactIncrement* ProtoBody::mutable_contactincrement() {
  set_has_contactincrement();
  if (contactincrement_ == NULL) contactincrement_ = new ::pp::ContactIncrement;
  return contactincrement_;
}
inline ::pp::ContactIncrement* ProtoBody::release_contactincrement() {
  clear_has_contactincrement();
  ::pp::ContactIncrement* temp = contactincrement_;
  contactincrement_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactincrement(::pp::ContactIncrement* contactincrement) {
  delete contactincrement_;
  contactincrement_ = contactincrement;
  if (contactincrement) {
    set_has_contactincrement();
  } else {
    clear_has_contactincrement();
  }
}

// optional .pp.AdListReq adListReq = 5120;
inline bool ProtoBody::has_adlistreq() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_adlistreq() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ProtoBody::clear_has_adlistreq() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ProtoBody::clear_adlistreq() {
  if (adlistreq_ != NULL) adlistreq_->::pp::AdListReq::Clear();
  clear_has_adlistreq();
}
inline const ::pp::AdListReq& ProtoBody::adlistreq() const {
  return adlistreq_ != NULL ? *adlistreq_ : *default_instance_->adlistreq_;
}
inline ::pp::AdListReq* ProtoBody::mutable_adlistreq() {
  set_has_adlistreq();
  if (adlistreq_ == NULL) adlistreq_ = new ::pp::AdListReq;
  return adlistreq_;
}
inline ::pp::AdListReq* ProtoBody::release_adlistreq() {
  clear_has_adlistreq();
  ::pp::AdListReq* temp = adlistreq_;
  adlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_adlistreq(::pp::AdListReq* adlistreq) {
  delete adlistreq_;
  adlistreq_ = adlistreq;
  if (adlistreq) {
    set_has_adlistreq();
  } else {
    clear_has_adlistreq();
  }
}

// optional .pp.AdListRes adListRes = 5121;
inline bool ProtoBody::has_adlistres() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_adlistres() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ProtoBody::clear_has_adlistres() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ProtoBody::clear_adlistres() {
  if (adlistres_ != NULL) adlistres_->::pp::AdListRes::Clear();
  clear_has_adlistres();
}
inline const ::pp::AdListRes& ProtoBody::adlistres() const {
  return adlistres_ != NULL ? *adlistres_ : *default_instance_->adlistres_;
}
inline ::pp::AdListRes* ProtoBody::mutable_adlistres() {
  set_has_adlistres();
  if (adlistres_ == NULL) adlistres_ = new ::pp::AdListRes;
  return adlistres_;
}
inline ::pp::AdListRes* ProtoBody::release_adlistres() {
  clear_has_adlistres();
  ::pp::AdListRes* temp = adlistres_;
  adlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_adlistres(::pp::AdListRes* adlistres) {
  delete adlistres_;
  adlistres_ = adlistres;
  if (adlistres) {
    set_has_adlistres();
  } else {
    clear_has_adlistres();
  }
}

// optional .pp.AdModifyReq adModifyReq = 5122;
inline bool ProtoBody::has_admodifyreq() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_admodifyreq() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ProtoBody::clear_has_admodifyreq() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ProtoBody::clear_admodifyreq() {
  if (admodifyreq_ != NULL) admodifyreq_->::pp::AdModifyReq::Clear();
  clear_has_admodifyreq();
}
inline const ::pp::AdModifyReq& ProtoBody::admodifyreq() const {
  return admodifyreq_ != NULL ? *admodifyreq_ : *default_instance_->admodifyreq_;
}
inline ::pp::AdModifyReq* ProtoBody::mutable_admodifyreq() {
  set_has_admodifyreq();
  if (admodifyreq_ == NULL) admodifyreq_ = new ::pp::AdModifyReq;
  return admodifyreq_;
}
inline ::pp::AdModifyReq* ProtoBody::release_admodifyreq() {
  clear_has_admodifyreq();
  ::pp::AdModifyReq* temp = admodifyreq_;
  admodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_admodifyreq(::pp::AdModifyReq* admodifyreq) {
  delete admodifyreq_;
  admodifyreq_ = admodifyreq;
  if (admodifyreq) {
    set_has_admodifyreq();
  } else {
    clear_has_admodifyreq();
  }
}

// optional .pp.AdModifyRes adModifyRes = 5123;
inline bool ProtoBody::has_admodifyres() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_admodifyres() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ProtoBody::clear_has_admodifyres() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ProtoBody::clear_admodifyres() {
  if (admodifyres_ != NULL) admodifyres_->::pp::AdModifyRes::Clear();
  clear_has_admodifyres();
}
inline const ::pp::AdModifyRes& ProtoBody::admodifyres() const {
  return admodifyres_ != NULL ? *admodifyres_ : *default_instance_->admodifyres_;
}
inline ::pp::AdModifyRes* ProtoBody::mutable_admodifyres() {
  set_has_admodifyres();
  if (admodifyres_ == NULL) admodifyres_ = new ::pp::AdModifyRes;
  return admodifyres_;
}
inline ::pp::AdModifyRes* ProtoBody::release_admodifyres() {
  clear_has_admodifyres();
  ::pp::AdModifyRes* temp = admodifyres_;
  admodifyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_admodifyres(::pp::AdModifyRes* admodifyres) {
  delete admodifyres_;
  admodifyres_ = admodifyres;
  if (admodifyres) {
    set_has_admodifyres();
  } else {
    clear_has_admodifyres();
  }
}

// optional .pp.AdRemoveReq adRemoveReq = 5124;
inline bool ProtoBody::has_adremovereq() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_adremovereq() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ProtoBody::clear_has_adremovereq() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ProtoBody::clear_adremovereq() {
  if (adremovereq_ != NULL) adremovereq_->::pp::AdRemoveReq::Clear();
  clear_has_adremovereq();
}
inline const ::pp::AdRemoveReq& ProtoBody::adremovereq() const {
  return adremovereq_ != NULL ? *adremovereq_ : *default_instance_->adremovereq_;
}
inline ::pp::AdRemoveReq* ProtoBody::mutable_adremovereq() {
  set_has_adremovereq();
  if (adremovereq_ == NULL) adremovereq_ = new ::pp::AdRemoveReq;
  return adremovereq_;
}
inline ::pp::AdRemoveReq* ProtoBody::release_adremovereq() {
  clear_has_adremovereq();
  ::pp::AdRemoveReq* temp = adremovereq_;
  adremovereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_adremovereq(::pp::AdRemoveReq* adremovereq) {
  delete adremovereq_;
  adremovereq_ = adremovereq;
  if (adremovereq) {
    set_has_adremovereq();
  } else {
    clear_has_adremovereq();
  }
}

// optional .pp.AdRemoveRes adRemoveRes = 5125;
inline bool ProtoBody::has_adremoveres() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_adremoveres() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ProtoBody::clear_has_adremoveres() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ProtoBody::clear_adremoveres() {
  if (adremoveres_ != NULL) adremoveres_->::pp::AdRemoveRes::Clear();
  clear_has_adremoveres();
}
inline const ::pp::AdRemoveRes& ProtoBody::adremoveres() const {
  return adremoveres_ != NULL ? *adremoveres_ : *default_instance_->adremoveres_;
}
inline ::pp::AdRemoveRes* ProtoBody::mutable_adremoveres() {
  set_has_adremoveres();
  if (adremoveres_ == NULL) adremoveres_ = new ::pp::AdRemoveRes;
  return adremoveres_;
}
inline ::pp::AdRemoveRes* ProtoBody::release_adremoveres() {
  clear_has_adremoveres();
  ::pp::AdRemoveRes* temp = adremoveres_;
  adremoveres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_adremoveres(::pp::AdRemoveRes* adremoveres) {
  delete adremoveres_;
  adremoveres_ = adremoveres;
  if (adremoveres) {
    set_has_adremoveres();
  } else {
    clear_has_adremoveres();
  }
}

// optional .pp.IDCodeApplyReq iDCodeApplyReq = 4864;
inline bool ProtoBody::has_idcodeapplyreq() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_idcodeapplyreq() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ProtoBody::clear_has_idcodeapplyreq() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ProtoBody::clear_idcodeapplyreq() {
  if (idcodeapplyreq_ != NULL) idcodeapplyreq_->::pp::IDCodeApplyReq::Clear();
  clear_has_idcodeapplyreq();
}
inline const ::pp::IDCodeApplyReq& ProtoBody::idcodeapplyreq() const {
  return idcodeapplyreq_ != NULL ? *idcodeapplyreq_ : *default_instance_->idcodeapplyreq_;
}
inline ::pp::IDCodeApplyReq* ProtoBody::mutable_idcodeapplyreq() {
  set_has_idcodeapplyreq();
  if (idcodeapplyreq_ == NULL) idcodeapplyreq_ = new ::pp::IDCodeApplyReq;
  return idcodeapplyreq_;
}
inline ::pp::IDCodeApplyReq* ProtoBody::release_idcodeapplyreq() {
  clear_has_idcodeapplyreq();
  ::pp::IDCodeApplyReq* temp = idcodeapplyreq_;
  idcodeapplyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_idcodeapplyreq(::pp::IDCodeApplyReq* idcodeapplyreq) {
  delete idcodeapplyreq_;
  idcodeapplyreq_ = idcodeapplyreq;
  if (idcodeapplyreq) {
    set_has_idcodeapplyreq();
  } else {
    clear_has_idcodeapplyreq();
  }
}

// optional .pp.IDCodeApplyRes iDCodeApplyRes = 4865;
inline bool ProtoBody::has_idcodeapplyres() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_idcodeapplyres() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ProtoBody::clear_has_idcodeapplyres() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ProtoBody::clear_idcodeapplyres() {
  if (idcodeapplyres_ != NULL) idcodeapplyres_->::pp::IDCodeApplyRes::Clear();
  clear_has_idcodeapplyres();
}
inline const ::pp::IDCodeApplyRes& ProtoBody::idcodeapplyres() const {
  return idcodeapplyres_ != NULL ? *idcodeapplyres_ : *default_instance_->idcodeapplyres_;
}
inline ::pp::IDCodeApplyRes* ProtoBody::mutable_idcodeapplyres() {
  set_has_idcodeapplyres();
  if (idcodeapplyres_ == NULL) idcodeapplyres_ = new ::pp::IDCodeApplyRes;
  return idcodeapplyres_;
}
inline ::pp::IDCodeApplyRes* ProtoBody::release_idcodeapplyres() {
  clear_has_idcodeapplyres();
  ::pp::IDCodeApplyRes* temp = idcodeapplyres_;
  idcodeapplyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_idcodeapplyres(::pp::IDCodeApplyRes* idcodeapplyres) {
  delete idcodeapplyres_;
  idcodeapplyres_ = idcodeapplyres;
  if (idcodeapplyres) {
    set_has_idcodeapplyres();
  } else {
    clear_has_idcodeapplyres();
  }
}

// optional .pp.IDReplaceReq iDReplaceReq = 4866;
inline bool ProtoBody::has_idreplacereq() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_idreplacereq() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ProtoBody::clear_has_idreplacereq() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ProtoBody::clear_idreplacereq() {
  if (idreplacereq_ != NULL) idreplacereq_->::pp::IDReplaceReq::Clear();
  clear_has_idreplacereq();
}
inline const ::pp::IDReplaceReq& ProtoBody::idreplacereq() const {
  return idreplacereq_ != NULL ? *idreplacereq_ : *default_instance_->idreplacereq_;
}
inline ::pp::IDReplaceReq* ProtoBody::mutable_idreplacereq() {
  set_has_idreplacereq();
  if (idreplacereq_ == NULL) idreplacereq_ = new ::pp::IDReplaceReq;
  return idreplacereq_;
}
inline ::pp::IDReplaceReq* ProtoBody::release_idreplacereq() {
  clear_has_idreplacereq();
  ::pp::IDReplaceReq* temp = idreplacereq_;
  idreplacereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_idreplacereq(::pp::IDReplaceReq* idreplacereq) {
  delete idreplacereq_;
  idreplacereq_ = idreplacereq;
  if (idreplacereq) {
    set_has_idreplacereq();
  } else {
    clear_has_idreplacereq();
  }
}

// optional .pp.PublicNumAddReq publicNumAddReq = 4880;
inline bool ProtoBody::has_publicnumaddreq() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_publicnumaddreq() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ProtoBody::clear_has_publicnumaddreq() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ProtoBody::clear_publicnumaddreq() {
  if (publicnumaddreq_ != NULL) publicnumaddreq_->::pp::PublicNumAddReq::Clear();
  clear_has_publicnumaddreq();
}
inline const ::pp::PublicNumAddReq& ProtoBody::publicnumaddreq() const {
  return publicnumaddreq_ != NULL ? *publicnumaddreq_ : *default_instance_->publicnumaddreq_;
}
inline ::pp::PublicNumAddReq* ProtoBody::mutable_publicnumaddreq() {
  set_has_publicnumaddreq();
  if (publicnumaddreq_ == NULL) publicnumaddreq_ = new ::pp::PublicNumAddReq;
  return publicnumaddreq_;
}
inline ::pp::PublicNumAddReq* ProtoBody::release_publicnumaddreq() {
  clear_has_publicnumaddreq();
  ::pp::PublicNumAddReq* temp = publicnumaddreq_;
  publicnumaddreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_publicnumaddreq(::pp::PublicNumAddReq* publicnumaddreq) {
  delete publicnumaddreq_;
  publicnumaddreq_ = publicnumaddreq;
  if (publicnumaddreq) {
    set_has_publicnumaddreq();
  } else {
    clear_has_publicnumaddreq();
  }
}

// optional .pp.UserForbidOpReq userForbidOpReq = 4882;
inline bool ProtoBody::has_userforbidopreq() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_userforbidopreq() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ProtoBody::clear_has_userforbidopreq() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ProtoBody::clear_userforbidopreq() {
  if (userforbidopreq_ != NULL) userforbidopreq_->::pp::UserForbidOpReq::Clear();
  clear_has_userforbidopreq();
}
inline const ::pp::UserForbidOpReq& ProtoBody::userforbidopreq() const {
  return userforbidopreq_ != NULL ? *userforbidopreq_ : *default_instance_->userforbidopreq_;
}
inline ::pp::UserForbidOpReq* ProtoBody::mutable_userforbidopreq() {
  set_has_userforbidopreq();
  if (userforbidopreq_ == NULL) userforbidopreq_ = new ::pp::UserForbidOpReq;
  return userforbidopreq_;
}
inline ::pp::UserForbidOpReq* ProtoBody::release_userforbidopreq() {
  clear_has_userforbidopreq();
  ::pp::UserForbidOpReq* temp = userforbidopreq_;
  userforbidopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userforbidopreq(::pp::UserForbidOpReq* userforbidopreq) {
  delete userforbidopreq_;
  userforbidopreq_ = userforbidopreq;
  if (userforbidopreq) {
    set_has_userforbidopreq();
  } else {
    clear_has_userforbidopreq();
  }
}

// optional .pp.UserForbidOpRes userForbidOpRes = 4883;
inline bool ProtoBody::has_userforbidopres() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_userforbidopres() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ProtoBody::clear_has_userforbidopres() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ProtoBody::clear_userforbidopres() {
  if (userforbidopres_ != NULL) userforbidopres_->::pp::UserForbidOpRes::Clear();
  clear_has_userforbidopres();
}
inline const ::pp::UserForbidOpRes& ProtoBody::userforbidopres() const {
  return userforbidopres_ != NULL ? *userforbidopres_ : *default_instance_->userforbidopres_;
}
inline ::pp::UserForbidOpRes* ProtoBody::mutable_userforbidopres() {
  set_has_userforbidopres();
  if (userforbidopres_ == NULL) userforbidopres_ = new ::pp::UserForbidOpRes;
  return userforbidopres_;
}
inline ::pp::UserForbidOpRes* ProtoBody::release_userforbidopres() {
  clear_has_userforbidopres();
  ::pp::UserForbidOpRes* temp = userforbidopres_;
  userforbidopres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userforbidopres(::pp::UserForbidOpRes* userforbidopres) {
  delete userforbidopres_;
  userforbidopres_ = userforbidopres;
  if (userforbidopres) {
    set_has_userforbidopres();
  } else {
    clear_has_userforbidopres();
  }
}

// optional .pp.UserForbidSearchReq userForbidSearchReq = 4884;
inline bool ProtoBody::has_userforbidsearchreq() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_userforbidsearchreq() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ProtoBody::clear_has_userforbidsearchreq() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ProtoBody::clear_userforbidsearchreq() {
  if (userforbidsearchreq_ != NULL) userforbidsearchreq_->::pp::UserForbidSearchReq::Clear();
  clear_has_userforbidsearchreq();
}
inline const ::pp::UserForbidSearchReq& ProtoBody::userforbidsearchreq() const {
  return userforbidsearchreq_ != NULL ? *userforbidsearchreq_ : *default_instance_->userforbidsearchreq_;
}
inline ::pp::UserForbidSearchReq* ProtoBody::mutable_userforbidsearchreq() {
  set_has_userforbidsearchreq();
  if (userforbidsearchreq_ == NULL) userforbidsearchreq_ = new ::pp::UserForbidSearchReq;
  return userforbidsearchreq_;
}
inline ::pp::UserForbidSearchReq* ProtoBody::release_userforbidsearchreq() {
  clear_has_userforbidsearchreq();
  ::pp::UserForbidSearchReq* temp = userforbidsearchreq_;
  userforbidsearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userforbidsearchreq(::pp::UserForbidSearchReq* userforbidsearchreq) {
  delete userforbidsearchreq_;
  userforbidsearchreq_ = userforbidsearchreq;
  if (userforbidsearchreq) {
    set_has_userforbidsearchreq();
  } else {
    clear_has_userforbidsearchreq();
  }
}

// optional .pp.UserForbidSearchRes userForbidSearchRes = 4885;
inline bool ProtoBody::has_userforbidsearchres() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_userforbidsearchres() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ProtoBody::clear_has_userforbidsearchres() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ProtoBody::clear_userforbidsearchres() {
  if (userforbidsearchres_ != NULL) userforbidsearchres_->::pp::UserForbidSearchRes::Clear();
  clear_has_userforbidsearchres();
}
inline const ::pp::UserForbidSearchRes& ProtoBody::userforbidsearchres() const {
  return userforbidsearchres_ != NULL ? *userforbidsearchres_ : *default_instance_->userforbidsearchres_;
}
inline ::pp::UserForbidSearchRes* ProtoBody::mutable_userforbidsearchres() {
  set_has_userforbidsearchres();
  if (userforbidsearchres_ == NULL) userforbidsearchres_ = new ::pp::UserForbidSearchRes;
  return userforbidsearchres_;
}
inline ::pp::UserForbidSearchRes* ProtoBody::release_userforbidsearchres() {
  clear_has_userforbidsearchres();
  ::pp::UserForbidSearchRes* temp = userforbidsearchres_;
  userforbidsearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userforbidsearchres(::pp::UserForbidSearchRes* userforbidsearchres) {
  delete userforbidsearchres_;
  userforbidsearchres_ = userforbidsearchres;
  if (userforbidsearchres) {
    set_has_userforbidsearchres();
  } else {
    clear_has_userforbidsearchres();
  }
}

// optional .pp.UserRoleModifyReq userRoleModifyReq = 4890;
inline bool ProtoBody::has_userrolemodifyreq() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_userrolemodifyreq() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ProtoBody::clear_has_userrolemodifyreq() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ProtoBody::clear_userrolemodifyreq() {
  if (userrolemodifyreq_ != NULL) userrolemodifyreq_->::pp::UserRoleModifyReq::Clear();
  clear_has_userrolemodifyreq();
}
inline const ::pp::UserRoleModifyReq& ProtoBody::userrolemodifyreq() const {
  return userrolemodifyreq_ != NULL ? *userrolemodifyreq_ : *default_instance_->userrolemodifyreq_;
}
inline ::pp::UserRoleModifyReq* ProtoBody::mutable_userrolemodifyreq() {
  set_has_userrolemodifyreq();
  if (userrolemodifyreq_ == NULL) userrolemodifyreq_ = new ::pp::UserRoleModifyReq;
  return userrolemodifyreq_;
}
inline ::pp::UserRoleModifyReq* ProtoBody::release_userrolemodifyreq() {
  clear_has_userrolemodifyreq();
  ::pp::UserRoleModifyReq* temp = userrolemodifyreq_;
  userrolemodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userrolemodifyreq(::pp::UserRoleModifyReq* userrolemodifyreq) {
  delete userrolemodifyreq_;
  userrolemodifyreq_ = userrolemodifyreq;
  if (userrolemodifyreq) {
    set_has_userrolemodifyreq();
  } else {
    clear_has_userrolemodifyreq();
  }
}

// optional .pp.BackstageGidSidReq backstageGidSidReq = 13569;
inline bool ProtoBody::has_backstagegidsidreq() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_backstagegidsidreq() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ProtoBody::clear_has_backstagegidsidreq() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ProtoBody::clear_backstagegidsidreq() {
  if (backstagegidsidreq_ != NULL) backstagegidsidreq_->::pp::BackstageGidSidReq::Clear();
  clear_has_backstagegidsidreq();
}
inline const ::pp::BackstageGidSidReq& ProtoBody::backstagegidsidreq() const {
  return backstagegidsidreq_ != NULL ? *backstagegidsidreq_ : *default_instance_->backstagegidsidreq_;
}
inline ::pp::BackstageGidSidReq* ProtoBody::mutable_backstagegidsidreq() {
  set_has_backstagegidsidreq();
  if (backstagegidsidreq_ == NULL) backstagegidsidreq_ = new ::pp::BackstageGidSidReq;
  return backstagegidsidreq_;
}
inline ::pp::BackstageGidSidReq* ProtoBody::release_backstagegidsidreq() {
  clear_has_backstagegidsidreq();
  ::pp::BackstageGidSidReq* temp = backstagegidsidreq_;
  backstagegidsidreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_backstagegidsidreq(::pp::BackstageGidSidReq* backstagegidsidreq) {
  delete backstagegidsidreq_;
  backstagegidsidreq_ = backstagegidsidreq;
  if (backstagegidsidreq) {
    set_has_backstagegidsidreq();
  } else {
    clear_has_backstagegidsidreq();
  }
}

// optional .pp.BackstageGidSidRes backstageGidSidRes = 13570;
inline bool ProtoBody::has_backstagegidsidres() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_backstagegidsidres() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ProtoBody::clear_has_backstagegidsidres() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ProtoBody::clear_backstagegidsidres() {
  if (backstagegidsidres_ != NULL) backstagegidsidres_->::pp::BackstageGidSidRes::Clear();
  clear_has_backstagegidsidres();
}
inline const ::pp::BackstageGidSidRes& ProtoBody::backstagegidsidres() const {
  return backstagegidsidres_ != NULL ? *backstagegidsidres_ : *default_instance_->backstagegidsidres_;
}
inline ::pp::BackstageGidSidRes* ProtoBody::mutable_backstagegidsidres() {
  set_has_backstagegidsidres();
  if (backstagegidsidres_ == NULL) backstagegidsidres_ = new ::pp::BackstageGidSidRes;
  return backstagegidsidres_;
}
inline ::pp::BackstageGidSidRes* ProtoBody::release_backstagegidsidres() {
  clear_has_backstagegidsidres();
  ::pp::BackstageGidSidRes* temp = backstagegidsidres_;
  backstagegidsidres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_backstagegidsidres(::pp::BackstageGidSidRes* backstagegidsidres) {
  delete backstagegidsidres_;
  backstagegidsidres_ = backstagegidsidres;
  if (backstagegidsidres) {
    set_has_backstagegidsidres();
  } else {
    clear_has_backstagegidsidres();
  }
}

// optional .pp.ConfigJsonReq configJsonReq = 6401;
inline bool ProtoBody::has_configjsonreq() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_configjsonreq() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ProtoBody::clear_has_configjsonreq() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ProtoBody::clear_configjsonreq() {
  if (configjsonreq_ != NULL) configjsonreq_->::pp::ConfigJsonReq::Clear();
  clear_has_configjsonreq();
}
inline const ::pp::ConfigJsonReq& ProtoBody::configjsonreq() const {
  return configjsonreq_ != NULL ? *configjsonreq_ : *default_instance_->configjsonreq_;
}
inline ::pp::ConfigJsonReq* ProtoBody::mutable_configjsonreq() {
  set_has_configjsonreq();
  if (configjsonreq_ == NULL) configjsonreq_ = new ::pp::ConfigJsonReq;
  return configjsonreq_;
}
inline ::pp::ConfigJsonReq* ProtoBody::release_configjsonreq() {
  clear_has_configjsonreq();
  ::pp::ConfigJsonReq* temp = configjsonreq_;
  configjsonreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonreq(::pp::ConfigJsonReq* configjsonreq) {
  delete configjsonreq_;
  configjsonreq_ = configjsonreq;
  if (configjsonreq) {
    set_has_configjsonreq();
  } else {
    clear_has_configjsonreq();
  }
}

// optional .pp.ConfigJsonRes configJsonRes = 6402;
inline bool ProtoBody::has_configjsonres() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_configjsonres() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ProtoBody::clear_has_configjsonres() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ProtoBody::clear_configjsonres() {
  if (configjsonres_ != NULL) configjsonres_->::pp::ConfigJsonRes::Clear();
  clear_has_configjsonres();
}
inline const ::pp::ConfigJsonRes& ProtoBody::configjsonres() const {
  return configjsonres_ != NULL ? *configjsonres_ : *default_instance_->configjsonres_;
}
inline ::pp::ConfigJsonRes* ProtoBody::mutable_configjsonres() {
  set_has_configjsonres();
  if (configjsonres_ == NULL) configjsonres_ = new ::pp::ConfigJsonRes;
  return configjsonres_;
}
inline ::pp::ConfigJsonRes* ProtoBody::release_configjsonres() {
  clear_has_configjsonres();
  ::pp::ConfigJsonRes* temp = configjsonres_;
  configjsonres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonres(::pp::ConfigJsonRes* configjsonres) {
  delete configjsonres_;
  configjsonres_ = configjsonres;
  if (configjsonres) {
    set_has_configjsonres();
  } else {
    clear_has_configjsonres();
  }
}

// optional .pp.ConfigJsonListReq configJsonListReq = 6403;
inline bool ProtoBody::has_configjsonlistreq() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_configjsonlistreq() {
  _has_bits_[0] |= 0x80000000u;
}
inline void ProtoBody::clear_has_configjsonlistreq() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void ProtoBody::clear_configjsonlistreq() {
  if (configjsonlistreq_ != NULL) configjsonlistreq_->::pp::ConfigJsonListReq::Clear();
  clear_has_configjsonlistreq();
}
inline const ::pp::ConfigJsonListReq& ProtoBody::configjsonlistreq() const {
  return configjsonlistreq_ != NULL ? *configjsonlistreq_ : *default_instance_->configjsonlistreq_;
}
inline ::pp::ConfigJsonListReq* ProtoBody::mutable_configjsonlistreq() {
  set_has_configjsonlistreq();
  if (configjsonlistreq_ == NULL) configjsonlistreq_ = new ::pp::ConfigJsonListReq;
  return configjsonlistreq_;
}
inline ::pp::ConfigJsonListReq* ProtoBody::release_configjsonlistreq() {
  clear_has_configjsonlistreq();
  ::pp::ConfigJsonListReq* temp = configjsonlistreq_;
  configjsonlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonlistreq(::pp::ConfigJsonListReq* configjsonlistreq) {
  delete configjsonlistreq_;
  configjsonlistreq_ = configjsonlistreq;
  if (configjsonlistreq) {
    set_has_configjsonlistreq();
  } else {
    clear_has_configjsonlistreq();
  }
}

// optional .pp.ConfigJsonListRes configJsonListRes = 6404;
inline bool ProtoBody::has_configjsonlistres() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_configjsonlistres() {
  _has_bits_[1] |= 0x00000001u;
}
inline void ProtoBody::clear_has_configjsonlistres() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void ProtoBody::clear_configjsonlistres() {
  if (configjsonlistres_ != NULL) configjsonlistres_->::pp::ConfigJsonListRes::Clear();
  clear_has_configjsonlistres();
}
inline const ::pp::ConfigJsonListRes& ProtoBody::configjsonlistres() const {
  return configjsonlistres_ != NULL ? *configjsonlistres_ : *default_instance_->configjsonlistres_;
}
inline ::pp::ConfigJsonListRes* ProtoBody::mutable_configjsonlistres() {
  set_has_configjsonlistres();
  if (configjsonlistres_ == NULL) configjsonlistres_ = new ::pp::ConfigJsonListRes;
  return configjsonlistres_;
}
inline ::pp::ConfigJsonListRes* ProtoBody::release_configjsonlistres() {
  clear_has_configjsonlistres();
  ::pp::ConfigJsonListRes* temp = configjsonlistres_;
  configjsonlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonlistres(::pp::ConfigJsonListRes* configjsonlistres) {
  delete configjsonlistres_;
  configjsonlistres_ = configjsonlistres;
  if (configjsonlistres) {
    set_has_configjsonlistres();
  } else {
    clear_has_configjsonlistres();
  }
}

// optional .pp.SysConfReq sysConfReq = 6405;
inline bool ProtoBody::has_sysconfreq() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_sysconfreq() {
  _has_bits_[1] |= 0x00000002u;
}
inline void ProtoBody::clear_has_sysconfreq() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void ProtoBody::clear_sysconfreq() {
  if (sysconfreq_ != NULL) sysconfreq_->::pp::SysConfReq::Clear();
  clear_has_sysconfreq();
}
inline const ::pp::SysConfReq& ProtoBody::sysconfreq() const {
  return sysconfreq_ != NULL ? *sysconfreq_ : *default_instance_->sysconfreq_;
}
inline ::pp::SysConfReq* ProtoBody::mutable_sysconfreq() {
  set_has_sysconfreq();
  if (sysconfreq_ == NULL) sysconfreq_ = new ::pp::SysConfReq;
  return sysconfreq_;
}
inline ::pp::SysConfReq* ProtoBody::release_sysconfreq() {
  clear_has_sysconfreq();
  ::pp::SysConfReq* temp = sysconfreq_;
  sysconfreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sysconfreq(::pp::SysConfReq* sysconfreq) {
  delete sysconfreq_;
  sysconfreq_ = sysconfreq;
  if (sysconfreq) {
    set_has_sysconfreq();
  } else {
    clear_has_sysconfreq();
  }
}

// optional .pp.SysConfRes sysConfRes = 6406;
inline bool ProtoBody::has_sysconfres() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_sysconfres() {
  _has_bits_[1] |= 0x00000004u;
}
inline void ProtoBody::clear_has_sysconfres() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void ProtoBody::clear_sysconfres() {
  if (sysconfres_ != NULL) sysconfres_->::pp::SysConfRes::Clear();
  clear_has_sysconfres();
}
inline const ::pp::SysConfRes& ProtoBody::sysconfres() const {
  return sysconfres_ != NULL ? *sysconfres_ : *default_instance_->sysconfres_;
}
inline ::pp::SysConfRes* ProtoBody::mutable_sysconfres() {
  set_has_sysconfres();
  if (sysconfres_ == NULL) sysconfres_ = new ::pp::SysConfRes;
  return sysconfres_;
}
inline ::pp::SysConfRes* ProtoBody::release_sysconfres() {
  clear_has_sysconfres();
  ::pp::SysConfRes* temp = sysconfres_;
  sysconfres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sysconfres(::pp::SysConfRes* sysconfres) {
  delete sysconfres_;
  sysconfres_ = sysconfres;
  if (sysconfres) {
    set_has_sysconfres();
  } else {
    clear_has_sysconfres();
  }
}

// optional .pp.UserSettingSetReq userSettingSetReq = 6452;
inline bool ProtoBody::has_usersettingsetreq() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_usersettingsetreq() {
  _has_bits_[1] |= 0x00000008u;
}
inline void ProtoBody::clear_has_usersettingsetreq() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void ProtoBody::clear_usersettingsetreq() {
  if (usersettingsetreq_ != NULL) usersettingsetreq_->::pp::UserSettingSetReq::Clear();
  clear_has_usersettingsetreq();
}
inline const ::pp::UserSettingSetReq& ProtoBody::usersettingsetreq() const {
  return usersettingsetreq_ != NULL ? *usersettingsetreq_ : *default_instance_->usersettingsetreq_;
}
inline ::pp::UserSettingSetReq* ProtoBody::mutable_usersettingsetreq() {
  set_has_usersettingsetreq();
  if (usersettingsetreq_ == NULL) usersettingsetreq_ = new ::pp::UserSettingSetReq;
  return usersettingsetreq_;
}
inline ::pp::UserSettingSetReq* ProtoBody::release_usersettingsetreq() {
  clear_has_usersettingsetreq();
  ::pp::UserSettingSetReq* temp = usersettingsetreq_;
  usersettingsetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usersettingsetreq(::pp::UserSettingSetReq* usersettingsetreq) {
  delete usersettingsetreq_;
  usersettingsetreq_ = usersettingsetreq;
  if (usersettingsetreq) {
    set_has_usersettingsetreq();
  } else {
    clear_has_usersettingsetreq();
  }
}

// optional .pp.UserSettingSetRes userSettingSetRes = 6453;
inline bool ProtoBody::has_usersettingsetres() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_usersettingsetres() {
  _has_bits_[1] |= 0x00000010u;
}
inline void ProtoBody::clear_has_usersettingsetres() {
  _has_bits_[1] &= ~0x00000010u;
}
inline void ProtoBody::clear_usersettingsetres() {
  if (usersettingsetres_ != NULL) usersettingsetres_->::pp::UserSettingSetRes::Clear();
  clear_has_usersettingsetres();
}
inline const ::pp::UserSettingSetRes& ProtoBody::usersettingsetres() const {
  return usersettingsetres_ != NULL ? *usersettingsetres_ : *default_instance_->usersettingsetres_;
}
inline ::pp::UserSettingSetRes* ProtoBody::mutable_usersettingsetres() {
  set_has_usersettingsetres();
  if (usersettingsetres_ == NULL) usersettingsetres_ = new ::pp::UserSettingSetRes;
  return usersettingsetres_;
}
inline ::pp::UserSettingSetRes* ProtoBody::release_usersettingsetres() {
  clear_has_usersettingsetres();
  ::pp::UserSettingSetRes* temp = usersettingsetres_;
  usersettingsetres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usersettingsetres(::pp::UserSettingSetRes* usersettingsetres) {
  delete usersettingsetres_;
  usersettingsetres_ = usersettingsetres;
  if (usersettingsetres) {
    set_has_usersettingsetres();
  } else {
    clear_has_usersettingsetres();
  }
}

// optional .pp.UserSettingGetReq userSettingGetReq = 6454;
inline bool ProtoBody::has_usersettinggetreq() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_usersettinggetreq() {
  _has_bits_[1] |= 0x00000020u;
}
inline void ProtoBody::clear_has_usersettinggetreq() {
  _has_bits_[1] &= ~0x00000020u;
}
inline void ProtoBody::clear_usersettinggetreq() {
  if (usersettinggetreq_ != NULL) usersettinggetreq_->::pp::UserSettingGetReq::Clear();
  clear_has_usersettinggetreq();
}
inline const ::pp::UserSettingGetReq& ProtoBody::usersettinggetreq() const {
  return usersettinggetreq_ != NULL ? *usersettinggetreq_ : *default_instance_->usersettinggetreq_;
}
inline ::pp::UserSettingGetReq* ProtoBody::mutable_usersettinggetreq() {
  set_has_usersettinggetreq();
  if (usersettinggetreq_ == NULL) usersettinggetreq_ = new ::pp::UserSettingGetReq;
  return usersettinggetreq_;
}
inline ::pp::UserSettingGetReq* ProtoBody::release_usersettinggetreq() {
  clear_has_usersettinggetreq();
  ::pp::UserSettingGetReq* temp = usersettinggetreq_;
  usersettinggetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usersettinggetreq(::pp::UserSettingGetReq* usersettinggetreq) {
  delete usersettinggetreq_;
  usersettinggetreq_ = usersettinggetreq;
  if (usersettinggetreq) {
    set_has_usersettinggetreq();
  } else {
    clear_has_usersettinggetreq();
  }
}

// optional .pp.UserSettingGetRes userSettingGetRes = 6455;
inline bool ProtoBody::has_usersettinggetres() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_usersettinggetres() {
  _has_bits_[1] |= 0x00000040u;
}
inline void ProtoBody::clear_has_usersettinggetres() {
  _has_bits_[1] &= ~0x00000040u;
}
inline void ProtoBody::clear_usersettinggetres() {
  if (usersettinggetres_ != NULL) usersettinggetres_->::pp::UserSettingGetRes::Clear();
  clear_has_usersettinggetres();
}
inline const ::pp::UserSettingGetRes& ProtoBody::usersettinggetres() const {
  return usersettinggetres_ != NULL ? *usersettinggetres_ : *default_instance_->usersettinggetres_;
}
inline ::pp::UserSettingGetRes* ProtoBody::mutable_usersettinggetres() {
  set_has_usersettinggetres();
  if (usersettinggetres_ == NULL) usersettinggetres_ = new ::pp::UserSettingGetRes;
  return usersettinggetres_;
}
inline ::pp::UserSettingGetRes* ProtoBody::release_usersettinggetres() {
  clear_has_usersettinggetres();
  ::pp::UserSettingGetRes* temp = usersettinggetres_;
  usersettinggetres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usersettinggetres(::pp::UserSettingGetRes* usersettinggetres) {
  delete usersettinggetres_;
  usersettinggetres_ = usersettinggetres;
  if (usersettinggetres) {
    set_has_usersettinggetres();
  } else {
    clear_has_usersettinggetres();
  }
}

// optional .pp.AppStateCheckReq appStateCheckReq = 6464;
inline bool ProtoBody::has_appstatecheckreq() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_appstatecheckreq() {
  _has_bits_[1] |= 0x00000080u;
}
inline void ProtoBody::clear_has_appstatecheckreq() {
  _has_bits_[1] &= ~0x00000080u;
}
inline void ProtoBody::clear_appstatecheckreq() {
  if (appstatecheckreq_ != NULL) appstatecheckreq_->::pp::AppStateCheckReq::Clear();
  clear_has_appstatecheckreq();
}
inline const ::pp::AppStateCheckReq& ProtoBody::appstatecheckreq() const {
  return appstatecheckreq_ != NULL ? *appstatecheckreq_ : *default_instance_->appstatecheckreq_;
}
inline ::pp::AppStateCheckReq* ProtoBody::mutable_appstatecheckreq() {
  set_has_appstatecheckreq();
  if (appstatecheckreq_ == NULL) appstatecheckreq_ = new ::pp::AppStateCheckReq;
  return appstatecheckreq_;
}
inline ::pp::AppStateCheckReq* ProtoBody::release_appstatecheckreq() {
  clear_has_appstatecheckreq();
  ::pp::AppStateCheckReq* temp = appstatecheckreq_;
  appstatecheckreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appstatecheckreq(::pp::AppStateCheckReq* appstatecheckreq) {
  delete appstatecheckreq_;
  appstatecheckreq_ = appstatecheckreq;
  if (appstatecheckreq) {
    set_has_appstatecheckreq();
  } else {
    clear_has_appstatecheckreq();
  }
}

// optional .pp.AppStateCheckRes appStateCheckRes = 6465;
inline bool ProtoBody::has_appstatecheckres() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_appstatecheckres() {
  _has_bits_[1] |= 0x00000100u;
}
inline void ProtoBody::clear_has_appstatecheckres() {
  _has_bits_[1] &= ~0x00000100u;
}
inline void ProtoBody::clear_appstatecheckres() {
  if (appstatecheckres_ != NULL) appstatecheckres_->::pp::AppStateCheckRes::Clear();
  clear_has_appstatecheckres();
}
inline const ::pp::AppStateCheckRes& ProtoBody::appstatecheckres() const {
  return appstatecheckres_ != NULL ? *appstatecheckres_ : *default_instance_->appstatecheckres_;
}
inline ::pp::AppStateCheckRes* ProtoBody::mutable_appstatecheckres() {
  set_has_appstatecheckres();
  if (appstatecheckres_ == NULL) appstatecheckres_ = new ::pp::AppStateCheckRes;
  return appstatecheckres_;
}
inline ::pp::AppStateCheckRes* ProtoBody::release_appstatecheckres() {
  clear_has_appstatecheckres();
  ::pp::AppStateCheckRes* temp = appstatecheckres_;
  appstatecheckres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appstatecheckres(::pp::AppStateCheckRes* appstatecheckres) {
  delete appstatecheckres_;
  appstatecheckres_ = appstatecheckres;
  if (appstatecheckres) {
    set_has_appstatecheckres();
  } else {
    clear_has_appstatecheckres();
  }
}

// optional .pp.AppStateUpdateReq appStateUpdateReq = 6466;
inline bool ProtoBody::has_appstateupdatereq() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_appstateupdatereq() {
  _has_bits_[1] |= 0x00000200u;
}
inline void ProtoBody::clear_has_appstateupdatereq() {
  _has_bits_[1] &= ~0x00000200u;
}
inline void ProtoBody::clear_appstateupdatereq() {
  if (appstateupdatereq_ != NULL) appstateupdatereq_->::pp::AppStateUpdateReq::Clear();
  clear_has_appstateupdatereq();
}
inline const ::pp::AppStateUpdateReq& ProtoBody::appstateupdatereq() const {
  return appstateupdatereq_ != NULL ? *appstateupdatereq_ : *default_instance_->appstateupdatereq_;
}
inline ::pp::AppStateUpdateReq* ProtoBody::mutable_appstateupdatereq() {
  set_has_appstateupdatereq();
  if (appstateupdatereq_ == NULL) appstateupdatereq_ = new ::pp::AppStateUpdateReq;
  return appstateupdatereq_;
}
inline ::pp::AppStateUpdateReq* ProtoBody::release_appstateupdatereq() {
  clear_has_appstateupdatereq();
  ::pp::AppStateUpdateReq* temp = appstateupdatereq_;
  appstateupdatereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appstateupdatereq(::pp::AppStateUpdateReq* appstateupdatereq) {
  delete appstateupdatereq_;
  appstateupdatereq_ = appstateupdatereq;
  if (appstateupdatereq) {
    set_has_appstateupdatereq();
  } else {
    clear_has_appstateupdatereq();
  }
}

// optional .pp.AppStateUpdateRes appStateUpdateRes = 6467;
inline bool ProtoBody::has_appstateupdateres() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_appstateupdateres() {
  _has_bits_[1] |= 0x00000400u;
}
inline void ProtoBody::clear_has_appstateupdateres() {
  _has_bits_[1] &= ~0x00000400u;
}
inline void ProtoBody::clear_appstateupdateres() {
  if (appstateupdateres_ != NULL) appstateupdateres_->::pp::AppStateUpdateRes::Clear();
  clear_has_appstateupdateres();
}
inline const ::pp::AppStateUpdateRes& ProtoBody::appstateupdateres() const {
  return appstateupdateres_ != NULL ? *appstateupdateres_ : *default_instance_->appstateupdateres_;
}
inline ::pp::AppStateUpdateRes* ProtoBody::mutable_appstateupdateres() {
  set_has_appstateupdateres();
  if (appstateupdateres_ == NULL) appstateupdateres_ = new ::pp::AppStateUpdateRes;
  return appstateupdateres_;
}
inline ::pp::AppStateUpdateRes* ProtoBody::release_appstateupdateres() {
  clear_has_appstateupdateres();
  ::pp::AppStateUpdateRes* temp = appstateupdateres_;
  appstateupdateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appstateupdateres(::pp::AppStateUpdateRes* appstateupdateres) {
  delete appstateupdateres_;
  appstateupdateres_ = appstateupdateres;
  if (appstateupdateres) {
    set_has_appstateupdateres();
  } else {
    clear_has_appstateupdateres();
  }
}

// optional .pp.AppActConfigReq appActConfigReq = 6468;
inline bool ProtoBody::has_appactconfigreq() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_appactconfigreq() {
  _has_bits_[1] |= 0x00000800u;
}
inline void ProtoBody::clear_has_appactconfigreq() {
  _has_bits_[1] &= ~0x00000800u;
}
inline void ProtoBody::clear_appactconfigreq() {
  if (appactconfigreq_ != NULL) appactconfigreq_->::pp::AppActConfigReq::Clear();
  clear_has_appactconfigreq();
}
inline const ::pp::AppActConfigReq& ProtoBody::appactconfigreq() const {
  return appactconfigreq_ != NULL ? *appactconfigreq_ : *default_instance_->appactconfigreq_;
}
inline ::pp::AppActConfigReq* ProtoBody::mutable_appactconfigreq() {
  set_has_appactconfigreq();
  if (appactconfigreq_ == NULL) appactconfigreq_ = new ::pp::AppActConfigReq;
  return appactconfigreq_;
}
inline ::pp::AppActConfigReq* ProtoBody::release_appactconfigreq() {
  clear_has_appactconfigreq();
  ::pp::AppActConfigReq* temp = appactconfigreq_;
  appactconfigreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appactconfigreq(::pp::AppActConfigReq* appactconfigreq) {
  delete appactconfigreq_;
  appactconfigreq_ = appactconfigreq;
  if (appactconfigreq) {
    set_has_appactconfigreq();
  } else {
    clear_has_appactconfigreq();
  }
}

// optional .pp.AppActConfigRes appActConfigRes = 6469;
inline bool ProtoBody::has_appactconfigres() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_appactconfigres() {
  _has_bits_[1] |= 0x00001000u;
}
inline void ProtoBody::clear_has_appactconfigres() {
  _has_bits_[1] &= ~0x00001000u;
}
inline void ProtoBody::clear_appactconfigres() {
  if (appactconfigres_ != NULL) appactconfigres_->::pp::AppActConfigRes::Clear();
  clear_has_appactconfigres();
}
inline const ::pp::AppActConfigRes& ProtoBody::appactconfigres() const {
  return appactconfigres_ != NULL ? *appactconfigres_ : *default_instance_->appactconfigres_;
}
inline ::pp::AppActConfigRes* ProtoBody::mutable_appactconfigres() {
  set_has_appactconfigres();
  if (appactconfigres_ == NULL) appactconfigres_ = new ::pp::AppActConfigRes;
  return appactconfigres_;
}
inline ::pp::AppActConfigRes* ProtoBody::release_appactconfigres() {
  clear_has_appactconfigres();
  ::pp::AppActConfigRes* temp = appactconfigres_;
  appactconfigres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appactconfigres(::pp::AppActConfigRes* appactconfigres) {
  delete appactconfigres_;
  appactconfigres_ = appactconfigres;
  if (appactconfigres) {
    set_has_appactconfigres();
  } else {
    clear_has_appactconfigres();
  }
}

// optional .pp.AppProtoVersionUpdateReq appProtoVersionUpdateReq = 6470;
inline bool ProtoBody::has_appprotoversionupdatereq() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_appprotoversionupdatereq() {
  _has_bits_[1] |= 0x00002000u;
}
inline void ProtoBody::clear_has_appprotoversionupdatereq() {
  _has_bits_[1] &= ~0x00002000u;
}
inline void ProtoBody::clear_appprotoversionupdatereq() {
  if (appprotoversionupdatereq_ != NULL) appprotoversionupdatereq_->::pp::AppProtoVersionUpdateReq::Clear();
  clear_has_appprotoversionupdatereq();
}
inline const ::pp::AppProtoVersionUpdateReq& ProtoBody::appprotoversionupdatereq() const {
  return appprotoversionupdatereq_ != NULL ? *appprotoversionupdatereq_ : *default_instance_->appprotoversionupdatereq_;
}
inline ::pp::AppProtoVersionUpdateReq* ProtoBody::mutable_appprotoversionupdatereq() {
  set_has_appprotoversionupdatereq();
  if (appprotoversionupdatereq_ == NULL) appprotoversionupdatereq_ = new ::pp::AppProtoVersionUpdateReq;
  return appprotoversionupdatereq_;
}
inline ::pp::AppProtoVersionUpdateReq* ProtoBody::release_appprotoversionupdatereq() {
  clear_has_appprotoversionupdatereq();
  ::pp::AppProtoVersionUpdateReq* temp = appprotoversionupdatereq_;
  appprotoversionupdatereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appprotoversionupdatereq(::pp::AppProtoVersionUpdateReq* appprotoversionupdatereq) {
  delete appprotoversionupdatereq_;
  appprotoversionupdatereq_ = appprotoversionupdatereq;
  if (appprotoversionupdatereq) {
    set_has_appprotoversionupdatereq();
  } else {
    clear_has_appprotoversionupdatereq();
  }
}

// optional .pp.AppProtoVersionUpdateRes appProtoVersionUpdateRes = 6471;
inline bool ProtoBody::has_appprotoversionupdateres() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_appprotoversionupdateres() {
  _has_bits_[1] |= 0x00004000u;
}
inline void ProtoBody::clear_has_appprotoversionupdateres() {
  _has_bits_[1] &= ~0x00004000u;
}
inline void ProtoBody::clear_appprotoversionupdateres() {
  if (appprotoversionupdateres_ != NULL) appprotoversionupdateres_->::pp::AppProtoVersionUpdateRes::Clear();
  clear_has_appprotoversionupdateres();
}
inline const ::pp::AppProtoVersionUpdateRes& ProtoBody::appprotoversionupdateres() const {
  return appprotoversionupdateres_ != NULL ? *appprotoversionupdateres_ : *default_instance_->appprotoversionupdateres_;
}
inline ::pp::AppProtoVersionUpdateRes* ProtoBody::mutable_appprotoversionupdateres() {
  set_has_appprotoversionupdateres();
  if (appprotoversionupdateres_ == NULL) appprotoversionupdateres_ = new ::pp::AppProtoVersionUpdateRes;
  return appprotoversionupdateres_;
}
inline ::pp::AppProtoVersionUpdateRes* ProtoBody::release_appprotoversionupdateres() {
  clear_has_appprotoversionupdateres();
  ::pp::AppProtoVersionUpdateRes* temp = appprotoversionupdateres_;
  appprotoversionupdateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_appprotoversionupdateres(::pp::AppProtoVersionUpdateRes* appprotoversionupdateres) {
  delete appprotoversionupdateres_;
  appprotoversionupdateres_ = appprotoversionupdateres;
  if (appprotoversionupdateres) {
    set_has_appprotoversionupdateres();
  } else {
    clear_has_appprotoversionupdateres();
  }
}

// optional .pp.ContactListReq contactListReq = 12801;
inline bool ProtoBody::has_contactlistreq() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_contactlistreq() {
  _has_bits_[1] |= 0x00008000u;
}
inline void ProtoBody::clear_has_contactlistreq() {
  _has_bits_[1] &= ~0x00008000u;
}
inline void ProtoBody::clear_contactlistreq() {
  if (contactlistreq_ != NULL) contactlistreq_->::pp::ContactListReq::Clear();
  clear_has_contactlistreq();
}
inline const ::pp::ContactListReq& ProtoBody::contactlistreq() const {
  return contactlistreq_ != NULL ? *contactlistreq_ : *default_instance_->contactlistreq_;
}
inline ::pp::ContactListReq* ProtoBody::mutable_contactlistreq() {
  set_has_contactlistreq();
  if (contactlistreq_ == NULL) contactlistreq_ = new ::pp::ContactListReq;
  return contactlistreq_;
}
inline ::pp::ContactListReq* ProtoBody::release_contactlistreq() {
  clear_has_contactlistreq();
  ::pp::ContactListReq* temp = contactlistreq_;
  contactlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactlistreq(::pp::ContactListReq* contactlistreq) {
  delete contactlistreq_;
  contactlistreq_ = contactlistreq;
  if (contactlistreq) {
    set_has_contactlistreq();
  } else {
    clear_has_contactlistreq();
  }
}

// optional .pp.ContactListRes contactListRes = 12802;
inline bool ProtoBody::has_contactlistres() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_contactlistres() {
  _has_bits_[1] |= 0x00010000u;
}
inline void ProtoBody::clear_has_contactlistres() {
  _has_bits_[1] &= ~0x00010000u;
}
inline void ProtoBody::clear_contactlistres() {
  if (contactlistres_ != NULL) contactlistres_->::pp::ContactListRes::Clear();
  clear_has_contactlistres();
}
inline const ::pp::ContactListRes& ProtoBody::contactlistres() const {
  return contactlistres_ != NULL ? *contactlistres_ : *default_instance_->contactlistres_;
}
inline ::pp::ContactListRes* ProtoBody::mutable_contactlistres() {
  set_has_contactlistres();
  if (contactlistres_ == NULL) contactlistres_ = new ::pp::ContactListRes;
  return contactlistres_;
}
inline ::pp::ContactListRes* ProtoBody::release_contactlistres() {
  clear_has_contactlistres();
  ::pp::ContactListRes* temp = contactlistres_;
  contactlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactlistres(::pp::ContactListRes* contactlistres) {
  delete contactlistres_;
  contactlistres_ = contactlistres;
  if (contactlistres) {
    set_has_contactlistres();
  } else {
    clear_has_contactlistres();
  }
}

// optional .pp.ContactAddReq contactAddReq = 12807;
inline bool ProtoBody::has_contactaddreq() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_contactaddreq() {
  _has_bits_[1] |= 0x00020000u;
}
inline void ProtoBody::clear_has_contactaddreq() {
  _has_bits_[1] &= ~0x00020000u;
}
inline void ProtoBody::clear_contactaddreq() {
  if (contactaddreq_ != NULL) contactaddreq_->::pp::ContactAddReq::Clear();
  clear_has_contactaddreq();
}
inline const ::pp::ContactAddReq& ProtoBody::contactaddreq() const {
  return contactaddreq_ != NULL ? *contactaddreq_ : *default_instance_->contactaddreq_;
}
inline ::pp::ContactAddReq* ProtoBody::mutable_contactaddreq() {
  set_has_contactaddreq();
  if (contactaddreq_ == NULL) contactaddreq_ = new ::pp::ContactAddReq;
  return contactaddreq_;
}
inline ::pp::ContactAddReq* ProtoBody::release_contactaddreq() {
  clear_has_contactaddreq();
  ::pp::ContactAddReq* temp = contactaddreq_;
  contactaddreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactaddreq(::pp::ContactAddReq* contactaddreq) {
  delete contactaddreq_;
  contactaddreq_ = contactaddreq;
  if (contactaddreq) {
    set_has_contactaddreq();
  } else {
    clear_has_contactaddreq();
  }
}

// optional .pp.ContactAddRes contactAddRes = 12808;
inline bool ProtoBody::has_contactaddres() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_contactaddres() {
  _has_bits_[1] |= 0x00040000u;
}
inline void ProtoBody::clear_has_contactaddres() {
  _has_bits_[1] &= ~0x00040000u;
}
inline void ProtoBody::clear_contactaddres() {
  if (contactaddres_ != NULL) contactaddres_->::pp::ContactAddRes::Clear();
  clear_has_contactaddres();
}
inline const ::pp::ContactAddRes& ProtoBody::contactaddres() const {
  return contactaddres_ != NULL ? *contactaddres_ : *default_instance_->contactaddres_;
}
inline ::pp::ContactAddRes* ProtoBody::mutable_contactaddres() {
  set_has_contactaddres();
  if (contactaddres_ == NULL) contactaddres_ = new ::pp::ContactAddRes;
  return contactaddres_;
}
inline ::pp::ContactAddRes* ProtoBody::release_contactaddres() {
  clear_has_contactaddres();
  ::pp::ContactAddRes* temp = contactaddres_;
  contactaddres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactaddres(::pp::ContactAddRes* contactaddres) {
  delete contactaddres_;
  contactaddres_ = contactaddres;
  if (contactaddres) {
    set_has_contactaddres();
  } else {
    clear_has_contactaddres();
  }
}

// optional .pp.ContactApproveReq contactApproveReq = 12809;
inline bool ProtoBody::has_contactapprovereq() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_contactapprovereq() {
  _has_bits_[1] |= 0x00080000u;
}
inline void ProtoBody::clear_has_contactapprovereq() {
  _has_bits_[1] &= ~0x00080000u;
}
inline void ProtoBody::clear_contactapprovereq() {
  if (contactapprovereq_ != NULL) contactapprovereq_->::pp::ContactApproveReq::Clear();
  clear_has_contactapprovereq();
}
inline const ::pp::ContactApproveReq& ProtoBody::contactapprovereq() const {
  return contactapprovereq_ != NULL ? *contactapprovereq_ : *default_instance_->contactapprovereq_;
}
inline ::pp::ContactApproveReq* ProtoBody::mutable_contactapprovereq() {
  set_has_contactapprovereq();
  if (contactapprovereq_ == NULL) contactapprovereq_ = new ::pp::ContactApproveReq;
  return contactapprovereq_;
}
inline ::pp::ContactApproveReq* ProtoBody::release_contactapprovereq() {
  clear_has_contactapprovereq();
  ::pp::ContactApproveReq* temp = contactapprovereq_;
  contactapprovereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactapprovereq(::pp::ContactApproveReq* contactapprovereq) {
  delete contactapprovereq_;
  contactapprovereq_ = contactapprovereq;
  if (contactapprovereq) {
    set_has_contactapprovereq();
  } else {
    clear_has_contactapprovereq();
  }
}

// optional .pp.ContactApproveRes contactApproveRes = 12810;
inline bool ProtoBody::has_contactapproveres() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_contactapproveres() {
  _has_bits_[1] |= 0x00100000u;
}
inline void ProtoBody::clear_has_contactapproveres() {
  _has_bits_[1] &= ~0x00100000u;
}
inline void ProtoBody::clear_contactapproveres() {
  if (contactapproveres_ != NULL) contactapproveres_->::pp::ContactApproveRes::Clear();
  clear_has_contactapproveres();
}
inline const ::pp::ContactApproveRes& ProtoBody::contactapproveres() const {
  return contactapproveres_ != NULL ? *contactapproveres_ : *default_instance_->contactapproveres_;
}
inline ::pp::ContactApproveRes* ProtoBody::mutable_contactapproveres() {
  set_has_contactapproveres();
  if (contactapproveres_ == NULL) contactapproveres_ = new ::pp::ContactApproveRes;
  return contactapproveres_;
}
inline ::pp::ContactApproveRes* ProtoBody::release_contactapproveres() {
  clear_has_contactapproveres();
  ::pp::ContactApproveRes* temp = contactapproveres_;
  contactapproveres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactapproveres(::pp::ContactApproveRes* contactapproveres) {
  delete contactapproveres_;
  contactapproveres_ = contactapproveres;
  if (contactapproveres) {
    set_has_contactapproveres();
  } else {
    clear_has_contactapproveres();
  }
}

// optional .pp.ContactModifyReq contactModifyReq = 12811;
inline bool ProtoBody::has_contactmodifyreq() const {
  return (_has_bits_[1] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_contactmodifyreq() {
  _has_bits_[1] |= 0x00200000u;
}
inline void ProtoBody::clear_has_contactmodifyreq() {
  _has_bits_[1] &= ~0x00200000u;
}
inline void ProtoBody::clear_contactmodifyreq() {
  if (contactmodifyreq_ != NULL) contactmodifyreq_->::pp::ContactModifyReq::Clear();
  clear_has_contactmodifyreq();
}
inline const ::pp::ContactModifyReq& ProtoBody::contactmodifyreq() const {
  return contactmodifyreq_ != NULL ? *contactmodifyreq_ : *default_instance_->contactmodifyreq_;
}
inline ::pp::ContactModifyReq* ProtoBody::mutable_contactmodifyreq() {
  set_has_contactmodifyreq();
  if (contactmodifyreq_ == NULL) contactmodifyreq_ = new ::pp::ContactModifyReq;
  return contactmodifyreq_;
}
inline ::pp::ContactModifyReq* ProtoBody::release_contactmodifyreq() {
  clear_has_contactmodifyreq();
  ::pp::ContactModifyReq* temp = contactmodifyreq_;
  contactmodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactmodifyreq(::pp::ContactModifyReq* contactmodifyreq) {
  delete contactmodifyreq_;
  contactmodifyreq_ = contactmodifyreq;
  if (contactmodifyreq) {
    set_has_contactmodifyreq();
  } else {
    clear_has_contactmodifyreq();
  }
}

// optional .pp.ContactModifyRes contactModifyRes = 12812;
inline bool ProtoBody::has_contactmodifyres() const {
  return (_has_bits_[1] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_contactmodifyres() {
  _has_bits_[1] |= 0x00400000u;
}
inline void ProtoBody::clear_has_contactmodifyres() {
  _has_bits_[1] &= ~0x00400000u;
}
inline void ProtoBody::clear_contactmodifyres() {
  if (contactmodifyres_ != NULL) contactmodifyres_->::pp::ContactModifyRes::Clear();
  clear_has_contactmodifyres();
}
inline const ::pp::ContactModifyRes& ProtoBody::contactmodifyres() const {
  return contactmodifyres_ != NULL ? *contactmodifyres_ : *default_instance_->contactmodifyres_;
}
inline ::pp::ContactModifyRes* ProtoBody::mutable_contactmodifyres() {
  set_has_contactmodifyres();
  if (contactmodifyres_ == NULL) contactmodifyres_ = new ::pp::ContactModifyRes;
  return contactmodifyres_;
}
inline ::pp::ContactModifyRes* ProtoBody::release_contactmodifyres() {
  clear_has_contactmodifyres();
  ::pp::ContactModifyRes* temp = contactmodifyres_;
  contactmodifyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_contactmodifyres(::pp::ContactModifyRes* contactmodifyres) {
  delete contactmodifyres_;
  contactmodifyres_ = contactmodifyres;
  if (contactmodifyres) {
    set_has_contactmodifyres();
  } else {
    clear_has_contactmodifyres();
  }
}

// optional .pp.KeyExchangeReq keyExchangeReq = 65280;
inline bool ProtoBody::has_keyexchangereq() const {
  return (_has_bits_[1] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_keyexchangereq() {
  _has_bits_[1] |= 0x00800000u;
}
inline void ProtoBody::clear_has_keyexchangereq() {
  _has_bits_[1] &= ~0x00800000u;
}
inline void ProtoBody::clear_keyexchangereq() {
  if (keyexchangereq_ != NULL) keyexchangereq_->::pp::KeyExchangeReq::Clear();
  clear_has_keyexchangereq();
}
inline const ::pp::KeyExchangeReq& ProtoBody::keyexchangereq() const {
  return keyexchangereq_ != NULL ? *keyexchangereq_ : *default_instance_->keyexchangereq_;
}
inline ::pp::KeyExchangeReq* ProtoBody::mutable_keyexchangereq() {
  set_has_keyexchangereq();
  if (keyexchangereq_ == NULL) keyexchangereq_ = new ::pp::KeyExchangeReq;
  return keyexchangereq_;
}
inline ::pp::KeyExchangeReq* ProtoBody::release_keyexchangereq() {
  clear_has_keyexchangereq();
  ::pp::KeyExchangeReq* temp = keyexchangereq_;
  keyexchangereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_keyexchangereq(::pp::KeyExchangeReq* keyexchangereq) {
  delete keyexchangereq_;
  keyexchangereq_ = keyexchangereq;
  if (keyexchangereq) {
    set_has_keyexchangereq();
  } else {
    clear_has_keyexchangereq();
  }
}

// optional .pp.KeyExchangeRes keyExchangeRes = 65281;
inline bool ProtoBody::has_keyexchangeres() const {
  return (_has_bits_[1] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_keyexchangeres() {
  _has_bits_[1] |= 0x01000000u;
}
inline void ProtoBody::clear_has_keyexchangeres() {
  _has_bits_[1] &= ~0x01000000u;
}
inline void ProtoBody::clear_keyexchangeres() {
  if (keyexchangeres_ != NULL) keyexchangeres_->::pp::KeyExchangeRes::Clear();
  clear_has_keyexchangeres();
}
inline const ::pp::KeyExchangeRes& ProtoBody::keyexchangeres() const {
  return keyexchangeres_ != NULL ? *keyexchangeres_ : *default_instance_->keyexchangeres_;
}
inline ::pp::KeyExchangeRes* ProtoBody::mutable_keyexchangeres() {
  set_has_keyexchangeres();
  if (keyexchangeres_ == NULL) keyexchangeres_ = new ::pp::KeyExchangeRes;
  return keyexchangeres_;
}
inline ::pp::KeyExchangeRes* ProtoBody::release_keyexchangeres() {
  clear_has_keyexchangeres();
  ::pp::KeyExchangeRes* temp = keyexchangeres_;
  keyexchangeres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_keyexchangeres(::pp::KeyExchangeRes* keyexchangeres) {
  delete keyexchangeres_;
  keyexchangeres_ = keyexchangeres;
  if (keyexchangeres) {
    set_has_keyexchangeres();
  } else {
    clear_has_keyexchangeres();
  }
}

// optional .pp.UserGameListReq userGameListReq = 12545;
inline bool ProtoBody::has_usergamelistreq() const {
  return (_has_bits_[1] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_usergamelistreq() {
  _has_bits_[1] |= 0x02000000u;
}
inline void ProtoBody::clear_has_usergamelistreq() {
  _has_bits_[1] &= ~0x02000000u;
}
inline void ProtoBody::clear_usergamelistreq() {
  if (usergamelistreq_ != NULL) usergamelistreq_->::pp::UserGameListReq::Clear();
  clear_has_usergamelistreq();
}
inline const ::pp::UserGameListReq& ProtoBody::usergamelistreq() const {
  return usergamelistreq_ != NULL ? *usergamelistreq_ : *default_instance_->usergamelistreq_;
}
inline ::pp::UserGameListReq* ProtoBody::mutable_usergamelistreq() {
  set_has_usergamelistreq();
  if (usergamelistreq_ == NULL) usergamelistreq_ = new ::pp::UserGameListReq;
  return usergamelistreq_;
}
inline ::pp::UserGameListReq* ProtoBody::release_usergamelistreq() {
  clear_has_usergamelistreq();
  ::pp::UserGameListReq* temp = usergamelistreq_;
  usergamelistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usergamelistreq(::pp::UserGameListReq* usergamelistreq) {
  delete usergamelistreq_;
  usergamelistreq_ = usergamelistreq;
  if (usergamelistreq) {
    set_has_usergamelistreq();
  } else {
    clear_has_usergamelistreq();
  }
}

// optional .pp.UserGameListRes userGameListRes = 12546;
inline bool ProtoBody::has_usergamelistres() const {
  return (_has_bits_[1] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_usergamelistres() {
  _has_bits_[1] |= 0x04000000u;
}
inline void ProtoBody::clear_has_usergamelistres() {
  _has_bits_[1] &= ~0x04000000u;
}
inline void ProtoBody::clear_usergamelistres() {
  if (usergamelistres_ != NULL) usergamelistres_->::pp::UserGameListRes::Clear();
  clear_has_usergamelistres();
}
inline const ::pp::UserGameListRes& ProtoBody::usergamelistres() const {
  return usergamelistres_ != NULL ? *usergamelistres_ : *default_instance_->usergamelistres_;
}
inline ::pp::UserGameListRes* ProtoBody::mutable_usergamelistres() {
  set_has_usergamelistres();
  if (usergamelistres_ == NULL) usergamelistres_ = new ::pp::UserGameListRes;
  return usergamelistres_;
}
inline ::pp::UserGameListRes* ProtoBody::release_usergamelistres() {
  clear_has_usergamelistres();
  ::pp::UserGameListRes* temp = usergamelistres_;
  usergamelistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usergamelistres(::pp::UserGameListRes* usergamelistres) {
  delete usergamelistres_;
  usergamelistres_ = usergamelistres;
  if (usergamelistres) {
    set_has_usergamelistres();
  } else {
    clear_has_usergamelistres();
  }
}

// optional .pp.UserGameListReportReq userGameListReportReq = 12547;
inline bool ProtoBody::has_usergamelistreportreq() const {
  return (_has_bits_[1] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_usergamelistreportreq() {
  _has_bits_[1] |= 0x08000000u;
}
inline void ProtoBody::clear_has_usergamelistreportreq() {
  _has_bits_[1] &= ~0x08000000u;
}
inline void ProtoBody::clear_usergamelistreportreq() {
  if (usergamelistreportreq_ != NULL) usergamelistreportreq_->::pp::UserGameListReportReq::Clear();
  clear_has_usergamelistreportreq();
}
inline const ::pp::UserGameListReportReq& ProtoBody::usergamelistreportreq() const {
  return usergamelistreportreq_ != NULL ? *usergamelistreportreq_ : *default_instance_->usergamelistreportreq_;
}
inline ::pp::UserGameListReportReq* ProtoBody::mutable_usergamelistreportreq() {
  set_has_usergamelistreportreq();
  if (usergamelistreportreq_ == NULL) usergamelistreportreq_ = new ::pp::UserGameListReportReq;
  return usergamelistreportreq_;
}
inline ::pp::UserGameListReportReq* ProtoBody::release_usergamelistreportreq() {
  clear_has_usergamelistreportreq();
  ::pp::UserGameListReportReq* temp = usergamelistreportreq_;
  usergamelistreportreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usergamelistreportreq(::pp::UserGameListReportReq* usergamelistreportreq) {
  delete usergamelistreportreq_;
  usergamelistreportreq_ = usergamelistreportreq;
  if (usergamelistreportreq) {
    set_has_usergamelistreportreq();
  } else {
    clear_has_usergamelistreportreq();
  }
}

// optional .pp.UserGameListReportRes userGameListReportRes = 12548;
inline bool ProtoBody::has_usergamelistreportres() const {
  return (_has_bits_[1] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_usergamelistreportres() {
  _has_bits_[1] |= 0x10000000u;
}
inline void ProtoBody::clear_has_usergamelistreportres() {
  _has_bits_[1] &= ~0x10000000u;
}
inline void ProtoBody::clear_usergamelistreportres() {
  if (usergamelistreportres_ != NULL) usergamelistreportres_->::pp::UserGameListReportRes::Clear();
  clear_has_usergamelistreportres();
}
inline const ::pp::UserGameListReportRes& ProtoBody::usergamelistreportres() const {
  return usergamelistreportres_ != NULL ? *usergamelistreportres_ : *default_instance_->usergamelistreportres_;
}
inline ::pp::UserGameListReportRes* ProtoBody::mutable_usergamelistreportres() {
  set_has_usergamelistreportres();
  if (usergamelistreportres_ == NULL) usergamelistreportres_ = new ::pp::UserGameListReportRes;
  return usergamelistreportres_;
}
inline ::pp::UserGameListReportRes* ProtoBody::release_usergamelistreportres() {
  clear_has_usergamelistreportres();
  ::pp::UserGameListReportRes* temp = usergamelistreportres_;
  usergamelistreportres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usergamelistreportres(::pp::UserGameListReportRes* usergamelistreportres) {
  delete usergamelistreportres_;
  usergamelistreportres_ = usergamelistreportres;
  if (usergamelistreportres) {
    set_has_usergamelistreportres();
  } else {
    clear_has_usergamelistreportres();
  }
}

// optional .pp.UserGameRunReportReq userGameRunReportReq = 12549;
inline bool ProtoBody::has_usergamerunreportreq() const {
  return (_has_bits_[1] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_usergamerunreportreq() {
  _has_bits_[1] |= 0x20000000u;
}
inline void ProtoBody::clear_has_usergamerunreportreq() {
  _has_bits_[1] &= ~0x20000000u;
}
inline void ProtoBody::clear_usergamerunreportreq() {
  if (usergamerunreportreq_ != NULL) usergamerunreportreq_->::pp::UserGameRunReportReq::Clear();
  clear_has_usergamerunreportreq();
}
inline const ::pp::UserGameRunReportReq& ProtoBody::usergamerunreportreq() const {
  return usergamerunreportreq_ != NULL ? *usergamerunreportreq_ : *default_instance_->usergamerunreportreq_;
}
inline ::pp::UserGameRunReportReq* ProtoBody::mutable_usergamerunreportreq() {
  set_has_usergamerunreportreq();
  if (usergamerunreportreq_ == NULL) usergamerunreportreq_ = new ::pp::UserGameRunReportReq;
  return usergamerunreportreq_;
}
inline ::pp::UserGameRunReportReq* ProtoBody::release_usergamerunreportreq() {
  clear_has_usergamerunreportreq();
  ::pp::UserGameRunReportReq* temp = usergamerunreportreq_;
  usergamerunreportreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usergamerunreportreq(::pp::UserGameRunReportReq* usergamerunreportreq) {
  delete usergamerunreportreq_;
  usergamerunreportreq_ = usergamerunreportreq;
  if (usergamerunreportreq) {
    set_has_usergamerunreportreq();
  } else {
    clear_has_usergamerunreportreq();
  }
}

// optional .pp.UserGameRunReportRes userGameRunReportRes = 12550;
inline bool ProtoBody::has_usergamerunreportres() const {
  return (_has_bits_[1] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_usergamerunreportres() {
  _has_bits_[1] |= 0x40000000u;
}
inline void ProtoBody::clear_has_usergamerunreportres() {
  _has_bits_[1] &= ~0x40000000u;
}
inline void ProtoBody::clear_usergamerunreportres() {
  if (usergamerunreportres_ != NULL) usergamerunreportres_->::pp::UserGameRunReportRes::Clear();
  clear_has_usergamerunreportres();
}
inline const ::pp::UserGameRunReportRes& ProtoBody::usergamerunreportres() const {
  return usergamerunreportres_ != NULL ? *usergamerunreportres_ : *default_instance_->usergamerunreportres_;
}
inline ::pp::UserGameRunReportRes* ProtoBody::mutable_usergamerunreportres() {
  set_has_usergamerunreportres();
  if (usergamerunreportres_ == NULL) usergamerunreportres_ = new ::pp::UserGameRunReportRes;
  return usergamerunreportres_;
}
inline ::pp::UserGameRunReportRes* ProtoBody::release_usergamerunreportres() {
  clear_has_usergamerunreportres();
  ::pp::UserGameRunReportRes* temp = usergamerunreportres_;
  usergamerunreportres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usergamerunreportres(::pp::UserGameRunReportRes* usergamerunreportres) {
  delete usergamerunreportres_;
  usergamerunreportres_ = usergamerunreportres;
  if (usergamerunreportres) {
    set_has_usergamerunreportres();
  } else {
    clear_has_usergamerunreportres();
  }
}

// optional .pp.GameAddReq gameAddReq = 12557;
inline bool ProtoBody::has_gameaddreq() const {
  return (_has_bits_[1] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_gameaddreq() {
  _has_bits_[1] |= 0x80000000u;
}
inline void ProtoBody::clear_has_gameaddreq() {
  _has_bits_[1] &= ~0x80000000u;
}
inline void ProtoBody::clear_gameaddreq() {
  if (gameaddreq_ != NULL) gameaddreq_->::pp::GameAddReq::Clear();
  clear_has_gameaddreq();
}
inline const ::pp::GameAddReq& ProtoBody::gameaddreq() const {
  return gameaddreq_ != NULL ? *gameaddreq_ : *default_instance_->gameaddreq_;
}
inline ::pp::GameAddReq* ProtoBody::mutable_gameaddreq() {
  set_has_gameaddreq();
  if (gameaddreq_ == NULL) gameaddreq_ = new ::pp::GameAddReq;
  return gameaddreq_;
}
inline ::pp::GameAddReq* ProtoBody::release_gameaddreq() {
  clear_has_gameaddreq();
  ::pp::GameAddReq* temp = gameaddreq_;
  gameaddreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gameaddreq(::pp::GameAddReq* gameaddreq) {
  delete gameaddreq_;
  gameaddreq_ = gameaddreq;
  if (gameaddreq) {
    set_has_gameaddreq();
  } else {
    clear_has_gameaddreq();
  }
}

// optional .pp.GameAddRes gameAddRes = 12558;
inline bool ProtoBody::has_gameaddres() const {
  return (_has_bits_[2] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_gameaddres() {
  _has_bits_[2] |= 0x00000001u;
}
inline void ProtoBody::clear_has_gameaddres() {
  _has_bits_[2] &= ~0x00000001u;
}
inline void ProtoBody::clear_gameaddres() {
  if (gameaddres_ != NULL) gameaddres_->::pp::GameAddRes::Clear();
  clear_has_gameaddres();
}
inline const ::pp::GameAddRes& ProtoBody::gameaddres() const {
  return gameaddres_ != NULL ? *gameaddres_ : *default_instance_->gameaddres_;
}
inline ::pp::GameAddRes* ProtoBody::mutable_gameaddres() {
  set_has_gameaddres();
  if (gameaddres_ == NULL) gameaddres_ = new ::pp::GameAddRes;
  return gameaddres_;
}
inline ::pp::GameAddRes* ProtoBody::release_gameaddres() {
  clear_has_gameaddres();
  ::pp::GameAddRes* temp = gameaddres_;
  gameaddres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gameaddres(::pp::GameAddRes* gameaddres) {
  delete gameaddres_;
  gameaddres_ = gameaddres;
  if (gameaddres) {
    set_has_gameaddres();
  } else {
    clear_has_gameaddres();
  }
}

// optional .pp.GameModifyReq gameModifyReq = 12559;
inline bool ProtoBody::has_gamemodifyreq() const {
  return (_has_bits_[2] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_gamemodifyreq() {
  _has_bits_[2] |= 0x00000002u;
}
inline void ProtoBody::clear_has_gamemodifyreq() {
  _has_bits_[2] &= ~0x00000002u;
}
inline void ProtoBody::clear_gamemodifyreq() {
  if (gamemodifyreq_ != NULL) gamemodifyreq_->::pp::GameModifyReq::Clear();
  clear_has_gamemodifyreq();
}
inline const ::pp::GameModifyReq& ProtoBody::gamemodifyreq() const {
  return gamemodifyreq_ != NULL ? *gamemodifyreq_ : *default_instance_->gamemodifyreq_;
}
inline ::pp::GameModifyReq* ProtoBody::mutable_gamemodifyreq() {
  set_has_gamemodifyreq();
  if (gamemodifyreq_ == NULL) gamemodifyreq_ = new ::pp::GameModifyReq;
  return gamemodifyreq_;
}
inline ::pp::GameModifyReq* ProtoBody::release_gamemodifyreq() {
  clear_has_gamemodifyreq();
  ::pp::GameModifyReq* temp = gamemodifyreq_;
  gamemodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamemodifyreq(::pp::GameModifyReq* gamemodifyreq) {
  delete gamemodifyreq_;
  gamemodifyreq_ = gamemodifyreq;
  if (gamemodifyreq) {
    set_has_gamemodifyreq();
  } else {
    clear_has_gamemodifyreq();
  }
}

// optional .pp.GameModifyRes gameModifyRes = 12560;
inline bool ProtoBody::has_gamemodifyres() const {
  return (_has_bits_[2] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_gamemodifyres() {
  _has_bits_[2] |= 0x00000004u;
}
inline void ProtoBody::clear_has_gamemodifyres() {
  _has_bits_[2] &= ~0x00000004u;
}
inline void ProtoBody::clear_gamemodifyres() {
  if (gamemodifyres_ != NULL) gamemodifyres_->::pp::GameModifyRes::Clear();
  clear_has_gamemodifyres();
}
inline const ::pp::GameModifyRes& ProtoBody::gamemodifyres() const {
  return gamemodifyres_ != NULL ? *gamemodifyres_ : *default_instance_->gamemodifyres_;
}
inline ::pp::GameModifyRes* ProtoBody::mutable_gamemodifyres() {
  set_has_gamemodifyres();
  if (gamemodifyres_ == NULL) gamemodifyres_ = new ::pp::GameModifyRes;
  return gamemodifyres_;
}
inline ::pp::GameModifyRes* ProtoBody::release_gamemodifyres() {
  clear_has_gamemodifyres();
  ::pp::GameModifyRes* temp = gamemodifyres_;
  gamemodifyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamemodifyres(::pp::GameModifyRes* gamemodifyres) {
  delete gamemodifyres_;
  gamemodifyres_ = gamemodifyres;
  if (gamemodifyres) {
    set_has_gamemodifyres();
  } else {
    clear_has_gamemodifyres();
  }
}

// optional .pp.GameSearchReq gameSearchReq = 12569;
inline bool ProtoBody::has_gamesearchreq() const {
  return (_has_bits_[2] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_gamesearchreq() {
  _has_bits_[2] |= 0x00000008u;
}
inline void ProtoBody::clear_has_gamesearchreq() {
  _has_bits_[2] &= ~0x00000008u;
}
inline void ProtoBody::clear_gamesearchreq() {
  if (gamesearchreq_ != NULL) gamesearchreq_->::pp::GameSearchReq::Clear();
  clear_has_gamesearchreq();
}
inline const ::pp::GameSearchReq& ProtoBody::gamesearchreq() const {
  return gamesearchreq_ != NULL ? *gamesearchreq_ : *default_instance_->gamesearchreq_;
}
inline ::pp::GameSearchReq* ProtoBody::mutable_gamesearchreq() {
  set_has_gamesearchreq();
  if (gamesearchreq_ == NULL) gamesearchreq_ = new ::pp::GameSearchReq;
  return gamesearchreq_;
}
inline ::pp::GameSearchReq* ProtoBody::release_gamesearchreq() {
  clear_has_gamesearchreq();
  ::pp::GameSearchReq* temp = gamesearchreq_;
  gamesearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamesearchreq(::pp::GameSearchReq* gamesearchreq) {
  delete gamesearchreq_;
  gamesearchreq_ = gamesearchreq;
  if (gamesearchreq) {
    set_has_gamesearchreq();
  } else {
    clear_has_gamesearchreq();
  }
}

// optional .pp.GameSearchRes gameSearchRes = 12570;
inline bool ProtoBody::has_gamesearchres() const {
  return (_has_bits_[2] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_gamesearchres() {
  _has_bits_[2] |= 0x00000010u;
}
inline void ProtoBody::clear_has_gamesearchres() {
  _has_bits_[2] &= ~0x00000010u;
}
inline void ProtoBody::clear_gamesearchres() {
  if (gamesearchres_ != NULL) gamesearchres_->::pp::GameSearchRes::Clear();
  clear_has_gamesearchres();
}
inline const ::pp::GameSearchRes& ProtoBody::gamesearchres() const {
  return gamesearchres_ != NULL ? *gamesearchres_ : *default_instance_->gamesearchres_;
}
inline ::pp::GameSearchRes* ProtoBody::mutable_gamesearchres() {
  set_has_gamesearchres();
  if (gamesearchres_ == NULL) gamesearchres_ = new ::pp::GameSearchRes;
  return gamesearchres_;
}
inline ::pp::GameSearchRes* ProtoBody::release_gamesearchres() {
  clear_has_gamesearchres();
  ::pp::GameSearchRes* temp = gamesearchres_;
  gamesearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamesearchres(::pp::GameSearchRes* gamesearchres) {
  delete gamesearchres_;
  gamesearchres_ = gamesearchres;
  if (gamesearchres) {
    set_has_gamesearchres();
  } else {
    clear_has_gamesearchres();
  }
}

// optional .pp.ModifyGroupGameReq modifyGroupGameReq = 12571;
inline bool ProtoBody::has_modifygroupgamereq() const {
  return (_has_bits_[2] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_modifygroupgamereq() {
  _has_bits_[2] |= 0x00000020u;
}
inline void ProtoBody::clear_has_modifygroupgamereq() {
  _has_bits_[2] &= ~0x00000020u;
}
inline void ProtoBody::clear_modifygroupgamereq() {
  if (modifygroupgamereq_ != NULL) modifygroupgamereq_->::pp::ModifyGroupGameReq::Clear();
  clear_has_modifygroupgamereq();
}
inline const ::pp::ModifyGroupGameReq& ProtoBody::modifygroupgamereq() const {
  return modifygroupgamereq_ != NULL ? *modifygroupgamereq_ : *default_instance_->modifygroupgamereq_;
}
inline ::pp::ModifyGroupGameReq* ProtoBody::mutable_modifygroupgamereq() {
  set_has_modifygroupgamereq();
  if (modifygroupgamereq_ == NULL) modifygroupgamereq_ = new ::pp::ModifyGroupGameReq;
  return modifygroupgamereq_;
}
inline ::pp::ModifyGroupGameReq* ProtoBody::release_modifygroupgamereq() {
  clear_has_modifygroupgamereq();
  ::pp::ModifyGroupGameReq* temp = modifygroupgamereq_;
  modifygroupgamereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygroupgamereq(::pp::ModifyGroupGameReq* modifygroupgamereq) {
  delete modifygroupgamereq_;
  modifygroupgamereq_ = modifygroupgamereq;
  if (modifygroupgamereq) {
    set_has_modifygroupgamereq();
  } else {
    clear_has_modifygroupgamereq();
  }
}

// optional .pp.ModifyGroupGameRes modifyGroupGameRes = 12572;
inline bool ProtoBody::has_modifygroupgameres() const {
  return (_has_bits_[2] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_modifygroupgameres() {
  _has_bits_[2] |= 0x00000040u;
}
inline void ProtoBody::clear_has_modifygroupgameres() {
  _has_bits_[2] &= ~0x00000040u;
}
inline void ProtoBody::clear_modifygroupgameres() {
  if (modifygroupgameres_ != NULL) modifygroupgameres_->::pp::ModifyGroupGameRes::Clear();
  clear_has_modifygroupgameres();
}
inline const ::pp::ModifyGroupGameRes& ProtoBody::modifygroupgameres() const {
  return modifygroupgameres_ != NULL ? *modifygroupgameres_ : *default_instance_->modifygroupgameres_;
}
inline ::pp::ModifyGroupGameRes* ProtoBody::mutable_modifygroupgameres() {
  set_has_modifygroupgameres();
  if (modifygroupgameres_ == NULL) modifygroupgameres_ = new ::pp::ModifyGroupGameRes;
  return modifygroupgameres_;
}
inline ::pp::ModifyGroupGameRes* ProtoBody::release_modifygroupgameres() {
  clear_has_modifygroupgameres();
  ::pp::ModifyGroupGameRes* temp = modifygroupgameres_;
  modifygroupgameres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygroupgameres(::pp::ModifyGroupGameRes* modifygroupgameres) {
  delete modifygroupgameres_;
  modifygroupgameres_ = modifygroupgameres;
  if (modifygroupgameres) {
    set_has_modifygroupgameres();
  } else {
    clear_has_modifygroupgameres();
  }
}

// optional .pp.GameDiscountListReq gameDiscountListReq = 12576;
inline bool ProtoBody::has_gamediscountlistreq() const {
  return (_has_bits_[2] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_gamediscountlistreq() {
  _has_bits_[2] |= 0x00000080u;
}
inline void ProtoBody::clear_has_gamediscountlistreq() {
  _has_bits_[2] &= ~0x00000080u;
}
inline void ProtoBody::clear_gamediscountlistreq() {
  if (gamediscountlistreq_ != NULL) gamediscountlistreq_->::pp::GameDiscountListReq::Clear();
  clear_has_gamediscountlistreq();
}
inline const ::pp::GameDiscountListReq& ProtoBody::gamediscountlistreq() const {
  return gamediscountlistreq_ != NULL ? *gamediscountlistreq_ : *default_instance_->gamediscountlistreq_;
}
inline ::pp::GameDiscountListReq* ProtoBody::mutable_gamediscountlistreq() {
  set_has_gamediscountlistreq();
  if (gamediscountlistreq_ == NULL) gamediscountlistreq_ = new ::pp::GameDiscountListReq;
  return gamediscountlistreq_;
}
inline ::pp::GameDiscountListReq* ProtoBody::release_gamediscountlistreq() {
  clear_has_gamediscountlistreq();
  ::pp::GameDiscountListReq* temp = gamediscountlistreq_;
  gamediscountlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamediscountlistreq(::pp::GameDiscountListReq* gamediscountlistreq) {
  delete gamediscountlistreq_;
  gamediscountlistreq_ = gamediscountlistreq;
  if (gamediscountlistreq) {
    set_has_gamediscountlistreq();
  } else {
    clear_has_gamediscountlistreq();
  }
}

// optional .pp.GameDiscountListRes gameDiscountListRes = 12577;
inline bool ProtoBody::has_gamediscountlistres() const {
  return (_has_bits_[2] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_gamediscountlistres() {
  _has_bits_[2] |= 0x00000100u;
}
inline void ProtoBody::clear_has_gamediscountlistres() {
  _has_bits_[2] &= ~0x00000100u;
}
inline void ProtoBody::clear_gamediscountlistres() {
  if (gamediscountlistres_ != NULL) gamediscountlistres_->::pp::GameDiscountListRes::Clear();
  clear_has_gamediscountlistres();
}
inline const ::pp::GameDiscountListRes& ProtoBody::gamediscountlistres() const {
  return gamediscountlistres_ != NULL ? *gamediscountlistres_ : *default_instance_->gamediscountlistres_;
}
inline ::pp::GameDiscountListRes* ProtoBody::mutable_gamediscountlistres() {
  set_has_gamediscountlistres();
  if (gamediscountlistres_ == NULL) gamediscountlistres_ = new ::pp::GameDiscountListRes;
  return gamediscountlistres_;
}
inline ::pp::GameDiscountListRes* ProtoBody::release_gamediscountlistres() {
  clear_has_gamediscountlistres();
  ::pp::GameDiscountListRes* temp = gamediscountlistres_;
  gamediscountlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamediscountlistres(::pp::GameDiscountListRes* gamediscountlistres) {
  delete gamediscountlistres_;
  gamediscountlistres_ = gamediscountlistres;
  if (gamediscountlistres) {
    set_has_gamediscountlistres();
  } else {
    clear_has_gamediscountlistres();
  }
}

// optional .pp.ModifyGroupGameApkurlReq modifyGroupGameApkurlReq = 12578;
inline bool ProtoBody::has_modifygroupgameapkurlreq() const {
  return (_has_bits_[2] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_modifygroupgameapkurlreq() {
  _has_bits_[2] |= 0x00000200u;
}
inline void ProtoBody::clear_has_modifygroupgameapkurlreq() {
  _has_bits_[2] &= ~0x00000200u;
}
inline void ProtoBody::clear_modifygroupgameapkurlreq() {
  if (modifygroupgameapkurlreq_ != NULL) modifygroupgameapkurlreq_->::pp::ModifyGroupGameApkurlReq::Clear();
  clear_has_modifygroupgameapkurlreq();
}
inline const ::pp::ModifyGroupGameApkurlReq& ProtoBody::modifygroupgameapkurlreq() const {
  return modifygroupgameapkurlreq_ != NULL ? *modifygroupgameapkurlreq_ : *default_instance_->modifygroupgameapkurlreq_;
}
inline ::pp::ModifyGroupGameApkurlReq* ProtoBody::mutable_modifygroupgameapkurlreq() {
  set_has_modifygroupgameapkurlreq();
  if (modifygroupgameapkurlreq_ == NULL) modifygroupgameapkurlreq_ = new ::pp::ModifyGroupGameApkurlReq;
  return modifygroupgameapkurlreq_;
}
inline ::pp::ModifyGroupGameApkurlReq* ProtoBody::release_modifygroupgameapkurlreq() {
  clear_has_modifygroupgameapkurlreq();
  ::pp::ModifyGroupGameApkurlReq* temp = modifygroupgameapkurlreq_;
  modifygroupgameapkurlreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygroupgameapkurlreq(::pp::ModifyGroupGameApkurlReq* modifygroupgameapkurlreq) {
  delete modifygroupgameapkurlreq_;
  modifygroupgameapkurlreq_ = modifygroupgameapkurlreq;
  if (modifygroupgameapkurlreq) {
    set_has_modifygroupgameapkurlreq();
  } else {
    clear_has_modifygroupgameapkurlreq();
  }
}

// optional .pp.ModifyGroupGameApkurlRes modifyGroupGameApkurlRes = 12579;
inline bool ProtoBody::has_modifygroupgameapkurlres() const {
  return (_has_bits_[2] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_modifygroupgameapkurlres() {
  _has_bits_[2] |= 0x00000400u;
}
inline void ProtoBody::clear_has_modifygroupgameapkurlres() {
  _has_bits_[2] &= ~0x00000400u;
}
inline void ProtoBody::clear_modifygroupgameapkurlres() {
  if (modifygroupgameapkurlres_ != NULL) modifygroupgameapkurlres_->::pp::ModifyGroupGameApkurlRes::Clear();
  clear_has_modifygroupgameapkurlres();
}
inline const ::pp::ModifyGroupGameApkurlRes& ProtoBody::modifygroupgameapkurlres() const {
  return modifygroupgameapkurlres_ != NULL ? *modifygroupgameapkurlres_ : *default_instance_->modifygroupgameapkurlres_;
}
inline ::pp::ModifyGroupGameApkurlRes* ProtoBody::mutable_modifygroupgameapkurlres() {
  set_has_modifygroupgameapkurlres();
  if (modifygroupgameapkurlres_ == NULL) modifygroupgameapkurlres_ = new ::pp::ModifyGroupGameApkurlRes;
  return modifygroupgameapkurlres_;
}
inline ::pp::ModifyGroupGameApkurlRes* ProtoBody::release_modifygroupgameapkurlres() {
  clear_has_modifygroupgameapkurlres();
  ::pp::ModifyGroupGameApkurlRes* temp = modifygroupgameapkurlres_;
  modifygroupgameapkurlres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygroupgameapkurlres(::pp::ModifyGroupGameApkurlRes* modifygroupgameapkurlres) {
  delete modifygroupgameapkurlres_;
  modifygroupgameapkurlres_ = modifygroupgameapkurlres;
  if (modifygroupgameapkurlres) {
    set_has_modifygroupgameapkurlres();
  } else {
    clear_has_modifygroupgameapkurlres();
  }
}

// optional .pp.SendInstallGameMsgReq sendInstallGameMsgReq = 12592;
inline bool ProtoBody::has_sendinstallgamemsgreq() const {
  return (_has_bits_[2] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_sendinstallgamemsgreq() {
  _has_bits_[2] |= 0x00000800u;
}
inline void ProtoBody::clear_has_sendinstallgamemsgreq() {
  _has_bits_[2] &= ~0x00000800u;
}
inline void ProtoBody::clear_sendinstallgamemsgreq() {
  if (sendinstallgamemsgreq_ != NULL) sendinstallgamemsgreq_->::pp::SendInstallGameMsgReq::Clear();
  clear_has_sendinstallgamemsgreq();
}
inline const ::pp::SendInstallGameMsgReq& ProtoBody::sendinstallgamemsgreq() const {
  return sendinstallgamemsgreq_ != NULL ? *sendinstallgamemsgreq_ : *default_instance_->sendinstallgamemsgreq_;
}
inline ::pp::SendInstallGameMsgReq* ProtoBody::mutable_sendinstallgamemsgreq() {
  set_has_sendinstallgamemsgreq();
  if (sendinstallgamemsgreq_ == NULL) sendinstallgamemsgreq_ = new ::pp::SendInstallGameMsgReq;
  return sendinstallgamemsgreq_;
}
inline ::pp::SendInstallGameMsgReq* ProtoBody::release_sendinstallgamemsgreq() {
  clear_has_sendinstallgamemsgreq();
  ::pp::SendInstallGameMsgReq* temp = sendinstallgamemsgreq_;
  sendinstallgamemsgreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sendinstallgamemsgreq(::pp::SendInstallGameMsgReq* sendinstallgamemsgreq) {
  delete sendinstallgamemsgreq_;
  sendinstallgamemsgreq_ = sendinstallgamemsgreq;
  if (sendinstallgamemsgreq) {
    set_has_sendinstallgamemsgreq();
  } else {
    clear_has_sendinstallgamemsgreq();
  }
}

// optional .pp.SendInstallGameMsgRes sendInstallGameMsgRes = 12593;
inline bool ProtoBody::has_sendinstallgamemsgres() const {
  return (_has_bits_[2] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_sendinstallgamemsgres() {
  _has_bits_[2] |= 0x00001000u;
}
inline void ProtoBody::clear_has_sendinstallgamemsgres() {
  _has_bits_[2] &= ~0x00001000u;
}
inline void ProtoBody::clear_sendinstallgamemsgres() {
  if (sendinstallgamemsgres_ != NULL) sendinstallgamemsgres_->::pp::SendInstallGameMsgRes::Clear();
  clear_has_sendinstallgamemsgres();
}
inline const ::pp::SendInstallGameMsgRes& ProtoBody::sendinstallgamemsgres() const {
  return sendinstallgamemsgres_ != NULL ? *sendinstallgamemsgres_ : *default_instance_->sendinstallgamemsgres_;
}
inline ::pp::SendInstallGameMsgRes* ProtoBody::mutable_sendinstallgamemsgres() {
  set_has_sendinstallgamemsgres();
  if (sendinstallgamemsgres_ == NULL) sendinstallgamemsgres_ = new ::pp::SendInstallGameMsgRes;
  return sendinstallgamemsgres_;
}
inline ::pp::SendInstallGameMsgRes* ProtoBody::release_sendinstallgamemsgres() {
  clear_has_sendinstallgamemsgres();
  ::pp::SendInstallGameMsgRes* temp = sendinstallgamemsgres_;
  sendinstallgamemsgres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sendinstallgamemsgres(::pp::SendInstallGameMsgRes* sendinstallgamemsgres) {
  delete sendinstallgamemsgres_;
  sendinstallgamemsgres_ = sendinstallgamemsgres;
  if (sendinstallgamemsgres) {
    set_has_sendinstallgamemsgres();
  } else {
    clear_has_sendinstallgamemsgres();
  }
}

// optional .pp.ModifyOurGameStateReq modifyOurGameStateReq = 12608;
inline bool ProtoBody::has_modifyourgamestatereq() const {
  return (_has_bits_[2] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_modifyourgamestatereq() {
  _has_bits_[2] |= 0x00002000u;
}
inline void ProtoBody::clear_has_modifyourgamestatereq() {
  _has_bits_[2] &= ~0x00002000u;
}
inline void ProtoBody::clear_modifyourgamestatereq() {
  if (modifyourgamestatereq_ != NULL) modifyourgamestatereq_->::pp::ModifyOurGameStateReq::Clear();
  clear_has_modifyourgamestatereq();
}
inline const ::pp::ModifyOurGameStateReq& ProtoBody::modifyourgamestatereq() const {
  return modifyourgamestatereq_ != NULL ? *modifyourgamestatereq_ : *default_instance_->modifyourgamestatereq_;
}
inline ::pp::ModifyOurGameStateReq* ProtoBody::mutable_modifyourgamestatereq() {
  set_has_modifyourgamestatereq();
  if (modifyourgamestatereq_ == NULL) modifyourgamestatereq_ = new ::pp::ModifyOurGameStateReq;
  return modifyourgamestatereq_;
}
inline ::pp::ModifyOurGameStateReq* ProtoBody::release_modifyourgamestatereq() {
  clear_has_modifyourgamestatereq();
  ::pp::ModifyOurGameStateReq* temp = modifyourgamestatereq_;
  modifyourgamestatereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifyourgamestatereq(::pp::ModifyOurGameStateReq* modifyourgamestatereq) {
  delete modifyourgamestatereq_;
  modifyourgamestatereq_ = modifyourgamestatereq;
  if (modifyourgamestatereq) {
    set_has_modifyourgamestatereq();
  } else {
    clear_has_modifyourgamestatereq();
  }
}

// optional .pp.ModifyOurGameStateRes modifyOurGameStateRes = 12609;
inline bool ProtoBody::has_modifyourgamestateres() const {
  return (_has_bits_[2] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_modifyourgamestateres() {
  _has_bits_[2] |= 0x00004000u;
}
inline void ProtoBody::clear_has_modifyourgamestateres() {
  _has_bits_[2] &= ~0x00004000u;
}
inline void ProtoBody::clear_modifyourgamestateres() {
  if (modifyourgamestateres_ != NULL) modifyourgamestateres_->::pp::ModifyOurGameStateRes::Clear();
  clear_has_modifyourgamestateres();
}
inline const ::pp::ModifyOurGameStateRes& ProtoBody::modifyourgamestateres() const {
  return modifyourgamestateres_ != NULL ? *modifyourgamestateres_ : *default_instance_->modifyourgamestateres_;
}
inline ::pp::ModifyOurGameStateRes* ProtoBody::mutable_modifyourgamestateres() {
  set_has_modifyourgamestateres();
  if (modifyourgamestateres_ == NULL) modifyourgamestateres_ = new ::pp::ModifyOurGameStateRes;
  return modifyourgamestateres_;
}
inline ::pp::ModifyOurGameStateRes* ProtoBody::release_modifyourgamestateres() {
  clear_has_modifyourgamestateres();
  ::pp::ModifyOurGameStateRes* temp = modifyourgamestateres_;
  modifyourgamestateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifyourgamestateres(::pp::ModifyOurGameStateRes* modifyourgamestateres) {
  delete modifyourgamestateres_;
  modifyourgamestateres_ = modifyourgamestateres;
  if (modifyourgamestateres) {
    set_has_modifyourgamestateres();
  } else {
    clear_has_modifyourgamestateres();
  }
}

// optional .pp.SearchGamesListReq searchGamesListReq = 12610;
inline bool ProtoBody::has_searchgameslistreq() const {
  return (_has_bits_[2] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_searchgameslistreq() {
  _has_bits_[2] |= 0x00008000u;
}
inline void ProtoBody::clear_has_searchgameslistreq() {
  _has_bits_[2] &= ~0x00008000u;
}
inline void ProtoBody::clear_searchgameslistreq() {
  if (searchgameslistreq_ != NULL) searchgameslistreq_->::pp::SearchGamesListReq::Clear();
  clear_has_searchgameslistreq();
}
inline const ::pp::SearchGamesListReq& ProtoBody::searchgameslistreq() const {
  return searchgameslistreq_ != NULL ? *searchgameslistreq_ : *default_instance_->searchgameslistreq_;
}
inline ::pp::SearchGamesListReq* ProtoBody::mutable_searchgameslistreq() {
  set_has_searchgameslistreq();
  if (searchgameslistreq_ == NULL) searchgameslistreq_ = new ::pp::SearchGamesListReq;
  return searchgameslistreq_;
}
inline ::pp::SearchGamesListReq* ProtoBody::release_searchgameslistreq() {
  clear_has_searchgameslistreq();
  ::pp::SearchGamesListReq* temp = searchgameslistreq_;
  searchgameslistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_searchgameslistreq(::pp::SearchGamesListReq* searchgameslistreq) {
  delete searchgameslistreq_;
  searchgameslistreq_ = searchgameslistreq;
  if (searchgameslistreq) {
    set_has_searchgameslistreq();
  } else {
    clear_has_searchgameslistreq();
  }
}

// optional .pp.SearchGamesListRes searchGamesListRes = 12611;
inline bool ProtoBody::has_searchgameslistres() const {
  return (_has_bits_[2] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_searchgameslistres() {
  _has_bits_[2] |= 0x00010000u;
}
inline void ProtoBody::clear_has_searchgameslistres() {
  _has_bits_[2] &= ~0x00010000u;
}
inline void ProtoBody::clear_searchgameslistres() {
  if (searchgameslistres_ != NULL) searchgameslistres_->::pp::SearchGamesListRes::Clear();
  clear_has_searchgameslistres();
}
inline const ::pp::SearchGamesListRes& ProtoBody::searchgameslistres() const {
  return searchgameslistres_ != NULL ? *searchgameslistres_ : *default_instance_->searchgameslistres_;
}
inline ::pp::SearchGamesListRes* ProtoBody::mutable_searchgameslistres() {
  set_has_searchgameslistres();
  if (searchgameslistres_ == NULL) searchgameslistres_ = new ::pp::SearchGamesListRes;
  return searchgameslistres_;
}
inline ::pp::SearchGamesListRes* ProtoBody::release_searchgameslistres() {
  clear_has_searchgameslistres();
  ::pp::SearchGamesListRes* temp = searchgameslistres_;
  searchgameslistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_searchgameslistres(::pp::SearchGamesListRes* searchgameslistres) {
  delete searchgameslistres_;
  searchgameslistres_ = searchgameslistres;
  if (searchgameslistres) {
    set_has_searchgameslistres();
  } else {
    clear_has_searchgameslistres();
  }
}

// optional .pp.GameCountReq gameCountReq = 12624;
inline bool ProtoBody::has_gamecountreq() const {
  return (_has_bits_[2] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_gamecountreq() {
  _has_bits_[2] |= 0x00020000u;
}
inline void ProtoBody::clear_has_gamecountreq() {
  _has_bits_[2] &= ~0x00020000u;
}
inline void ProtoBody::clear_gamecountreq() {
  if (gamecountreq_ != NULL) gamecountreq_->::pp::GameCountReq::Clear();
  clear_has_gamecountreq();
}
inline const ::pp::GameCountReq& ProtoBody::gamecountreq() const {
  return gamecountreq_ != NULL ? *gamecountreq_ : *default_instance_->gamecountreq_;
}
inline ::pp::GameCountReq* ProtoBody::mutable_gamecountreq() {
  set_has_gamecountreq();
  if (gamecountreq_ == NULL) gamecountreq_ = new ::pp::GameCountReq;
  return gamecountreq_;
}
inline ::pp::GameCountReq* ProtoBody::release_gamecountreq() {
  clear_has_gamecountreq();
  ::pp::GameCountReq* temp = gamecountreq_;
  gamecountreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamecountreq(::pp::GameCountReq* gamecountreq) {
  delete gamecountreq_;
  gamecountreq_ = gamecountreq;
  if (gamecountreq) {
    set_has_gamecountreq();
  } else {
    clear_has_gamecountreq();
  }
}

// optional .pp.GameCountRes gameCountRes = 12625;
inline bool ProtoBody::has_gamecountres() const {
  return (_has_bits_[2] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_gamecountres() {
  _has_bits_[2] |= 0x00040000u;
}
inline void ProtoBody::clear_has_gamecountres() {
  _has_bits_[2] &= ~0x00040000u;
}
inline void ProtoBody::clear_gamecountres() {
  if (gamecountres_ != NULL) gamecountres_->::pp::GameCountRes::Clear();
  clear_has_gamecountres();
}
inline const ::pp::GameCountRes& ProtoBody::gamecountres() const {
  return gamecountres_ != NULL ? *gamecountres_ : *default_instance_->gamecountres_;
}
inline ::pp::GameCountRes* ProtoBody::mutable_gamecountres() {
  set_has_gamecountres();
  if (gamecountres_ == NULL) gamecountres_ = new ::pp::GameCountRes;
  return gamecountres_;
}
inline ::pp::GameCountRes* ProtoBody::release_gamecountres() {
  clear_has_gamecountres();
  ::pp::GameCountRes* temp = gamecountres_;
  gamecountres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamecountres(::pp::GameCountRes* gamecountres) {
  delete gamecountres_;
  gamecountres_ = gamecountres;
  if (gamecountres) {
    set_has_gamecountres();
  } else {
    clear_has_gamecountres();
  }
}

// optional .pp.RecommendPackNameReq recommendPackNameReq = 12626;
inline bool ProtoBody::has_recommendpacknamereq() const {
  return (_has_bits_[2] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_recommendpacknamereq() {
  _has_bits_[2] |= 0x00080000u;
}
inline void ProtoBody::clear_has_recommendpacknamereq() {
  _has_bits_[2] &= ~0x00080000u;
}
inline void ProtoBody::clear_recommendpacknamereq() {
  if (recommendpacknamereq_ != NULL) recommendpacknamereq_->::pp::RecommendPackNameReq::Clear();
  clear_has_recommendpacknamereq();
}
inline const ::pp::RecommendPackNameReq& ProtoBody::recommendpacknamereq() const {
  return recommendpacknamereq_ != NULL ? *recommendpacknamereq_ : *default_instance_->recommendpacknamereq_;
}
inline ::pp::RecommendPackNameReq* ProtoBody::mutable_recommendpacknamereq() {
  set_has_recommendpacknamereq();
  if (recommendpacknamereq_ == NULL) recommendpacknamereq_ = new ::pp::RecommendPackNameReq;
  return recommendpacknamereq_;
}
inline ::pp::RecommendPackNameReq* ProtoBody::release_recommendpacknamereq() {
  clear_has_recommendpacknamereq();
  ::pp::RecommendPackNameReq* temp = recommendpacknamereq_;
  recommendpacknamereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_recommendpacknamereq(::pp::RecommendPackNameReq* recommendpacknamereq) {
  delete recommendpacknamereq_;
  recommendpacknamereq_ = recommendpacknamereq;
  if (recommendpacknamereq) {
    set_has_recommendpacknamereq();
  } else {
    clear_has_recommendpacknamereq();
  }
}

// optional .pp.RecommendPackNameRes recommendPackNameRes = 12627;
inline bool ProtoBody::has_recommendpacknameres() const {
  return (_has_bits_[2] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_recommendpacknameres() {
  _has_bits_[2] |= 0x00100000u;
}
inline void ProtoBody::clear_has_recommendpacknameres() {
  _has_bits_[2] &= ~0x00100000u;
}
inline void ProtoBody::clear_recommendpacknameres() {
  if (recommendpacknameres_ != NULL) recommendpacknameres_->::pp::RecommendPackNameRes::Clear();
  clear_has_recommendpacknameres();
}
inline const ::pp::RecommendPackNameRes& ProtoBody::recommendpacknameres() const {
  return recommendpacknameres_ != NULL ? *recommendpacknameres_ : *default_instance_->recommendpacknameres_;
}
inline ::pp::RecommendPackNameRes* ProtoBody::mutable_recommendpacknameres() {
  set_has_recommendpacknameres();
  if (recommendpacknameres_ == NULL) recommendpacknameres_ = new ::pp::RecommendPackNameRes;
  return recommendpacknameres_;
}
inline ::pp::RecommendPackNameRes* ProtoBody::release_recommendpacknameres() {
  clear_has_recommendpacknameres();
  ::pp::RecommendPackNameRes* temp = recommendpacknameres_;
  recommendpacknameres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_recommendpacknameres(::pp::RecommendPackNameRes* recommendpacknameres) {
  delete recommendpacknameres_;
  recommendpacknameres_ = recommendpacknameres;
  if (recommendpacknameres) {
    set_has_recommendpacknameres();
  } else {
    clear_has_recommendpacknameres();
  }
}

// optional .pp.GameFilterSearchReq gameFilterSearchReq = 12628;
inline bool ProtoBody::has_gamefiltersearchreq() const {
  return (_has_bits_[2] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_gamefiltersearchreq() {
  _has_bits_[2] |= 0x00200000u;
}
inline void ProtoBody::clear_has_gamefiltersearchreq() {
  _has_bits_[2] &= ~0x00200000u;
}
inline void ProtoBody::clear_gamefiltersearchreq() {
  if (gamefiltersearchreq_ != NULL) gamefiltersearchreq_->::pp::GameFilterSearchReq::Clear();
  clear_has_gamefiltersearchreq();
}
inline const ::pp::GameFilterSearchReq& ProtoBody::gamefiltersearchreq() const {
  return gamefiltersearchreq_ != NULL ? *gamefiltersearchreq_ : *default_instance_->gamefiltersearchreq_;
}
inline ::pp::GameFilterSearchReq* ProtoBody::mutable_gamefiltersearchreq() {
  set_has_gamefiltersearchreq();
  if (gamefiltersearchreq_ == NULL) gamefiltersearchreq_ = new ::pp::GameFilterSearchReq;
  return gamefiltersearchreq_;
}
inline ::pp::GameFilterSearchReq* ProtoBody::release_gamefiltersearchreq() {
  clear_has_gamefiltersearchreq();
  ::pp::GameFilterSearchReq* temp = gamefiltersearchreq_;
  gamefiltersearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamefiltersearchreq(::pp::GameFilterSearchReq* gamefiltersearchreq) {
  delete gamefiltersearchreq_;
  gamefiltersearchreq_ = gamefiltersearchreq;
  if (gamefiltersearchreq) {
    set_has_gamefiltersearchreq();
  } else {
    clear_has_gamefiltersearchreq();
  }
}

// optional .pp.GameFilterSearchRes gameFilterSearchRes = 12629;
inline bool ProtoBody::has_gamefiltersearchres() const {
  return (_has_bits_[2] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_gamefiltersearchres() {
  _has_bits_[2] |= 0x00400000u;
}
inline void ProtoBody::clear_has_gamefiltersearchres() {
  _has_bits_[2] &= ~0x00400000u;
}
inline void ProtoBody::clear_gamefiltersearchres() {
  if (gamefiltersearchres_ != NULL) gamefiltersearchres_->::pp::GameFilterSearchRes::Clear();
  clear_has_gamefiltersearchres();
}
inline const ::pp::GameFilterSearchRes& ProtoBody::gamefiltersearchres() const {
  return gamefiltersearchres_ != NULL ? *gamefiltersearchres_ : *default_instance_->gamefiltersearchres_;
}
inline ::pp::GameFilterSearchRes* ProtoBody::mutable_gamefiltersearchres() {
  set_has_gamefiltersearchres();
  if (gamefiltersearchres_ == NULL) gamefiltersearchres_ = new ::pp::GameFilterSearchRes;
  return gamefiltersearchres_;
}
inline ::pp::GameFilterSearchRes* ProtoBody::release_gamefiltersearchres() {
  clear_has_gamefiltersearchres();
  ::pp::GameFilterSearchRes* temp = gamefiltersearchres_;
  gamefiltersearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamefiltersearchres(::pp::GameFilterSearchRes* gamefiltersearchres) {
  delete gamefiltersearchres_;
  gamefiltersearchres_ = gamefiltersearchres;
  if (gamefiltersearchres) {
    set_has_gamefiltersearchres();
  } else {
    clear_has_gamefiltersearchres();
  }
}

// optional .pp.ModifyGameFilterReq modifyGameFilterReq = 12630;
inline bool ProtoBody::has_modifygamefilterreq() const {
  return (_has_bits_[2] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_modifygamefilterreq() {
  _has_bits_[2] |= 0x00800000u;
}
inline void ProtoBody::clear_has_modifygamefilterreq() {
  _has_bits_[2] &= ~0x00800000u;
}
inline void ProtoBody::clear_modifygamefilterreq() {
  if (modifygamefilterreq_ != NULL) modifygamefilterreq_->::pp::ModifyGameFilterReq::Clear();
  clear_has_modifygamefilterreq();
}
inline const ::pp::ModifyGameFilterReq& ProtoBody::modifygamefilterreq() const {
  return modifygamefilterreq_ != NULL ? *modifygamefilterreq_ : *default_instance_->modifygamefilterreq_;
}
inline ::pp::ModifyGameFilterReq* ProtoBody::mutable_modifygamefilterreq() {
  set_has_modifygamefilterreq();
  if (modifygamefilterreq_ == NULL) modifygamefilterreq_ = new ::pp::ModifyGameFilterReq;
  return modifygamefilterreq_;
}
inline ::pp::ModifyGameFilterReq* ProtoBody::release_modifygamefilterreq() {
  clear_has_modifygamefilterreq();
  ::pp::ModifyGameFilterReq* temp = modifygamefilterreq_;
  modifygamefilterreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygamefilterreq(::pp::ModifyGameFilterReq* modifygamefilterreq) {
  delete modifygamefilterreq_;
  modifygamefilterreq_ = modifygamefilterreq;
  if (modifygamefilterreq) {
    set_has_modifygamefilterreq();
  } else {
    clear_has_modifygamefilterreq();
  }
}

// optional .pp.ModifyGameFilterRes modifyGameFilterRes = 12631;
inline bool ProtoBody::has_modifygamefilterres() const {
  return (_has_bits_[2] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_modifygamefilterres() {
  _has_bits_[2] |= 0x01000000u;
}
inline void ProtoBody::clear_has_modifygamefilterres() {
  _has_bits_[2] &= ~0x01000000u;
}
inline void ProtoBody::clear_modifygamefilterres() {
  if (modifygamefilterres_ != NULL) modifygamefilterres_->::pp::ModifyGameFilterRes::Clear();
  clear_has_modifygamefilterres();
}
inline const ::pp::ModifyGameFilterRes& ProtoBody::modifygamefilterres() const {
  return modifygamefilterres_ != NULL ? *modifygamefilterres_ : *default_instance_->modifygamefilterres_;
}
inline ::pp::ModifyGameFilterRes* ProtoBody::mutable_modifygamefilterres() {
  set_has_modifygamefilterres();
  if (modifygamefilterres_ == NULL) modifygamefilterres_ = new ::pp::ModifyGameFilterRes;
  return modifygamefilterres_;
}
inline ::pp::ModifyGameFilterRes* ProtoBody::release_modifygamefilterres() {
  clear_has_modifygamefilterres();
  ::pp::ModifyGameFilterRes* temp = modifygamefilterres_;
  modifygamefilterres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygamefilterres(::pp::ModifyGameFilterRes* modifygamefilterres) {
  delete modifygamefilterres_;
  modifygamefilterres_ = modifygamefilterres;
  if (modifygamefilterres) {
    set_has_modifygamefilterres();
  } else {
    clear_has_modifygamefilterres();
  }
}

// optional .pp.GameSpiderReq gameSpiderReq = 12632;
inline bool ProtoBody::has_gamespiderreq() const {
  return (_has_bits_[2] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_gamespiderreq() {
  _has_bits_[2] |= 0x02000000u;
}
inline void ProtoBody::clear_has_gamespiderreq() {
  _has_bits_[2] &= ~0x02000000u;
}
inline void ProtoBody::clear_gamespiderreq() {
  if (gamespiderreq_ != NULL) gamespiderreq_->::pp::GameSpiderReq::Clear();
  clear_has_gamespiderreq();
}
inline const ::pp::GameSpiderReq& ProtoBody::gamespiderreq() const {
  return gamespiderreq_ != NULL ? *gamespiderreq_ : *default_instance_->gamespiderreq_;
}
inline ::pp::GameSpiderReq* ProtoBody::mutable_gamespiderreq() {
  set_has_gamespiderreq();
  if (gamespiderreq_ == NULL) gamespiderreq_ = new ::pp::GameSpiderReq;
  return gamespiderreq_;
}
inline ::pp::GameSpiderReq* ProtoBody::release_gamespiderreq() {
  clear_has_gamespiderreq();
  ::pp::GameSpiderReq* temp = gamespiderreq_;
  gamespiderreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamespiderreq(::pp::GameSpiderReq* gamespiderreq) {
  delete gamespiderreq_;
  gamespiderreq_ = gamespiderreq;
  if (gamespiderreq) {
    set_has_gamespiderreq();
  } else {
    clear_has_gamespiderreq();
  }
}

// optional .pp.GameSpiderRes gameSpiderRes = 12633;
inline bool ProtoBody::has_gamespiderres() const {
  return (_has_bits_[2] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_gamespiderres() {
  _has_bits_[2] |= 0x04000000u;
}
inline void ProtoBody::clear_has_gamespiderres() {
  _has_bits_[2] &= ~0x04000000u;
}
inline void ProtoBody::clear_gamespiderres() {
  if (gamespiderres_ != NULL) gamespiderres_->::pp::GameSpiderRes::Clear();
  clear_has_gamespiderres();
}
inline const ::pp::GameSpiderRes& ProtoBody::gamespiderres() const {
  return gamespiderres_ != NULL ? *gamespiderres_ : *default_instance_->gamespiderres_;
}
inline ::pp::GameSpiderRes* ProtoBody::mutable_gamespiderres() {
  set_has_gamespiderres();
  if (gamespiderres_ == NULL) gamespiderres_ = new ::pp::GameSpiderRes;
  return gamespiderres_;
}
inline ::pp::GameSpiderRes* ProtoBody::release_gamespiderres() {
  clear_has_gamespiderres();
  ::pp::GameSpiderRes* temp = gamespiderres_;
  gamespiderres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_gamespiderres(::pp::GameSpiderRes* gamespiderres) {
  delete gamespiderres_;
  gamespiderres_ = gamespiderres;
  if (gamespiderres) {
    set_has_gamespiderres();
  } else {
    clear_has_gamespiderres();
  }
}

// optional .pp.ModifyGameDiscountReq modifyGameDiscountReq = 12634;
inline bool ProtoBody::has_modifygamediscountreq() const {
  return (_has_bits_[2] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_modifygamediscountreq() {
  _has_bits_[2] |= 0x08000000u;
}
inline void ProtoBody::clear_has_modifygamediscountreq() {
  _has_bits_[2] &= ~0x08000000u;
}
inline void ProtoBody::clear_modifygamediscountreq() {
  if (modifygamediscountreq_ != NULL) modifygamediscountreq_->::pp::ModifyGameDiscountReq::Clear();
  clear_has_modifygamediscountreq();
}
inline const ::pp::ModifyGameDiscountReq& ProtoBody::modifygamediscountreq() const {
  return modifygamediscountreq_ != NULL ? *modifygamediscountreq_ : *default_instance_->modifygamediscountreq_;
}
inline ::pp::ModifyGameDiscountReq* ProtoBody::mutable_modifygamediscountreq() {
  set_has_modifygamediscountreq();
  if (modifygamediscountreq_ == NULL) modifygamediscountreq_ = new ::pp::ModifyGameDiscountReq;
  return modifygamediscountreq_;
}
inline ::pp::ModifyGameDiscountReq* ProtoBody::release_modifygamediscountreq() {
  clear_has_modifygamediscountreq();
  ::pp::ModifyGameDiscountReq* temp = modifygamediscountreq_;
  modifygamediscountreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygamediscountreq(::pp::ModifyGameDiscountReq* modifygamediscountreq) {
  delete modifygamediscountreq_;
  modifygamediscountreq_ = modifygamediscountreq;
  if (modifygamediscountreq) {
    set_has_modifygamediscountreq();
  } else {
    clear_has_modifygamediscountreq();
  }
}

// optional .pp.ModifyGameDiscountRes modifyGameDiscountRes = 12635;
inline bool ProtoBody::has_modifygamediscountres() const {
  return (_has_bits_[2] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_modifygamediscountres() {
  _has_bits_[2] |= 0x10000000u;
}
inline void ProtoBody::clear_has_modifygamediscountres() {
  _has_bits_[2] &= ~0x10000000u;
}
inline void ProtoBody::clear_modifygamediscountres() {
  if (modifygamediscountres_ != NULL) modifygamediscountres_->::pp::ModifyGameDiscountRes::Clear();
  clear_has_modifygamediscountres();
}
inline const ::pp::ModifyGameDiscountRes& ProtoBody::modifygamediscountres() const {
  return modifygamediscountres_ != NULL ? *modifygamediscountres_ : *default_instance_->modifygamediscountres_;
}
inline ::pp::ModifyGameDiscountRes* ProtoBody::mutable_modifygamediscountres() {
  set_has_modifygamediscountres();
  if (modifygamediscountres_ == NULL) modifygamediscountres_ = new ::pp::ModifyGameDiscountRes;
  return modifygamediscountres_;
}
inline ::pp::ModifyGameDiscountRes* ProtoBody::release_modifygamediscountres() {
  clear_has_modifygamediscountres();
  ::pp::ModifyGameDiscountRes* temp = modifygamediscountres_;
  modifygamediscountres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygamediscountres(::pp::ModifyGameDiscountRes* modifygamediscountres) {
  delete modifygamediscountres_;
  modifygamediscountres_ = modifygamediscountres;
  if (modifygamediscountres) {
    set_has_modifygamediscountres();
  } else {
    clear_has_modifygamediscountres();
  }
}

// optional .pp.ModifyGroupDiscountReq modifyGroupDiscountReq = 12636;
inline bool ProtoBody::has_modifygroupdiscountreq() const {
  return (_has_bits_[2] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_modifygroupdiscountreq() {
  _has_bits_[2] |= 0x20000000u;
}
inline void ProtoBody::clear_has_modifygroupdiscountreq() {
  _has_bits_[2] &= ~0x20000000u;
}
inline void ProtoBody::clear_modifygroupdiscountreq() {
  if (modifygroupdiscountreq_ != NULL) modifygroupdiscountreq_->::pp::ModifyGroupDiscountReq::Clear();
  clear_has_modifygroupdiscountreq();
}
inline const ::pp::ModifyGroupDiscountReq& ProtoBody::modifygroupdiscountreq() const {
  return modifygroupdiscountreq_ != NULL ? *modifygroupdiscountreq_ : *default_instance_->modifygroupdiscountreq_;
}
inline ::pp::ModifyGroupDiscountReq* ProtoBody::mutable_modifygroupdiscountreq() {
  set_has_modifygroupdiscountreq();
  if (modifygroupdiscountreq_ == NULL) modifygroupdiscountreq_ = new ::pp::ModifyGroupDiscountReq;
  return modifygroupdiscountreq_;
}
inline ::pp::ModifyGroupDiscountReq* ProtoBody::release_modifygroupdiscountreq() {
  clear_has_modifygroupdiscountreq();
  ::pp::ModifyGroupDiscountReq* temp = modifygroupdiscountreq_;
  modifygroupdiscountreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygroupdiscountreq(::pp::ModifyGroupDiscountReq* modifygroupdiscountreq) {
  delete modifygroupdiscountreq_;
  modifygroupdiscountreq_ = modifygroupdiscountreq;
  if (modifygroupdiscountreq) {
    set_has_modifygroupdiscountreq();
  } else {
    clear_has_modifygroupdiscountreq();
  }
}

// optional .pp.ModifyGroupDiscountRes modifyGroupDiscountRes = 12637;
inline bool ProtoBody::has_modifygroupdiscountres() const {
  return (_has_bits_[2] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_modifygroupdiscountres() {
  _has_bits_[2] |= 0x40000000u;
}
inline void ProtoBody::clear_has_modifygroupdiscountres() {
  _has_bits_[2] &= ~0x40000000u;
}
inline void ProtoBody::clear_modifygroupdiscountres() {
  if (modifygroupdiscountres_ != NULL) modifygroupdiscountres_->::pp::ModifyGroupDiscountRes::Clear();
  clear_has_modifygroupdiscountres();
}
inline const ::pp::ModifyGroupDiscountRes& ProtoBody::modifygroupdiscountres() const {
  return modifygroupdiscountres_ != NULL ? *modifygroupdiscountres_ : *default_instance_->modifygroupdiscountres_;
}
inline ::pp::ModifyGroupDiscountRes* ProtoBody::mutable_modifygroupdiscountres() {
  set_has_modifygroupdiscountres();
  if (modifygroupdiscountres_ == NULL) modifygroupdiscountres_ = new ::pp::ModifyGroupDiscountRes;
  return modifygroupdiscountres_;
}
inline ::pp::ModifyGroupDiscountRes* ProtoBody::release_modifygroupdiscountres() {
  clear_has_modifygroupdiscountres();
  ::pp::ModifyGroupDiscountRes* temp = modifygroupdiscountres_;
  modifygroupdiscountres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_modifygroupdiscountres(::pp::ModifyGroupDiscountRes* modifygroupdiscountres) {
  delete modifygroupdiscountres_;
  modifygroupdiscountres_ = modifygroupdiscountres;
  if (modifygroupdiscountres) {
    set_has_modifygroupdiscountres();
  } else {
    clear_has_modifygroupdiscountres();
  }
}

// optional .pp.GroupDiscountListReq groupDiscountListReq = 12638;
inline bool ProtoBody::has_groupdiscountlistreq() const {
  return (_has_bits_[2] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_groupdiscountlistreq() {
  _has_bits_[2] |= 0x80000000u;
}
inline void ProtoBody::clear_has_groupdiscountlistreq() {
  _has_bits_[2] &= ~0x80000000u;
}
inline void ProtoBody::clear_groupdiscountlistreq() {
  if (groupdiscountlistreq_ != NULL) groupdiscountlistreq_->::pp::GroupDiscountListReq::Clear();
  clear_has_groupdiscountlistreq();
}
inline const ::pp::GroupDiscountListReq& ProtoBody::groupdiscountlistreq() const {
  return groupdiscountlistreq_ != NULL ? *groupdiscountlistreq_ : *default_instance_->groupdiscountlistreq_;
}
inline ::pp::GroupDiscountListReq* ProtoBody::mutable_groupdiscountlistreq() {
  set_has_groupdiscountlistreq();
  if (groupdiscountlistreq_ == NULL) groupdiscountlistreq_ = new ::pp::GroupDiscountListReq;
  return groupdiscountlistreq_;
}
inline ::pp::GroupDiscountListReq* ProtoBody::release_groupdiscountlistreq() {
  clear_has_groupdiscountlistreq();
  ::pp::GroupDiscountListReq* temp = groupdiscountlistreq_;
  groupdiscountlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupdiscountlistreq(::pp::GroupDiscountListReq* groupdiscountlistreq) {
  delete groupdiscountlistreq_;
  groupdiscountlistreq_ = groupdiscountlistreq;
  if (groupdiscountlistreq) {
    set_has_groupdiscountlistreq();
  } else {
    clear_has_groupdiscountlistreq();
  }
}

// optional .pp.GroupDiscountListRes groupDiscountListRes = 12639;
inline bool ProtoBody::has_groupdiscountlistres() const {
  return (_has_bits_[3] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_groupdiscountlistres() {
  _has_bits_[3] |= 0x00000001u;
}
inline void ProtoBody::clear_has_groupdiscountlistres() {
  _has_bits_[3] &= ~0x00000001u;
}
inline void ProtoBody::clear_groupdiscountlistres() {
  if (groupdiscountlistres_ != NULL) groupdiscountlistres_->::pp::GroupDiscountListRes::Clear();
  clear_has_groupdiscountlistres();
}
inline const ::pp::GroupDiscountListRes& ProtoBody::groupdiscountlistres() const {
  return groupdiscountlistres_ != NULL ? *groupdiscountlistres_ : *default_instance_->groupdiscountlistres_;
}
inline ::pp::GroupDiscountListRes* ProtoBody::mutable_groupdiscountlistres() {
  set_has_groupdiscountlistres();
  if (groupdiscountlistres_ == NULL) groupdiscountlistres_ = new ::pp::GroupDiscountListRes;
  return groupdiscountlistres_;
}
inline ::pp::GroupDiscountListRes* ProtoBody::release_groupdiscountlistres() {
  clear_has_groupdiscountlistres();
  ::pp::GroupDiscountListRes* temp = groupdiscountlistres_;
  groupdiscountlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupdiscountlistres(::pp::GroupDiscountListRes* groupdiscountlistres) {
  delete groupdiscountlistres_;
  groupdiscountlistres_ = groupdiscountlistres;
  if (groupdiscountlistres) {
    set_has_groupdiscountlistres();
  } else {
    clear_has_groupdiscountlistres();
  }
}

// optional .pp.UserYYCoinsPayMethodReq userYYCoinsPayMethodReq = 2817;
inline bool ProtoBody::has_useryycoinspaymethodreq() const {
  return (_has_bits_[3] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_useryycoinspaymethodreq() {
  _has_bits_[3] |= 0x00000002u;
}
inline void ProtoBody::clear_has_useryycoinspaymethodreq() {
  _has_bits_[3] &= ~0x00000002u;
}
inline void ProtoBody::clear_useryycoinspaymethodreq() {
  if (useryycoinspaymethodreq_ != NULL) useryycoinspaymethodreq_->::pp::UserYYCoinsPayMethodReq::Clear();
  clear_has_useryycoinspaymethodreq();
}
inline const ::pp::UserYYCoinsPayMethodReq& ProtoBody::useryycoinspaymethodreq() const {
  return useryycoinspaymethodreq_ != NULL ? *useryycoinspaymethodreq_ : *default_instance_->useryycoinspaymethodreq_;
}
inline ::pp::UserYYCoinsPayMethodReq* ProtoBody::mutable_useryycoinspaymethodreq() {
  set_has_useryycoinspaymethodreq();
  if (useryycoinspaymethodreq_ == NULL) useryycoinspaymethodreq_ = new ::pp::UserYYCoinsPayMethodReq;
  return useryycoinspaymethodreq_;
}
inline ::pp::UserYYCoinsPayMethodReq* ProtoBody::release_useryycoinspaymethodreq() {
  clear_has_useryycoinspaymethodreq();
  ::pp::UserYYCoinsPayMethodReq* temp = useryycoinspaymethodreq_;
  useryycoinspaymethodreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinspaymethodreq(::pp::UserYYCoinsPayMethodReq* useryycoinspaymethodreq) {
  delete useryycoinspaymethodreq_;
  useryycoinspaymethodreq_ = useryycoinspaymethodreq;
  if (useryycoinspaymethodreq) {
    set_has_useryycoinspaymethodreq();
  } else {
    clear_has_useryycoinspaymethodreq();
  }
}

// optional .pp.UserYYCoinsPayMethodRes userYYCoinsPayMethodRes = 2818;
inline bool ProtoBody::has_useryycoinspaymethodres() const {
  return (_has_bits_[3] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_useryycoinspaymethodres() {
  _has_bits_[3] |= 0x00000004u;
}
inline void ProtoBody::clear_has_useryycoinspaymethodres() {
  _has_bits_[3] &= ~0x00000004u;
}
inline void ProtoBody::clear_useryycoinspaymethodres() {
  if (useryycoinspaymethodres_ != NULL) useryycoinspaymethodres_->::pp::UserYYCoinsPayMethodRes::Clear();
  clear_has_useryycoinspaymethodres();
}
inline const ::pp::UserYYCoinsPayMethodRes& ProtoBody::useryycoinspaymethodres() const {
  return useryycoinspaymethodres_ != NULL ? *useryycoinspaymethodres_ : *default_instance_->useryycoinspaymethodres_;
}
inline ::pp::UserYYCoinsPayMethodRes* ProtoBody::mutable_useryycoinspaymethodres() {
  set_has_useryycoinspaymethodres();
  if (useryycoinspaymethodres_ == NULL) useryycoinspaymethodres_ = new ::pp::UserYYCoinsPayMethodRes;
  return useryycoinspaymethodres_;
}
inline ::pp::UserYYCoinsPayMethodRes* ProtoBody::release_useryycoinspaymethodres() {
  clear_has_useryycoinspaymethodres();
  ::pp::UserYYCoinsPayMethodRes* temp = useryycoinspaymethodres_;
  useryycoinspaymethodres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinspaymethodres(::pp::UserYYCoinsPayMethodRes* useryycoinspaymethodres) {
  delete useryycoinspaymethodres_;
  useryycoinspaymethodres_ = useryycoinspaymethodres;
  if (useryycoinspaymethodres) {
    set_has_useryycoinspaymethodres();
  } else {
    clear_has_useryycoinspaymethodres();
  }
}

// optional .pp.UserYYCoinsShopListReq userYYCoinsShopListReq = 2821;
inline bool ProtoBody::has_useryycoinsshoplistreq() const {
  return (_has_bits_[3] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_useryycoinsshoplistreq() {
  _has_bits_[3] |= 0x00000008u;
}
inline void ProtoBody::clear_has_useryycoinsshoplistreq() {
  _has_bits_[3] &= ~0x00000008u;
}
inline void ProtoBody::clear_useryycoinsshoplistreq() {
  if (useryycoinsshoplistreq_ != NULL) useryycoinsshoplistreq_->::pp::UserYYCoinsShopListReq::Clear();
  clear_has_useryycoinsshoplistreq();
}
inline const ::pp::UserYYCoinsShopListReq& ProtoBody::useryycoinsshoplistreq() const {
  return useryycoinsshoplistreq_ != NULL ? *useryycoinsshoplistreq_ : *default_instance_->useryycoinsshoplistreq_;
}
inline ::pp::UserYYCoinsShopListReq* ProtoBody::mutable_useryycoinsshoplistreq() {
  set_has_useryycoinsshoplistreq();
  if (useryycoinsshoplistreq_ == NULL) useryycoinsshoplistreq_ = new ::pp::UserYYCoinsShopListReq;
  return useryycoinsshoplistreq_;
}
inline ::pp::UserYYCoinsShopListReq* ProtoBody::release_useryycoinsshoplistreq() {
  clear_has_useryycoinsshoplistreq();
  ::pp::UserYYCoinsShopListReq* temp = useryycoinsshoplistreq_;
  useryycoinsshoplistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsshoplistreq(::pp::UserYYCoinsShopListReq* useryycoinsshoplistreq) {
  delete useryycoinsshoplistreq_;
  useryycoinsshoplistreq_ = useryycoinsshoplistreq;
  if (useryycoinsshoplistreq) {
    set_has_useryycoinsshoplistreq();
  } else {
    clear_has_useryycoinsshoplistreq();
  }
}

// optional .pp.UserYYCoinsShopListRes userYYCoinsShopListRes = 2822;
inline bool ProtoBody::has_useryycoinsshoplistres() const {
  return (_has_bits_[3] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_useryycoinsshoplistres() {
  _has_bits_[3] |= 0x00000010u;
}
inline void ProtoBody::clear_has_useryycoinsshoplistres() {
  _has_bits_[3] &= ~0x00000010u;
}
inline void ProtoBody::clear_useryycoinsshoplistres() {
  if (useryycoinsshoplistres_ != NULL) useryycoinsshoplistres_->::pp::UserYYCoinsShopListRes::Clear();
  clear_has_useryycoinsshoplistres();
}
inline const ::pp::UserYYCoinsShopListRes& ProtoBody::useryycoinsshoplistres() const {
  return useryycoinsshoplistres_ != NULL ? *useryycoinsshoplistres_ : *default_instance_->useryycoinsshoplistres_;
}
inline ::pp::UserYYCoinsShopListRes* ProtoBody::mutable_useryycoinsshoplistres() {
  set_has_useryycoinsshoplistres();
  if (useryycoinsshoplistres_ == NULL) useryycoinsshoplistres_ = new ::pp::UserYYCoinsShopListRes;
  return useryycoinsshoplistres_;
}
inline ::pp::UserYYCoinsShopListRes* ProtoBody::release_useryycoinsshoplistres() {
  clear_has_useryycoinsshoplistres();
  ::pp::UserYYCoinsShopListRes* temp = useryycoinsshoplistres_;
  useryycoinsshoplistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsshoplistres(::pp::UserYYCoinsShopListRes* useryycoinsshoplistres) {
  delete useryycoinsshoplistres_;
  useryycoinsshoplistres_ = useryycoinsshoplistres;
  if (useryycoinsshoplistres) {
    set_has_useryycoinsshoplistres();
  } else {
    clear_has_useryycoinsshoplistres();
  }
}

// optional .pp.UserYYCoinsQueryReq userYYCoinsQueryReq = 2825;
inline bool ProtoBody::has_useryycoinsqueryreq() const {
  return (_has_bits_[3] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_useryycoinsqueryreq() {
  _has_bits_[3] |= 0x00000020u;
}
inline void ProtoBody::clear_has_useryycoinsqueryreq() {
  _has_bits_[3] &= ~0x00000020u;
}
inline void ProtoBody::clear_useryycoinsqueryreq() {
  if (useryycoinsqueryreq_ != NULL) useryycoinsqueryreq_->::pp::UserYYCoinsQueryReq::Clear();
  clear_has_useryycoinsqueryreq();
}
inline const ::pp::UserYYCoinsQueryReq& ProtoBody::useryycoinsqueryreq() const {
  return useryycoinsqueryreq_ != NULL ? *useryycoinsqueryreq_ : *default_instance_->useryycoinsqueryreq_;
}
inline ::pp::UserYYCoinsQueryReq* ProtoBody::mutable_useryycoinsqueryreq() {
  set_has_useryycoinsqueryreq();
  if (useryycoinsqueryreq_ == NULL) useryycoinsqueryreq_ = new ::pp::UserYYCoinsQueryReq;
  return useryycoinsqueryreq_;
}
inline ::pp::UserYYCoinsQueryReq* ProtoBody::release_useryycoinsqueryreq() {
  clear_has_useryycoinsqueryreq();
  ::pp::UserYYCoinsQueryReq* temp = useryycoinsqueryreq_;
  useryycoinsqueryreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsqueryreq(::pp::UserYYCoinsQueryReq* useryycoinsqueryreq) {
  delete useryycoinsqueryreq_;
  useryycoinsqueryreq_ = useryycoinsqueryreq;
  if (useryycoinsqueryreq) {
    set_has_useryycoinsqueryreq();
  } else {
    clear_has_useryycoinsqueryreq();
  }
}

// optional .pp.UserYYCoinsQueryRes userYYCoinsQueryRes = 2826;
inline bool ProtoBody::has_useryycoinsqueryres() const {
  return (_has_bits_[3] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_useryycoinsqueryres() {
  _has_bits_[3] |= 0x00000040u;
}
inline void ProtoBody::clear_has_useryycoinsqueryres() {
  _has_bits_[3] &= ~0x00000040u;
}
inline void ProtoBody::clear_useryycoinsqueryres() {
  if (useryycoinsqueryres_ != NULL) useryycoinsqueryres_->::pp::UserYYCoinsQueryRes::Clear();
  clear_has_useryycoinsqueryres();
}
inline const ::pp::UserYYCoinsQueryRes& ProtoBody::useryycoinsqueryres() const {
  return useryycoinsqueryres_ != NULL ? *useryycoinsqueryres_ : *default_instance_->useryycoinsqueryres_;
}
inline ::pp::UserYYCoinsQueryRes* ProtoBody::mutable_useryycoinsqueryres() {
  set_has_useryycoinsqueryres();
  if (useryycoinsqueryres_ == NULL) useryycoinsqueryres_ = new ::pp::UserYYCoinsQueryRes;
  return useryycoinsqueryres_;
}
inline ::pp::UserYYCoinsQueryRes* ProtoBody::release_useryycoinsqueryres() {
  clear_has_useryycoinsqueryres();
  ::pp::UserYYCoinsQueryRes* temp = useryycoinsqueryres_;
  useryycoinsqueryres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsqueryres(::pp::UserYYCoinsQueryRes* useryycoinsqueryres) {
  delete useryycoinsqueryres_;
  useryycoinsqueryres_ = useryycoinsqueryres;
  if (useryycoinsqueryres) {
    set_has_useryycoinsqueryres();
  } else {
    clear_has_useryycoinsqueryres();
  }
}

// optional .pp.UserYYCoinsBuyReq userYYCoinsBuyReq = 2833;
inline bool ProtoBody::has_useryycoinsbuyreq() const {
  return (_has_bits_[3] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_useryycoinsbuyreq() {
  _has_bits_[3] |= 0x00000080u;
}
inline void ProtoBody::clear_has_useryycoinsbuyreq() {
  _has_bits_[3] &= ~0x00000080u;
}
inline void ProtoBody::clear_useryycoinsbuyreq() {
  if (useryycoinsbuyreq_ != NULL) useryycoinsbuyreq_->::pp::UserYYCoinsBuyReq::Clear();
  clear_has_useryycoinsbuyreq();
}
inline const ::pp::UserYYCoinsBuyReq& ProtoBody::useryycoinsbuyreq() const {
  return useryycoinsbuyreq_ != NULL ? *useryycoinsbuyreq_ : *default_instance_->useryycoinsbuyreq_;
}
inline ::pp::UserYYCoinsBuyReq* ProtoBody::mutable_useryycoinsbuyreq() {
  set_has_useryycoinsbuyreq();
  if (useryycoinsbuyreq_ == NULL) useryycoinsbuyreq_ = new ::pp::UserYYCoinsBuyReq;
  return useryycoinsbuyreq_;
}
inline ::pp::UserYYCoinsBuyReq* ProtoBody::release_useryycoinsbuyreq() {
  clear_has_useryycoinsbuyreq();
  ::pp::UserYYCoinsBuyReq* temp = useryycoinsbuyreq_;
  useryycoinsbuyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsbuyreq(::pp::UserYYCoinsBuyReq* useryycoinsbuyreq) {
  delete useryycoinsbuyreq_;
  useryycoinsbuyreq_ = useryycoinsbuyreq;
  if (useryycoinsbuyreq) {
    set_has_useryycoinsbuyreq();
  } else {
    clear_has_useryycoinsbuyreq();
  }
}

// optional .pp.UserYYCoinsBuyRes userYYCoinsBuyRes = 2834;
inline bool ProtoBody::has_useryycoinsbuyres() const {
  return (_has_bits_[3] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_useryycoinsbuyres() {
  _has_bits_[3] |= 0x00000100u;
}
inline void ProtoBody::clear_has_useryycoinsbuyres() {
  _has_bits_[3] &= ~0x00000100u;
}
inline void ProtoBody::clear_useryycoinsbuyres() {
  if (useryycoinsbuyres_ != NULL) useryycoinsbuyres_->::pp::UserYYCoinsBuyRes::Clear();
  clear_has_useryycoinsbuyres();
}
inline const ::pp::UserYYCoinsBuyRes& ProtoBody::useryycoinsbuyres() const {
  return useryycoinsbuyres_ != NULL ? *useryycoinsbuyres_ : *default_instance_->useryycoinsbuyres_;
}
inline ::pp::UserYYCoinsBuyRes* ProtoBody::mutable_useryycoinsbuyres() {
  set_has_useryycoinsbuyres();
  if (useryycoinsbuyres_ == NULL) useryycoinsbuyres_ = new ::pp::UserYYCoinsBuyRes;
  return useryycoinsbuyres_;
}
inline ::pp::UserYYCoinsBuyRes* ProtoBody::release_useryycoinsbuyres() {
  clear_has_useryycoinsbuyres();
  ::pp::UserYYCoinsBuyRes* temp = useryycoinsbuyres_;
  useryycoinsbuyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsbuyres(::pp::UserYYCoinsBuyRes* useryycoinsbuyres) {
  delete useryycoinsbuyres_;
  useryycoinsbuyres_ = useryycoinsbuyres;
  if (useryycoinsbuyres) {
    set_has_useryycoinsbuyres();
  } else {
    clear_has_useryycoinsbuyres();
  }
}

// optional .pp.UserYYCoinsBuyFeedbackReq userYYCoinsBuyFeedbackReq = 2835;
inline bool ProtoBody::has_useryycoinsbuyfeedbackreq() const {
  return (_has_bits_[3] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_useryycoinsbuyfeedbackreq() {
  _has_bits_[3] |= 0x00000200u;
}
inline void ProtoBody::clear_has_useryycoinsbuyfeedbackreq() {
  _has_bits_[3] &= ~0x00000200u;
}
inline void ProtoBody::clear_useryycoinsbuyfeedbackreq() {
  if (useryycoinsbuyfeedbackreq_ != NULL) useryycoinsbuyfeedbackreq_->::pp::UserYYCoinsBuyFeedbackReq::Clear();
  clear_has_useryycoinsbuyfeedbackreq();
}
inline const ::pp::UserYYCoinsBuyFeedbackReq& ProtoBody::useryycoinsbuyfeedbackreq() const {
  return useryycoinsbuyfeedbackreq_ != NULL ? *useryycoinsbuyfeedbackreq_ : *default_instance_->useryycoinsbuyfeedbackreq_;
}
inline ::pp::UserYYCoinsBuyFeedbackReq* ProtoBody::mutable_useryycoinsbuyfeedbackreq() {
  set_has_useryycoinsbuyfeedbackreq();
  if (useryycoinsbuyfeedbackreq_ == NULL) useryycoinsbuyfeedbackreq_ = new ::pp::UserYYCoinsBuyFeedbackReq;
  return useryycoinsbuyfeedbackreq_;
}
inline ::pp::UserYYCoinsBuyFeedbackReq* ProtoBody::release_useryycoinsbuyfeedbackreq() {
  clear_has_useryycoinsbuyfeedbackreq();
  ::pp::UserYYCoinsBuyFeedbackReq* temp = useryycoinsbuyfeedbackreq_;
  useryycoinsbuyfeedbackreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsbuyfeedbackreq(::pp::UserYYCoinsBuyFeedbackReq* useryycoinsbuyfeedbackreq) {
  delete useryycoinsbuyfeedbackreq_;
  useryycoinsbuyfeedbackreq_ = useryycoinsbuyfeedbackreq;
  if (useryycoinsbuyfeedbackreq) {
    set_has_useryycoinsbuyfeedbackreq();
  } else {
    clear_has_useryycoinsbuyfeedbackreq();
  }
}

// optional .pp.UserYYCoinsBuyFeedbackRes userYYCoinsBuyFeedbackRes = 2836;
inline bool ProtoBody::has_useryycoinsbuyfeedbackres() const {
  return (_has_bits_[3] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_useryycoinsbuyfeedbackres() {
  _has_bits_[3] |= 0x00000400u;
}
inline void ProtoBody::clear_has_useryycoinsbuyfeedbackres() {
  _has_bits_[3] &= ~0x00000400u;
}
inline void ProtoBody::clear_useryycoinsbuyfeedbackres() {
  if (useryycoinsbuyfeedbackres_ != NULL) useryycoinsbuyfeedbackres_->::pp::UserYYCoinsBuyFeedbackRes::Clear();
  clear_has_useryycoinsbuyfeedbackres();
}
inline const ::pp::UserYYCoinsBuyFeedbackRes& ProtoBody::useryycoinsbuyfeedbackres() const {
  return useryycoinsbuyfeedbackres_ != NULL ? *useryycoinsbuyfeedbackres_ : *default_instance_->useryycoinsbuyfeedbackres_;
}
inline ::pp::UserYYCoinsBuyFeedbackRes* ProtoBody::mutable_useryycoinsbuyfeedbackres() {
  set_has_useryycoinsbuyfeedbackres();
  if (useryycoinsbuyfeedbackres_ == NULL) useryycoinsbuyfeedbackres_ = new ::pp::UserYYCoinsBuyFeedbackRes;
  return useryycoinsbuyfeedbackres_;
}
inline ::pp::UserYYCoinsBuyFeedbackRes* ProtoBody::release_useryycoinsbuyfeedbackres() {
  clear_has_useryycoinsbuyfeedbackres();
  ::pp::UserYYCoinsBuyFeedbackRes* temp = useryycoinsbuyfeedbackres_;
  useryycoinsbuyfeedbackres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinsbuyfeedbackres(::pp::UserYYCoinsBuyFeedbackRes* useryycoinsbuyfeedbackres) {
  delete useryycoinsbuyfeedbackres_;
  useryycoinsbuyfeedbackres_ = useryycoinsbuyfeedbackres;
  if (useryycoinsbuyfeedbackres) {
    set_has_useryycoinsbuyfeedbackres();
  } else {
    clear_has_useryycoinsbuyfeedbackres();
  }
}

// optional .pp.UserYYCoinsHistoryReq userYYCoinsHistoryReq = 2837;
inline bool ProtoBody::has_useryycoinshistoryreq() const {
  return (_has_bits_[3] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_useryycoinshistoryreq() {
  _has_bits_[3] |= 0x00000800u;
}
inline void ProtoBody::clear_has_useryycoinshistoryreq() {
  _has_bits_[3] &= ~0x00000800u;
}
inline void ProtoBody::clear_useryycoinshistoryreq() {
  if (useryycoinshistoryreq_ != NULL) useryycoinshistoryreq_->::pp::UserYYCoinsHistoryReq::Clear();
  clear_has_useryycoinshistoryreq();
}
inline const ::pp::UserYYCoinsHistoryReq& ProtoBody::useryycoinshistoryreq() const {
  return useryycoinshistoryreq_ != NULL ? *useryycoinshistoryreq_ : *default_instance_->useryycoinshistoryreq_;
}
inline ::pp::UserYYCoinsHistoryReq* ProtoBody::mutable_useryycoinshistoryreq() {
  set_has_useryycoinshistoryreq();
  if (useryycoinshistoryreq_ == NULL) useryycoinshistoryreq_ = new ::pp::UserYYCoinsHistoryReq;
  return useryycoinshistoryreq_;
}
inline ::pp::UserYYCoinsHistoryReq* ProtoBody::release_useryycoinshistoryreq() {
  clear_has_useryycoinshistoryreq();
  ::pp::UserYYCoinsHistoryReq* temp = useryycoinshistoryreq_;
  useryycoinshistoryreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinshistoryreq(::pp::UserYYCoinsHistoryReq* useryycoinshistoryreq) {
  delete useryycoinshistoryreq_;
  useryycoinshistoryreq_ = useryycoinshistoryreq;
  if (useryycoinshistoryreq) {
    set_has_useryycoinshistoryreq();
  } else {
    clear_has_useryycoinshistoryreq();
  }
}

// optional .pp.UserYYCoinsHistoryRes userYYCoinsHistoryRes = 2838;
inline bool ProtoBody::has_useryycoinshistoryres() const {
  return (_has_bits_[3] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_useryycoinshistoryres() {
  _has_bits_[3] |= 0x00001000u;
}
inline void ProtoBody::clear_has_useryycoinshistoryres() {
  _has_bits_[3] &= ~0x00001000u;
}
inline void ProtoBody::clear_useryycoinshistoryres() {
  if (useryycoinshistoryres_ != NULL) useryycoinshistoryres_->::pp::UserYYCoinsHistoryRes::Clear();
  clear_has_useryycoinshistoryres();
}
inline const ::pp::UserYYCoinsHistoryRes& ProtoBody::useryycoinshistoryres() const {
  return useryycoinshistoryres_ != NULL ? *useryycoinshistoryres_ : *default_instance_->useryycoinshistoryres_;
}
inline ::pp::UserYYCoinsHistoryRes* ProtoBody::mutable_useryycoinshistoryres() {
  set_has_useryycoinshistoryres();
  if (useryycoinshistoryres_ == NULL) useryycoinshistoryres_ = new ::pp::UserYYCoinsHistoryRes;
  return useryycoinshistoryres_;
}
inline ::pp::UserYYCoinsHistoryRes* ProtoBody::release_useryycoinshistoryres() {
  clear_has_useryycoinshistoryres();
  ::pp::UserYYCoinsHistoryRes* temp = useryycoinshistoryres_;
  useryycoinshistoryres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinshistoryres(::pp::UserYYCoinsHistoryRes* useryycoinshistoryres) {
  delete useryycoinshistoryres_;
  useryycoinshistoryres_ = useryycoinshistoryres;
  if (useryycoinshistoryres) {
    set_has_useryycoinshistoryres();
  } else {
    clear_has_useryycoinshistoryres();
  }
}

// optional .pp.UserYYCoinsPayGateCallbackReq userYYCoinsPayGateCallbackReq = 2839;
inline bool ProtoBody::has_useryycoinspaygatecallbackreq() const {
  return (_has_bits_[3] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_useryycoinspaygatecallbackreq() {
  _has_bits_[3] |= 0x00002000u;
}
inline void ProtoBody::clear_has_useryycoinspaygatecallbackreq() {
  _has_bits_[3] &= ~0x00002000u;
}
inline void ProtoBody::clear_useryycoinspaygatecallbackreq() {
  if (useryycoinspaygatecallbackreq_ != NULL) useryycoinspaygatecallbackreq_->::pp::UserYYCoinsPayGateCallbackReq::Clear();
  clear_has_useryycoinspaygatecallbackreq();
}
inline const ::pp::UserYYCoinsPayGateCallbackReq& ProtoBody::useryycoinspaygatecallbackreq() const {
  return useryycoinspaygatecallbackreq_ != NULL ? *useryycoinspaygatecallbackreq_ : *default_instance_->useryycoinspaygatecallbackreq_;
}
inline ::pp::UserYYCoinsPayGateCallbackReq* ProtoBody::mutable_useryycoinspaygatecallbackreq() {
  set_has_useryycoinspaygatecallbackreq();
  if (useryycoinspaygatecallbackreq_ == NULL) useryycoinspaygatecallbackreq_ = new ::pp::UserYYCoinsPayGateCallbackReq;
  return useryycoinspaygatecallbackreq_;
}
inline ::pp::UserYYCoinsPayGateCallbackReq* ProtoBody::release_useryycoinspaygatecallbackreq() {
  clear_has_useryycoinspaygatecallbackreq();
  ::pp::UserYYCoinsPayGateCallbackReq* temp = useryycoinspaygatecallbackreq_;
  useryycoinspaygatecallbackreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useryycoinspaygatecallbackreq(::pp::UserYYCoinsPayGateCallbackReq* useryycoinspaygatecallbackreq) {
  delete useryycoinspaygatecallbackreq_;
  useryycoinspaygatecallbackreq_ = useryycoinspaygatecallbackreq;
  if (useryycoinspaygatecallbackreq) {
    set_has_useryycoinspaygatecallbackreq();
  } else {
    clear_has_useryycoinspaygatecallbackreq();
  }
}

// optional .pp.GroupApplyReq groupApplyReq = 1282;
inline bool ProtoBody::has_groupapplyreq() const {
  return (_has_bits_[3] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_groupapplyreq() {
  _has_bits_[3] |= 0x00004000u;
}
inline void ProtoBody::clear_has_groupapplyreq() {
  _has_bits_[3] &= ~0x00004000u;
}
inline void ProtoBody::clear_groupapplyreq() {
  if (groupapplyreq_ != NULL) groupapplyreq_->::pp::GroupApplyReq::Clear();
  clear_has_groupapplyreq();
}
inline const ::pp::GroupApplyReq& ProtoBody::groupapplyreq() const {
  return groupapplyreq_ != NULL ? *groupapplyreq_ : *default_instance_->groupapplyreq_;
}
inline ::pp::GroupApplyReq* ProtoBody::mutable_groupapplyreq() {
  set_has_groupapplyreq();
  if (groupapplyreq_ == NULL) groupapplyreq_ = new ::pp::GroupApplyReq;
  return groupapplyreq_;
}
inline ::pp::GroupApplyReq* ProtoBody::release_groupapplyreq() {
  clear_has_groupapplyreq();
  ::pp::GroupApplyReq* temp = groupapplyreq_;
  groupapplyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupapplyreq(::pp::GroupApplyReq* groupapplyreq) {
  delete groupapplyreq_;
  groupapplyreq_ = groupapplyreq;
  if (groupapplyreq) {
    set_has_groupapplyreq();
  } else {
    clear_has_groupapplyreq();
  }
}

// optional .pp.GroupApplyRes groupApplyRes = 1283;
inline bool ProtoBody::has_groupapplyres() const {
  return (_has_bits_[3] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_groupapplyres() {
  _has_bits_[3] |= 0x00008000u;
}
inline void ProtoBody::clear_has_groupapplyres() {
  _has_bits_[3] &= ~0x00008000u;
}
inline void ProtoBody::clear_groupapplyres() {
  if (groupapplyres_ != NULL) groupapplyres_->::pp::GroupApplyRes::Clear();
  clear_has_groupapplyres();
}
inline const ::pp::GroupApplyRes& ProtoBody::groupapplyres() const {
  return groupapplyres_ != NULL ? *groupapplyres_ : *default_instance_->groupapplyres_;
}
inline ::pp::GroupApplyRes* ProtoBody::mutable_groupapplyres() {
  set_has_groupapplyres();
  if (groupapplyres_ == NULL) groupapplyres_ = new ::pp::GroupApplyRes;
  return groupapplyres_;
}
inline ::pp::GroupApplyRes* ProtoBody::release_groupapplyres() {
  clear_has_groupapplyres();
  ::pp::GroupApplyRes* temp = groupapplyres_;
  groupapplyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupapplyres(::pp::GroupApplyRes* groupapplyres) {
  delete groupapplyres_;
  groupapplyres_ = groupapplyres;
  if (groupapplyres) {
    set_has_groupapplyres();
  } else {
    clear_has_groupapplyres();
  }
}

// optional .pp.GroupCheckinReq groupCheckinReq = 1284;
inline bool ProtoBody::has_groupcheckinreq() const {
  return (_has_bits_[3] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_groupcheckinreq() {
  _has_bits_[3] |= 0x00010000u;
}
inline void ProtoBody::clear_has_groupcheckinreq() {
  _has_bits_[3] &= ~0x00010000u;
}
inline void ProtoBody::clear_groupcheckinreq() {
  if (groupcheckinreq_ != NULL) groupcheckinreq_->::pp::GroupCheckinReq::Clear();
  clear_has_groupcheckinreq();
}
inline const ::pp::GroupCheckinReq& ProtoBody::groupcheckinreq() const {
  return groupcheckinreq_ != NULL ? *groupcheckinreq_ : *default_instance_->groupcheckinreq_;
}
inline ::pp::GroupCheckinReq* ProtoBody::mutable_groupcheckinreq() {
  set_has_groupcheckinreq();
  if (groupcheckinreq_ == NULL) groupcheckinreq_ = new ::pp::GroupCheckinReq;
  return groupcheckinreq_;
}
inline ::pp::GroupCheckinReq* ProtoBody::release_groupcheckinreq() {
  clear_has_groupcheckinreq();
  ::pp::GroupCheckinReq* temp = groupcheckinreq_;
  groupcheckinreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupcheckinreq(::pp::GroupCheckinReq* groupcheckinreq) {
  delete groupcheckinreq_;
  groupcheckinreq_ = groupcheckinreq;
  if (groupcheckinreq) {
    set_has_groupcheckinreq();
  } else {
    clear_has_groupcheckinreq();
  }
}

// optional .pp.GroupCheckinRes groupCheckinRes = 1285;
inline bool ProtoBody::has_groupcheckinres() const {
  return (_has_bits_[3] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_groupcheckinres() {
  _has_bits_[3] |= 0x00020000u;
}
inline void ProtoBody::clear_has_groupcheckinres() {
  _has_bits_[3] &= ~0x00020000u;
}
inline void ProtoBody::clear_groupcheckinres() {
  if (groupcheckinres_ != NULL) groupcheckinres_->::pp::GroupCheckinRes::Clear();
  clear_has_groupcheckinres();
}
inline const ::pp::GroupCheckinRes& ProtoBody::groupcheckinres() const {
  return groupcheckinres_ != NULL ? *groupcheckinres_ : *default_instance_->groupcheckinres_;
}
inline ::pp::GroupCheckinRes* ProtoBody::mutable_groupcheckinres() {
  set_has_groupcheckinres();
  if (groupcheckinres_ == NULL) groupcheckinres_ = new ::pp::GroupCheckinRes;
  return groupcheckinres_;
}
inline ::pp::GroupCheckinRes* ProtoBody::release_groupcheckinres() {
  clear_has_groupcheckinres();
  ::pp::GroupCheckinRes* temp = groupcheckinres_;
  groupcheckinres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupcheckinres(::pp::GroupCheckinRes* groupcheckinres) {
  delete groupcheckinres_;
  groupcheckinres_ = groupcheckinres;
  if (groupcheckinres) {
    set_has_groupcheckinres();
  } else {
    clear_has_groupcheckinres();
  }
}

// optional .pp.GroupQuitReq groupQuitReq = 1286;
inline bool ProtoBody::has_groupquitreq() const {
  return (_has_bits_[3] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_groupquitreq() {
  _has_bits_[3] |= 0x00040000u;
}
inline void ProtoBody::clear_has_groupquitreq() {
  _has_bits_[3] &= ~0x00040000u;
}
inline void ProtoBody::clear_groupquitreq() {
  if (groupquitreq_ != NULL) groupquitreq_->::pp::GroupQuitReq::Clear();
  clear_has_groupquitreq();
}
inline const ::pp::GroupQuitReq& ProtoBody::groupquitreq() const {
  return groupquitreq_ != NULL ? *groupquitreq_ : *default_instance_->groupquitreq_;
}
inline ::pp::GroupQuitReq* ProtoBody::mutable_groupquitreq() {
  set_has_groupquitreq();
  if (groupquitreq_ == NULL) groupquitreq_ = new ::pp::GroupQuitReq;
  return groupquitreq_;
}
inline ::pp::GroupQuitReq* ProtoBody::release_groupquitreq() {
  clear_has_groupquitreq();
  ::pp::GroupQuitReq* temp = groupquitreq_;
  groupquitreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupquitreq(::pp::GroupQuitReq* groupquitreq) {
  delete groupquitreq_;
  groupquitreq_ = groupquitreq;
  if (groupquitreq) {
    set_has_groupquitreq();
  } else {
    clear_has_groupquitreq();
  }
}

// optional .pp.GroupInfoReq groupInfoReq = 1288;
inline bool ProtoBody::has_groupinforeq() const {
  return (_has_bits_[3] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_groupinforeq() {
  _has_bits_[3] |= 0x00080000u;
}
inline void ProtoBody::clear_has_groupinforeq() {
  _has_bits_[3] &= ~0x00080000u;
}
inline void ProtoBody::clear_groupinforeq() {
  if (groupinforeq_ != NULL) groupinforeq_->::pp::GroupInfoReq::Clear();
  clear_has_groupinforeq();
}
inline const ::pp::GroupInfoReq& ProtoBody::groupinforeq() const {
  return groupinforeq_ != NULL ? *groupinforeq_ : *default_instance_->groupinforeq_;
}
inline ::pp::GroupInfoReq* ProtoBody::mutable_groupinforeq() {
  set_has_groupinforeq();
  if (groupinforeq_ == NULL) groupinforeq_ = new ::pp::GroupInfoReq;
  return groupinforeq_;
}
inline ::pp::GroupInfoReq* ProtoBody::release_groupinforeq() {
  clear_has_groupinforeq();
  ::pp::GroupInfoReq* temp = groupinforeq_;
  groupinforeq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupinforeq(::pp::GroupInfoReq* groupinforeq) {
  delete groupinforeq_;
  groupinforeq_ = groupinforeq;
  if (groupinforeq) {
    set_has_groupinforeq();
  } else {
    clear_has_groupinforeq();
  }
}

// optional .pp.GroupSearchReq groupSearchReq = 1292;
inline bool ProtoBody::has_groupsearchreq() const {
  return (_has_bits_[3] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_groupsearchreq() {
  _has_bits_[3] |= 0x00100000u;
}
inline void ProtoBody::clear_has_groupsearchreq() {
  _has_bits_[3] &= ~0x00100000u;
}
inline void ProtoBody::clear_groupsearchreq() {
  if (groupsearchreq_ != NULL) groupsearchreq_->::pp::GroupSearchReq::Clear();
  clear_has_groupsearchreq();
}
inline const ::pp::GroupSearchReq& ProtoBody::groupsearchreq() const {
  return groupsearchreq_ != NULL ? *groupsearchreq_ : *default_instance_->groupsearchreq_;
}
inline ::pp::GroupSearchReq* ProtoBody::mutable_groupsearchreq() {
  set_has_groupsearchreq();
  if (groupsearchreq_ == NULL) groupsearchreq_ = new ::pp::GroupSearchReq;
  return groupsearchreq_;
}
inline ::pp::GroupSearchReq* ProtoBody::release_groupsearchreq() {
  clear_has_groupsearchreq();
  ::pp::GroupSearchReq* temp = groupsearchreq_;
  groupsearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupsearchreq(::pp::GroupSearchReq* groupsearchreq) {
  delete groupsearchreq_;
  groupsearchreq_ = groupsearchreq;
  if (groupsearchreq) {
    set_has_groupsearchreq();
  } else {
    clear_has_groupsearchreq();
  }
}

// optional .pp.GroupSearchRes groupSearchRes = 1293;
inline bool ProtoBody::has_groupsearchres() const {
  return (_has_bits_[3] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_groupsearchres() {
  _has_bits_[3] |= 0x00200000u;
}
inline void ProtoBody::clear_has_groupsearchres() {
  _has_bits_[3] &= ~0x00200000u;
}
inline void ProtoBody::clear_groupsearchres() {
  if (groupsearchres_ != NULL) groupsearchres_->::pp::GroupSearchRes::Clear();
  clear_has_groupsearchres();
}
inline const ::pp::GroupSearchRes& ProtoBody::groupsearchres() const {
  return groupsearchres_ != NULL ? *groupsearchres_ : *default_instance_->groupsearchres_;
}
inline ::pp::GroupSearchRes* ProtoBody::mutable_groupsearchres() {
  set_has_groupsearchres();
  if (groupsearchres_ == NULL) groupsearchres_ = new ::pp::GroupSearchRes;
  return groupsearchres_;
}
inline ::pp::GroupSearchRes* ProtoBody::release_groupsearchres() {
  clear_has_groupsearchres();
  ::pp::GroupSearchRes* temp = groupsearchres_;
  groupsearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupsearchres(::pp::GroupSearchRes* groupsearchres) {
  delete groupsearchres_;
  groupsearchres_ = groupsearchres;
  if (groupsearchres) {
    set_has_groupsearchres();
  } else {
    clear_has_groupsearchres();
  }
}

// optional .pp.GroupSearchKeywordsReq groupSearchKeywordsReq = 1294;
inline bool ProtoBody::has_groupsearchkeywordsreq() const {
  return (_has_bits_[3] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_groupsearchkeywordsreq() {
  _has_bits_[3] |= 0x00400000u;
}
inline void ProtoBody::clear_has_groupsearchkeywordsreq() {
  _has_bits_[3] &= ~0x00400000u;
}
inline void ProtoBody::clear_groupsearchkeywordsreq() {
  if (groupsearchkeywordsreq_ != NULL) groupsearchkeywordsreq_->::pp::GroupSearchKeywordsReq::Clear();
  clear_has_groupsearchkeywordsreq();
}
inline const ::pp::GroupSearchKeywordsReq& ProtoBody::groupsearchkeywordsreq() const {
  return groupsearchkeywordsreq_ != NULL ? *groupsearchkeywordsreq_ : *default_instance_->groupsearchkeywordsreq_;
}
inline ::pp::GroupSearchKeywordsReq* ProtoBody::mutable_groupsearchkeywordsreq() {
  set_has_groupsearchkeywordsreq();
  if (groupsearchkeywordsreq_ == NULL) groupsearchkeywordsreq_ = new ::pp::GroupSearchKeywordsReq;
  return groupsearchkeywordsreq_;
}
inline ::pp::GroupSearchKeywordsReq* ProtoBody::release_groupsearchkeywordsreq() {
  clear_has_groupsearchkeywordsreq();
  ::pp::GroupSearchKeywordsReq* temp = groupsearchkeywordsreq_;
  groupsearchkeywordsreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupsearchkeywordsreq(::pp::GroupSearchKeywordsReq* groupsearchkeywordsreq) {
  delete groupsearchkeywordsreq_;
  groupsearchkeywordsreq_ = groupsearchkeywordsreq;
  if (groupsearchkeywordsreq) {
    set_has_groupsearchkeywordsreq();
  } else {
    clear_has_groupsearchkeywordsreq();
  }
}

// optional .pp.GroupSearchKeywordsRes groupSearchKeywordsRes = 1295;
inline bool ProtoBody::has_groupsearchkeywordsres() const {
  return (_has_bits_[3] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_groupsearchkeywordsres() {
  _has_bits_[3] |= 0x00800000u;
}
inline void ProtoBody::clear_has_groupsearchkeywordsres() {
  _has_bits_[3] &= ~0x00800000u;
}
inline void ProtoBody::clear_groupsearchkeywordsres() {
  if (groupsearchkeywordsres_ != NULL) groupsearchkeywordsres_->::pp::GroupSearchKeywordsRes::Clear();
  clear_has_groupsearchkeywordsres();
}
inline const ::pp::GroupSearchKeywordsRes& ProtoBody::groupsearchkeywordsres() const {
  return groupsearchkeywordsres_ != NULL ? *groupsearchkeywordsres_ : *default_instance_->groupsearchkeywordsres_;
}
inline ::pp::GroupSearchKeywordsRes* ProtoBody::mutable_groupsearchkeywordsres() {
  set_has_groupsearchkeywordsres();
  if (groupsearchkeywordsres_ == NULL) groupsearchkeywordsres_ = new ::pp::GroupSearchKeywordsRes;
  return groupsearchkeywordsres_;
}
inline ::pp::GroupSearchKeywordsRes* ProtoBody::release_groupsearchkeywordsres() {
  clear_has_groupsearchkeywordsres();
  ::pp::GroupSearchKeywordsRes* temp = groupsearchkeywordsres_;
  groupsearchkeywordsres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupsearchkeywordsres(::pp::GroupSearchKeywordsRes* groupsearchkeywordsres) {
  delete groupsearchkeywordsres_;
  groupsearchkeywordsres_ = groupsearchkeywordsres;
  if (groupsearchkeywordsres) {
    set_has_groupsearchkeywordsres();
  } else {
    clear_has_groupsearchkeywordsres();
  }
}

// optional .pp.GroupListReq groupListReq = 1296;
inline bool ProtoBody::has_grouplistreq() const {
  return (_has_bits_[3] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_grouplistreq() {
  _has_bits_[3] |= 0x01000000u;
}
inline void ProtoBody::clear_has_grouplistreq() {
  _has_bits_[3] &= ~0x01000000u;
}
inline void ProtoBody::clear_grouplistreq() {
  if (grouplistreq_ != NULL) grouplistreq_->::pp::GroupListReq::Clear();
  clear_has_grouplistreq();
}
inline const ::pp::GroupListReq& ProtoBody::grouplistreq() const {
  return grouplistreq_ != NULL ? *grouplistreq_ : *default_instance_->grouplistreq_;
}
inline ::pp::GroupListReq* ProtoBody::mutable_grouplistreq() {
  set_has_grouplistreq();
  if (grouplistreq_ == NULL) grouplistreq_ = new ::pp::GroupListReq;
  return grouplistreq_;
}
inline ::pp::GroupListReq* ProtoBody::release_grouplistreq() {
  clear_has_grouplistreq();
  ::pp::GroupListReq* temp = grouplistreq_;
  grouplistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouplistreq(::pp::GroupListReq* grouplistreq) {
  delete grouplistreq_;
  grouplistreq_ = grouplistreq;
  if (grouplistreq) {
    set_has_grouplistreq();
  } else {
    clear_has_grouplistreq();
  }
}

// optional .pp.GroupListRes groupListRes = 1297;
inline bool ProtoBody::has_grouplistres() const {
  return (_has_bits_[3] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_grouplistres() {
  _has_bits_[3] |= 0x02000000u;
}
inline void ProtoBody::clear_has_grouplistres() {
  _has_bits_[3] &= ~0x02000000u;
}
inline void ProtoBody::clear_grouplistres() {
  if (grouplistres_ != NULL) grouplistres_->::pp::GroupListRes::Clear();
  clear_has_grouplistres();
}
inline const ::pp::GroupListRes& ProtoBody::grouplistres() const {
  return grouplistres_ != NULL ? *grouplistres_ : *default_instance_->grouplistres_;
}
inline ::pp::GroupListRes* ProtoBody::mutable_grouplistres() {
  set_has_grouplistres();
  if (grouplistres_ == NULL) grouplistres_ = new ::pp::GroupListRes;
  return grouplistres_;
}
inline ::pp::GroupListRes* ProtoBody::release_grouplistres() {
  clear_has_grouplistres();
  ::pp::GroupListRes* temp = grouplistres_;
  grouplistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouplistres(::pp::GroupListRes* grouplistres) {
  delete grouplistres_;
  grouplistres_ = grouplistres;
  if (grouplistres) {
    set_has_grouplistres();
  } else {
    clear_has_grouplistres();
  }
}

// optional .pp.GroupApproveReq groupApproveReq = 1312;
inline bool ProtoBody::has_groupapprovereq() const {
  return (_has_bits_[3] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_groupapprovereq() {
  _has_bits_[3] |= 0x04000000u;
}
inline void ProtoBody::clear_has_groupapprovereq() {
  _has_bits_[3] &= ~0x04000000u;
}
inline void ProtoBody::clear_groupapprovereq() {
  if (groupapprovereq_ != NULL) groupapprovereq_->::pp::GroupApproveReq::Clear();
  clear_has_groupapprovereq();
}
inline const ::pp::GroupApproveReq& ProtoBody::groupapprovereq() const {
  return groupapprovereq_ != NULL ? *groupapprovereq_ : *default_instance_->groupapprovereq_;
}
inline ::pp::GroupApproveReq* ProtoBody::mutable_groupapprovereq() {
  set_has_groupapprovereq();
  if (groupapprovereq_ == NULL) groupapprovereq_ = new ::pp::GroupApproveReq;
  return groupapprovereq_;
}
inline ::pp::GroupApproveReq* ProtoBody::release_groupapprovereq() {
  clear_has_groupapprovereq();
  ::pp::GroupApproveReq* temp = groupapprovereq_;
  groupapprovereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupapprovereq(::pp::GroupApproveReq* groupapprovereq) {
  delete groupapprovereq_;
  groupapprovereq_ = groupapprovereq;
  if (groupapprovereq) {
    set_has_groupapprovereq();
  } else {
    clear_has_groupapprovereq();
  }
}

// optional .pp.GroupApproveRes groupApproveRes = 1313;
inline bool ProtoBody::has_groupapproveres() const {
  return (_has_bits_[3] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_groupapproveres() {
  _has_bits_[3] |= 0x08000000u;
}
inline void ProtoBody::clear_has_groupapproveres() {
  _has_bits_[3] &= ~0x08000000u;
}
inline void ProtoBody::clear_groupapproveres() {
  if (groupapproveres_ != NULL) groupapproveres_->::pp::GroupApproveRes::Clear();
  clear_has_groupapproveres();
}
inline const ::pp::GroupApproveRes& ProtoBody::groupapproveres() const {
  return groupapproveres_ != NULL ? *groupapproveres_ : *default_instance_->groupapproveres_;
}
inline ::pp::GroupApproveRes* ProtoBody::mutable_groupapproveres() {
  set_has_groupapproveres();
  if (groupapproveres_ == NULL) groupapproveres_ = new ::pp::GroupApproveRes;
  return groupapproveres_;
}
inline ::pp::GroupApproveRes* ProtoBody::release_groupapproveres() {
  clear_has_groupapproveres();
  ::pp::GroupApproveRes* temp = groupapproveres_;
  groupapproveres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupapproveres(::pp::GroupApproveRes* groupapproveres) {
  delete groupapproveres_;
  groupapproveres_ = groupapproveres;
  if (groupapproveres) {
    set_has_groupapproveres();
  } else {
    clear_has_groupapproveres();
  }
}

// optional .pp.GroupLobbyOrderModifyReq groupLobbyOrderModifyReq = 1334;
inline bool ProtoBody::has_grouplobbyordermodifyreq() const {
  return (_has_bits_[3] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_grouplobbyordermodifyreq() {
  _has_bits_[3] |= 0x10000000u;
}
inline void ProtoBody::clear_has_grouplobbyordermodifyreq() {
  _has_bits_[3] &= ~0x10000000u;
}
inline void ProtoBody::clear_grouplobbyordermodifyreq() {
  if (grouplobbyordermodifyreq_ != NULL) grouplobbyordermodifyreq_->::pp::GroupLobbyOrderModifyReq::Clear();
  clear_has_grouplobbyordermodifyreq();
}
inline const ::pp::GroupLobbyOrderModifyReq& ProtoBody::grouplobbyordermodifyreq() const {
  return grouplobbyordermodifyreq_ != NULL ? *grouplobbyordermodifyreq_ : *default_instance_->grouplobbyordermodifyreq_;
}
inline ::pp::GroupLobbyOrderModifyReq* ProtoBody::mutable_grouplobbyordermodifyreq() {
  set_has_grouplobbyordermodifyreq();
  if (grouplobbyordermodifyreq_ == NULL) grouplobbyordermodifyreq_ = new ::pp::GroupLobbyOrderModifyReq;
  return grouplobbyordermodifyreq_;
}
inline ::pp::GroupLobbyOrderModifyReq* ProtoBody::release_grouplobbyordermodifyreq() {
  clear_has_grouplobbyordermodifyreq();
  ::pp::GroupLobbyOrderModifyReq* temp = grouplobbyordermodifyreq_;
  grouplobbyordermodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouplobbyordermodifyreq(::pp::GroupLobbyOrderModifyReq* grouplobbyordermodifyreq) {
  delete grouplobbyordermodifyreq_;
  grouplobbyordermodifyreq_ = grouplobbyordermodifyreq;
  if (grouplobbyordermodifyreq) {
    set_has_grouplobbyordermodifyreq();
  } else {
    clear_has_grouplobbyordermodifyreq();
  }
}

// optional .pp.GroupLobbyOrderModifyRes groupLobbyOrderModifyRes = 1335;
inline bool ProtoBody::has_grouplobbyordermodifyres() const {
  return (_has_bits_[3] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_grouplobbyordermodifyres() {
  _has_bits_[3] |= 0x20000000u;
}
inline void ProtoBody::clear_has_grouplobbyordermodifyres() {
  _has_bits_[3] &= ~0x20000000u;
}
inline void ProtoBody::clear_grouplobbyordermodifyres() {
  if (grouplobbyordermodifyres_ != NULL) grouplobbyordermodifyres_->::pp::GroupLobbyOrderModifyRes::Clear();
  clear_has_grouplobbyordermodifyres();
}
inline const ::pp::GroupLobbyOrderModifyRes& ProtoBody::grouplobbyordermodifyres() const {
  return grouplobbyordermodifyres_ != NULL ? *grouplobbyordermodifyres_ : *default_instance_->grouplobbyordermodifyres_;
}
inline ::pp::GroupLobbyOrderModifyRes* ProtoBody::mutable_grouplobbyordermodifyres() {
  set_has_grouplobbyordermodifyres();
  if (grouplobbyordermodifyres_ == NULL) grouplobbyordermodifyres_ = new ::pp::GroupLobbyOrderModifyRes;
  return grouplobbyordermodifyres_;
}
inline ::pp::GroupLobbyOrderModifyRes* ProtoBody::release_grouplobbyordermodifyres() {
  clear_has_grouplobbyordermodifyres();
  ::pp::GroupLobbyOrderModifyRes* temp = grouplobbyordermodifyres_;
  grouplobbyordermodifyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouplobbyordermodifyres(::pp::GroupLobbyOrderModifyRes* grouplobbyordermodifyres) {
  delete grouplobbyordermodifyres_;
  grouplobbyordermodifyres_ = grouplobbyordermodifyres;
  if (grouplobbyordermodifyres) {
    set_has_grouplobbyordermodifyres();
  } else {
    clear_has_grouplobbyordermodifyres();
  }
}

// optional .pp.GroupTeamOpReq groupTeamOpReq = 1383;
inline bool ProtoBody::has_groupteamopreq() const {
  return (_has_bits_[3] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_groupteamopreq() {
  _has_bits_[3] |= 0x40000000u;
}
inline void ProtoBody::clear_has_groupteamopreq() {
  _has_bits_[3] &= ~0x40000000u;
}
inline void ProtoBody::clear_groupteamopreq() {
  if (groupteamopreq_ != NULL) groupteamopreq_->::pp::GroupTeamOpReq::Clear();
  clear_has_groupteamopreq();
}
inline const ::pp::GroupTeamOpReq& ProtoBody::groupteamopreq() const {
  return groupteamopreq_ != NULL ? *groupteamopreq_ : *default_instance_->groupteamopreq_;
}
inline ::pp::GroupTeamOpReq* ProtoBody::mutable_groupteamopreq() {
  set_has_groupteamopreq();
  if (groupteamopreq_ == NULL) groupteamopreq_ = new ::pp::GroupTeamOpReq;
  return groupteamopreq_;
}
inline ::pp::GroupTeamOpReq* ProtoBody::release_groupteamopreq() {
  clear_has_groupteamopreq();
  ::pp::GroupTeamOpReq* temp = groupteamopreq_;
  groupteamopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupteamopreq(::pp::GroupTeamOpReq* groupteamopreq) {
  delete groupteamopreq_;
  groupteamopreq_ = groupteamopreq;
  if (groupteamopreq) {
    set_has_groupteamopreq();
  } else {
    clear_has_groupteamopreq();
  }
}

// optional .pp.GroupLabelOpReq groupLabelOpReq = 1385;
inline bool ProtoBody::has_grouplabelopreq() const {
  return (_has_bits_[3] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_grouplabelopreq() {
  _has_bits_[3] |= 0x80000000u;
}
inline void ProtoBody::clear_has_grouplabelopreq() {
  _has_bits_[3] &= ~0x80000000u;
}
inline void ProtoBody::clear_grouplabelopreq() {
  if (grouplabelopreq_ != NULL) grouplabelopreq_->::pp::GroupLabelOpReq::Clear();
  clear_has_grouplabelopreq();
}
inline const ::pp::GroupLabelOpReq& ProtoBody::grouplabelopreq() const {
  return grouplabelopreq_ != NULL ? *grouplabelopreq_ : *default_instance_->grouplabelopreq_;
}
inline ::pp::GroupLabelOpReq* ProtoBody::mutable_grouplabelopreq() {
  set_has_grouplabelopreq();
  if (grouplabelopreq_ == NULL) grouplabelopreq_ = new ::pp::GroupLabelOpReq;
  return grouplabelopreq_;
}
inline ::pp::GroupLabelOpReq* ProtoBody::release_grouplabelopreq() {
  clear_has_grouplabelopreq();
  ::pp::GroupLabelOpReq* temp = grouplabelopreq_;
  grouplabelopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouplabelopreq(::pp::GroupLabelOpReq* grouplabelopreq) {
  delete grouplabelopreq_;
  grouplabelopreq_ = grouplabelopreq;
  if (grouplabelopreq) {
    set_has_grouplabelopreq();
  } else {
    clear_has_grouplabelopreq();
  }
}

// optional .pp.GroupAppSendReq groupAppSendReq = 2048;
inline bool ProtoBody::has_groupappsendreq() const {
  return (_has_bits_[4] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_groupappsendreq() {
  _has_bits_[4] |= 0x00000001u;
}
inline void ProtoBody::clear_has_groupappsendreq() {
  _has_bits_[4] &= ~0x00000001u;
}
inline void ProtoBody::clear_groupappsendreq() {
  if (groupappsendreq_ != NULL) groupappsendreq_->::pp::GroupAppSendReq::Clear();
  clear_has_groupappsendreq();
}
inline const ::pp::GroupAppSendReq& ProtoBody::groupappsendreq() const {
  return groupappsendreq_ != NULL ? *groupappsendreq_ : *default_instance_->groupappsendreq_;
}
inline ::pp::GroupAppSendReq* ProtoBody::mutable_groupappsendreq() {
  set_has_groupappsendreq();
  if (groupappsendreq_ == NULL) groupappsendreq_ = new ::pp::GroupAppSendReq;
  return groupappsendreq_;
}
inline ::pp::GroupAppSendReq* ProtoBody::release_groupappsendreq() {
  clear_has_groupappsendreq();
  ::pp::GroupAppSendReq* temp = groupappsendreq_;
  groupappsendreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupappsendreq(::pp::GroupAppSendReq* groupappsendreq) {
  delete groupappsendreq_;
  groupappsendreq_ = groupappsendreq;
  if (groupappsendreq) {
    set_has_groupappsendreq();
  } else {
    clear_has_groupappsendreq();
  }
}

// optional .pp.GroupAppSendRes groupAppSendRes = 2049;
inline bool ProtoBody::has_groupappsendres() const {
  return (_has_bits_[4] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_groupappsendres() {
  _has_bits_[4] |= 0x00000002u;
}
inline void ProtoBody::clear_has_groupappsendres() {
  _has_bits_[4] &= ~0x00000002u;
}
inline void ProtoBody::clear_groupappsendres() {
  if (groupappsendres_ != NULL) groupappsendres_->::pp::GroupAppSendRes::Clear();
  clear_has_groupappsendres();
}
inline const ::pp::GroupAppSendRes& ProtoBody::groupappsendres() const {
  return groupappsendres_ != NULL ? *groupappsendres_ : *default_instance_->groupappsendres_;
}
inline ::pp::GroupAppSendRes* ProtoBody::mutable_groupappsendres() {
  set_has_groupappsendres();
  if (groupappsendres_ == NULL) groupappsendres_ = new ::pp::GroupAppSendRes;
  return groupappsendres_;
}
inline ::pp::GroupAppSendRes* ProtoBody::release_groupappsendres() {
  clear_has_groupappsendres();
  ::pp::GroupAppSendRes* temp = groupappsendres_;
  groupappsendres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupappsendres(::pp::GroupAppSendRes* groupappsendres) {
  delete groupappsendres_;
  groupappsendres_ = groupappsendres;
  if (groupappsendres) {
    set_has_groupappsendres();
  } else {
    clear_has_groupappsendres();
  }
}

// optional .pp.GroupAppListReq groupAppListReq = 2050;
inline bool ProtoBody::has_groupapplistreq() const {
  return (_has_bits_[4] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_groupapplistreq() {
  _has_bits_[4] |= 0x00000004u;
}
inline void ProtoBody::clear_has_groupapplistreq() {
  _has_bits_[4] &= ~0x00000004u;
}
inline void ProtoBody::clear_groupapplistreq() {
  if (groupapplistreq_ != NULL) groupapplistreq_->::pp::GroupAppListReq::Clear();
  clear_has_groupapplistreq();
}
inline const ::pp::GroupAppListReq& ProtoBody::groupapplistreq() const {
  return groupapplistreq_ != NULL ? *groupapplistreq_ : *default_instance_->groupapplistreq_;
}
inline ::pp::GroupAppListReq* ProtoBody::mutable_groupapplistreq() {
  set_has_groupapplistreq();
  if (groupapplistreq_ == NULL) groupapplistreq_ = new ::pp::GroupAppListReq;
  return groupapplistreq_;
}
inline ::pp::GroupAppListReq* ProtoBody::release_groupapplistreq() {
  clear_has_groupapplistreq();
  ::pp::GroupAppListReq* temp = groupapplistreq_;
  groupapplistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupapplistreq(::pp::GroupAppListReq* groupapplistreq) {
  delete groupapplistreq_;
  groupapplistreq_ = groupapplistreq;
  if (groupapplistreq) {
    set_has_groupapplistreq();
  } else {
    clear_has_groupapplistreq();
  }
}

// optional .pp.GroupAppListRes groupAppListRes = 2051;
inline bool ProtoBody::has_groupapplistres() const {
  return (_has_bits_[4] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_groupapplistres() {
  _has_bits_[4] |= 0x00000008u;
}
inline void ProtoBody::clear_has_groupapplistres() {
  _has_bits_[4] &= ~0x00000008u;
}
inline void ProtoBody::clear_groupapplistres() {
  if (groupapplistres_ != NULL) groupapplistres_->::pp::GroupAppListRes::Clear();
  clear_has_groupapplistres();
}
inline const ::pp::GroupAppListRes& ProtoBody::groupapplistres() const {
  return groupapplistres_ != NULL ? *groupapplistres_ : *default_instance_->groupapplistres_;
}
inline ::pp::GroupAppListRes* ProtoBody::mutable_groupapplistres() {
  set_has_groupapplistres();
  if (groupapplistres_ == NULL) groupapplistres_ = new ::pp::GroupAppListRes;
  return groupapplistres_;
}
inline ::pp::GroupAppListRes* ProtoBody::release_groupapplistres() {
  clear_has_groupapplistres();
  ::pp::GroupAppListRes* temp = groupapplistres_;
  groupapplistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupapplistres(::pp::GroupAppListRes* groupapplistres) {
  delete groupapplistres_;
  groupapplistres_ = groupapplistres;
  if (groupapplistres) {
    set_has_groupapplistres();
  } else {
    clear_has_groupapplistres();
  }
}

// optional .pp.GroupMsgAppReq groupMsgAppReq = 2052;
inline bool ProtoBody::has_groupmsgappreq() const {
  return (_has_bits_[4] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_groupmsgappreq() {
  _has_bits_[4] |= 0x00000010u;
}
inline void ProtoBody::clear_has_groupmsgappreq() {
  _has_bits_[4] &= ~0x00000010u;
}
inline void ProtoBody::clear_groupmsgappreq() {
  if (groupmsgappreq_ != NULL) groupmsgappreq_->::pp::GroupMsgAppReq::Clear();
  clear_has_groupmsgappreq();
}
inline const ::pp::GroupMsgAppReq& ProtoBody::groupmsgappreq() const {
  return groupmsgappreq_ != NULL ? *groupmsgappreq_ : *default_instance_->groupmsgappreq_;
}
inline ::pp::GroupMsgAppReq* ProtoBody::mutable_groupmsgappreq() {
  set_has_groupmsgappreq();
  if (groupmsgappreq_ == NULL) groupmsgappreq_ = new ::pp::GroupMsgAppReq;
  return groupmsgappreq_;
}
inline ::pp::GroupMsgAppReq* ProtoBody::release_groupmsgappreq() {
  clear_has_groupmsgappreq();
  ::pp::GroupMsgAppReq* temp = groupmsgappreq_;
  groupmsgappreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgappreq(::pp::GroupMsgAppReq* groupmsgappreq) {
  delete groupmsgappreq_;
  groupmsgappreq_ = groupmsgappreq;
  if (groupmsgappreq) {
    set_has_groupmsgappreq();
  } else {
    clear_has_groupmsgappreq();
  }
}

// optional .pp.GroupMsgAppRes groupMsgAppRes = 2053;
inline bool ProtoBody::has_groupmsgappres() const {
  return (_has_bits_[4] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_groupmsgappres() {
  _has_bits_[4] |= 0x00000020u;
}
inline void ProtoBody::clear_has_groupmsgappres() {
  _has_bits_[4] &= ~0x00000020u;
}
inline void ProtoBody::clear_groupmsgappres() {
  if (groupmsgappres_ != NULL) groupmsgappres_->::pp::GroupMsgAppRes::Clear();
  clear_has_groupmsgappres();
}
inline const ::pp::GroupMsgAppRes& ProtoBody::groupmsgappres() const {
  return groupmsgappres_ != NULL ? *groupmsgappres_ : *default_instance_->groupmsgappres_;
}
inline ::pp::GroupMsgAppRes* ProtoBody::mutable_groupmsgappres() {
  set_has_groupmsgappres();
  if (groupmsgappres_ == NULL) groupmsgappres_ = new ::pp::GroupMsgAppRes;
  return groupmsgappres_;
}
inline ::pp::GroupMsgAppRes* ProtoBody::release_groupmsgappres() {
  clear_has_groupmsgappres();
  ::pp::GroupMsgAppRes* temp = groupmsgappres_;
  groupmsgappres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgappres(::pp::GroupMsgAppRes* groupmsgappres) {
  delete groupmsgappres_;
  groupmsgappres_ = groupmsgappres;
  if (groupmsgappres) {
    set_has_groupmsgappres();
  } else {
    clear_has_groupmsgappres();
  }
}

// optional .pp.GroupMemberKickReq groupMemberKickReq = 2320;
inline bool ProtoBody::has_groupmemberkickreq() const {
  return (_has_bits_[4] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_groupmemberkickreq() {
  _has_bits_[4] |= 0x00000040u;
}
inline void ProtoBody::clear_has_groupmemberkickreq() {
  _has_bits_[4] &= ~0x00000040u;
}
inline void ProtoBody::clear_groupmemberkickreq() {
  if (groupmemberkickreq_ != NULL) groupmemberkickreq_->::pp::GroupMemberKickReq::Clear();
  clear_has_groupmemberkickreq();
}
inline const ::pp::GroupMemberKickReq& ProtoBody::groupmemberkickreq() const {
  return groupmemberkickreq_ != NULL ? *groupmemberkickreq_ : *default_instance_->groupmemberkickreq_;
}
inline ::pp::GroupMemberKickReq* ProtoBody::mutable_groupmemberkickreq() {
  set_has_groupmemberkickreq();
  if (groupmemberkickreq_ == NULL) groupmemberkickreq_ = new ::pp::GroupMemberKickReq;
  return groupmemberkickreq_;
}
inline ::pp::GroupMemberKickReq* ProtoBody::release_groupmemberkickreq() {
  clear_has_groupmemberkickreq();
  ::pp::GroupMemberKickReq* temp = groupmemberkickreq_;
  groupmemberkickreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberkickreq(::pp::GroupMemberKickReq* groupmemberkickreq) {
  delete groupmemberkickreq_;
  groupmemberkickreq_ = groupmemberkickreq;
  if (groupmemberkickreq) {
    set_has_groupmemberkickreq();
  } else {
    clear_has_groupmemberkickreq();
  }
}

// optional .pp.GroupMemberListReq groupMemberListReq = 2336;
inline bool ProtoBody::has_groupmemberlistreq() const {
  return (_has_bits_[4] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_groupmemberlistreq() {
  _has_bits_[4] |= 0x00000080u;
}
inline void ProtoBody::clear_has_groupmemberlistreq() {
  _has_bits_[4] &= ~0x00000080u;
}
inline void ProtoBody::clear_groupmemberlistreq() {
  if (groupmemberlistreq_ != NULL) groupmemberlistreq_->::pp::GroupMemberListReq::Clear();
  clear_has_groupmemberlistreq();
}
inline const ::pp::GroupMemberListReq& ProtoBody::groupmemberlistreq() const {
  return groupmemberlistreq_ != NULL ? *groupmemberlistreq_ : *default_instance_->groupmemberlistreq_;
}
inline ::pp::GroupMemberListReq* ProtoBody::mutable_groupmemberlistreq() {
  set_has_groupmemberlistreq();
  if (groupmemberlistreq_ == NULL) groupmemberlistreq_ = new ::pp::GroupMemberListReq;
  return groupmemberlistreq_;
}
inline ::pp::GroupMemberListReq* ProtoBody::release_groupmemberlistreq() {
  clear_has_groupmemberlistreq();
  ::pp::GroupMemberListReq* temp = groupmemberlistreq_;
  groupmemberlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberlistreq(::pp::GroupMemberListReq* groupmemberlistreq) {
  delete groupmemberlistreq_;
  groupmemberlistreq_ = groupmemberlistreq;
  if (groupmemberlistreq) {
    set_has_groupmemberlistreq();
  } else {
    clear_has_groupmemberlistreq();
  }
}

// optional .pp.GroupMemberListRes groupMemberListRes = 2337;
inline bool ProtoBody::has_groupmemberlistres() const {
  return (_has_bits_[4] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_groupmemberlistres() {
  _has_bits_[4] |= 0x00000100u;
}
inline void ProtoBody::clear_has_groupmemberlistres() {
  _has_bits_[4] &= ~0x00000100u;
}
inline void ProtoBody::clear_groupmemberlistres() {
  if (groupmemberlistres_ != NULL) groupmemberlistres_->::pp::GroupMemberListRes::Clear();
  clear_has_groupmemberlistres();
}
inline const ::pp::GroupMemberListRes& ProtoBody::groupmemberlistres() const {
  return groupmemberlistres_ != NULL ? *groupmemberlistres_ : *default_instance_->groupmemberlistres_;
}
inline ::pp::GroupMemberListRes* ProtoBody::mutable_groupmemberlistres() {
  set_has_groupmemberlistres();
  if (groupmemberlistres_ == NULL) groupmemberlistres_ = new ::pp::GroupMemberListRes;
  return groupmemberlistres_;
}
inline ::pp::GroupMemberListRes* ProtoBody::release_groupmemberlistres() {
  clear_has_groupmemberlistres();
  ::pp::GroupMemberListRes* temp = groupmemberlistres_;
  groupmemberlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberlistres(::pp::GroupMemberListRes* groupmemberlistres) {
  delete groupmemberlistres_;
  groupmemberlistres_ = groupmemberlistres;
  if (groupmemberlistres) {
    set_has_groupmemberlistres();
  } else {
    clear_has_groupmemberlistres();
  }
}

// optional .pp.GroupMemberReq groupMemberReq = 2338;
inline bool ProtoBody::has_groupmemberreq() const {
  return (_has_bits_[4] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_groupmemberreq() {
  _has_bits_[4] |= 0x00000200u;
}
inline void ProtoBody::clear_has_groupmemberreq() {
  _has_bits_[4] &= ~0x00000200u;
}
inline void ProtoBody::clear_groupmemberreq() {
  if (groupmemberreq_ != NULL) groupmemberreq_->::pp::GroupMemberReq::Clear();
  clear_has_groupmemberreq();
}
inline const ::pp::GroupMemberReq& ProtoBody::groupmemberreq() const {
  return groupmemberreq_ != NULL ? *groupmemberreq_ : *default_instance_->groupmemberreq_;
}
inline ::pp::GroupMemberReq* ProtoBody::mutable_groupmemberreq() {
  set_has_groupmemberreq();
  if (groupmemberreq_ == NULL) groupmemberreq_ = new ::pp::GroupMemberReq;
  return groupmemberreq_;
}
inline ::pp::GroupMemberReq* ProtoBody::release_groupmemberreq() {
  clear_has_groupmemberreq();
  ::pp::GroupMemberReq* temp = groupmemberreq_;
  groupmemberreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberreq(::pp::GroupMemberReq* groupmemberreq) {
  delete groupmemberreq_;
  groupmemberreq_ = groupmemberreq;
  if (groupmemberreq) {
    set_has_groupmemberreq();
  } else {
    clear_has_groupmemberreq();
  }
}

// optional .pp.GroupMemberRes groupMemberRes = 2339;
inline bool ProtoBody::has_groupmemberres() const {
  return (_has_bits_[4] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_groupmemberres() {
  _has_bits_[4] |= 0x00000400u;
}
inline void ProtoBody::clear_has_groupmemberres() {
  _has_bits_[4] &= ~0x00000400u;
}
inline void ProtoBody::clear_groupmemberres() {
  if (groupmemberres_ != NULL) groupmemberres_->::pp::GroupMemberRes::Clear();
  clear_has_groupmemberres();
}
inline const ::pp::GroupMemberRes& ProtoBody::groupmemberres() const {
  return groupmemberres_ != NULL ? *groupmemberres_ : *default_instance_->groupmemberres_;
}
inline ::pp::GroupMemberRes* ProtoBody::mutable_groupmemberres() {
  set_has_groupmemberres();
  if (groupmemberres_ == NULL) groupmemberres_ = new ::pp::GroupMemberRes;
  return groupmemberres_;
}
inline ::pp::GroupMemberRes* ProtoBody::release_groupmemberres() {
  clear_has_groupmemberres();
  ::pp::GroupMemberRes* temp = groupmemberres_;
  groupmemberres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberres(::pp::GroupMemberRes* groupmemberres) {
  delete groupmemberres_;
  groupmemberres_ = groupmemberres;
  if (groupmemberres) {
    set_has_groupmemberres();
  } else {
    clear_has_groupmemberres();
  }
}

// optional .pp.GroupMemberModifyReq groupMemberModifyReq = 2340;
inline bool ProtoBody::has_groupmembermodifyreq() const {
  return (_has_bits_[4] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_groupmembermodifyreq() {
  _has_bits_[4] |= 0x00000800u;
}
inline void ProtoBody::clear_has_groupmembermodifyreq() {
  _has_bits_[4] &= ~0x00000800u;
}
inline void ProtoBody::clear_groupmembermodifyreq() {
  if (groupmembermodifyreq_ != NULL) groupmembermodifyreq_->::pp::GroupMemberModifyReq::Clear();
  clear_has_groupmembermodifyreq();
}
inline const ::pp::GroupMemberModifyReq& ProtoBody::groupmembermodifyreq() const {
  return groupmembermodifyreq_ != NULL ? *groupmembermodifyreq_ : *default_instance_->groupmembermodifyreq_;
}
inline ::pp::GroupMemberModifyReq* ProtoBody::mutable_groupmembermodifyreq() {
  set_has_groupmembermodifyreq();
  if (groupmembermodifyreq_ == NULL) groupmembermodifyreq_ = new ::pp::GroupMemberModifyReq;
  return groupmembermodifyreq_;
}
inline ::pp::GroupMemberModifyReq* ProtoBody::release_groupmembermodifyreq() {
  clear_has_groupmembermodifyreq();
  ::pp::GroupMemberModifyReq* temp = groupmembermodifyreq_;
  groupmembermodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmembermodifyreq(::pp::GroupMemberModifyReq* groupmembermodifyreq) {
  delete groupmembermodifyreq_;
  groupmembermodifyreq_ = groupmembermodifyreq;
  if (groupmembermodifyreq) {
    set_has_groupmembermodifyreq();
  } else {
    clear_has_groupmembermodifyreq();
  }
}

// optional .pp.GroupMemberSearchReq groupMemberSearchReq = 2342;
inline bool ProtoBody::has_groupmembersearchreq() const {
  return (_has_bits_[4] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_groupmembersearchreq() {
  _has_bits_[4] |= 0x00001000u;
}
inline void ProtoBody::clear_has_groupmembersearchreq() {
  _has_bits_[4] &= ~0x00001000u;
}
inline void ProtoBody::clear_groupmembersearchreq() {
  if (groupmembersearchreq_ != NULL) groupmembersearchreq_->::pp::GroupMemberSearchReq::Clear();
  clear_has_groupmembersearchreq();
}
inline const ::pp::GroupMemberSearchReq& ProtoBody::groupmembersearchreq() const {
  return groupmembersearchreq_ != NULL ? *groupmembersearchreq_ : *default_instance_->groupmembersearchreq_;
}
inline ::pp::GroupMemberSearchReq* ProtoBody::mutable_groupmembersearchreq() {
  set_has_groupmembersearchreq();
  if (groupmembersearchreq_ == NULL) groupmembersearchreq_ = new ::pp::GroupMemberSearchReq;
  return groupmembersearchreq_;
}
inline ::pp::GroupMemberSearchReq* ProtoBody::release_groupmembersearchreq() {
  clear_has_groupmembersearchreq();
  ::pp::GroupMemberSearchReq* temp = groupmembersearchreq_;
  groupmembersearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmembersearchreq(::pp::GroupMemberSearchReq* groupmembersearchreq) {
  delete groupmembersearchreq_;
  groupmembersearchreq_ = groupmembersearchreq;
  if (groupmembersearchreq) {
    set_has_groupmembersearchreq();
  } else {
    clear_has_groupmembersearchreq();
  }
}

// optional .pp.GroupMemberSearchRes groupMemberSearchRes = 2343;
inline bool ProtoBody::has_groupmembersearchres() const {
  return (_has_bits_[4] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_groupmembersearchres() {
  _has_bits_[4] |= 0x00002000u;
}
inline void ProtoBody::clear_has_groupmembersearchres() {
  _has_bits_[4] &= ~0x00002000u;
}
inline void ProtoBody::clear_groupmembersearchres() {
  if (groupmembersearchres_ != NULL) groupmembersearchres_->::pp::GroupMemberSearchRes::Clear();
  clear_has_groupmembersearchres();
}
inline const ::pp::GroupMemberSearchRes& ProtoBody::groupmembersearchres() const {
  return groupmembersearchres_ != NULL ? *groupmembersearchres_ : *default_instance_->groupmembersearchres_;
}
inline ::pp::GroupMemberSearchRes* ProtoBody::mutable_groupmembersearchres() {
  set_has_groupmembersearchres();
  if (groupmembersearchres_ == NULL) groupmembersearchres_ = new ::pp::GroupMemberSearchRes;
  return groupmembersearchres_;
}
inline ::pp::GroupMemberSearchRes* ProtoBody::release_groupmembersearchres() {
  clear_has_groupmembersearchres();
  ::pp::GroupMemberSearchRes* temp = groupmembersearchres_;
  groupmembersearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmembersearchres(::pp::GroupMemberSearchRes* groupmembersearchres) {
  delete groupmembersearchres_;
  groupmembersearchres_ = groupmembersearchres;
  if (groupmembersearchres) {
    set_has_groupmembersearchres();
  } else {
    clear_has_groupmembersearchres();
  }
}

// optional .pp.GroupMemberCountReq groupMemberCountReq = 2344;
inline bool ProtoBody::has_groupmembercountreq() const {
  return (_has_bits_[4] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_groupmembercountreq() {
  _has_bits_[4] |= 0x00004000u;
}
inline void ProtoBody::clear_has_groupmembercountreq() {
  _has_bits_[4] &= ~0x00004000u;
}
inline void ProtoBody::clear_groupmembercountreq() {
  if (groupmembercountreq_ != NULL) groupmembercountreq_->::pp::GroupMemberCountReq::Clear();
  clear_has_groupmembercountreq();
}
inline const ::pp::GroupMemberCountReq& ProtoBody::groupmembercountreq() const {
  return groupmembercountreq_ != NULL ? *groupmembercountreq_ : *default_instance_->groupmembercountreq_;
}
inline ::pp::GroupMemberCountReq* ProtoBody::mutable_groupmembercountreq() {
  set_has_groupmembercountreq();
  if (groupmembercountreq_ == NULL) groupmembercountreq_ = new ::pp::GroupMemberCountReq;
  return groupmembercountreq_;
}
inline ::pp::GroupMemberCountReq* ProtoBody::release_groupmembercountreq() {
  clear_has_groupmembercountreq();
  ::pp::GroupMemberCountReq* temp = groupmembercountreq_;
  groupmembercountreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmembercountreq(::pp::GroupMemberCountReq* groupmembercountreq) {
  delete groupmembercountreq_;
  groupmembercountreq_ = groupmembercountreq;
  if (groupmembercountreq) {
    set_has_groupmembercountreq();
  } else {
    clear_has_groupmembercountreq();
  }
}

// optional .pp.GroupMemberCountRes groupMemberCountRes = 2345;
inline bool ProtoBody::has_groupmembercountres() const {
  return (_has_bits_[4] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_groupmembercountres() {
  _has_bits_[4] |= 0x00008000u;
}
inline void ProtoBody::clear_has_groupmembercountres() {
  _has_bits_[4] &= ~0x00008000u;
}
inline void ProtoBody::clear_groupmembercountres() {
  if (groupmembercountres_ != NULL) groupmembercountres_->::pp::GroupMemberCountRes::Clear();
  clear_has_groupmembercountres();
}
inline const ::pp::GroupMemberCountRes& ProtoBody::groupmembercountres() const {
  return groupmembercountres_ != NULL ? *groupmembercountres_ : *default_instance_->groupmembercountres_;
}
inline ::pp::GroupMemberCountRes* ProtoBody::mutable_groupmembercountres() {
  set_has_groupmembercountres();
  if (groupmembercountres_ == NULL) groupmembercountres_ = new ::pp::GroupMemberCountRes;
  return groupmembercountres_;
}
inline ::pp::GroupMemberCountRes* ProtoBody::release_groupmembercountres() {
  clear_has_groupmembercountres();
  ::pp::GroupMemberCountRes* temp = groupmembercountres_;
  groupmembercountres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmembercountres(::pp::GroupMemberCountRes* groupmembercountres) {
  delete groupmembercountres_;
  groupmembercountres_ = groupmembercountres;
  if (groupmembercountres) {
    set_has_groupmembercountres();
  } else {
    clear_has_groupmembercountres();
  }
}

// optional .pp.GroupMemberRolerListReq groupMemberRolerListReq = 2401;
inline bool ProtoBody::has_groupmemberrolerlistreq() const {
  return (_has_bits_[4] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_groupmemberrolerlistreq() {
  _has_bits_[4] |= 0x00010000u;
}
inline void ProtoBody::clear_has_groupmemberrolerlistreq() {
  _has_bits_[4] &= ~0x00010000u;
}
inline void ProtoBody::clear_groupmemberrolerlistreq() {
  if (groupmemberrolerlistreq_ != NULL) groupmemberrolerlistreq_->::pp::GroupMemberRolerListReq::Clear();
  clear_has_groupmemberrolerlistreq();
}
inline const ::pp::GroupMemberRolerListReq& ProtoBody::groupmemberrolerlistreq() const {
  return groupmemberrolerlistreq_ != NULL ? *groupmemberrolerlistreq_ : *default_instance_->groupmemberrolerlistreq_;
}
inline ::pp::GroupMemberRolerListReq* ProtoBody::mutable_groupmemberrolerlistreq() {
  set_has_groupmemberrolerlistreq();
  if (groupmemberrolerlistreq_ == NULL) groupmemberrolerlistreq_ = new ::pp::GroupMemberRolerListReq;
  return groupmemberrolerlistreq_;
}
inline ::pp::GroupMemberRolerListReq* ProtoBody::release_groupmemberrolerlistreq() {
  clear_has_groupmemberrolerlistreq();
  ::pp::GroupMemberRolerListReq* temp = groupmemberrolerlistreq_;
  groupmemberrolerlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberrolerlistreq(::pp::GroupMemberRolerListReq* groupmemberrolerlistreq) {
  delete groupmemberrolerlistreq_;
  groupmemberrolerlistreq_ = groupmemberrolerlistreq;
  if (groupmemberrolerlistreq) {
    set_has_groupmemberrolerlistreq();
  } else {
    clear_has_groupmemberrolerlistreq();
  }
}

// optional .pp.GroupMemberRolerListRes groupMemberRolerListRes = 2402;
inline bool ProtoBody::has_groupmemberrolerlistres() const {
  return (_has_bits_[4] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_groupmemberrolerlistres() {
  _has_bits_[4] |= 0x00020000u;
}
inline void ProtoBody::clear_has_groupmemberrolerlistres() {
  _has_bits_[4] &= ~0x00020000u;
}
inline void ProtoBody::clear_groupmemberrolerlistres() {
  if (groupmemberrolerlistres_ != NULL) groupmemberrolerlistres_->::pp::GroupMemberRolerListRes::Clear();
  clear_has_groupmemberrolerlistres();
}
inline const ::pp::GroupMemberRolerListRes& ProtoBody::groupmemberrolerlistres() const {
  return groupmemberrolerlistres_ != NULL ? *groupmemberrolerlistres_ : *default_instance_->groupmemberrolerlistres_;
}
inline ::pp::GroupMemberRolerListRes* ProtoBody::mutable_groupmemberrolerlistres() {
  set_has_groupmemberrolerlistres();
  if (groupmemberrolerlistres_ == NULL) groupmemberrolerlistres_ = new ::pp::GroupMemberRolerListRes;
  return groupmemberrolerlistres_;
}
inline ::pp::GroupMemberRolerListRes* ProtoBody::release_groupmemberrolerlistres() {
  clear_has_groupmemberrolerlistres();
  ::pp::GroupMemberRolerListRes* temp = groupmemberrolerlistres_;
  groupmemberrolerlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberrolerlistres(::pp::GroupMemberRolerListRes* groupmemberrolerlistres) {
  delete groupmemberrolerlistres_;
  groupmemberrolerlistres_ = groupmemberrolerlistres;
  if (groupmemberrolerlistres) {
    set_has_groupmemberrolerlistres();
  } else {
    clear_has_groupmemberrolerlistres();
  }
}

// optional .pp.GroupMemberRolerSetReq groupMemberRolerSetReq = 2403;
inline bool ProtoBody::has_groupmemberrolersetreq() const {
  return (_has_bits_[4] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_groupmemberrolersetreq() {
  _has_bits_[4] |= 0x00040000u;
}
inline void ProtoBody::clear_has_groupmemberrolersetreq() {
  _has_bits_[4] &= ~0x00040000u;
}
inline void ProtoBody::clear_groupmemberrolersetreq() {
  if (groupmemberrolersetreq_ != NULL) groupmemberrolersetreq_->::pp::GroupMemberRolerSetReq::Clear();
  clear_has_groupmemberrolersetreq();
}
inline const ::pp::GroupMemberRolerSetReq& ProtoBody::groupmemberrolersetreq() const {
  return groupmemberrolersetreq_ != NULL ? *groupmemberrolersetreq_ : *default_instance_->groupmemberrolersetreq_;
}
inline ::pp::GroupMemberRolerSetReq* ProtoBody::mutable_groupmemberrolersetreq() {
  set_has_groupmemberrolersetreq();
  if (groupmemberrolersetreq_ == NULL) groupmemberrolersetreq_ = new ::pp::GroupMemberRolerSetReq;
  return groupmemberrolersetreq_;
}
inline ::pp::GroupMemberRolerSetReq* ProtoBody::release_groupmemberrolersetreq() {
  clear_has_groupmemberrolersetreq();
  ::pp::GroupMemberRolerSetReq* temp = groupmemberrolersetreq_;
  groupmemberrolersetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmemberrolersetreq(::pp::GroupMemberRolerSetReq* groupmemberrolersetreq) {
  delete groupmemberrolersetreq_;
  groupmemberrolersetreq_ = groupmemberrolersetreq;
  if (groupmemberrolersetreq) {
    set_has_groupmemberrolersetreq();
  } else {
    clear_has_groupmemberrolersetreq();
  }
}

// optional .pp.GroupMsgListReq groupMsgListReq = 1536;
inline bool ProtoBody::has_groupmsglistreq() const {
  return (_has_bits_[4] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_groupmsglistreq() {
  _has_bits_[4] |= 0x00080000u;
}
inline void ProtoBody::clear_has_groupmsglistreq() {
  _has_bits_[4] &= ~0x00080000u;
}
inline void ProtoBody::clear_groupmsglistreq() {
  if (groupmsglistreq_ != NULL) groupmsglistreq_->::pp::GroupMsgListReq::Clear();
  clear_has_groupmsglistreq();
}
inline const ::pp::GroupMsgListReq& ProtoBody::groupmsglistreq() const {
  return groupmsglistreq_ != NULL ? *groupmsglistreq_ : *default_instance_->groupmsglistreq_;
}
inline ::pp::GroupMsgListReq* ProtoBody::mutable_groupmsglistreq() {
  set_has_groupmsglistreq();
  if (groupmsglistreq_ == NULL) groupmsglistreq_ = new ::pp::GroupMsgListReq;
  return groupmsglistreq_;
}
inline ::pp::GroupMsgListReq* ProtoBody::release_groupmsglistreq() {
  clear_has_groupmsglistreq();
  ::pp::GroupMsgListReq* temp = groupmsglistreq_;
  groupmsglistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsglistreq(::pp::GroupMsgListReq* groupmsglistreq) {
  delete groupmsglistreq_;
  groupmsglistreq_ = groupmsglistreq;
  if (groupmsglistreq) {
    set_has_groupmsglistreq();
  } else {
    clear_has_groupmsglistreq();
  }
}

// optional .pp.GroupMsgListRes groupMsgListRes = 1537;
inline bool ProtoBody::has_groupmsglistres() const {
  return (_has_bits_[4] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_groupmsglistres() {
  _has_bits_[4] |= 0x00100000u;
}
inline void ProtoBody::clear_has_groupmsglistres() {
  _has_bits_[4] &= ~0x00100000u;
}
inline void ProtoBody::clear_groupmsglistres() {
  if (groupmsglistres_ != NULL) groupmsglistres_->::pp::GroupMsgListRes::Clear();
  clear_has_groupmsglistres();
}
inline const ::pp::GroupMsgListRes& ProtoBody::groupmsglistres() const {
  return groupmsglistres_ != NULL ? *groupmsglistres_ : *default_instance_->groupmsglistres_;
}
inline ::pp::GroupMsgListRes* ProtoBody::mutable_groupmsglistres() {
  set_has_groupmsglistres();
  if (groupmsglistres_ == NULL) groupmsglistres_ = new ::pp::GroupMsgListRes;
  return groupmsglistres_;
}
inline ::pp::GroupMsgListRes* ProtoBody::release_groupmsglistres() {
  clear_has_groupmsglistres();
  ::pp::GroupMsgListRes* temp = groupmsglistres_;
  groupmsglistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsglistres(::pp::GroupMsgListRes* groupmsglistres) {
  delete groupmsglistres_;
  groupmsglistres_ = groupmsglistres;
  if (groupmsglistres) {
    set_has_groupmsglistres();
  } else {
    clear_has_groupmsglistres();
  }
}

// optional .pp.GroupMsgVoiceReq groupMsgVoiceReq = 1542;
inline bool ProtoBody::has_groupmsgvoicereq() const {
  return (_has_bits_[4] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_groupmsgvoicereq() {
  _has_bits_[4] |= 0x00200000u;
}
inline void ProtoBody::clear_has_groupmsgvoicereq() {
  _has_bits_[4] &= ~0x00200000u;
}
inline void ProtoBody::clear_groupmsgvoicereq() {
  if (groupmsgvoicereq_ != NULL) groupmsgvoicereq_->::pp::GroupMsgVoiceReq::Clear();
  clear_has_groupmsgvoicereq();
}
inline const ::pp::GroupMsgVoiceReq& ProtoBody::groupmsgvoicereq() const {
  return groupmsgvoicereq_ != NULL ? *groupmsgvoicereq_ : *default_instance_->groupmsgvoicereq_;
}
inline ::pp::GroupMsgVoiceReq* ProtoBody::mutable_groupmsgvoicereq() {
  set_has_groupmsgvoicereq();
  if (groupmsgvoicereq_ == NULL) groupmsgvoicereq_ = new ::pp::GroupMsgVoiceReq;
  return groupmsgvoicereq_;
}
inline ::pp::GroupMsgVoiceReq* ProtoBody::release_groupmsgvoicereq() {
  clear_has_groupmsgvoicereq();
  ::pp::GroupMsgVoiceReq* temp = groupmsgvoicereq_;
  groupmsgvoicereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgvoicereq(::pp::GroupMsgVoiceReq* groupmsgvoicereq) {
  delete groupmsgvoicereq_;
  groupmsgvoicereq_ = groupmsgvoicereq;
  if (groupmsgvoicereq) {
    set_has_groupmsgvoicereq();
  } else {
    clear_has_groupmsgvoicereq();
  }
}

// optional .pp.GroupMsgVoiceRes groupMsgVoiceRes = 1543;
inline bool ProtoBody::has_groupmsgvoiceres() const {
  return (_has_bits_[4] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_groupmsgvoiceres() {
  _has_bits_[4] |= 0x00400000u;
}
inline void ProtoBody::clear_has_groupmsgvoiceres() {
  _has_bits_[4] &= ~0x00400000u;
}
inline void ProtoBody::clear_groupmsgvoiceres() {
  if (groupmsgvoiceres_ != NULL) groupmsgvoiceres_->::pp::GroupMsgVoiceRes::Clear();
  clear_has_groupmsgvoiceres();
}
inline const ::pp::GroupMsgVoiceRes& ProtoBody::groupmsgvoiceres() const {
  return groupmsgvoiceres_ != NULL ? *groupmsgvoiceres_ : *default_instance_->groupmsgvoiceres_;
}
inline ::pp::GroupMsgVoiceRes* ProtoBody::mutable_groupmsgvoiceres() {
  set_has_groupmsgvoiceres();
  if (groupmsgvoiceres_ == NULL) groupmsgvoiceres_ = new ::pp::GroupMsgVoiceRes;
  return groupmsgvoiceres_;
}
inline ::pp::GroupMsgVoiceRes* ProtoBody::release_groupmsgvoiceres() {
  clear_has_groupmsgvoiceres();
  ::pp::GroupMsgVoiceRes* temp = groupmsgvoiceres_;
  groupmsgvoiceres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgvoiceres(::pp::GroupMsgVoiceRes* groupmsgvoiceres) {
  delete groupmsgvoiceres_;
  groupmsgvoiceres_ = groupmsgvoiceres;
  if (groupmsgvoiceres) {
    set_has_groupmsgvoiceres();
  } else {
    clear_has_groupmsgvoiceres();
  }
}

// optional .pp.GroupMsgSendReq groupMsgSendReq = 1552;
inline bool ProtoBody::has_groupmsgsendreq() const {
  return (_has_bits_[4] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_groupmsgsendreq() {
  _has_bits_[4] |= 0x00800000u;
}
inline void ProtoBody::clear_has_groupmsgsendreq() {
  _has_bits_[4] &= ~0x00800000u;
}
inline void ProtoBody::clear_groupmsgsendreq() {
  if (groupmsgsendreq_ != NULL) groupmsgsendreq_->::pp::GroupMsgSendReq::Clear();
  clear_has_groupmsgsendreq();
}
inline const ::pp::GroupMsgSendReq& ProtoBody::groupmsgsendreq() const {
  return groupmsgsendreq_ != NULL ? *groupmsgsendreq_ : *default_instance_->groupmsgsendreq_;
}
inline ::pp::GroupMsgSendReq* ProtoBody::mutable_groupmsgsendreq() {
  set_has_groupmsgsendreq();
  if (groupmsgsendreq_ == NULL) groupmsgsendreq_ = new ::pp::GroupMsgSendReq;
  return groupmsgsendreq_;
}
inline ::pp::GroupMsgSendReq* ProtoBody::release_groupmsgsendreq() {
  clear_has_groupmsgsendreq();
  ::pp::GroupMsgSendReq* temp = groupmsgsendreq_;
  groupmsgsendreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgsendreq(::pp::GroupMsgSendReq* groupmsgsendreq) {
  delete groupmsgsendreq_;
  groupmsgsendreq_ = groupmsgsendreq;
  if (groupmsgsendreq) {
    set_has_groupmsgsendreq();
  } else {
    clear_has_groupmsgsendreq();
  }
}

// optional .pp.GroupMsgSearchReq groupMsgSearchReq = 1554;
inline bool ProtoBody::has_groupmsgsearchreq() const {
  return (_has_bits_[4] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_groupmsgsearchreq() {
  _has_bits_[4] |= 0x01000000u;
}
inline void ProtoBody::clear_has_groupmsgsearchreq() {
  _has_bits_[4] &= ~0x01000000u;
}
inline void ProtoBody::clear_groupmsgsearchreq() {
  if (groupmsgsearchreq_ != NULL) groupmsgsearchreq_->::pp::GroupMsgSearchReq::Clear();
  clear_has_groupmsgsearchreq();
}
inline const ::pp::GroupMsgSearchReq& ProtoBody::groupmsgsearchreq() const {
  return groupmsgsearchreq_ != NULL ? *groupmsgsearchreq_ : *default_instance_->groupmsgsearchreq_;
}
inline ::pp::GroupMsgSearchReq* ProtoBody::mutable_groupmsgsearchreq() {
  set_has_groupmsgsearchreq();
  if (groupmsgsearchreq_ == NULL) groupmsgsearchreq_ = new ::pp::GroupMsgSearchReq;
  return groupmsgsearchreq_;
}
inline ::pp::GroupMsgSearchReq* ProtoBody::release_groupmsgsearchreq() {
  clear_has_groupmsgsearchreq();
  ::pp::GroupMsgSearchReq* temp = groupmsgsearchreq_;
  groupmsgsearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgsearchreq(::pp::GroupMsgSearchReq* groupmsgsearchreq) {
  delete groupmsgsearchreq_;
  groupmsgsearchreq_ = groupmsgsearchreq;
  if (groupmsgsearchreq) {
    set_has_groupmsgsearchreq();
  } else {
    clear_has_groupmsgsearchreq();
  }
}

// optional .pp.GroupMsgSearchRes groupMsgSearchRes = 1555;
inline bool ProtoBody::has_groupmsgsearchres() const {
  return (_has_bits_[4] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_groupmsgsearchres() {
  _has_bits_[4] |= 0x02000000u;
}
inline void ProtoBody::clear_has_groupmsgsearchres() {
  _has_bits_[4] &= ~0x02000000u;
}
inline void ProtoBody::clear_groupmsgsearchres() {
  if (groupmsgsearchres_ != NULL) groupmsgsearchres_->::pp::GroupMsgSearchRes::Clear();
  clear_has_groupmsgsearchres();
}
inline const ::pp::GroupMsgSearchRes& ProtoBody::groupmsgsearchres() const {
  return groupmsgsearchres_ != NULL ? *groupmsgsearchres_ : *default_instance_->groupmsgsearchres_;
}
inline ::pp::GroupMsgSearchRes* ProtoBody::mutable_groupmsgsearchres() {
  set_has_groupmsgsearchres();
  if (groupmsgsearchres_ == NULL) groupmsgsearchres_ = new ::pp::GroupMsgSearchRes;
  return groupmsgsearchres_;
}
inline ::pp::GroupMsgSearchRes* ProtoBody::release_groupmsgsearchres() {
  clear_has_groupmsgsearchres();
  ::pp::GroupMsgSearchRes* temp = groupmsgsearchres_;
  groupmsgsearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_groupmsgsearchres(::pp::GroupMsgSearchRes* groupmsgsearchres) {
  delete groupmsgsearchres_;
  groupmsgsearchres_ = groupmsgsearchres;
  if (groupmsgsearchres) {
    set_has_groupmsgsearchres();
  } else {
    clear_has_groupmsgsearchres();
  }
}

// optional .pp.UserLoginReq userLoginReq = 256;
inline bool ProtoBody::has_userloginreq() const {
  return (_has_bits_[4] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_userloginreq() {
  _has_bits_[4] |= 0x04000000u;
}
inline void ProtoBody::clear_has_userloginreq() {
  _has_bits_[4] &= ~0x04000000u;
}
inline void ProtoBody::clear_userloginreq() {
  if (userloginreq_ != NULL) userloginreq_->::pp::UserLoginReq::Clear();
  clear_has_userloginreq();
}
inline const ::pp::UserLoginReq& ProtoBody::userloginreq() const {
  return userloginreq_ != NULL ? *userloginreq_ : *default_instance_->userloginreq_;
}
inline ::pp::UserLoginReq* ProtoBody::mutable_userloginreq() {
  set_has_userloginreq();
  if (userloginreq_ == NULL) userloginreq_ = new ::pp::UserLoginReq;
  return userloginreq_;
}
inline ::pp::UserLoginReq* ProtoBody::release_userloginreq() {
  clear_has_userloginreq();
  ::pp::UserLoginReq* temp = userloginreq_;
  userloginreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userloginreq(::pp::UserLoginReq* userloginreq) {
  delete userloginreq_;
  userloginreq_ = userloginreq;
  if (userloginreq) {
    set_has_userloginreq();
  } else {
    clear_has_userloginreq();
  }
}

// optional .pp.UserLoginRes userLoginRes = 257;
inline bool ProtoBody::has_userloginres() const {
  return (_has_bits_[4] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_userloginres() {
  _has_bits_[4] |= 0x08000000u;
}
inline void ProtoBody::clear_has_userloginres() {
  _has_bits_[4] &= ~0x08000000u;
}
inline void ProtoBody::clear_userloginres() {
  if (userloginres_ != NULL) userloginres_->::pp::UserLoginRes::Clear();
  clear_has_userloginres();
}
inline const ::pp::UserLoginRes& ProtoBody::userloginres() const {
  return userloginres_ != NULL ? *userloginres_ : *default_instance_->userloginres_;
}
inline ::pp::UserLoginRes* ProtoBody::mutable_userloginres() {
  set_has_userloginres();
  if (userloginres_ == NULL) userloginres_ = new ::pp::UserLoginRes;
  return userloginres_;
}
inline ::pp::UserLoginRes* ProtoBody::release_userloginres() {
  clear_has_userloginres();
  ::pp::UserLoginRes* temp = userloginres_;
  userloginres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userloginres(::pp::UserLoginRes* userloginres) {
  delete userloginres_;
  userloginres_ = userloginres;
  if (userloginres) {
    set_has_userloginres();
  } else {
    clear_has_userloginres();
  }
}

// optional .pp.UserActivateReq userActivateReq = 258;
inline bool ProtoBody::has_useractivatereq() const {
  return (_has_bits_[4] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_useractivatereq() {
  _has_bits_[4] |= 0x10000000u;
}
inline void ProtoBody::clear_has_useractivatereq() {
  _has_bits_[4] &= ~0x10000000u;
}
inline void ProtoBody::clear_useractivatereq() {
  if (useractivatereq_ != NULL) useractivatereq_->::pp::UserActivateReq::Clear();
  clear_has_useractivatereq();
}
inline const ::pp::UserActivateReq& ProtoBody::useractivatereq() const {
  return useractivatereq_ != NULL ? *useractivatereq_ : *default_instance_->useractivatereq_;
}
inline ::pp::UserActivateReq* ProtoBody::mutable_useractivatereq() {
  set_has_useractivatereq();
  if (useractivatereq_ == NULL) useractivatereq_ = new ::pp::UserActivateReq;
  return useractivatereq_;
}
inline ::pp::UserActivateReq* ProtoBody::release_useractivatereq() {
  clear_has_useractivatereq();
  ::pp::UserActivateReq* temp = useractivatereq_;
  useractivatereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useractivatereq(::pp::UserActivateReq* useractivatereq) {
  delete useractivatereq_;
  useractivatereq_ = useractivatereq;
  if (useractivatereq) {
    set_has_useractivatereq();
  } else {
    clear_has_useractivatereq();
  }
}

// optional .pp.UserActivateRes userActivateRes = 259;
inline bool ProtoBody::has_useractivateres() const {
  return (_has_bits_[4] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_useractivateres() {
  _has_bits_[4] |= 0x20000000u;
}
inline void ProtoBody::clear_has_useractivateres() {
  _has_bits_[4] &= ~0x20000000u;
}
inline void ProtoBody::clear_useractivateres() {
  if (useractivateres_ != NULL) useractivateres_->::pp::UserActivateRes::Clear();
  clear_has_useractivateres();
}
inline const ::pp::UserActivateRes& ProtoBody::useractivateres() const {
  return useractivateres_ != NULL ? *useractivateres_ : *default_instance_->useractivateres_;
}
inline ::pp::UserActivateRes* ProtoBody::mutable_useractivateres() {
  set_has_useractivateres();
  if (useractivateres_ == NULL) useractivateres_ = new ::pp::UserActivateRes;
  return useractivateres_;
}
inline ::pp::UserActivateRes* ProtoBody::release_useractivateres() {
  clear_has_useractivateres();
  ::pp::UserActivateRes* temp = useractivateres_;
  useractivateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useractivateres(::pp::UserActivateRes* useractivateres) {
  delete useractivateres_;
  useractivateres_ = useractivateres;
  if (useractivateres) {
    set_has_useractivateres();
  } else {
    clear_has_useractivateres();
  }
}

// optional .pp.UserHeartBeatReq userHeartBeatReq = 260;
inline bool ProtoBody::has_userheartbeatreq() const {
  return (_has_bits_[4] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_userheartbeatreq() {
  _has_bits_[4] |= 0x40000000u;
}
inline void ProtoBody::clear_has_userheartbeatreq() {
  _has_bits_[4] &= ~0x40000000u;
}
inline void ProtoBody::clear_userheartbeatreq() {
  if (userheartbeatreq_ != NULL) userheartbeatreq_->::pp::UserHeartBeatReq::Clear();
  clear_has_userheartbeatreq();
}
inline const ::pp::UserHeartBeatReq& ProtoBody::userheartbeatreq() const {
  return userheartbeatreq_ != NULL ? *userheartbeatreq_ : *default_instance_->userheartbeatreq_;
}
inline ::pp::UserHeartBeatReq* ProtoBody::mutable_userheartbeatreq() {
  set_has_userheartbeatreq();
  if (userheartbeatreq_ == NULL) userheartbeatreq_ = new ::pp::UserHeartBeatReq;
  return userheartbeatreq_;
}
inline ::pp::UserHeartBeatReq* ProtoBody::release_userheartbeatreq() {
  clear_has_userheartbeatreq();
  ::pp::UserHeartBeatReq* temp = userheartbeatreq_;
  userheartbeatreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userheartbeatreq(::pp::UserHeartBeatReq* userheartbeatreq) {
  delete userheartbeatreq_;
  userheartbeatreq_ = userheartbeatreq;
  if (userheartbeatreq) {
    set_has_userheartbeatreq();
  } else {
    clear_has_userheartbeatreq();
  }
}

// optional .pp.UserHeartBeatRes userHeartBeatRes = 261;
inline bool ProtoBody::has_userheartbeatres() const {
  return (_has_bits_[4] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_userheartbeatres() {
  _has_bits_[4] |= 0x80000000u;
}
inline void ProtoBody::clear_has_userheartbeatres() {
  _has_bits_[4] &= ~0x80000000u;
}
inline void ProtoBody::clear_userheartbeatres() {
  if (userheartbeatres_ != NULL) userheartbeatres_->::pp::UserHeartBeatRes::Clear();
  clear_has_userheartbeatres();
}
inline const ::pp::UserHeartBeatRes& ProtoBody::userheartbeatres() const {
  return userheartbeatres_ != NULL ? *userheartbeatres_ : *default_instance_->userheartbeatres_;
}
inline ::pp::UserHeartBeatRes* ProtoBody::mutable_userheartbeatres() {
  set_has_userheartbeatres();
  if (userheartbeatres_ == NULL) userheartbeatres_ = new ::pp::UserHeartBeatRes;
  return userheartbeatres_;
}
inline ::pp::UserHeartBeatRes* ProtoBody::release_userheartbeatres() {
  clear_has_userheartbeatres();
  ::pp::UserHeartBeatRes* temp = userheartbeatres_;
  userheartbeatres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userheartbeatres(::pp::UserHeartBeatRes* userheartbeatres) {
  delete userheartbeatres_;
  userheartbeatres_ = userheartbeatres;
  if (userheartbeatres) {
    set_has_userheartbeatres();
  } else {
    clear_has_userheartbeatres();
  }
}

// optional .pp.AccountBindReq accountBindReq = 262;
inline bool ProtoBody::has_accountbindreq() const {
  return (_has_bits_[5] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_accountbindreq() {
  _has_bits_[5] |= 0x00000001u;
}
inline void ProtoBody::clear_has_accountbindreq() {
  _has_bits_[5] &= ~0x00000001u;
}
inline void ProtoBody::clear_accountbindreq() {
  if (accountbindreq_ != NULL) accountbindreq_->::pp::AccountBindReq::Clear();
  clear_has_accountbindreq();
}
inline const ::pp::AccountBindReq& ProtoBody::accountbindreq() const {
  return accountbindreq_ != NULL ? *accountbindreq_ : *default_instance_->accountbindreq_;
}
inline ::pp::AccountBindReq* ProtoBody::mutable_accountbindreq() {
  set_has_accountbindreq();
  if (accountbindreq_ == NULL) accountbindreq_ = new ::pp::AccountBindReq;
  return accountbindreq_;
}
inline ::pp::AccountBindReq* ProtoBody::release_accountbindreq() {
  clear_has_accountbindreq();
  ::pp::AccountBindReq* temp = accountbindreq_;
  accountbindreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_accountbindreq(::pp::AccountBindReq* accountbindreq) {
  delete accountbindreq_;
  accountbindreq_ = accountbindreq;
  if (accountbindreq) {
    set_has_accountbindreq();
  } else {
    clear_has_accountbindreq();
  }
}

// optional .pp.AccountBindRes accountBindRes = 263;
inline bool ProtoBody::has_accountbindres() const {
  return (_has_bits_[5] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_accountbindres() {
  _has_bits_[5] |= 0x00000002u;
}
inline void ProtoBody::clear_has_accountbindres() {
  _has_bits_[5] &= ~0x00000002u;
}
inline void ProtoBody::clear_accountbindres() {
  if (accountbindres_ != NULL) accountbindres_->::pp::AccountBindRes::Clear();
  clear_has_accountbindres();
}
inline const ::pp::AccountBindRes& ProtoBody::accountbindres() const {
  return accountbindres_ != NULL ? *accountbindres_ : *default_instance_->accountbindres_;
}
inline ::pp::AccountBindRes* ProtoBody::mutable_accountbindres() {
  set_has_accountbindres();
  if (accountbindres_ == NULL) accountbindres_ = new ::pp::AccountBindRes;
  return accountbindres_;
}
inline ::pp::AccountBindRes* ProtoBody::release_accountbindres() {
  clear_has_accountbindres();
  ::pp::AccountBindRes* temp = accountbindres_;
  accountbindres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_accountbindres(::pp::AccountBindRes* accountbindres) {
  delete accountbindres_;
  accountbindres_ = accountbindres;
  if (accountbindres) {
    set_has_accountbindres();
  } else {
    clear_has_accountbindres();
  }
}

// optional .pp.UserWebLoginReq userWebLoginReq = 264;
inline bool ProtoBody::has_userwebloginreq() const {
  return (_has_bits_[5] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_userwebloginreq() {
  _has_bits_[5] |= 0x00000004u;
}
inline void ProtoBody::clear_has_userwebloginreq() {
  _has_bits_[5] &= ~0x00000004u;
}
inline void ProtoBody::clear_userwebloginreq() {
  if (userwebloginreq_ != NULL) userwebloginreq_->::pp::UserWebLoginReq::Clear();
  clear_has_userwebloginreq();
}
inline const ::pp::UserWebLoginReq& ProtoBody::userwebloginreq() const {
  return userwebloginreq_ != NULL ? *userwebloginreq_ : *default_instance_->userwebloginreq_;
}
inline ::pp::UserWebLoginReq* ProtoBody::mutable_userwebloginreq() {
  set_has_userwebloginreq();
  if (userwebloginreq_ == NULL) userwebloginreq_ = new ::pp::UserWebLoginReq;
  return userwebloginreq_;
}
inline ::pp::UserWebLoginReq* ProtoBody::release_userwebloginreq() {
  clear_has_userwebloginreq();
  ::pp::UserWebLoginReq* temp = userwebloginreq_;
  userwebloginreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userwebloginreq(::pp::UserWebLoginReq* userwebloginreq) {
  delete userwebloginreq_;
  userwebloginreq_ = userwebloginreq;
  if (userwebloginreq) {
    set_has_userwebloginreq();
  } else {
    clear_has_userwebloginreq();
  }
}

// optional .pp.UserWebLoginRes userWebLoginRes = 265;
inline bool ProtoBody::has_userwebloginres() const {
  return (_has_bits_[5] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_userwebloginres() {
  _has_bits_[5] |= 0x00000008u;
}
inline void ProtoBody::clear_has_userwebloginres() {
  _has_bits_[5] &= ~0x00000008u;
}
inline void ProtoBody::clear_userwebloginres() {
  if (userwebloginres_ != NULL) userwebloginres_->::pp::UserWebLoginRes::Clear();
  clear_has_userwebloginres();
}
inline const ::pp::UserWebLoginRes& ProtoBody::userwebloginres() const {
  return userwebloginres_ != NULL ? *userwebloginres_ : *default_instance_->userwebloginres_;
}
inline ::pp::UserWebLoginRes* ProtoBody::mutable_userwebloginres() {
  set_has_userwebloginres();
  if (userwebloginres_ == NULL) userwebloginres_ = new ::pp::UserWebLoginRes;
  return userwebloginres_;
}
inline ::pp::UserWebLoginRes* ProtoBody::release_userwebloginres() {
  clear_has_userwebloginres();
  ::pp::UserWebLoginRes* temp = userwebloginres_;
  userwebloginres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userwebloginres(::pp::UserWebLoginRes* userwebloginres) {
  delete userwebloginres_;
  userwebloginres_ = userwebloginres;
  if (userwebloginres) {
    set_has_userwebloginres();
  } else {
    clear_has_userwebloginres();
  }
}

// optional .pp.SessionResumeReq sessionResumeReq = 272;
inline bool ProtoBody::has_sessionresumereq() const {
  return (_has_bits_[5] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_sessionresumereq() {
  _has_bits_[5] |= 0x00000010u;
}
inline void ProtoBody::clear_has_sessionresumereq() {
  _has_bits_[5] &= ~0x00000010u;
}
inline void ProtoBody::clear_sessionresumereq() {
  if (sessionresumereq_ != NULL) sessionresumereq_->::pp::SessionResumeReq::Clear();
  clear_has_sessionresumereq();
}
inline const ::pp::SessionResumeReq& ProtoBody::sessionresumereq() const {
  return sessionresumereq_ != NULL ? *sessionresumereq_ : *default_instance_->sessionresumereq_;
}
inline ::pp::SessionResumeReq* ProtoBody::mutable_sessionresumereq() {
  set_has_sessionresumereq();
  if (sessionresumereq_ == NULL) sessionresumereq_ = new ::pp::SessionResumeReq;
  return sessionresumereq_;
}
inline ::pp::SessionResumeReq* ProtoBody::release_sessionresumereq() {
  clear_has_sessionresumereq();
  ::pp::SessionResumeReq* temp = sessionresumereq_;
  sessionresumereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sessionresumereq(::pp::SessionResumeReq* sessionresumereq) {
  delete sessionresumereq_;
  sessionresumereq_ = sessionresumereq;
  if (sessionresumereq) {
    set_has_sessionresumereq();
  } else {
    clear_has_sessionresumereq();
  }
}

// optional .pp.SessionResumeRes sessionResumeRes = 273;
inline bool ProtoBody::has_sessionresumeres() const {
  return (_has_bits_[5] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_sessionresumeres() {
  _has_bits_[5] |= 0x00000020u;
}
inline void ProtoBody::clear_has_sessionresumeres() {
  _has_bits_[5] &= ~0x00000020u;
}
inline void ProtoBody::clear_sessionresumeres() {
  if (sessionresumeres_ != NULL) sessionresumeres_->::pp::SessionResumeRes::Clear();
  clear_has_sessionresumeres();
}
inline const ::pp::SessionResumeRes& ProtoBody::sessionresumeres() const {
  return sessionresumeres_ != NULL ? *sessionresumeres_ : *default_instance_->sessionresumeres_;
}
inline ::pp::SessionResumeRes* ProtoBody::mutable_sessionresumeres() {
  set_has_sessionresumeres();
  if (sessionresumeres_ == NULL) sessionresumeres_ = new ::pp::SessionResumeRes;
  return sessionresumeres_;
}
inline ::pp::SessionResumeRes* ProtoBody::release_sessionresumeres() {
  clear_has_sessionresumeres();
  ::pp::SessionResumeRes* temp = sessionresumeres_;
  sessionresumeres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sessionresumeres(::pp::SessionResumeRes* sessionresumeres) {
  delete sessionresumeres_;
  sessionresumeres_ = sessionresumeres;
  if (sessionresumeres) {
    set_has_sessionresumeres();
  } else {
    clear_has_sessionresumeres();
  }
}

// optional .pp.SessionSuspendReq sessionSuspendReq = 274;
inline bool ProtoBody::has_sessionsuspendreq() const {
  return (_has_bits_[5] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_sessionsuspendreq() {
  _has_bits_[5] |= 0x00000040u;
}
inline void ProtoBody::clear_has_sessionsuspendreq() {
  _has_bits_[5] &= ~0x00000040u;
}
inline void ProtoBody::clear_sessionsuspendreq() {
  if (sessionsuspendreq_ != NULL) sessionsuspendreq_->::pp::SessionSuspendReq::Clear();
  clear_has_sessionsuspendreq();
}
inline const ::pp::SessionSuspendReq& ProtoBody::sessionsuspendreq() const {
  return sessionsuspendreq_ != NULL ? *sessionsuspendreq_ : *default_instance_->sessionsuspendreq_;
}
inline ::pp::SessionSuspendReq* ProtoBody::mutable_sessionsuspendreq() {
  set_has_sessionsuspendreq();
  if (sessionsuspendreq_ == NULL) sessionsuspendreq_ = new ::pp::SessionSuspendReq;
  return sessionsuspendreq_;
}
inline ::pp::SessionSuspendReq* ProtoBody::release_sessionsuspendreq() {
  clear_has_sessionsuspendreq();
  ::pp::SessionSuspendReq* temp = sessionsuspendreq_;
  sessionsuspendreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_sessionsuspendreq(::pp::SessionSuspendReq* sessionsuspendreq) {
  delete sessionsuspendreq_;
  sessionsuspendreq_ = sessionsuspendreq;
  if (sessionsuspendreq) {
    set_has_sessionsuspendreq();
  } else {
    clear_has_sessionsuspendreq();
  }
}

// optional .pp.UserTokenReq userTokenReq = 290;
inline bool ProtoBody::has_usertokenreq() const {
  return (_has_bits_[5] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_usertokenreq() {
  _has_bits_[5] |= 0x00000080u;
}
inline void ProtoBody::clear_has_usertokenreq() {
  _has_bits_[5] &= ~0x00000080u;
}
inline void ProtoBody::clear_usertokenreq() {
  if (usertokenreq_ != NULL) usertokenreq_->::pp::UserTokenReq::Clear();
  clear_has_usertokenreq();
}
inline const ::pp::UserTokenReq& ProtoBody::usertokenreq() const {
  return usertokenreq_ != NULL ? *usertokenreq_ : *default_instance_->usertokenreq_;
}
inline ::pp::UserTokenReq* ProtoBody::mutable_usertokenreq() {
  set_has_usertokenreq();
  if (usertokenreq_ == NULL) usertokenreq_ = new ::pp::UserTokenReq;
  return usertokenreq_;
}
inline ::pp::UserTokenReq* ProtoBody::release_usertokenreq() {
  clear_has_usertokenreq();
  ::pp::UserTokenReq* temp = usertokenreq_;
  usertokenreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertokenreq(::pp::UserTokenReq* usertokenreq) {
  delete usertokenreq_;
  usertokenreq_ = usertokenreq;
  if (usertokenreq) {
    set_has_usertokenreq();
  } else {
    clear_has_usertokenreq();
  }
}

// optional .pp.UserTokenRes userTokenRes = 291;
inline bool ProtoBody::has_usertokenres() const {
  return (_has_bits_[5] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_usertokenres() {
  _has_bits_[5] |= 0x00000100u;
}
inline void ProtoBody::clear_has_usertokenres() {
  _has_bits_[5] &= ~0x00000100u;
}
inline void ProtoBody::clear_usertokenres() {
  if (usertokenres_ != NULL) usertokenres_->::pp::UserTokenRes::Clear();
  clear_has_usertokenres();
}
inline const ::pp::UserTokenRes& ProtoBody::usertokenres() const {
  return usertokenres_ != NULL ? *usertokenres_ : *default_instance_->usertokenres_;
}
inline ::pp::UserTokenRes* ProtoBody::mutable_usertokenres() {
  set_has_usertokenres();
  if (usertokenres_ == NULL) usertokenres_ = new ::pp::UserTokenRes;
  return usertokenres_;
}
inline ::pp::UserTokenRes* ProtoBody::release_usertokenres() {
  clear_has_usertokenres();
  ::pp::UserTokenRes* temp = usertokenres_;
  usertokenres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertokenres(::pp::UserTokenRes* usertokenres) {
  delete usertokenres_;
  usertokenres_ = usertokenres;
  if (usertokenres) {
    set_has_usertokenres();
  } else {
    clear_has_usertokenres();
  }
}

// optional .pp.UptokenReq uptokenReq = 304;
inline bool ProtoBody::has_uptokenreq() const {
  return (_has_bits_[5] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_uptokenreq() {
  _has_bits_[5] |= 0x00000200u;
}
inline void ProtoBody::clear_has_uptokenreq() {
  _has_bits_[5] &= ~0x00000200u;
}
inline void ProtoBody::clear_uptokenreq() {
  if (uptokenreq_ != NULL) uptokenreq_->::pp::UptokenReq::Clear();
  clear_has_uptokenreq();
}
inline const ::pp::UptokenReq& ProtoBody::uptokenreq() const {
  return uptokenreq_ != NULL ? *uptokenreq_ : *default_instance_->uptokenreq_;
}
inline ::pp::UptokenReq* ProtoBody::mutable_uptokenreq() {
  set_has_uptokenreq();
  if (uptokenreq_ == NULL) uptokenreq_ = new ::pp::UptokenReq;
  return uptokenreq_;
}
inline ::pp::UptokenReq* ProtoBody::release_uptokenreq() {
  clear_has_uptokenreq();
  ::pp::UptokenReq* temp = uptokenreq_;
  uptokenreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_uptokenreq(::pp::UptokenReq* uptokenreq) {
  delete uptokenreq_;
  uptokenreq_ = uptokenreq;
  if (uptokenreq) {
    set_has_uptokenreq();
  } else {
    clear_has_uptokenreq();
  }
}

// optional .pp.UptokenRes uptokenRes = 305;
inline bool ProtoBody::has_uptokenres() const {
  return (_has_bits_[5] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_uptokenres() {
  _has_bits_[5] |= 0x00000400u;
}
inline void ProtoBody::clear_has_uptokenres() {
  _has_bits_[5] &= ~0x00000400u;
}
inline void ProtoBody::clear_uptokenres() {
  if (uptokenres_ != NULL) uptokenres_->::pp::UptokenRes::Clear();
  clear_has_uptokenres();
}
inline const ::pp::UptokenRes& ProtoBody::uptokenres() const {
  return uptokenres_ != NULL ? *uptokenres_ : *default_instance_->uptokenres_;
}
inline ::pp::UptokenRes* ProtoBody::mutable_uptokenres() {
  set_has_uptokenres();
  if (uptokenres_ == NULL) uptokenres_ = new ::pp::UptokenRes;
  return uptokenres_;
}
inline ::pp::UptokenRes* ProtoBody::release_uptokenres() {
  clear_has_uptokenres();
  ::pp::UptokenRes* temp = uptokenres_;
  uptokenres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_uptokenres(::pp::UptokenRes* uptokenres) {
  delete uptokenres_;
  uptokenres_ = uptokenres;
  if (uptokenres) {
    set_has_uptokenres();
  } else {
    clear_has_uptokenres();
  }
}

// optional .pp.UserPushTokenRegisterReq userPushTokenRegisterReq = 306;
inline bool ProtoBody::has_userpushtokenregisterreq() const {
  return (_has_bits_[5] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_userpushtokenregisterreq() {
  _has_bits_[5] |= 0x00000800u;
}
inline void ProtoBody::clear_has_userpushtokenregisterreq() {
  _has_bits_[5] &= ~0x00000800u;
}
inline void ProtoBody::clear_userpushtokenregisterreq() {
  if (userpushtokenregisterreq_ != NULL) userpushtokenregisterreq_->::pp::UserPushTokenRegisterReq::Clear();
  clear_has_userpushtokenregisterreq();
}
inline const ::pp::UserPushTokenRegisterReq& ProtoBody::userpushtokenregisterreq() const {
  return userpushtokenregisterreq_ != NULL ? *userpushtokenregisterreq_ : *default_instance_->userpushtokenregisterreq_;
}
inline ::pp::UserPushTokenRegisterReq* ProtoBody::mutable_userpushtokenregisterreq() {
  set_has_userpushtokenregisterreq();
  if (userpushtokenregisterreq_ == NULL) userpushtokenregisterreq_ = new ::pp::UserPushTokenRegisterReq;
  return userpushtokenregisterreq_;
}
inline ::pp::UserPushTokenRegisterReq* ProtoBody::release_userpushtokenregisterreq() {
  clear_has_userpushtokenregisterreq();
  ::pp::UserPushTokenRegisterReq* temp = userpushtokenregisterreq_;
  userpushtokenregisterreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpushtokenregisterreq(::pp::UserPushTokenRegisterReq* userpushtokenregisterreq) {
  delete userpushtokenregisterreq_;
  userpushtokenregisterreq_ = userpushtokenregisterreq;
  if (userpushtokenregisterreq) {
    set_has_userpushtokenregisterreq();
  } else {
    clear_has_userpushtokenregisterreq();
  }
}

// optional .pp.UserPushTokenRegisterRes userPushTokenRegisterRes = 307;
inline bool ProtoBody::has_userpushtokenregisterres() const {
  return (_has_bits_[5] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_userpushtokenregisterres() {
  _has_bits_[5] |= 0x00001000u;
}
inline void ProtoBody::clear_has_userpushtokenregisterres() {
  _has_bits_[5] &= ~0x00001000u;
}
inline void ProtoBody::clear_userpushtokenregisterres() {
  if (userpushtokenregisterres_ != NULL) userpushtokenregisterres_->::pp::UserPushTokenRegisterRes::Clear();
  clear_has_userpushtokenregisterres();
}
inline const ::pp::UserPushTokenRegisterRes& ProtoBody::userpushtokenregisterres() const {
  return userpushtokenregisterres_ != NULL ? *userpushtokenregisterres_ : *default_instance_->userpushtokenregisterres_;
}
inline ::pp::UserPushTokenRegisterRes* ProtoBody::mutable_userpushtokenregisterres() {
  set_has_userpushtokenregisterres();
  if (userpushtokenregisterres_ == NULL) userpushtokenregisterres_ = new ::pp::UserPushTokenRegisterRes;
  return userpushtokenregisterres_;
}
inline ::pp::UserPushTokenRegisterRes* ProtoBody::release_userpushtokenregisterres() {
  clear_has_userpushtokenregisterres();
  ::pp::UserPushTokenRegisterRes* temp = userpushtokenregisterres_;
  userpushtokenregisterres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpushtokenregisterres(::pp::UserPushTokenRegisterRes* userpushtokenregisterres) {
  delete userpushtokenregisterres_;
  userpushtokenregisterres_ = userpushtokenregisterres;
  if (userpushtokenregisterres) {
    set_has_userpushtokenregisterres();
  } else {
    clear_has_userpushtokenregisterres();
  }
}

// optional .pp.UserLogoutReq userLogoutReq = 308;
inline bool ProtoBody::has_userlogoutreq() const {
  return (_has_bits_[5] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_userlogoutreq() {
  _has_bits_[5] |= 0x00002000u;
}
inline void ProtoBody::clear_has_userlogoutreq() {
  _has_bits_[5] &= ~0x00002000u;
}
inline void ProtoBody::clear_userlogoutreq() {
  if (userlogoutreq_ != NULL) userlogoutreq_->::pp::UserLogoutReq::Clear();
  clear_has_userlogoutreq();
}
inline const ::pp::UserLogoutReq& ProtoBody::userlogoutreq() const {
  return userlogoutreq_ != NULL ? *userlogoutreq_ : *default_instance_->userlogoutreq_;
}
inline ::pp::UserLogoutReq* ProtoBody::mutable_userlogoutreq() {
  set_has_userlogoutreq();
  if (userlogoutreq_ == NULL) userlogoutreq_ = new ::pp::UserLogoutReq;
  return userlogoutreq_;
}
inline ::pp::UserLogoutReq* ProtoBody::release_userlogoutreq() {
  clear_has_userlogoutreq();
  ::pp::UserLogoutReq* temp = userlogoutreq_;
  userlogoutreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userlogoutreq(::pp::UserLogoutReq* userlogoutreq) {
  delete userlogoutreq_;
  userlogoutreq_ = userlogoutreq;
  if (userlogoutreq) {
    set_has_userlogoutreq();
  } else {
    clear_has_userlogoutreq();
  }
}

// optional .pp.UserLogoutRes userLogoutRes = 309;
inline bool ProtoBody::has_userlogoutres() const {
  return (_has_bits_[5] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_userlogoutres() {
  _has_bits_[5] |= 0x00004000u;
}
inline void ProtoBody::clear_has_userlogoutres() {
  _has_bits_[5] &= ~0x00004000u;
}
inline void ProtoBody::clear_userlogoutres() {
  if (userlogoutres_ != NULL) userlogoutres_->::pp::UserLogoutRes::Clear();
  clear_has_userlogoutres();
}
inline const ::pp::UserLogoutRes& ProtoBody::userlogoutres() const {
  return userlogoutres_ != NULL ? *userlogoutres_ : *default_instance_->userlogoutres_;
}
inline ::pp::UserLogoutRes* ProtoBody::mutable_userlogoutres() {
  set_has_userlogoutres();
  if (userlogoutres_ == NULL) userlogoutres_ = new ::pp::UserLogoutRes;
  return userlogoutres_;
}
inline ::pp::UserLogoutRes* ProtoBody::release_userlogoutres() {
  clear_has_userlogoutres();
  ::pp::UserLogoutRes* temp = userlogoutres_;
  userlogoutres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userlogoutres(::pp::UserLogoutRes* userlogoutres) {
  delete userlogoutres_;
  userlogoutres_ = userlogoutres;
  if (userlogoutres) {
    set_has_userlogoutres();
  } else {
    clear_has_userlogoutres();
  }
}

// optional .pp.CpsWebLoginReq cpsWebLoginReq = 320;
inline bool ProtoBody::has_cpswebloginreq() const {
  return (_has_bits_[5] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_cpswebloginreq() {
  _has_bits_[5] |= 0x00008000u;
}
inline void ProtoBody::clear_has_cpswebloginreq() {
  _has_bits_[5] &= ~0x00008000u;
}
inline void ProtoBody::clear_cpswebloginreq() {
  if (cpswebloginreq_ != NULL) cpswebloginreq_->::pp::CpsWebLoginReq::Clear();
  clear_has_cpswebloginreq();
}
inline const ::pp::CpsWebLoginReq& ProtoBody::cpswebloginreq() const {
  return cpswebloginreq_ != NULL ? *cpswebloginreq_ : *default_instance_->cpswebloginreq_;
}
inline ::pp::CpsWebLoginReq* ProtoBody::mutable_cpswebloginreq() {
  set_has_cpswebloginreq();
  if (cpswebloginreq_ == NULL) cpswebloginreq_ = new ::pp::CpsWebLoginReq;
  return cpswebloginreq_;
}
inline ::pp::CpsWebLoginReq* ProtoBody::release_cpswebloginreq() {
  clear_has_cpswebloginreq();
  ::pp::CpsWebLoginReq* temp = cpswebloginreq_;
  cpswebloginreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_cpswebloginreq(::pp::CpsWebLoginReq* cpswebloginreq) {
  delete cpswebloginreq_;
  cpswebloginreq_ = cpswebloginreq;
  if (cpswebloginreq) {
    set_has_cpswebloginreq();
  } else {
    clear_has_cpswebloginreq();
  }
}

// optional .pp.CpsWebLoginRes cpsWebLoginRes = 321;
inline bool ProtoBody::has_cpswebloginres() const {
  return (_has_bits_[5] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_cpswebloginres() {
  _has_bits_[5] |= 0x00010000u;
}
inline void ProtoBody::clear_has_cpswebloginres() {
  _has_bits_[5] &= ~0x00010000u;
}
inline void ProtoBody::clear_cpswebloginres() {
  if (cpswebloginres_ != NULL) cpswebloginres_->::pp::CpsWebLoginRes::Clear();
  clear_has_cpswebloginres();
}
inline const ::pp::CpsWebLoginRes& ProtoBody::cpswebloginres() const {
  return cpswebloginres_ != NULL ? *cpswebloginres_ : *default_instance_->cpswebloginres_;
}
inline ::pp::CpsWebLoginRes* ProtoBody::mutable_cpswebloginres() {
  set_has_cpswebloginres();
  if (cpswebloginres_ == NULL) cpswebloginres_ = new ::pp::CpsWebLoginRes;
  return cpswebloginres_;
}
inline ::pp::CpsWebLoginRes* ProtoBody::release_cpswebloginres() {
  clear_has_cpswebloginres();
  ::pp::CpsWebLoginRes* temp = cpswebloginres_;
  cpswebloginres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_cpswebloginres(::pp::CpsWebLoginRes* cpswebloginres) {
  delete cpswebloginres_;
  cpswebloginres_ = cpswebloginres;
  if (cpswebloginres) {
    set_has_cpswebloginres();
  } else {
    clear_has_cpswebloginres();
  }
}

// optional .pp.CpsAccountBindReq cpsAccountBindReq = 322;
inline bool ProtoBody::has_cpsaccountbindreq() const {
  return (_has_bits_[5] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_cpsaccountbindreq() {
  _has_bits_[5] |= 0x00020000u;
}
inline void ProtoBody::clear_has_cpsaccountbindreq() {
  _has_bits_[5] &= ~0x00020000u;
}
inline void ProtoBody::clear_cpsaccountbindreq() {
  if (cpsaccountbindreq_ != NULL) cpsaccountbindreq_->::pp::CpsAccountBindReq::Clear();
  clear_has_cpsaccountbindreq();
}
inline const ::pp::CpsAccountBindReq& ProtoBody::cpsaccountbindreq() const {
  return cpsaccountbindreq_ != NULL ? *cpsaccountbindreq_ : *default_instance_->cpsaccountbindreq_;
}
inline ::pp::CpsAccountBindReq* ProtoBody::mutable_cpsaccountbindreq() {
  set_has_cpsaccountbindreq();
  if (cpsaccountbindreq_ == NULL) cpsaccountbindreq_ = new ::pp::CpsAccountBindReq;
  return cpsaccountbindreq_;
}
inline ::pp::CpsAccountBindReq* ProtoBody::release_cpsaccountbindreq() {
  clear_has_cpsaccountbindreq();
  ::pp::CpsAccountBindReq* temp = cpsaccountbindreq_;
  cpsaccountbindreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_cpsaccountbindreq(::pp::CpsAccountBindReq* cpsaccountbindreq) {
  delete cpsaccountbindreq_;
  cpsaccountbindreq_ = cpsaccountbindreq;
  if (cpsaccountbindreq) {
    set_has_cpsaccountbindreq();
  } else {
    clear_has_cpsaccountbindreq();
  }
}

// optional .pp.CpsAccountBindRes cpsAccountBindRes = 323;
inline bool ProtoBody::has_cpsaccountbindres() const {
  return (_has_bits_[5] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_cpsaccountbindres() {
  _has_bits_[5] |= 0x00040000u;
}
inline void ProtoBody::clear_has_cpsaccountbindres() {
  _has_bits_[5] &= ~0x00040000u;
}
inline void ProtoBody::clear_cpsaccountbindres() {
  if (cpsaccountbindres_ != NULL) cpsaccountbindres_->::pp::CpsAccountBindRes::Clear();
  clear_has_cpsaccountbindres();
}
inline const ::pp::CpsAccountBindRes& ProtoBody::cpsaccountbindres() const {
  return cpsaccountbindres_ != NULL ? *cpsaccountbindres_ : *default_instance_->cpsaccountbindres_;
}
inline ::pp::CpsAccountBindRes* ProtoBody::mutable_cpsaccountbindres() {
  set_has_cpsaccountbindres();
  if (cpsaccountbindres_ == NULL) cpsaccountbindres_ = new ::pp::CpsAccountBindRes;
  return cpsaccountbindres_;
}
inline ::pp::CpsAccountBindRes* ProtoBody::release_cpsaccountbindres() {
  clear_has_cpsaccountbindres();
  ::pp::CpsAccountBindRes* temp = cpsaccountbindres_;
  cpsaccountbindres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_cpsaccountbindres(::pp::CpsAccountBindRes* cpsaccountbindres) {
  delete cpsaccountbindres_;
  cpsaccountbindres_ = cpsaccountbindres;
  if (cpsaccountbindres) {
    set_has_cpsaccountbindres();
  } else {
    clear_has_cpsaccountbindres();
  }
}

// optional .pp.PresentInfoReq presentInfoReq = 13057;
inline bool ProtoBody::has_presentinforeq() const {
  return (_has_bits_[5] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_presentinforeq() {
  _has_bits_[5] |= 0x00080000u;
}
inline void ProtoBody::clear_has_presentinforeq() {
  _has_bits_[5] &= ~0x00080000u;
}
inline void ProtoBody::clear_presentinforeq() {
  if (presentinforeq_ != NULL) presentinforeq_->::pp::PresentInfoReq::Clear();
  clear_has_presentinforeq();
}
inline const ::pp::PresentInfoReq& ProtoBody::presentinforeq() const {
  return presentinforeq_ != NULL ? *presentinforeq_ : *default_instance_->presentinforeq_;
}
inline ::pp::PresentInfoReq* ProtoBody::mutable_presentinforeq() {
  set_has_presentinforeq();
  if (presentinforeq_ == NULL) presentinforeq_ = new ::pp::PresentInfoReq;
  return presentinforeq_;
}
inline ::pp::PresentInfoReq* ProtoBody::release_presentinforeq() {
  clear_has_presentinforeq();
  ::pp::PresentInfoReq* temp = presentinforeq_;
  presentinforeq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentinforeq(::pp::PresentInfoReq* presentinforeq) {
  delete presentinforeq_;
  presentinforeq_ = presentinforeq;
  if (presentinforeq) {
    set_has_presentinforeq();
  } else {
    clear_has_presentinforeq();
  }
}

// optional .pp.PresentInfoRes presentInfoRes = 13058;
inline bool ProtoBody::has_presentinfores() const {
  return (_has_bits_[5] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_presentinfores() {
  _has_bits_[5] |= 0x00100000u;
}
inline void ProtoBody::clear_has_presentinfores() {
  _has_bits_[5] &= ~0x00100000u;
}
inline void ProtoBody::clear_presentinfores() {
  if (presentinfores_ != NULL) presentinfores_->::pp::PresentInfoRes::Clear();
  clear_has_presentinfores();
}
inline const ::pp::PresentInfoRes& ProtoBody::presentinfores() const {
  return presentinfores_ != NULL ? *presentinfores_ : *default_instance_->presentinfores_;
}
inline ::pp::PresentInfoRes* ProtoBody::mutable_presentinfores() {
  set_has_presentinfores();
  if (presentinfores_ == NULL) presentinfores_ = new ::pp::PresentInfoRes;
  return presentinfores_;
}
inline ::pp::PresentInfoRes* ProtoBody::release_presentinfores() {
  clear_has_presentinfores();
  ::pp::PresentInfoRes* temp = presentinfores_;
  presentinfores_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentinfores(::pp::PresentInfoRes* presentinfores) {
  delete presentinfores_;
  presentinfores_ = presentinfores;
  if (presentinfores) {
    set_has_presentinfores();
  } else {
    clear_has_presentinfores();
  }
}

// optional .pp.PresentAddReq presentAddReq = 13059;
inline bool ProtoBody::has_presentaddreq() const {
  return (_has_bits_[5] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_presentaddreq() {
  _has_bits_[5] |= 0x00200000u;
}
inline void ProtoBody::clear_has_presentaddreq() {
  _has_bits_[5] &= ~0x00200000u;
}
inline void ProtoBody::clear_presentaddreq() {
  if (presentaddreq_ != NULL) presentaddreq_->::pp::PresentAddReq::Clear();
  clear_has_presentaddreq();
}
inline const ::pp::PresentAddReq& ProtoBody::presentaddreq() const {
  return presentaddreq_ != NULL ? *presentaddreq_ : *default_instance_->presentaddreq_;
}
inline ::pp::PresentAddReq* ProtoBody::mutable_presentaddreq() {
  set_has_presentaddreq();
  if (presentaddreq_ == NULL) presentaddreq_ = new ::pp::PresentAddReq;
  return presentaddreq_;
}
inline ::pp::PresentAddReq* ProtoBody::release_presentaddreq() {
  clear_has_presentaddreq();
  ::pp::PresentAddReq* temp = presentaddreq_;
  presentaddreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentaddreq(::pp::PresentAddReq* presentaddreq) {
  delete presentaddreq_;
  presentaddreq_ = presentaddreq;
  if (presentaddreq) {
    set_has_presentaddreq();
  } else {
    clear_has_presentaddreq();
  }
}

// optional .pp.GetPresentsByGameIdReq getPresentsByGameIdReq = 13061;
inline bool ProtoBody::has_getpresentsbygameidreq() const {
  return (_has_bits_[5] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_getpresentsbygameidreq() {
  _has_bits_[5] |= 0x00400000u;
}
inline void ProtoBody::clear_has_getpresentsbygameidreq() {
  _has_bits_[5] &= ~0x00400000u;
}
inline void ProtoBody::clear_getpresentsbygameidreq() {
  if (getpresentsbygameidreq_ != NULL) getpresentsbygameidreq_->::pp::GetPresentsByGameIdReq::Clear();
  clear_has_getpresentsbygameidreq();
}
inline const ::pp::GetPresentsByGameIdReq& ProtoBody::getpresentsbygameidreq() const {
  return getpresentsbygameidreq_ != NULL ? *getpresentsbygameidreq_ : *default_instance_->getpresentsbygameidreq_;
}
inline ::pp::GetPresentsByGameIdReq* ProtoBody::mutable_getpresentsbygameidreq() {
  set_has_getpresentsbygameidreq();
  if (getpresentsbygameidreq_ == NULL) getpresentsbygameidreq_ = new ::pp::GetPresentsByGameIdReq;
  return getpresentsbygameidreq_;
}
inline ::pp::GetPresentsByGameIdReq* ProtoBody::release_getpresentsbygameidreq() {
  clear_has_getpresentsbygameidreq();
  ::pp::GetPresentsByGameIdReq* temp = getpresentsbygameidreq_;
  getpresentsbygameidreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_getpresentsbygameidreq(::pp::GetPresentsByGameIdReq* getpresentsbygameidreq) {
  delete getpresentsbygameidreq_;
  getpresentsbygameidreq_ = getpresentsbygameidreq;
  if (getpresentsbygameidreq) {
    set_has_getpresentsbygameidreq();
  } else {
    clear_has_getpresentsbygameidreq();
  }
}

// optional .pp.GetPresentsByGameIdRes getPresentsByGameIdRes = 13062;
inline bool ProtoBody::has_getpresentsbygameidres() const {
  return (_has_bits_[5] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_getpresentsbygameidres() {
  _has_bits_[5] |= 0x00800000u;
}
inline void ProtoBody::clear_has_getpresentsbygameidres() {
  _has_bits_[5] &= ~0x00800000u;
}
inline void ProtoBody::clear_getpresentsbygameidres() {
  if (getpresentsbygameidres_ != NULL) getpresentsbygameidres_->::pp::GetPresentsByGameIdRes::Clear();
  clear_has_getpresentsbygameidres();
}
inline const ::pp::GetPresentsByGameIdRes& ProtoBody::getpresentsbygameidres() const {
  return getpresentsbygameidres_ != NULL ? *getpresentsbygameidres_ : *default_instance_->getpresentsbygameidres_;
}
inline ::pp::GetPresentsByGameIdRes* ProtoBody::mutable_getpresentsbygameidres() {
  set_has_getpresentsbygameidres();
  if (getpresentsbygameidres_ == NULL) getpresentsbygameidres_ = new ::pp::GetPresentsByGameIdRes;
  return getpresentsbygameidres_;
}
inline ::pp::GetPresentsByGameIdRes* ProtoBody::release_getpresentsbygameidres() {
  clear_has_getpresentsbygameidres();
  ::pp::GetPresentsByGameIdRes* temp = getpresentsbygameidres_;
  getpresentsbygameidres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_getpresentsbygameidres(::pp::GetPresentsByGameIdRes* getpresentsbygameidres) {
  delete getpresentsbygameidres_;
  getpresentsbygameidres_ = getpresentsbygameidres;
  if (getpresentsbygameidres) {
    set_has_getpresentsbygameidres();
  } else {
    clear_has_getpresentsbygameidres();
  }
}

// optional .pp.PresentListReq presentListReq = 13063;
inline bool ProtoBody::has_presentlistreq() const {
  return (_has_bits_[5] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_presentlistreq() {
  _has_bits_[5] |= 0x01000000u;
}
inline void ProtoBody::clear_has_presentlistreq() {
  _has_bits_[5] &= ~0x01000000u;
}
inline void ProtoBody::clear_presentlistreq() {
  if (presentlistreq_ != NULL) presentlistreq_->::pp::PresentListReq::Clear();
  clear_has_presentlistreq();
}
inline const ::pp::PresentListReq& ProtoBody::presentlistreq() const {
  return presentlistreq_ != NULL ? *presentlistreq_ : *default_instance_->presentlistreq_;
}
inline ::pp::PresentListReq* ProtoBody::mutable_presentlistreq() {
  set_has_presentlistreq();
  if (presentlistreq_ == NULL) presentlistreq_ = new ::pp::PresentListReq;
  return presentlistreq_;
}
inline ::pp::PresentListReq* ProtoBody::release_presentlistreq() {
  clear_has_presentlistreq();
  ::pp::PresentListReq* temp = presentlistreq_;
  presentlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentlistreq(::pp::PresentListReq* presentlistreq) {
  delete presentlistreq_;
  presentlistreq_ = presentlistreq;
  if (presentlistreq) {
    set_has_presentlistreq();
  } else {
    clear_has_presentlistreq();
  }
}

// optional .pp.PresentListRes presentListRes = 13064;
inline bool ProtoBody::has_presentlistres() const {
  return (_has_bits_[5] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_presentlistres() {
  _has_bits_[5] |= 0x02000000u;
}
inline void ProtoBody::clear_has_presentlistres() {
  _has_bits_[5] &= ~0x02000000u;
}
inline void ProtoBody::clear_presentlistres() {
  if (presentlistres_ != NULL) presentlistres_->::pp::PresentListRes::Clear();
  clear_has_presentlistres();
}
inline const ::pp::PresentListRes& ProtoBody::presentlistres() const {
  return presentlistres_ != NULL ? *presentlistres_ : *default_instance_->presentlistres_;
}
inline ::pp::PresentListRes* ProtoBody::mutable_presentlistres() {
  set_has_presentlistres();
  if (presentlistres_ == NULL) presentlistres_ = new ::pp::PresentListRes;
  return presentlistres_;
}
inline ::pp::PresentListRes* ProtoBody::release_presentlistres() {
  clear_has_presentlistres();
  ::pp::PresentListRes* temp = presentlistres_;
  presentlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentlistres(::pp::PresentListRes* presentlistres) {
  delete presentlistres_;
  presentlistres_ = presentlistres;
  if (presentlistres) {
    set_has_presentlistres();
  } else {
    clear_has_presentlistres();
  }
}

// optional .pp.PresentCountReq presentCountReq = 13065;
inline bool ProtoBody::has_presentcountreq() const {
  return (_has_bits_[5] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_presentcountreq() {
  _has_bits_[5] |= 0x04000000u;
}
inline void ProtoBody::clear_has_presentcountreq() {
  _has_bits_[5] &= ~0x04000000u;
}
inline void ProtoBody::clear_presentcountreq() {
  if (presentcountreq_ != NULL) presentcountreq_->::pp::PresentCountReq::Clear();
  clear_has_presentcountreq();
}
inline const ::pp::PresentCountReq& ProtoBody::presentcountreq() const {
  return presentcountreq_ != NULL ? *presentcountreq_ : *default_instance_->presentcountreq_;
}
inline ::pp::PresentCountReq* ProtoBody::mutable_presentcountreq() {
  set_has_presentcountreq();
  if (presentcountreq_ == NULL) presentcountreq_ = new ::pp::PresentCountReq;
  return presentcountreq_;
}
inline ::pp::PresentCountReq* ProtoBody::release_presentcountreq() {
  clear_has_presentcountreq();
  ::pp::PresentCountReq* temp = presentcountreq_;
  presentcountreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentcountreq(::pp::PresentCountReq* presentcountreq) {
  delete presentcountreq_;
  presentcountreq_ = presentcountreq;
  if (presentcountreq) {
    set_has_presentcountreq();
  } else {
    clear_has_presentcountreq();
  }
}

// optional .pp.PresentCountRes presentCountRes = 13066;
inline bool ProtoBody::has_presentcountres() const {
  return (_has_bits_[5] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_presentcountres() {
  _has_bits_[5] |= 0x08000000u;
}
inline void ProtoBody::clear_has_presentcountres() {
  _has_bits_[5] &= ~0x08000000u;
}
inline void ProtoBody::clear_presentcountres() {
  if (presentcountres_ != NULL) presentcountres_->::pp::PresentCountRes::Clear();
  clear_has_presentcountres();
}
inline const ::pp::PresentCountRes& ProtoBody::presentcountres() const {
  return presentcountres_ != NULL ? *presentcountres_ : *default_instance_->presentcountres_;
}
inline ::pp::PresentCountRes* ProtoBody::mutable_presentcountres() {
  set_has_presentcountres();
  if (presentcountres_ == NULL) presentcountres_ = new ::pp::PresentCountRes;
  return presentcountres_;
}
inline ::pp::PresentCountRes* ProtoBody::release_presentcountres() {
  clear_has_presentcountres();
  ::pp::PresentCountRes* temp = presentcountres_;
  presentcountres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentcountres(::pp::PresentCountRes* presentcountres) {
  delete presentcountres_;
  presentcountres_ = presentcountres;
  if (presentcountres) {
    set_has_presentcountres();
  } else {
    clear_has_presentcountres();
  }
}

// optional .pp.PresentGroupListReq presentGroupListReq = 13067;
inline bool ProtoBody::has_presentgrouplistreq() const {
  return (_has_bits_[5] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_presentgrouplistreq() {
  _has_bits_[5] |= 0x10000000u;
}
inline void ProtoBody::clear_has_presentgrouplistreq() {
  _has_bits_[5] &= ~0x10000000u;
}
inline void ProtoBody::clear_presentgrouplistreq() {
  if (presentgrouplistreq_ != NULL) presentgrouplistreq_->::pp::PresentGroupListReq::Clear();
  clear_has_presentgrouplistreq();
}
inline const ::pp::PresentGroupListReq& ProtoBody::presentgrouplistreq() const {
  return presentgrouplistreq_ != NULL ? *presentgrouplistreq_ : *default_instance_->presentgrouplistreq_;
}
inline ::pp::PresentGroupListReq* ProtoBody::mutable_presentgrouplistreq() {
  set_has_presentgrouplistreq();
  if (presentgrouplistreq_ == NULL) presentgrouplistreq_ = new ::pp::PresentGroupListReq;
  return presentgrouplistreq_;
}
inline ::pp::PresentGroupListReq* ProtoBody::release_presentgrouplistreq() {
  clear_has_presentgrouplistreq();
  ::pp::PresentGroupListReq* temp = presentgrouplistreq_;
  presentgrouplistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentgrouplistreq(::pp::PresentGroupListReq* presentgrouplistreq) {
  delete presentgrouplistreq_;
  presentgrouplistreq_ = presentgrouplistreq;
  if (presentgrouplistreq) {
    set_has_presentgrouplistreq();
  } else {
    clear_has_presentgrouplistreq();
  }
}

// optional .pp.PresentGroupListRes presentGroupListRes = 13068;
inline bool ProtoBody::has_presentgrouplistres() const {
  return (_has_bits_[5] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_presentgrouplistres() {
  _has_bits_[5] |= 0x20000000u;
}
inline void ProtoBody::clear_has_presentgrouplistres() {
  _has_bits_[5] &= ~0x20000000u;
}
inline void ProtoBody::clear_presentgrouplistres() {
  if (presentgrouplistres_ != NULL) presentgrouplistres_->::pp::PresentGroupListRes::Clear();
  clear_has_presentgrouplistres();
}
inline const ::pp::PresentGroupListRes& ProtoBody::presentgrouplistres() const {
  return presentgrouplistres_ != NULL ? *presentgrouplistres_ : *default_instance_->presentgrouplistres_;
}
inline ::pp::PresentGroupListRes* ProtoBody::mutable_presentgrouplistres() {
  set_has_presentgrouplistres();
  if (presentgrouplistres_ == NULL) presentgrouplistres_ = new ::pp::PresentGroupListRes;
  return presentgrouplistres_;
}
inline ::pp::PresentGroupListRes* ProtoBody::release_presentgrouplistres() {
  clear_has_presentgrouplistres();
  ::pp::PresentGroupListRes* temp = presentgrouplistres_;
  presentgrouplistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentgrouplistres(::pp::PresentGroupListRes* presentgrouplistres) {
  delete presentgrouplistres_;
  presentgrouplistres_ = presentgrouplistres;
  if (presentgrouplistres) {
    set_has_presentgrouplistres();
  } else {
    clear_has_presentgrouplistres();
  }
}

// optional .pp.PresentUserTakeReq presentUserTakeReq = 13069;
inline bool ProtoBody::has_presentusertakereq() const {
  return (_has_bits_[5] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_presentusertakereq() {
  _has_bits_[5] |= 0x40000000u;
}
inline void ProtoBody::clear_has_presentusertakereq() {
  _has_bits_[5] &= ~0x40000000u;
}
inline void ProtoBody::clear_presentusertakereq() {
  if (presentusertakereq_ != NULL) presentusertakereq_->::pp::PresentUserTakeReq::Clear();
  clear_has_presentusertakereq();
}
inline const ::pp::PresentUserTakeReq& ProtoBody::presentusertakereq() const {
  return presentusertakereq_ != NULL ? *presentusertakereq_ : *default_instance_->presentusertakereq_;
}
inline ::pp::PresentUserTakeReq* ProtoBody::mutable_presentusertakereq() {
  set_has_presentusertakereq();
  if (presentusertakereq_ == NULL) presentusertakereq_ = new ::pp::PresentUserTakeReq;
  return presentusertakereq_;
}
inline ::pp::PresentUserTakeReq* ProtoBody::release_presentusertakereq() {
  clear_has_presentusertakereq();
  ::pp::PresentUserTakeReq* temp = presentusertakereq_;
  presentusertakereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentusertakereq(::pp::PresentUserTakeReq* presentusertakereq) {
  delete presentusertakereq_;
  presentusertakereq_ = presentusertakereq;
  if (presentusertakereq) {
    set_has_presentusertakereq();
  } else {
    clear_has_presentusertakereq();
  }
}

// optional .pp.PresentUserTakeRes presentUserTakeRes = 13070;
inline bool ProtoBody::has_presentusertakeres() const {
  return (_has_bits_[5] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_presentusertakeres() {
  _has_bits_[5] |= 0x80000000u;
}
inline void ProtoBody::clear_has_presentusertakeres() {
  _has_bits_[5] &= ~0x80000000u;
}
inline void ProtoBody::clear_presentusertakeres() {
  if (presentusertakeres_ != NULL) presentusertakeres_->::pp::PresentUserTakeRes::Clear();
  clear_has_presentusertakeres();
}
inline const ::pp::PresentUserTakeRes& ProtoBody::presentusertakeres() const {
  return presentusertakeres_ != NULL ? *presentusertakeres_ : *default_instance_->presentusertakeres_;
}
inline ::pp::PresentUserTakeRes* ProtoBody::mutable_presentusertakeres() {
  set_has_presentusertakeres();
  if (presentusertakeres_ == NULL) presentusertakeres_ = new ::pp::PresentUserTakeRes;
  return presentusertakeres_;
}
inline ::pp::PresentUserTakeRes* ProtoBody::release_presentusertakeres() {
  clear_has_presentusertakeres();
  ::pp::PresentUserTakeRes* temp = presentusertakeres_;
  presentusertakeres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentusertakeres(::pp::PresentUserTakeRes* presentusertakeres) {
  delete presentusertakeres_;
  presentusertakeres_ = presentusertakeres;
  if (presentusertakeres) {
    set_has_presentusertakeres();
  } else {
    clear_has_presentusertakeres();
  }
}

// optional .pp.PresentModifyReq presentModifyReq = 13073;
inline bool ProtoBody::has_presentmodifyreq() const {
  return (_has_bits_[6] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_presentmodifyreq() {
  _has_bits_[6] |= 0x00000001u;
}
inline void ProtoBody::clear_has_presentmodifyreq() {
  _has_bits_[6] &= ~0x00000001u;
}
inline void ProtoBody::clear_presentmodifyreq() {
  if (presentmodifyreq_ != NULL) presentmodifyreq_->::pp::PresentModifyReq::Clear();
  clear_has_presentmodifyreq();
}
inline const ::pp::PresentModifyReq& ProtoBody::presentmodifyreq() const {
  return presentmodifyreq_ != NULL ? *presentmodifyreq_ : *default_instance_->presentmodifyreq_;
}
inline ::pp::PresentModifyReq* ProtoBody::mutable_presentmodifyreq() {
  set_has_presentmodifyreq();
  if (presentmodifyreq_ == NULL) presentmodifyreq_ = new ::pp::PresentModifyReq;
  return presentmodifyreq_;
}
inline ::pp::PresentModifyReq* ProtoBody::release_presentmodifyreq() {
  clear_has_presentmodifyreq();
  ::pp::PresentModifyReq* temp = presentmodifyreq_;
  presentmodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentmodifyreq(::pp::PresentModifyReq* presentmodifyreq) {
  delete presentmodifyreq_;
  presentmodifyreq_ = presentmodifyreq;
  if (presentmodifyreq) {
    set_has_presentmodifyreq();
  } else {
    clear_has_presentmodifyreq();
  }
}

// optional .pp.UserPresentReq userPresentReq = 13088;
inline bool ProtoBody::has_userpresentreq() const {
  return (_has_bits_[6] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_userpresentreq() {
  _has_bits_[6] |= 0x00000002u;
}
inline void ProtoBody::clear_has_userpresentreq() {
  _has_bits_[6] &= ~0x00000002u;
}
inline void ProtoBody::clear_userpresentreq() {
  if (userpresentreq_ != NULL) userpresentreq_->::pp::UserPresentReq::Clear();
  clear_has_userpresentreq();
}
inline const ::pp::UserPresentReq& ProtoBody::userpresentreq() const {
  return userpresentreq_ != NULL ? *userpresentreq_ : *default_instance_->userpresentreq_;
}
inline ::pp::UserPresentReq* ProtoBody::mutable_userpresentreq() {
  set_has_userpresentreq();
  if (userpresentreq_ == NULL) userpresentreq_ = new ::pp::UserPresentReq;
  return userpresentreq_;
}
inline ::pp::UserPresentReq* ProtoBody::release_userpresentreq() {
  clear_has_userpresentreq();
  ::pp::UserPresentReq* temp = userpresentreq_;
  userpresentreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpresentreq(::pp::UserPresentReq* userpresentreq) {
  delete userpresentreq_;
  userpresentreq_ = userpresentreq;
  if (userpresentreq) {
    set_has_userpresentreq();
  } else {
    clear_has_userpresentreq();
  }
}

// optional .pp.UserPresentRes userPresentRes = 13089;
inline bool ProtoBody::has_userpresentres() const {
  return (_has_bits_[6] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_userpresentres() {
  _has_bits_[6] |= 0x00000004u;
}
inline void ProtoBody::clear_has_userpresentres() {
  _has_bits_[6] &= ~0x00000004u;
}
inline void ProtoBody::clear_userpresentres() {
  if (userpresentres_ != NULL) userpresentres_->::pp::UserPresentRes::Clear();
  clear_has_userpresentres();
}
inline const ::pp::UserPresentRes& ProtoBody::userpresentres() const {
  return userpresentres_ != NULL ? *userpresentres_ : *default_instance_->userpresentres_;
}
inline ::pp::UserPresentRes* ProtoBody::mutable_userpresentres() {
  set_has_userpresentres();
  if (userpresentres_ == NULL) userpresentres_ = new ::pp::UserPresentRes;
  return userpresentres_;
}
inline ::pp::UserPresentRes* ProtoBody::release_userpresentres() {
  clear_has_userpresentres();
  ::pp::UserPresentRes* temp = userpresentres_;
  userpresentres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpresentres(::pp::UserPresentRes* userpresentres) {
  delete userpresentres_;
  userpresentres_ = userpresentres;
  if (userpresentres) {
    set_has_userpresentres();
  } else {
    clear_has_userpresentres();
  }
}

// optional .pp.UserPresentListReq userPresentListReq = 13090;
inline bool ProtoBody::has_userpresentlistreq() const {
  return (_has_bits_[6] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_userpresentlistreq() {
  _has_bits_[6] |= 0x00000008u;
}
inline void ProtoBody::clear_has_userpresentlistreq() {
  _has_bits_[6] &= ~0x00000008u;
}
inline void ProtoBody::clear_userpresentlistreq() {
  if (userpresentlistreq_ != NULL) userpresentlistreq_->::pp::UserPresentListReq::Clear();
  clear_has_userpresentlistreq();
}
inline const ::pp::UserPresentListReq& ProtoBody::userpresentlistreq() const {
  return userpresentlistreq_ != NULL ? *userpresentlistreq_ : *default_instance_->userpresentlistreq_;
}
inline ::pp::UserPresentListReq* ProtoBody::mutable_userpresentlistreq() {
  set_has_userpresentlistreq();
  if (userpresentlistreq_ == NULL) userpresentlistreq_ = new ::pp::UserPresentListReq;
  return userpresentlistreq_;
}
inline ::pp::UserPresentListReq* ProtoBody::release_userpresentlistreq() {
  clear_has_userpresentlistreq();
  ::pp::UserPresentListReq* temp = userpresentlistreq_;
  userpresentlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpresentlistreq(::pp::UserPresentListReq* userpresentlistreq) {
  delete userpresentlistreq_;
  userpresentlistreq_ = userpresentlistreq;
  if (userpresentlistreq) {
    set_has_userpresentlistreq();
  } else {
    clear_has_userpresentlistreq();
  }
}

// optional .pp.UserPresentListRes userPresentListRes = 13091;
inline bool ProtoBody::has_userpresentlistres() const {
  return (_has_bits_[6] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_userpresentlistres() {
  _has_bits_[6] |= 0x00000010u;
}
inline void ProtoBody::clear_has_userpresentlistres() {
  _has_bits_[6] &= ~0x00000010u;
}
inline void ProtoBody::clear_userpresentlistres() {
  if (userpresentlistres_ != NULL) userpresentlistres_->::pp::UserPresentListRes::Clear();
  clear_has_userpresentlistres();
}
inline const ::pp::UserPresentListRes& ProtoBody::userpresentlistres() const {
  return userpresentlistres_ != NULL ? *userpresentlistres_ : *default_instance_->userpresentlistres_;
}
inline ::pp::UserPresentListRes* ProtoBody::mutable_userpresentlistres() {
  set_has_userpresentlistres();
  if (userpresentlistres_ == NULL) userpresentlistres_ = new ::pp::UserPresentListRes;
  return userpresentlistres_;
}
inline ::pp::UserPresentListRes* ProtoBody::release_userpresentlistres() {
  clear_has_userpresentlistres();
  ::pp::UserPresentListRes* temp = userpresentlistres_;
  userpresentlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpresentlistres(::pp::UserPresentListRes* userpresentlistres) {
  delete userpresentlistres_;
  userpresentlistres_ = userpresentlistres;
  if (userpresentlistres) {
    set_has_userpresentlistres();
  } else {
    clear_has_userpresentlistres();
  }
}

// optional .pp.GroupPresentOpReq groupPresentOpReq = 13092;
inline bool ProtoBody::has_grouppresentopreq() const {
  return (_has_bits_[6] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_grouppresentopreq() {
  _has_bits_[6] |= 0x00000020u;
}
inline void ProtoBody::clear_has_grouppresentopreq() {
  _has_bits_[6] &= ~0x00000020u;
}
inline void ProtoBody::clear_grouppresentopreq() {
  if (grouppresentopreq_ != NULL) grouppresentopreq_->::pp::GroupPresentOpReq::Clear();
  clear_has_grouppresentopreq();
}
inline const ::pp::GroupPresentOpReq& ProtoBody::grouppresentopreq() const {
  return grouppresentopreq_ != NULL ? *grouppresentopreq_ : *default_instance_->grouppresentopreq_;
}
inline ::pp::GroupPresentOpReq* ProtoBody::mutable_grouppresentopreq() {
  set_has_grouppresentopreq();
  if (grouppresentopreq_ == NULL) grouppresentopreq_ = new ::pp::GroupPresentOpReq;
  return grouppresentopreq_;
}
inline ::pp::GroupPresentOpReq* ProtoBody::release_grouppresentopreq() {
  clear_has_grouppresentopreq();
  ::pp::GroupPresentOpReq* temp = grouppresentopreq_;
  grouppresentopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouppresentopreq(::pp::GroupPresentOpReq* grouppresentopreq) {
  delete grouppresentopreq_;
  grouppresentopreq_ = grouppresentopreq;
  if (grouppresentopreq) {
    set_has_grouppresentopreq();
  } else {
    clear_has_grouppresentopreq();
  }
}

// optional .pp.GroupPresentOpRes groupPresentOpRes = 13093;
inline bool ProtoBody::has_grouppresentopres() const {
  return (_has_bits_[6] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_grouppresentopres() {
  _has_bits_[6] |= 0x00000040u;
}
inline void ProtoBody::clear_has_grouppresentopres() {
  _has_bits_[6] &= ~0x00000040u;
}
inline void ProtoBody::clear_grouppresentopres() {
  if (grouppresentopres_ != NULL) grouppresentopres_->::pp::GroupPresentOpRes::Clear();
  clear_has_grouppresentopres();
}
inline const ::pp::GroupPresentOpRes& ProtoBody::grouppresentopres() const {
  return grouppresentopres_ != NULL ? *grouppresentopres_ : *default_instance_->grouppresentopres_;
}
inline ::pp::GroupPresentOpRes* ProtoBody::mutable_grouppresentopres() {
  set_has_grouppresentopres();
  if (grouppresentopres_ == NULL) grouppresentopres_ = new ::pp::GroupPresentOpRes;
  return grouppresentopres_;
}
inline ::pp::GroupPresentOpRes* ProtoBody::release_grouppresentopres() {
  clear_has_grouppresentopres();
  ::pp::GroupPresentOpRes* temp = grouppresentopres_;
  grouppresentopres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouppresentopres(::pp::GroupPresentOpRes* grouppresentopres) {
  delete grouppresentopres_;
  grouppresentopres_ = grouppresentopres;
  if (grouppresentopres) {
    set_has_grouppresentopres();
  } else {
    clear_has_grouppresentopres();
  }
}

// optional .pp.GroupPresentListReq groupPresentListReq = 13094;
inline bool ProtoBody::has_grouppresentlistreq() const {
  return (_has_bits_[6] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_grouppresentlistreq() {
  _has_bits_[6] |= 0x00000080u;
}
inline void ProtoBody::clear_has_grouppresentlistreq() {
  _has_bits_[6] &= ~0x00000080u;
}
inline void ProtoBody::clear_grouppresentlistreq() {
  if (grouppresentlistreq_ != NULL) grouppresentlistreq_->::pp::GroupPresentListReq::Clear();
  clear_has_grouppresentlistreq();
}
inline const ::pp::GroupPresentListReq& ProtoBody::grouppresentlistreq() const {
  return grouppresentlistreq_ != NULL ? *grouppresentlistreq_ : *default_instance_->grouppresentlistreq_;
}
inline ::pp::GroupPresentListReq* ProtoBody::mutable_grouppresentlistreq() {
  set_has_grouppresentlistreq();
  if (grouppresentlistreq_ == NULL) grouppresentlistreq_ = new ::pp::GroupPresentListReq;
  return grouppresentlistreq_;
}
inline ::pp::GroupPresentListReq* ProtoBody::release_grouppresentlistreq() {
  clear_has_grouppresentlistreq();
  ::pp::GroupPresentListReq* temp = grouppresentlistreq_;
  grouppresentlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouppresentlistreq(::pp::GroupPresentListReq* grouppresentlistreq) {
  delete grouppresentlistreq_;
  grouppresentlistreq_ = grouppresentlistreq;
  if (grouppresentlistreq) {
    set_has_grouppresentlistreq();
  } else {
    clear_has_grouppresentlistreq();
  }
}

// optional .pp.GroupPresentListRes groupPresentListRes = 13095;
inline bool ProtoBody::has_grouppresentlistres() const {
  return (_has_bits_[6] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_grouppresentlistres() {
  _has_bits_[6] |= 0x00000100u;
}
inline void ProtoBody::clear_has_grouppresentlistres() {
  _has_bits_[6] &= ~0x00000100u;
}
inline void ProtoBody::clear_grouppresentlistres() {
  if (grouppresentlistres_ != NULL) grouppresentlistres_->::pp::GroupPresentListRes::Clear();
  clear_has_grouppresentlistres();
}
inline const ::pp::GroupPresentListRes& ProtoBody::grouppresentlistres() const {
  return grouppresentlistres_ != NULL ? *grouppresentlistres_ : *default_instance_->grouppresentlistres_;
}
inline ::pp::GroupPresentListRes* ProtoBody::mutable_grouppresentlistres() {
  set_has_grouppresentlistres();
  if (grouppresentlistres_ == NULL) grouppresentlistres_ = new ::pp::GroupPresentListRes;
  return grouppresentlistres_;
}
inline ::pp::GroupPresentListRes* ProtoBody::release_grouppresentlistres() {
  clear_has_grouppresentlistres();
  ::pp::GroupPresentListRes* temp = grouppresentlistres_;
  grouppresentlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_grouppresentlistres(::pp::GroupPresentListRes* grouppresentlistres) {
  delete grouppresentlistres_;
  grouppresentlistres_ = grouppresentlistres;
  if (grouppresentlistres) {
    set_has_grouppresentlistres();
  } else {
    clear_has_grouppresentlistres();
  }
}

// optional .pp.PresentUserListReq presentUserListReq = 13096;
inline bool ProtoBody::has_presentuserlistreq() const {
  return (_has_bits_[6] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_presentuserlistreq() {
  _has_bits_[6] |= 0x00000200u;
}
inline void ProtoBody::clear_has_presentuserlistreq() {
  _has_bits_[6] &= ~0x00000200u;
}
inline void ProtoBody::clear_presentuserlistreq() {
  if (presentuserlistreq_ != NULL) presentuserlistreq_->::pp::PresentUserListReq::Clear();
  clear_has_presentuserlistreq();
}
inline const ::pp::PresentUserListReq& ProtoBody::presentuserlistreq() const {
  return presentuserlistreq_ != NULL ? *presentuserlistreq_ : *default_instance_->presentuserlistreq_;
}
inline ::pp::PresentUserListReq* ProtoBody::mutable_presentuserlistreq() {
  set_has_presentuserlistreq();
  if (presentuserlistreq_ == NULL) presentuserlistreq_ = new ::pp::PresentUserListReq;
  return presentuserlistreq_;
}
inline ::pp::PresentUserListReq* ProtoBody::release_presentuserlistreq() {
  clear_has_presentuserlistreq();
  ::pp::PresentUserListReq* temp = presentuserlistreq_;
  presentuserlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentuserlistreq(::pp::PresentUserListReq* presentuserlistreq) {
  delete presentuserlistreq_;
  presentuserlistreq_ = presentuserlistreq;
  if (presentuserlistreq) {
    set_has_presentuserlistreq();
  } else {
    clear_has_presentuserlistreq();
  }
}

// optional .pp.PresentUserListRes presentUserListRes = 13097;
inline bool ProtoBody::has_presentuserlistres() const {
  return (_has_bits_[6] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_presentuserlistres() {
  _has_bits_[6] |= 0x00000400u;
}
inline void ProtoBody::clear_has_presentuserlistres() {
  _has_bits_[6] &= ~0x00000400u;
}
inline void ProtoBody::clear_presentuserlistres() {
  if (presentuserlistres_ != NULL) presentuserlistres_->::pp::PresentUserListRes::Clear();
  clear_has_presentuserlistres();
}
inline const ::pp::PresentUserListRes& ProtoBody::presentuserlistres() const {
  return presentuserlistres_ != NULL ? *presentuserlistres_ : *default_instance_->presentuserlistres_;
}
inline ::pp::PresentUserListRes* ProtoBody::mutable_presentuserlistres() {
  set_has_presentuserlistres();
  if (presentuserlistres_ == NULL) presentuserlistres_ = new ::pp::PresentUserListRes;
  return presentuserlistres_;
}
inline ::pp::PresentUserListRes* ProtoBody::release_presentuserlistres() {
  clear_has_presentuserlistres();
  ::pp::PresentUserListRes* temp = presentuserlistres_;
  presentuserlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_presentuserlistres(::pp::PresentUserListRes* presentuserlistres) {
  delete presentuserlistres_;
  presentuserlistres_ = presentuserlistres;
  if (presentuserlistres) {
    set_has_presentuserlistres();
  } else {
    clear_has_presentuserlistres();
  }
}

// optional .pp.ReportViolatorReq reportViolatorReq = 2561;
inline bool ProtoBody::has_reportviolatorreq() const {
  return (_has_bits_[6] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_reportviolatorreq() {
  _has_bits_[6] |= 0x00000800u;
}
inline void ProtoBody::clear_has_reportviolatorreq() {
  _has_bits_[6] &= ~0x00000800u;
}
inline void ProtoBody::clear_reportviolatorreq() {
  if (reportviolatorreq_ != NULL) reportviolatorreq_->::pp::ReportViolatorReq::Clear();
  clear_has_reportviolatorreq();
}
inline const ::pp::ReportViolatorReq& ProtoBody::reportviolatorreq() const {
  return reportviolatorreq_ != NULL ? *reportviolatorreq_ : *default_instance_->reportviolatorreq_;
}
inline ::pp::ReportViolatorReq* ProtoBody::mutable_reportviolatorreq() {
  set_has_reportviolatorreq();
  if (reportviolatorreq_ == NULL) reportviolatorreq_ = new ::pp::ReportViolatorReq;
  return reportviolatorreq_;
}
inline ::pp::ReportViolatorReq* ProtoBody::release_reportviolatorreq() {
  clear_has_reportviolatorreq();
  ::pp::ReportViolatorReq* temp = reportviolatorreq_;
  reportviolatorreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_reportviolatorreq(::pp::ReportViolatorReq* reportviolatorreq) {
  delete reportviolatorreq_;
  reportviolatorreq_ = reportviolatorreq;
  if (reportviolatorreq) {
    set_has_reportviolatorreq();
  } else {
    clear_has_reportviolatorreq();
  }
}

// optional .pp.ReportLogReq reportLogReq = 2563;
inline bool ProtoBody::has_reportlogreq() const {
  return (_has_bits_[6] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_reportlogreq() {
  _has_bits_[6] |= 0x00001000u;
}
inline void ProtoBody::clear_has_reportlogreq() {
  _has_bits_[6] &= ~0x00001000u;
}
inline void ProtoBody::clear_reportlogreq() {
  if (reportlogreq_ != NULL) reportlogreq_->::pp::ReportLogReq::Clear();
  clear_has_reportlogreq();
}
inline const ::pp::ReportLogReq& ProtoBody::reportlogreq() const {
  return reportlogreq_ != NULL ? *reportlogreq_ : *default_instance_->reportlogreq_;
}
inline ::pp::ReportLogReq* ProtoBody::mutable_reportlogreq() {
  set_has_reportlogreq();
  if (reportlogreq_ == NULL) reportlogreq_ = new ::pp::ReportLogReq;
  return reportlogreq_;
}
inline ::pp::ReportLogReq* ProtoBody::release_reportlogreq() {
  clear_has_reportlogreq();
  ::pp::ReportLogReq* temp = reportlogreq_;
  reportlogreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_reportlogreq(::pp::ReportLogReq* reportlogreq) {
  delete reportlogreq_;
  reportlogreq_ = reportlogreq;
  if (reportlogreq) {
    set_has_reportlogreq();
  } else {
    clear_has_reportlogreq();
  }
}

// optional .pp.YYGiftListReq yYGiftListReq = 4352;
inline bool ProtoBody::has_yygiftlistreq() const {
  return (_has_bits_[6] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_yygiftlistreq() {
  _has_bits_[6] |= 0x00002000u;
}
inline void ProtoBody::clear_has_yygiftlistreq() {
  _has_bits_[6] &= ~0x00002000u;
}
inline void ProtoBody::clear_yygiftlistreq() {
  if (yygiftlistreq_ != NULL) yygiftlistreq_->::pp::YYGiftListReq::Clear();
  clear_has_yygiftlistreq();
}
inline const ::pp::YYGiftListReq& ProtoBody::yygiftlistreq() const {
  return yygiftlistreq_ != NULL ? *yygiftlistreq_ : *default_instance_->yygiftlistreq_;
}
inline ::pp::YYGiftListReq* ProtoBody::mutable_yygiftlistreq() {
  set_has_yygiftlistreq();
  if (yygiftlistreq_ == NULL) yygiftlistreq_ = new ::pp::YYGiftListReq;
  return yygiftlistreq_;
}
inline ::pp::YYGiftListReq* ProtoBody::release_yygiftlistreq() {
  clear_has_yygiftlistreq();
  ::pp::YYGiftListReq* temp = yygiftlistreq_;
  yygiftlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yygiftlistreq(::pp::YYGiftListReq* yygiftlistreq) {
  delete yygiftlistreq_;
  yygiftlistreq_ = yygiftlistreq;
  if (yygiftlistreq) {
    set_has_yygiftlistreq();
  } else {
    clear_has_yygiftlistreq();
  }
}

// optional .pp.YYGiftListRes yYGiftListRes = 4353;
inline bool ProtoBody::has_yygiftlistres() const {
  return (_has_bits_[6] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_yygiftlistres() {
  _has_bits_[6] |= 0x00004000u;
}
inline void ProtoBody::clear_has_yygiftlistres() {
  _has_bits_[6] &= ~0x00004000u;
}
inline void ProtoBody::clear_yygiftlistres() {
  if (yygiftlistres_ != NULL) yygiftlistres_->::pp::YYGiftListRes::Clear();
  clear_has_yygiftlistres();
}
inline const ::pp::YYGiftListRes& ProtoBody::yygiftlistres() const {
  return yygiftlistres_ != NULL ? *yygiftlistres_ : *default_instance_->yygiftlistres_;
}
inline ::pp::YYGiftListRes* ProtoBody::mutable_yygiftlistres() {
  set_has_yygiftlistres();
  if (yygiftlistres_ == NULL) yygiftlistres_ = new ::pp::YYGiftListRes;
  return yygiftlistres_;
}
inline ::pp::YYGiftListRes* ProtoBody::release_yygiftlistres() {
  clear_has_yygiftlistres();
  ::pp::YYGiftListRes* temp = yygiftlistres_;
  yygiftlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yygiftlistres(::pp::YYGiftListRes* yygiftlistres) {
  delete yygiftlistres_;
  yygiftlistres_ = yygiftlistres;
  if (yygiftlistres) {
    set_has_yygiftlistres();
  } else {
    clear_has_yygiftlistres();
  }
}

// optional .pp.YYGiftDonateReq yYGiftDonateReq = 4354;
inline bool ProtoBody::has_yygiftdonatereq() const {
  return (_has_bits_[6] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_yygiftdonatereq() {
  _has_bits_[6] |= 0x00008000u;
}
inline void ProtoBody::clear_has_yygiftdonatereq() {
  _has_bits_[6] &= ~0x00008000u;
}
inline void ProtoBody::clear_yygiftdonatereq() {
  if (yygiftdonatereq_ != NULL) yygiftdonatereq_->::pp::YYGiftDonateReq::Clear();
  clear_has_yygiftdonatereq();
}
inline const ::pp::YYGiftDonateReq& ProtoBody::yygiftdonatereq() const {
  return yygiftdonatereq_ != NULL ? *yygiftdonatereq_ : *default_instance_->yygiftdonatereq_;
}
inline ::pp::YYGiftDonateReq* ProtoBody::mutable_yygiftdonatereq() {
  set_has_yygiftdonatereq();
  if (yygiftdonatereq_ == NULL) yygiftdonatereq_ = new ::pp::YYGiftDonateReq;
  return yygiftdonatereq_;
}
inline ::pp::YYGiftDonateReq* ProtoBody::release_yygiftdonatereq() {
  clear_has_yygiftdonatereq();
  ::pp::YYGiftDonateReq* temp = yygiftdonatereq_;
  yygiftdonatereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yygiftdonatereq(::pp::YYGiftDonateReq* yygiftdonatereq) {
  delete yygiftdonatereq_;
  yygiftdonatereq_ = yygiftdonatereq;
  if (yygiftdonatereq) {
    set_has_yygiftdonatereq();
  } else {
    clear_has_yygiftdonatereq();
  }
}

// optional .pp.YYGiftDonateRes yYGiftDonateRes = 4355;
inline bool ProtoBody::has_yygiftdonateres() const {
  return (_has_bits_[6] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_yygiftdonateres() {
  _has_bits_[6] |= 0x00010000u;
}
inline void ProtoBody::clear_has_yygiftdonateres() {
  _has_bits_[6] &= ~0x00010000u;
}
inline void ProtoBody::clear_yygiftdonateres() {
  if (yygiftdonateres_ != NULL) yygiftdonateres_->::pp::YYGiftDonateRes::Clear();
  clear_has_yygiftdonateres();
}
inline const ::pp::YYGiftDonateRes& ProtoBody::yygiftdonateres() const {
  return yygiftdonateres_ != NULL ? *yygiftdonateres_ : *default_instance_->yygiftdonateres_;
}
inline ::pp::YYGiftDonateRes* ProtoBody::mutable_yygiftdonateres() {
  set_has_yygiftdonateres();
  if (yygiftdonateres_ == NULL) yygiftdonateres_ = new ::pp::YYGiftDonateRes;
  return yygiftdonateres_;
}
inline ::pp::YYGiftDonateRes* ProtoBody::release_yygiftdonateres() {
  clear_has_yygiftdonateres();
  ::pp::YYGiftDonateRes* temp = yygiftdonateres_;
  yygiftdonateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yygiftdonateres(::pp::YYGiftDonateRes* yygiftdonateres) {
  delete yygiftdonateres_;
  yygiftdonateres_ = yygiftdonateres;
  if (yygiftdonateres) {
    set_has_yygiftdonateres();
  } else {
    clear_has_yygiftdonateres();
  }
}

// optional .pp.YYGiftPayConfirmReq yYGiftPayConfirmReq = 4356;
inline bool ProtoBody::has_yygiftpayconfirmreq() const {
  return (_has_bits_[6] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_yygiftpayconfirmreq() {
  _has_bits_[6] |= 0x00020000u;
}
inline void ProtoBody::clear_has_yygiftpayconfirmreq() {
  _has_bits_[6] &= ~0x00020000u;
}
inline void ProtoBody::clear_yygiftpayconfirmreq() {
  if (yygiftpayconfirmreq_ != NULL) yygiftpayconfirmreq_->::pp::YYGiftPayConfirmReq::Clear();
  clear_has_yygiftpayconfirmreq();
}
inline const ::pp::YYGiftPayConfirmReq& ProtoBody::yygiftpayconfirmreq() const {
  return yygiftpayconfirmreq_ != NULL ? *yygiftpayconfirmreq_ : *default_instance_->yygiftpayconfirmreq_;
}
inline ::pp::YYGiftPayConfirmReq* ProtoBody::mutable_yygiftpayconfirmreq() {
  set_has_yygiftpayconfirmreq();
  if (yygiftpayconfirmreq_ == NULL) yygiftpayconfirmreq_ = new ::pp::YYGiftPayConfirmReq;
  return yygiftpayconfirmreq_;
}
inline ::pp::YYGiftPayConfirmReq* ProtoBody::release_yygiftpayconfirmreq() {
  clear_has_yygiftpayconfirmreq();
  ::pp::YYGiftPayConfirmReq* temp = yygiftpayconfirmreq_;
  yygiftpayconfirmreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yygiftpayconfirmreq(::pp::YYGiftPayConfirmReq* yygiftpayconfirmreq) {
  delete yygiftpayconfirmreq_;
  yygiftpayconfirmreq_ = yygiftpayconfirmreq;
  if (yygiftpayconfirmreq) {
    set_has_yygiftpayconfirmreq();
  } else {
    clear_has_yygiftpayconfirmreq();
  }
}

// optional .pp.YYGiftPayConfirmRes yYGiftPayConfirmRes = 4357;
inline bool ProtoBody::has_yygiftpayconfirmres() const {
  return (_has_bits_[6] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_yygiftpayconfirmres() {
  _has_bits_[6] |= 0x00040000u;
}
inline void ProtoBody::clear_has_yygiftpayconfirmres() {
  _has_bits_[6] &= ~0x00040000u;
}
inline void ProtoBody::clear_yygiftpayconfirmres() {
  if (yygiftpayconfirmres_ != NULL) yygiftpayconfirmres_->::pp::YYGiftPayConfirmRes::Clear();
  clear_has_yygiftpayconfirmres();
}
inline const ::pp::YYGiftPayConfirmRes& ProtoBody::yygiftpayconfirmres() const {
  return yygiftpayconfirmres_ != NULL ? *yygiftpayconfirmres_ : *default_instance_->yygiftpayconfirmres_;
}
inline ::pp::YYGiftPayConfirmRes* ProtoBody::mutable_yygiftpayconfirmres() {
  set_has_yygiftpayconfirmres();
  if (yygiftpayconfirmres_ == NULL) yygiftpayconfirmres_ = new ::pp::YYGiftPayConfirmRes;
  return yygiftpayconfirmres_;
}
inline ::pp::YYGiftPayConfirmRes* ProtoBody::release_yygiftpayconfirmres() {
  clear_has_yygiftpayconfirmres();
  ::pp::YYGiftPayConfirmRes* temp = yygiftpayconfirmres_;
  yygiftpayconfirmres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yygiftpayconfirmres(::pp::YYGiftPayConfirmRes* yygiftpayconfirmres) {
  delete yygiftpayconfirmres_;
  yygiftpayconfirmres_ = yygiftpayconfirmres;
  if (yygiftpayconfirmres) {
    set_has_yygiftpayconfirmres();
  } else {
    clear_has_yygiftpayconfirmres();
  }
}

// optional .pp.ProductListReq productListReq = 4369;
inline bool ProtoBody::has_productlistreq() const {
  return (_has_bits_[6] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_productlistreq() {
  _has_bits_[6] |= 0x00080000u;
}
inline void ProtoBody::clear_has_productlistreq() {
  _has_bits_[6] &= ~0x00080000u;
}
inline void ProtoBody::clear_productlistreq() {
  if (productlistreq_ != NULL) productlistreq_->::pp::ProductListReq::Clear();
  clear_has_productlistreq();
}
inline const ::pp::ProductListReq& ProtoBody::productlistreq() const {
  return productlistreq_ != NULL ? *productlistreq_ : *default_instance_->productlistreq_;
}
inline ::pp::ProductListReq* ProtoBody::mutable_productlistreq() {
  set_has_productlistreq();
  if (productlistreq_ == NULL) productlistreq_ = new ::pp::ProductListReq;
  return productlistreq_;
}
inline ::pp::ProductListReq* ProtoBody::release_productlistreq() {
  clear_has_productlistreq();
  ::pp::ProductListReq* temp = productlistreq_;
  productlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_productlistreq(::pp::ProductListReq* productlistreq) {
  delete productlistreq_;
  productlistreq_ = productlistreq;
  if (productlistreq) {
    set_has_productlistreq();
  } else {
    clear_has_productlistreq();
  }
}

// optional .pp.ProductListRes productListRes = 4370;
inline bool ProtoBody::has_productlistres() const {
  return (_has_bits_[6] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_productlistres() {
  _has_bits_[6] |= 0x00100000u;
}
inline void ProtoBody::clear_has_productlistres() {
  _has_bits_[6] &= ~0x00100000u;
}
inline void ProtoBody::clear_productlistres() {
  if (productlistres_ != NULL) productlistres_->::pp::ProductListRes::Clear();
  clear_has_productlistres();
}
inline const ::pp::ProductListRes& ProtoBody::productlistres() const {
  return productlistres_ != NULL ? *productlistres_ : *default_instance_->productlistres_;
}
inline ::pp::ProductListRes* ProtoBody::mutable_productlistres() {
  set_has_productlistres();
  if (productlistres_ == NULL) productlistres_ = new ::pp::ProductListRes;
  return productlistres_;
}
inline ::pp::ProductListRes* ProtoBody::release_productlistres() {
  clear_has_productlistres();
  ::pp::ProductListRes* temp = productlistres_;
  productlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_productlistres(::pp::ProductListRes* productlistres) {
  delete productlistres_;
  productlistres_ = productlistres;
  if (productlistres) {
    set_has_productlistres();
  } else {
    clear_has_productlistres();
  }
}

// optional .pp.ProductOpReq productOpReq = 4371;
inline bool ProtoBody::has_productopreq() const {
  return (_has_bits_[6] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_productopreq() {
  _has_bits_[6] |= 0x00200000u;
}
inline void ProtoBody::clear_has_productopreq() {
  _has_bits_[6] &= ~0x00200000u;
}
inline void ProtoBody::clear_productopreq() {
  if (productopreq_ != NULL) productopreq_->::pp::ProductOpReq::Clear();
  clear_has_productopreq();
}
inline const ::pp::ProductOpReq& ProtoBody::productopreq() const {
  return productopreq_ != NULL ? *productopreq_ : *default_instance_->productopreq_;
}
inline ::pp::ProductOpReq* ProtoBody::mutable_productopreq() {
  set_has_productopreq();
  if (productopreq_ == NULL) productopreq_ = new ::pp::ProductOpReq;
  return productopreq_;
}
inline ::pp::ProductOpReq* ProtoBody::release_productopreq() {
  clear_has_productopreq();
  ::pp::ProductOpReq* temp = productopreq_;
  productopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_productopreq(::pp::ProductOpReq* productopreq) {
  delete productopreq_;
  productopreq_ = productopreq;
  if (productopreq) {
    set_has_productopreq();
  } else {
    clear_has_productopreq();
  }
}

// optional .pp.ProductBuyReq productBuyReq = 4373;
inline bool ProtoBody::has_productbuyreq() const {
  return (_has_bits_[6] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_productbuyreq() {
  _has_bits_[6] |= 0x00400000u;
}
inline void ProtoBody::clear_has_productbuyreq() {
  _has_bits_[6] &= ~0x00400000u;
}
inline void ProtoBody::clear_productbuyreq() {
  if (productbuyreq_ != NULL) productbuyreq_->::pp::ProductBuyReq::Clear();
  clear_has_productbuyreq();
}
inline const ::pp::ProductBuyReq& ProtoBody::productbuyreq() const {
  return productbuyreq_ != NULL ? *productbuyreq_ : *default_instance_->productbuyreq_;
}
inline ::pp::ProductBuyReq* ProtoBody::mutable_productbuyreq() {
  set_has_productbuyreq();
  if (productbuyreq_ == NULL) productbuyreq_ = new ::pp::ProductBuyReq;
  return productbuyreq_;
}
inline ::pp::ProductBuyReq* ProtoBody::release_productbuyreq() {
  clear_has_productbuyreq();
  ::pp::ProductBuyReq* temp = productbuyreq_;
  productbuyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_productbuyreq(::pp::ProductBuyReq* productbuyreq) {
  delete productbuyreq_;
  productbuyreq_ = productbuyreq;
  if (productbuyreq) {
    set_has_productbuyreq();
  } else {
    clear_has_productbuyreq();
  }
}

// optional .pp.UserWithdrawReq userWithdrawReq = 4377;
inline bool ProtoBody::has_userwithdrawreq() const {
  return (_has_bits_[6] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_userwithdrawreq() {
  _has_bits_[6] |= 0x00800000u;
}
inline void ProtoBody::clear_has_userwithdrawreq() {
  _has_bits_[6] &= ~0x00800000u;
}
inline void ProtoBody::clear_userwithdrawreq() {
  if (userwithdrawreq_ != NULL) userwithdrawreq_->::pp::UserWithdrawReq::Clear();
  clear_has_userwithdrawreq();
}
inline const ::pp::UserWithdrawReq& ProtoBody::userwithdrawreq() const {
  return userwithdrawreq_ != NULL ? *userwithdrawreq_ : *default_instance_->userwithdrawreq_;
}
inline ::pp::UserWithdrawReq* ProtoBody::mutable_userwithdrawreq() {
  set_has_userwithdrawreq();
  if (userwithdrawreq_ == NULL) userwithdrawreq_ = new ::pp::UserWithdrawReq;
  return userwithdrawreq_;
}
inline ::pp::UserWithdrawReq* ProtoBody::release_userwithdrawreq() {
  clear_has_userwithdrawreq();
  ::pp::UserWithdrawReq* temp = userwithdrawreq_;
  userwithdrawreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userwithdrawreq(::pp::UserWithdrawReq* userwithdrawreq) {
  delete userwithdrawreq_;
  userwithdrawreq_ = userwithdrawreq;
  if (userwithdrawreq) {
    set_has_userwithdrawreq();
  } else {
    clear_has_userwithdrawreq();
  }
}

// optional .pp.UserMoneyStatReq userMoneyStatReq = 4384;
inline bool ProtoBody::has_usermoneystatreq() const {
  return (_has_bits_[6] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_usermoneystatreq() {
  _has_bits_[6] |= 0x01000000u;
}
inline void ProtoBody::clear_has_usermoneystatreq() {
  _has_bits_[6] &= ~0x01000000u;
}
inline void ProtoBody::clear_usermoneystatreq() {
  if (usermoneystatreq_ != NULL) usermoneystatreq_->::pp::UserMoneyStatReq::Clear();
  clear_has_usermoneystatreq();
}
inline const ::pp::UserMoneyStatReq& ProtoBody::usermoneystatreq() const {
  return usermoneystatreq_ != NULL ? *usermoneystatreq_ : *default_instance_->usermoneystatreq_;
}
inline ::pp::UserMoneyStatReq* ProtoBody::mutable_usermoneystatreq() {
  set_has_usermoneystatreq();
  if (usermoneystatreq_ == NULL) usermoneystatreq_ = new ::pp::UserMoneyStatReq;
  return usermoneystatreq_;
}
inline ::pp::UserMoneyStatReq* ProtoBody::release_usermoneystatreq() {
  clear_has_usermoneystatreq();
  ::pp::UserMoneyStatReq* temp = usermoneystatreq_;
  usermoneystatreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermoneystatreq(::pp::UserMoneyStatReq* usermoneystatreq) {
  delete usermoneystatreq_;
  usermoneystatreq_ = usermoneystatreq;
  if (usermoneystatreq) {
    set_has_usermoneystatreq();
  } else {
    clear_has_usermoneystatreq();
  }
}

// optional .pp.UserMoneyStatRes userMoneyStatRes = 4385;
inline bool ProtoBody::has_usermoneystatres() const {
  return (_has_bits_[6] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_usermoneystatres() {
  _has_bits_[6] |= 0x02000000u;
}
inline void ProtoBody::clear_has_usermoneystatres() {
  _has_bits_[6] &= ~0x02000000u;
}
inline void ProtoBody::clear_usermoneystatres() {
  if (usermoneystatres_ != NULL) usermoneystatres_->::pp::UserMoneyStatRes::Clear();
  clear_has_usermoneystatres();
}
inline const ::pp::UserMoneyStatRes& ProtoBody::usermoneystatres() const {
  return usermoneystatres_ != NULL ? *usermoneystatres_ : *default_instance_->usermoneystatres_;
}
inline ::pp::UserMoneyStatRes* ProtoBody::mutable_usermoneystatres() {
  set_has_usermoneystatres();
  if (usermoneystatres_ == NULL) usermoneystatres_ = new ::pp::UserMoneyStatRes;
  return usermoneystatres_;
}
inline ::pp::UserMoneyStatRes* ProtoBody::release_usermoneystatres() {
  clear_has_usermoneystatres();
  ::pp::UserMoneyStatRes* temp = usermoneystatres_;
  usermoneystatres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermoneystatres(::pp::UserMoneyStatRes* usermoneystatres) {
  delete usermoneystatres_;
  usermoneystatres_ = usermoneystatres;
  if (usermoneystatres) {
    set_has_usermoneystatres();
  } else {
    clear_has_usermoneystatres();
  }
}

// optional .pp.UserBankInfoOpReq userBankInfoOpReq = 4386;
inline bool ProtoBody::has_userbankinfoopreq() const {
  return (_has_bits_[6] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_userbankinfoopreq() {
  _has_bits_[6] |= 0x04000000u;
}
inline void ProtoBody::clear_has_userbankinfoopreq() {
  _has_bits_[6] &= ~0x04000000u;
}
inline void ProtoBody::clear_userbankinfoopreq() {
  if (userbankinfoopreq_ != NULL) userbankinfoopreq_->::pp::UserBankInfoOpReq::Clear();
  clear_has_userbankinfoopreq();
}
inline const ::pp::UserBankInfoOpReq& ProtoBody::userbankinfoopreq() const {
  return userbankinfoopreq_ != NULL ? *userbankinfoopreq_ : *default_instance_->userbankinfoopreq_;
}
inline ::pp::UserBankInfoOpReq* ProtoBody::mutable_userbankinfoopreq() {
  set_has_userbankinfoopreq();
  if (userbankinfoopreq_ == NULL) userbankinfoopreq_ = new ::pp::UserBankInfoOpReq;
  return userbankinfoopreq_;
}
inline ::pp::UserBankInfoOpReq* ProtoBody::release_userbankinfoopreq() {
  clear_has_userbankinfoopreq();
  ::pp::UserBankInfoOpReq* temp = userbankinfoopreq_;
  userbankinfoopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userbankinfoopreq(::pp::UserBankInfoOpReq* userbankinfoopreq) {
  delete userbankinfoopreq_;
  userbankinfoopreq_ = userbankinfoopreq;
  if (userbankinfoopreq) {
    set_has_userbankinfoopreq();
  } else {
    clear_has_userbankinfoopreq();
  }
}

// optional .pp.UserBankInfoOpRes userBankInfoOpRes = 4387;
inline bool ProtoBody::has_userbankinfoopres() const {
  return (_has_bits_[6] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_userbankinfoopres() {
  _has_bits_[6] |= 0x08000000u;
}
inline void ProtoBody::clear_has_userbankinfoopres() {
  _has_bits_[6] &= ~0x08000000u;
}
inline void ProtoBody::clear_userbankinfoopres() {
  if (userbankinfoopres_ != NULL) userbankinfoopres_->::pp::UserBankInfoOpRes::Clear();
  clear_has_userbankinfoopres();
}
inline const ::pp::UserBankInfoOpRes& ProtoBody::userbankinfoopres() const {
  return userbankinfoopres_ != NULL ? *userbankinfoopres_ : *default_instance_->userbankinfoopres_;
}
inline ::pp::UserBankInfoOpRes* ProtoBody::mutable_userbankinfoopres() {
  set_has_userbankinfoopres();
  if (userbankinfoopres_ == NULL) userbankinfoopres_ = new ::pp::UserBankInfoOpRes;
  return userbankinfoopres_;
}
inline ::pp::UserBankInfoOpRes* ProtoBody::release_userbankinfoopres() {
  clear_has_userbankinfoopres();
  ::pp::UserBankInfoOpRes* temp = userbankinfoopres_;
  userbankinfoopres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userbankinfoopres(::pp::UserBankInfoOpRes* userbankinfoopres) {
  delete userbankinfoopres_;
  userbankinfoopres_ = userbankinfoopres;
  if (userbankinfoopres) {
    set_has_userbankinfoopres();
  } else {
    clear_has_userbankinfoopres();
  }
}

// optional .pp.BankListReq bankListReq = 4388;
inline bool ProtoBody::has_banklistreq() const {
  return (_has_bits_[6] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_banklistreq() {
  _has_bits_[6] |= 0x10000000u;
}
inline void ProtoBody::clear_has_banklistreq() {
  _has_bits_[6] &= ~0x10000000u;
}
inline void ProtoBody::clear_banklistreq() {
  if (banklistreq_ != NULL) banklistreq_->::pp::BankListReq::Clear();
  clear_has_banklistreq();
}
inline const ::pp::BankListReq& ProtoBody::banklistreq() const {
  return banklistreq_ != NULL ? *banklistreq_ : *default_instance_->banklistreq_;
}
inline ::pp::BankListReq* ProtoBody::mutable_banklistreq() {
  set_has_banklistreq();
  if (banklistreq_ == NULL) banklistreq_ = new ::pp::BankListReq;
  return banklistreq_;
}
inline ::pp::BankListReq* ProtoBody::release_banklistreq() {
  clear_has_banklistreq();
  ::pp::BankListReq* temp = banklistreq_;
  banklistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_banklistreq(::pp::BankListReq* banklistreq) {
  delete banklistreq_;
  banklistreq_ = banklistreq;
  if (banklistreq) {
    set_has_banklistreq();
  } else {
    clear_has_banklistreq();
  }
}

// optional .pp.BankListRes bankListRes = 4389;
inline bool ProtoBody::has_banklistres() const {
  return (_has_bits_[6] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_banklistres() {
  _has_bits_[6] |= 0x20000000u;
}
inline void ProtoBody::clear_has_banklistres() {
  _has_bits_[6] &= ~0x20000000u;
}
inline void ProtoBody::clear_banklistres() {
  if (banklistres_ != NULL) banklistres_->::pp::BankListRes::Clear();
  clear_has_banklistres();
}
inline const ::pp::BankListRes& ProtoBody::banklistres() const {
  return banklistres_ != NULL ? *banklistres_ : *default_instance_->banklistres_;
}
inline ::pp::BankListRes* ProtoBody::mutable_banklistres() {
  set_has_banklistres();
  if (banklistres_ == NULL) banklistres_ = new ::pp::BankListRes;
  return banklistres_;
}
inline ::pp::BankListRes* ProtoBody::release_banklistres() {
  clear_has_banklistres();
  ::pp::BankListRes* temp = banklistres_;
  banklistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_banklistres(::pp::BankListRes* banklistres) {
  delete banklistres_;
  banklistres_ = banklistres;
  if (banklistres) {
    set_has_banklistres();
  } else {
    clear_has_banklistres();
  }
}

// optional .pp.UserTaskStateReq userTaskStateReq = 1025;
inline bool ProtoBody::has_usertaskstatereq() const {
  return (_has_bits_[6] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_usertaskstatereq() {
  _has_bits_[6] |= 0x40000000u;
}
inline void ProtoBody::clear_has_usertaskstatereq() {
  _has_bits_[6] &= ~0x40000000u;
}
inline void ProtoBody::clear_usertaskstatereq() {
  if (usertaskstatereq_ != NULL) usertaskstatereq_->::pp::UserTaskStateReq::Clear();
  clear_has_usertaskstatereq();
}
inline const ::pp::UserTaskStateReq& ProtoBody::usertaskstatereq() const {
  return usertaskstatereq_ != NULL ? *usertaskstatereq_ : *default_instance_->usertaskstatereq_;
}
inline ::pp::UserTaskStateReq* ProtoBody::mutable_usertaskstatereq() {
  set_has_usertaskstatereq();
  if (usertaskstatereq_ == NULL) usertaskstatereq_ = new ::pp::UserTaskStateReq;
  return usertaskstatereq_;
}
inline ::pp::UserTaskStateReq* ProtoBody::release_usertaskstatereq() {
  clear_has_usertaskstatereq();
  ::pp::UserTaskStateReq* temp = usertaskstatereq_;
  usertaskstatereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertaskstatereq(::pp::UserTaskStateReq* usertaskstatereq) {
  delete usertaskstatereq_;
  usertaskstatereq_ = usertaskstatereq;
  if (usertaskstatereq) {
    set_has_usertaskstatereq();
  } else {
    clear_has_usertaskstatereq();
  }
}

// optional .pp.UserTaskStateRes userTaskStateRes = 1026;
inline bool ProtoBody::has_usertaskstateres() const {
  return (_has_bits_[6] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_usertaskstateres() {
  _has_bits_[6] |= 0x80000000u;
}
inline void ProtoBody::clear_has_usertaskstateres() {
  _has_bits_[6] &= ~0x80000000u;
}
inline void ProtoBody::clear_usertaskstateres() {
  if (usertaskstateres_ != NULL) usertaskstateres_->::pp::UserTaskStateRes::Clear();
  clear_has_usertaskstateres();
}
inline const ::pp::UserTaskStateRes& ProtoBody::usertaskstateres() const {
  return usertaskstateres_ != NULL ? *usertaskstateres_ : *default_instance_->usertaskstateres_;
}
inline ::pp::UserTaskStateRes* ProtoBody::mutable_usertaskstateres() {
  set_has_usertaskstateres();
  if (usertaskstateres_ == NULL) usertaskstateres_ = new ::pp::UserTaskStateRes;
  return usertaskstateres_;
}
inline ::pp::UserTaskStateRes* ProtoBody::release_usertaskstateres() {
  clear_has_usertaskstateres();
  ::pp::UserTaskStateRes* temp = usertaskstateres_;
  usertaskstateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertaskstateres(::pp::UserTaskStateRes* usertaskstateres) {
  delete usertaskstateres_;
  usertaskstateres_ = usertaskstateres;
  if (usertaskstateres) {
    set_has_usertaskstateres();
  } else {
    clear_has_usertaskstateres();
  }
}

// optional .pp.UserTaskTakeAwardReq userTaskTakeAwardReq = 1027;
inline bool ProtoBody::has_usertasktakeawardreq() const {
  return (_has_bits_[7] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_usertasktakeawardreq() {
  _has_bits_[7] |= 0x00000001u;
}
inline void ProtoBody::clear_has_usertasktakeawardreq() {
  _has_bits_[7] &= ~0x00000001u;
}
inline void ProtoBody::clear_usertasktakeawardreq() {
  if (usertasktakeawardreq_ != NULL) usertasktakeawardreq_->::pp::UserTaskTakeAwardReq::Clear();
  clear_has_usertasktakeawardreq();
}
inline const ::pp::UserTaskTakeAwardReq& ProtoBody::usertasktakeawardreq() const {
  return usertasktakeawardreq_ != NULL ? *usertasktakeawardreq_ : *default_instance_->usertasktakeawardreq_;
}
inline ::pp::UserTaskTakeAwardReq* ProtoBody::mutable_usertasktakeawardreq() {
  set_has_usertasktakeawardreq();
  if (usertasktakeawardreq_ == NULL) usertasktakeawardreq_ = new ::pp::UserTaskTakeAwardReq;
  return usertasktakeawardreq_;
}
inline ::pp::UserTaskTakeAwardReq* ProtoBody::release_usertasktakeawardreq() {
  clear_has_usertasktakeawardreq();
  ::pp::UserTaskTakeAwardReq* temp = usertasktakeawardreq_;
  usertasktakeawardreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertasktakeawardreq(::pp::UserTaskTakeAwardReq* usertasktakeawardreq) {
  delete usertasktakeawardreq_;
  usertasktakeawardreq_ = usertasktakeawardreq;
  if (usertasktakeawardreq) {
    set_has_usertasktakeawardreq();
  } else {
    clear_has_usertasktakeawardreq();
  }
}

// optional .pp.UserTaskTakeAwardRes userTaskTakeAwardRes = 1028;
inline bool ProtoBody::has_usertasktakeawardres() const {
  return (_has_bits_[7] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_usertasktakeawardres() {
  _has_bits_[7] |= 0x00000002u;
}
inline void ProtoBody::clear_has_usertasktakeawardres() {
  _has_bits_[7] &= ~0x00000002u;
}
inline void ProtoBody::clear_usertasktakeawardres() {
  if (usertasktakeawardres_ != NULL) usertasktakeawardres_->::pp::UserTaskTakeAwardRes::Clear();
  clear_has_usertasktakeawardres();
}
inline const ::pp::UserTaskTakeAwardRes& ProtoBody::usertasktakeawardres() const {
  return usertasktakeawardres_ != NULL ? *usertasktakeawardres_ : *default_instance_->usertasktakeawardres_;
}
inline ::pp::UserTaskTakeAwardRes* ProtoBody::mutable_usertasktakeawardres() {
  set_has_usertasktakeawardres();
  if (usertasktakeawardres_ == NULL) usertasktakeawardres_ = new ::pp::UserTaskTakeAwardRes;
  return usertasktakeawardres_;
}
inline ::pp::UserTaskTakeAwardRes* ProtoBody::release_usertasktakeawardres() {
  clear_has_usertasktakeawardres();
  ::pp::UserTaskTakeAwardRes* temp = usertasktakeawardres_;
  usertasktakeawardres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertasktakeawardres(::pp::UserTaskTakeAwardRes* usertasktakeawardres) {
  delete usertasktakeawardres_;
  usertasktakeawardres_ = usertasktakeawardres;
  if (usertasktakeawardres) {
    set_has_usertasktakeawardres();
  } else {
    clear_has_usertasktakeawardres();
  }
}

// optional .pp.UserTaskCheckReq userTaskCheckReq = 1029;
inline bool ProtoBody::has_usertaskcheckreq() const {
  return (_has_bits_[7] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_usertaskcheckreq() {
  _has_bits_[7] |= 0x00000004u;
}
inline void ProtoBody::clear_has_usertaskcheckreq() {
  _has_bits_[7] &= ~0x00000004u;
}
inline void ProtoBody::clear_usertaskcheckreq() {
  if (usertaskcheckreq_ != NULL) usertaskcheckreq_->::pp::UserTaskCheckReq::Clear();
  clear_has_usertaskcheckreq();
}
inline const ::pp::UserTaskCheckReq& ProtoBody::usertaskcheckreq() const {
  return usertaskcheckreq_ != NULL ? *usertaskcheckreq_ : *default_instance_->usertaskcheckreq_;
}
inline ::pp::UserTaskCheckReq* ProtoBody::mutable_usertaskcheckreq() {
  set_has_usertaskcheckreq();
  if (usertaskcheckreq_ == NULL) usertaskcheckreq_ = new ::pp::UserTaskCheckReq;
  return usertaskcheckreq_;
}
inline ::pp::UserTaskCheckReq* ProtoBody::release_usertaskcheckreq() {
  clear_has_usertaskcheckreq();
  ::pp::UserTaskCheckReq* temp = usertaskcheckreq_;
  usertaskcheckreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertaskcheckreq(::pp::UserTaskCheckReq* usertaskcheckreq) {
  delete usertaskcheckreq_;
  usertaskcheckreq_ = usertaskcheckreq;
  if (usertaskcheckreq) {
    set_has_usertaskcheckreq();
  } else {
    clear_has_usertaskcheckreq();
  }
}

// optional .pp.UserTaskCheckRes userTaskCheckRes = 1030;
inline bool ProtoBody::has_usertaskcheckres() const {
  return (_has_bits_[7] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_usertaskcheckres() {
  _has_bits_[7] |= 0x00000008u;
}
inline void ProtoBody::clear_has_usertaskcheckres() {
  _has_bits_[7] &= ~0x00000008u;
}
inline void ProtoBody::clear_usertaskcheckres() {
  if (usertaskcheckres_ != NULL) usertaskcheckres_->::pp::UserTaskCheckRes::Clear();
  clear_has_usertaskcheckres();
}
inline const ::pp::UserTaskCheckRes& ProtoBody::usertaskcheckres() const {
  return usertaskcheckres_ != NULL ? *usertaskcheckres_ : *default_instance_->usertaskcheckres_;
}
inline ::pp::UserTaskCheckRes* ProtoBody::mutable_usertaskcheckres() {
  set_has_usertaskcheckres();
  if (usertaskcheckres_ == NULL) usertaskcheckres_ = new ::pp::UserTaskCheckRes;
  return usertaskcheckres_;
}
inline ::pp::UserTaskCheckRes* ProtoBody::release_usertaskcheckres() {
  clear_has_usertaskcheckres();
  ::pp::UserTaskCheckRes* temp = usertaskcheckres_;
  usertaskcheckres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usertaskcheckres(::pp::UserTaskCheckRes* usertaskcheckres) {
  delete usertaskcheckres_;
  usertaskcheckres_ = usertaskcheckres;
  if (usertaskcheckres) {
    set_has_usertaskcheckres();
  } else {
    clear_has_usertaskcheckres();
  }
}

// optional .pp.UserInfoReq userInfoReq = 512;
inline bool ProtoBody::has_userinforeq() const {
  return (_has_bits_[7] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_userinforeq() {
  _has_bits_[7] |= 0x00000010u;
}
inline void ProtoBody::clear_has_userinforeq() {
  _has_bits_[7] &= ~0x00000010u;
}
inline void ProtoBody::clear_userinforeq() {
  if (userinforeq_ != NULL) userinforeq_->::pp::UserInfoReq::Clear();
  clear_has_userinforeq();
}
inline const ::pp::UserInfoReq& ProtoBody::userinforeq() const {
  return userinforeq_ != NULL ? *userinforeq_ : *default_instance_->userinforeq_;
}
inline ::pp::UserInfoReq* ProtoBody::mutable_userinforeq() {
  set_has_userinforeq();
  if (userinforeq_ == NULL) userinforeq_ = new ::pp::UserInfoReq;
  return userinforeq_;
}
inline ::pp::UserInfoReq* ProtoBody::release_userinforeq() {
  clear_has_userinforeq();
  ::pp::UserInfoReq* temp = userinforeq_;
  userinforeq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinforeq(::pp::UserInfoReq* userinforeq) {
  delete userinforeq_;
  userinforeq_ = userinforeq;
  if (userinforeq) {
    set_has_userinforeq();
  } else {
    clear_has_userinforeq();
  }
}

// optional .pp.UserInfoRes userInfoRes = 513;
inline bool ProtoBody::has_userinfores() const {
  return (_has_bits_[7] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_userinfores() {
  _has_bits_[7] |= 0x00000020u;
}
inline void ProtoBody::clear_has_userinfores() {
  _has_bits_[7] &= ~0x00000020u;
}
inline void ProtoBody::clear_userinfores() {
  if (userinfores_ != NULL) userinfores_->::pp::UserInfoRes::Clear();
  clear_has_userinfores();
}
inline const ::pp::UserInfoRes& ProtoBody::userinfores() const {
  return userinfores_ != NULL ? *userinfores_ : *default_instance_->userinfores_;
}
inline ::pp::UserInfoRes* ProtoBody::mutable_userinfores() {
  set_has_userinfores();
  if (userinfores_ == NULL) userinfores_ = new ::pp::UserInfoRes;
  return userinfores_;
}
inline ::pp::UserInfoRes* ProtoBody::release_userinfores() {
  clear_has_userinfores();
  ::pp::UserInfoRes* temp = userinfores_;
  userinfores_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinfores(::pp::UserInfoRes* userinfores) {
  delete userinfores_;
  userinfores_ = userinfores;
  if (userinfores) {
    set_has_userinfores();
  } else {
    clear_has_userinfores();
  }
}

// optional .pp.UserInfoModifyReq userInfoModifyReq = 514;
inline bool ProtoBody::has_userinfomodifyreq() const {
  return (_has_bits_[7] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_userinfomodifyreq() {
  _has_bits_[7] |= 0x00000040u;
}
inline void ProtoBody::clear_has_userinfomodifyreq() {
  _has_bits_[7] &= ~0x00000040u;
}
inline void ProtoBody::clear_userinfomodifyreq() {
  if (userinfomodifyreq_ != NULL) userinfomodifyreq_->::pp::UserInfoModifyReq::Clear();
  clear_has_userinfomodifyreq();
}
inline const ::pp::UserInfoModifyReq& ProtoBody::userinfomodifyreq() const {
  return userinfomodifyreq_ != NULL ? *userinfomodifyreq_ : *default_instance_->userinfomodifyreq_;
}
inline ::pp::UserInfoModifyReq* ProtoBody::mutable_userinfomodifyreq() {
  set_has_userinfomodifyreq();
  if (userinfomodifyreq_ == NULL) userinfomodifyreq_ = new ::pp::UserInfoModifyReq;
  return userinfomodifyreq_;
}
inline ::pp::UserInfoModifyReq* ProtoBody::release_userinfomodifyreq() {
  clear_has_userinfomodifyreq();
  ::pp::UserInfoModifyReq* temp = userinfomodifyreq_;
  userinfomodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinfomodifyreq(::pp::UserInfoModifyReq* userinfomodifyreq) {
  delete userinfomodifyreq_;
  userinfomodifyreq_ = userinfomodifyreq;
  if (userinfomodifyreq) {
    set_has_userinfomodifyreq();
  } else {
    clear_has_userinfomodifyreq();
  }
}

// optional .pp.UserInfoModifyRes userInfoModifyRes = 515;
inline bool ProtoBody::has_userinfomodifyres() const {
  return (_has_bits_[7] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_userinfomodifyres() {
  _has_bits_[7] |= 0x00000080u;
}
inline void ProtoBody::clear_has_userinfomodifyres() {
  _has_bits_[7] &= ~0x00000080u;
}
inline void ProtoBody::clear_userinfomodifyres() {
  if (userinfomodifyres_ != NULL) userinfomodifyres_->::pp::UserInfoModifyRes::Clear();
  clear_has_userinfomodifyres();
}
inline const ::pp::UserInfoModifyRes& ProtoBody::userinfomodifyres() const {
  return userinfomodifyres_ != NULL ? *userinfomodifyres_ : *default_instance_->userinfomodifyres_;
}
inline ::pp::UserInfoModifyRes* ProtoBody::mutable_userinfomodifyres() {
  set_has_userinfomodifyres();
  if (userinfomodifyres_ == NULL) userinfomodifyres_ = new ::pp::UserInfoModifyRes;
  return userinfomodifyres_;
}
inline ::pp::UserInfoModifyRes* ProtoBody::release_userinfomodifyres() {
  clear_has_userinfomodifyres();
  ::pp::UserInfoModifyRes* temp = userinfomodifyres_;
  userinfomodifyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinfomodifyres(::pp::UserInfoModifyRes* userinfomodifyres) {
  delete userinfomodifyres_;
  userinfomodifyres_ = userinfomodifyres;
  if (userinfomodifyres) {
    set_has_userinfomodifyres();
  } else {
    clear_has_userinfomodifyres();
  }
}

// optional .pp.UserInfoListReq userInfoListReq = 518;
inline bool ProtoBody::has_userinfolistreq() const {
  return (_has_bits_[7] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_userinfolistreq() {
  _has_bits_[7] |= 0x00000100u;
}
inline void ProtoBody::clear_has_userinfolistreq() {
  _has_bits_[7] &= ~0x00000100u;
}
inline void ProtoBody::clear_userinfolistreq() {
  if (userinfolistreq_ != NULL) userinfolistreq_->::pp::UserInfoListReq::Clear();
  clear_has_userinfolistreq();
}
inline const ::pp::UserInfoListReq& ProtoBody::userinfolistreq() const {
  return userinfolistreq_ != NULL ? *userinfolistreq_ : *default_instance_->userinfolistreq_;
}
inline ::pp::UserInfoListReq* ProtoBody::mutable_userinfolistreq() {
  set_has_userinfolistreq();
  if (userinfolistreq_ == NULL) userinfolistreq_ = new ::pp::UserInfoListReq;
  return userinfolistreq_;
}
inline ::pp::UserInfoListReq* ProtoBody::release_userinfolistreq() {
  clear_has_userinfolistreq();
  ::pp::UserInfoListReq* temp = userinfolistreq_;
  userinfolistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinfolistreq(::pp::UserInfoListReq* userinfolistreq) {
  delete userinfolistreq_;
  userinfolistreq_ = userinfolistreq;
  if (userinfolistreq) {
    set_has_userinfolistreq();
  } else {
    clear_has_userinfolistreq();
  }
}

// optional .pp.UserInfoListRes userInfoListRes = 519;
inline bool ProtoBody::has_userinfolistres() const {
  return (_has_bits_[7] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_userinfolistres() {
  _has_bits_[7] |= 0x00000200u;
}
inline void ProtoBody::clear_has_userinfolistres() {
  _has_bits_[7] &= ~0x00000200u;
}
inline void ProtoBody::clear_userinfolistres() {
  if (userinfolistres_ != NULL) userinfolistres_->::pp::UserInfoListRes::Clear();
  clear_has_userinfolistres();
}
inline const ::pp::UserInfoListRes& ProtoBody::userinfolistres() const {
  return userinfolistres_ != NULL ? *userinfolistres_ : *default_instance_->userinfolistres_;
}
inline ::pp::UserInfoListRes* ProtoBody::mutable_userinfolistres() {
  set_has_userinfolistres();
  if (userinfolistres_ == NULL) userinfolistres_ = new ::pp::UserInfoListRes;
  return userinfolistres_;
}
inline ::pp::UserInfoListRes* ProtoBody::release_userinfolistres() {
  clear_has_userinfolistres();
  ::pp::UserInfoListRes* temp = userinfolistres_;
  userinfolistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userinfolistres(::pp::UserInfoListRes* userinfolistres) {
  delete userinfolistres_;
  userinfolistres_ = userinfolistres;
  if (userinfolistres) {
    set_has_userinfolistres();
  } else {
    clear_has_userinfolistres();
  }
}

// optional .pp.UserPasswordModifyReq userPasswordModifyReq = 522;
inline bool ProtoBody::has_userpasswordmodifyreq() const {
  return (_has_bits_[7] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_userpasswordmodifyreq() {
  _has_bits_[7] |= 0x00000400u;
}
inline void ProtoBody::clear_has_userpasswordmodifyreq() {
  _has_bits_[7] &= ~0x00000400u;
}
inline void ProtoBody::clear_userpasswordmodifyreq() {
  if (userpasswordmodifyreq_ != NULL) userpasswordmodifyreq_->::pp::UserPasswordModifyReq::Clear();
  clear_has_userpasswordmodifyreq();
}
inline const ::pp::UserPasswordModifyReq& ProtoBody::userpasswordmodifyreq() const {
  return userpasswordmodifyreq_ != NULL ? *userpasswordmodifyreq_ : *default_instance_->userpasswordmodifyreq_;
}
inline ::pp::UserPasswordModifyReq* ProtoBody::mutable_userpasswordmodifyreq() {
  set_has_userpasswordmodifyreq();
  if (userpasswordmodifyreq_ == NULL) userpasswordmodifyreq_ = new ::pp::UserPasswordModifyReq;
  return userpasswordmodifyreq_;
}
inline ::pp::UserPasswordModifyReq* ProtoBody::release_userpasswordmodifyreq() {
  clear_has_userpasswordmodifyreq();
  ::pp::UserPasswordModifyReq* temp = userpasswordmodifyreq_;
  userpasswordmodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpasswordmodifyreq(::pp::UserPasswordModifyReq* userpasswordmodifyreq) {
  delete userpasswordmodifyreq_;
  userpasswordmodifyreq_ = userpasswordmodifyreq;
  if (userpasswordmodifyreq) {
    set_has_userpasswordmodifyreq();
  } else {
    clear_has_userpasswordmodifyreq();
  }
}

// optional .pp.UserPasswordModifyRes userPasswordModifyRes = 523;
inline bool ProtoBody::has_userpasswordmodifyres() const {
  return (_has_bits_[7] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_userpasswordmodifyres() {
  _has_bits_[7] |= 0x00000800u;
}
inline void ProtoBody::clear_has_userpasswordmodifyres() {
  _has_bits_[7] &= ~0x00000800u;
}
inline void ProtoBody::clear_userpasswordmodifyres() {
  if (userpasswordmodifyres_ != NULL) userpasswordmodifyres_->::pp::UserPasswordModifyRes::Clear();
  clear_has_userpasswordmodifyres();
}
inline const ::pp::UserPasswordModifyRes& ProtoBody::userpasswordmodifyres() const {
  return userpasswordmodifyres_ != NULL ? *userpasswordmodifyres_ : *default_instance_->userpasswordmodifyres_;
}
inline ::pp::UserPasswordModifyRes* ProtoBody::mutable_userpasswordmodifyres() {
  set_has_userpasswordmodifyres();
  if (userpasswordmodifyres_ == NULL) userpasswordmodifyres_ = new ::pp::UserPasswordModifyRes;
  return userpasswordmodifyres_;
}
inline ::pp::UserPasswordModifyRes* ProtoBody::release_userpasswordmodifyres() {
  clear_has_userpasswordmodifyres();
  ::pp::UserPasswordModifyRes* temp = userpasswordmodifyres_;
  userpasswordmodifyres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userpasswordmodifyres(::pp::UserPasswordModifyRes* userpasswordmodifyres) {
  delete userpasswordmodifyres_;
  userpasswordmodifyres_ = userpasswordmodifyres;
  if (userpasswordmodifyres) {
    set_has_userpasswordmodifyres();
  } else {
    clear_has_userpasswordmodifyres();
  }
}

// optional .pp.UserSearchReq userSearchReq = 528;
inline bool ProtoBody::has_usersearchreq() const {
  return (_has_bits_[7] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_usersearchreq() {
  _has_bits_[7] |= 0x00001000u;
}
inline void ProtoBody::clear_has_usersearchreq() {
  _has_bits_[7] &= ~0x00001000u;
}
inline void ProtoBody::clear_usersearchreq() {
  if (usersearchreq_ != NULL) usersearchreq_->::pp::UserSearchReq::Clear();
  clear_has_usersearchreq();
}
inline const ::pp::UserSearchReq& ProtoBody::usersearchreq() const {
  return usersearchreq_ != NULL ? *usersearchreq_ : *default_instance_->usersearchreq_;
}
inline ::pp::UserSearchReq* ProtoBody::mutable_usersearchreq() {
  set_has_usersearchreq();
  if (usersearchreq_ == NULL) usersearchreq_ = new ::pp::UserSearchReq;
  return usersearchreq_;
}
inline ::pp::UserSearchReq* ProtoBody::release_usersearchreq() {
  clear_has_usersearchreq();
  ::pp::UserSearchReq* temp = usersearchreq_;
  usersearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usersearchreq(::pp::UserSearchReq* usersearchreq) {
  delete usersearchreq_;
  usersearchreq_ = usersearchreq;
  if (usersearchreq) {
    set_has_usersearchreq();
  } else {
    clear_has_usersearchreq();
  }
}

// optional .pp.UserSearchRes userSearchRes = 529;
inline bool ProtoBody::has_usersearchres() const {
  return (_has_bits_[7] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_usersearchres() {
  _has_bits_[7] |= 0x00002000u;
}
inline void ProtoBody::clear_has_usersearchres() {
  _has_bits_[7] &= ~0x00002000u;
}
inline void ProtoBody::clear_usersearchres() {
  if (usersearchres_ != NULL) usersearchres_->::pp::UserSearchRes::Clear();
  clear_has_usersearchres();
}
inline const ::pp::UserSearchRes& ProtoBody::usersearchres() const {
  return usersearchres_ != NULL ? *usersearchres_ : *default_instance_->usersearchres_;
}
inline ::pp::UserSearchRes* ProtoBody::mutable_usersearchres() {
  set_has_usersearchres();
  if (usersearchres_ == NULL) usersearchres_ = new ::pp::UserSearchRes;
  return usersearchres_;
}
inline ::pp::UserSearchRes* ProtoBody::release_usersearchres() {
  clear_has_usersearchres();
  ::pp::UserSearchRes* temp = usersearchres_;
  usersearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usersearchres(::pp::UserSearchRes* usersearchres) {
  delete usersearchres_;
  usersearchres_ = usersearchres;
  if (usersearchres) {
    set_has_usersearchres();
  } else {
    clear_has_usersearchres();
  }
}

// optional .pp.UserImageListReq userImageListReq = 562;
inline bool ProtoBody::has_userimagelistreq() const {
  return (_has_bits_[7] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_userimagelistreq() {
  _has_bits_[7] |= 0x00004000u;
}
inline void ProtoBody::clear_has_userimagelistreq() {
  _has_bits_[7] &= ~0x00004000u;
}
inline void ProtoBody::clear_userimagelistreq() {
  if (userimagelistreq_ != NULL) userimagelistreq_->::pp::UserImageListReq::Clear();
  clear_has_userimagelistreq();
}
inline const ::pp::UserImageListReq& ProtoBody::userimagelistreq() const {
  return userimagelistreq_ != NULL ? *userimagelistreq_ : *default_instance_->userimagelistreq_;
}
inline ::pp::UserImageListReq* ProtoBody::mutable_userimagelistreq() {
  set_has_userimagelistreq();
  if (userimagelistreq_ == NULL) userimagelistreq_ = new ::pp::UserImageListReq;
  return userimagelistreq_;
}
inline ::pp::UserImageListReq* ProtoBody::release_userimagelistreq() {
  clear_has_userimagelistreq();
  ::pp::UserImageListReq* temp = userimagelistreq_;
  userimagelistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userimagelistreq(::pp::UserImageListReq* userimagelistreq) {
  delete userimagelistreq_;
  userimagelistreq_ = userimagelistreq;
  if (userimagelistreq) {
    set_has_userimagelistreq();
  } else {
    clear_has_userimagelistreq();
  }
}

// optional .pp.UserImageListRes userImageListRes = 563;
inline bool ProtoBody::has_userimagelistres() const {
  return (_has_bits_[7] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_userimagelistres() {
  _has_bits_[7] |= 0x00008000u;
}
inline void ProtoBody::clear_has_userimagelistres() {
  _has_bits_[7] &= ~0x00008000u;
}
inline void ProtoBody::clear_userimagelistres() {
  if (userimagelistres_ != NULL) userimagelistres_->::pp::UserImageListRes::Clear();
  clear_has_userimagelistres();
}
inline const ::pp::UserImageListRes& ProtoBody::userimagelistres() const {
  return userimagelistres_ != NULL ? *userimagelistres_ : *default_instance_->userimagelistres_;
}
inline ::pp::UserImageListRes* ProtoBody::mutable_userimagelistres() {
  set_has_userimagelistres();
  if (userimagelistres_ == NULL) userimagelistres_ = new ::pp::UserImageListRes;
  return userimagelistres_;
}
inline ::pp::UserImageListRes* ProtoBody::release_userimagelistres() {
  clear_has_userimagelistres();
  ::pp::UserImageListRes* temp = userimagelistres_;
  userimagelistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userimagelistres(::pp::UserImageListRes* userimagelistres) {
  delete userimagelistres_;
  userimagelistres_ = userimagelistres;
  if (userimagelistres) {
    set_has_userimagelistres();
  } else {
    clear_has_userimagelistres();
  }
}

// optional .pp.UserImageOpReq userImageOpReq = 564;
inline bool ProtoBody::has_userimageopreq() const {
  return (_has_bits_[7] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_userimageopreq() {
  _has_bits_[7] |= 0x00010000u;
}
inline void ProtoBody::clear_has_userimageopreq() {
  _has_bits_[7] &= ~0x00010000u;
}
inline void ProtoBody::clear_userimageopreq() {
  if (userimageopreq_ != NULL) userimageopreq_->::pp::UserImageOpReq::Clear();
  clear_has_userimageopreq();
}
inline const ::pp::UserImageOpReq& ProtoBody::userimageopreq() const {
  return userimageopreq_ != NULL ? *userimageopreq_ : *default_instance_->userimageopreq_;
}
inline ::pp::UserImageOpReq* ProtoBody::mutable_userimageopreq() {
  set_has_userimageopreq();
  if (userimageopreq_ == NULL) userimageopreq_ = new ::pp::UserImageOpReq;
  return userimageopreq_;
}
inline ::pp::UserImageOpReq* ProtoBody::release_userimageopreq() {
  clear_has_userimageopreq();
  ::pp::UserImageOpReq* temp = userimageopreq_;
  userimageopreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userimageopreq(::pp::UserImageOpReq* userimageopreq) {
  delete userimageopreq_;
  userimageopreq_ = userimageopreq;
  if (userimageopreq) {
    set_has_userimageopreq();
  } else {
    clear_has_userimageopreq();
  }
}

// optional .pp.UserImageOpRes userImageOpRes = 565;
inline bool ProtoBody::has_userimageopres() const {
  return (_has_bits_[7] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_userimageopres() {
  _has_bits_[7] |= 0x00020000u;
}
inline void ProtoBody::clear_has_userimageopres() {
  _has_bits_[7] &= ~0x00020000u;
}
inline void ProtoBody::clear_userimageopres() {
  if (userimageopres_ != NULL) userimageopres_->::pp::UserImageOpRes::Clear();
  clear_has_userimageopres();
}
inline const ::pp::UserImageOpRes& ProtoBody::userimageopres() const {
  return userimageopres_ != NULL ? *userimageopres_ : *default_instance_->userimageopres_;
}
inline ::pp::UserImageOpRes* ProtoBody::mutable_userimageopres() {
  set_has_userimageopres();
  if (userimageopres_ == NULL) userimageopres_ = new ::pp::UserImageOpRes;
  return userimageopres_;
}
inline ::pp::UserImageOpRes* ProtoBody::release_userimageopres() {
  clear_has_userimageopres();
  ::pp::UserImageOpRes* temp = userimageopres_;
  userimageopres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userimageopres(::pp::UserImageOpRes* userimageopres) {
  delete userimageopres_;
  userimageopres_ = userimageopres;
  if (userimageopres) {
    set_has_userimageopres();
  } else {
    clear_has_userimageopres();
  }
}

// optional .pp.UserImageLikeReq userImageLikeReq = 566;
inline bool ProtoBody::has_userimagelikereq() const {
  return (_has_bits_[7] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_userimagelikereq() {
  _has_bits_[7] |= 0x00040000u;
}
inline void ProtoBody::clear_has_userimagelikereq() {
  _has_bits_[7] &= ~0x00040000u;
}
inline void ProtoBody::clear_userimagelikereq() {
  if (userimagelikereq_ != NULL) userimagelikereq_->::pp::UserImageLikeReq::Clear();
  clear_has_userimagelikereq();
}
inline const ::pp::UserImageLikeReq& ProtoBody::userimagelikereq() const {
  return userimagelikereq_ != NULL ? *userimagelikereq_ : *default_instance_->userimagelikereq_;
}
inline ::pp::UserImageLikeReq* ProtoBody::mutable_userimagelikereq() {
  set_has_userimagelikereq();
  if (userimagelikereq_ == NULL) userimagelikereq_ = new ::pp::UserImageLikeReq;
  return userimagelikereq_;
}
inline ::pp::UserImageLikeReq* ProtoBody::release_userimagelikereq() {
  clear_has_userimagelikereq();
  ::pp::UserImageLikeReq* temp = userimagelikereq_;
  userimagelikereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userimagelikereq(::pp::UserImageLikeReq* userimagelikereq) {
  delete userimagelikereq_;
  userimagelikereq_ = userimagelikereq;
  if (userimagelikereq) {
    set_has_userimagelikereq();
  } else {
    clear_has_userimagelikereq();
  }
}

// optional .pp.UserImageLikeRes userImageLikeRes = 567;
inline bool ProtoBody::has_userimagelikeres() const {
  return (_has_bits_[7] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_userimagelikeres() {
  _has_bits_[7] |= 0x00080000u;
}
inline void ProtoBody::clear_has_userimagelikeres() {
  _has_bits_[7] &= ~0x00080000u;
}
inline void ProtoBody::clear_userimagelikeres() {
  if (userimagelikeres_ != NULL) userimagelikeres_->::pp::UserImageLikeRes::Clear();
  clear_has_userimagelikeres();
}
inline const ::pp::UserImageLikeRes& ProtoBody::userimagelikeres() const {
  return userimagelikeres_ != NULL ? *userimagelikeres_ : *default_instance_->userimagelikeres_;
}
inline ::pp::UserImageLikeRes* ProtoBody::mutable_userimagelikeres() {
  set_has_userimagelikeres();
  if (userimagelikeres_ == NULL) userimagelikeres_ = new ::pp::UserImageLikeRes;
  return userimagelikeres_;
}
inline ::pp::UserImageLikeRes* ProtoBody::release_userimagelikeres() {
  clear_has_userimagelikeres();
  ::pp::UserImageLikeRes* temp = userimagelikeres_;
  userimagelikeres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userimagelikeres(::pp::UserImageLikeRes* userimagelikeres) {
  delete userimagelikeres_;
  userimagelikeres_ = userimagelikeres;
  if (userimagelikeres) {
    set_has_userimagelikeres();
  } else {
    clear_has_userimagelikeres();
  }
}

// optional .pp.UserRecommendRegisterReq userRecommendRegisterReq = 608;
inline bool ProtoBody::has_userrecommendregisterreq() const {
  return (_has_bits_[7] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_userrecommendregisterreq() {
  _has_bits_[7] |= 0x00100000u;
}
inline void ProtoBody::clear_has_userrecommendregisterreq() {
  _has_bits_[7] &= ~0x00100000u;
}
inline void ProtoBody::clear_userrecommendregisterreq() {
  if (userrecommendregisterreq_ != NULL) userrecommendregisterreq_->::pp::UserRecommendRegisterReq::Clear();
  clear_has_userrecommendregisterreq();
}
inline const ::pp::UserRecommendRegisterReq& ProtoBody::userrecommendregisterreq() const {
  return userrecommendregisterreq_ != NULL ? *userrecommendregisterreq_ : *default_instance_->userrecommendregisterreq_;
}
inline ::pp::UserRecommendRegisterReq* ProtoBody::mutable_userrecommendregisterreq() {
  set_has_userrecommendregisterreq();
  if (userrecommendregisterreq_ == NULL) userrecommendregisterreq_ = new ::pp::UserRecommendRegisterReq;
  return userrecommendregisterreq_;
}
inline ::pp::UserRecommendRegisterReq* ProtoBody::release_userrecommendregisterreq() {
  clear_has_userrecommendregisterreq();
  ::pp::UserRecommendRegisterReq* temp = userrecommendregisterreq_;
  userrecommendregisterreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userrecommendregisterreq(::pp::UserRecommendRegisterReq* userrecommendregisterreq) {
  delete userrecommendregisterreq_;
  userrecommendregisterreq_ = userrecommendregisterreq;
  if (userrecommendregisterreq) {
    set_has_userrecommendregisterreq();
  } else {
    clear_has_userrecommendregisterreq();
  }
}

// optional .pp.UserRecommendRegisterRes userRecommendRegisterRes = 609;
inline bool ProtoBody::has_userrecommendregisterres() const {
  return (_has_bits_[7] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_userrecommendregisterres() {
  _has_bits_[7] |= 0x00200000u;
}
inline void ProtoBody::clear_has_userrecommendregisterres() {
  _has_bits_[7] &= ~0x00200000u;
}
inline void ProtoBody::clear_userrecommendregisterres() {
  if (userrecommendregisterres_ != NULL) userrecommendregisterres_->::pp::UserRecommendRegisterRes::Clear();
  clear_has_userrecommendregisterres();
}
inline const ::pp::UserRecommendRegisterRes& ProtoBody::userrecommendregisterres() const {
  return userrecommendregisterres_ != NULL ? *userrecommendregisterres_ : *default_instance_->userrecommendregisterres_;
}
inline ::pp::UserRecommendRegisterRes* ProtoBody::mutable_userrecommendregisterres() {
  set_has_userrecommendregisterres();
  if (userrecommendregisterres_ == NULL) userrecommendregisterres_ = new ::pp::UserRecommendRegisterRes;
  return userrecommendregisterres_;
}
inline ::pp::UserRecommendRegisterRes* ProtoBody::release_userrecommendregisterres() {
  clear_has_userrecommendregisterres();
  ::pp::UserRecommendRegisterRes* temp = userrecommendregisterres_;
  userrecommendregisterres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userrecommendregisterres(::pp::UserRecommendRegisterRes* userrecommendregisterres) {
  delete userrecommendregisterres_;
  userrecommendregisterres_ = userrecommendregisterres;
  if (userrecommendregisterres) {
    set_has_userrecommendregisterres();
  } else {
    clear_has_userrecommendregisterres();
  }
}

// optional .pp.UserRefererListReq userRefererListReq = 610;
inline bool ProtoBody::has_userrefererlistreq() const {
  return (_has_bits_[7] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_userrefererlistreq() {
  _has_bits_[7] |= 0x00400000u;
}
inline void ProtoBody::clear_has_userrefererlistreq() {
  _has_bits_[7] &= ~0x00400000u;
}
inline void ProtoBody::clear_userrefererlistreq() {
  if (userrefererlistreq_ != NULL) userrefererlistreq_->::pp::UserRefererListReq::Clear();
  clear_has_userrefererlistreq();
}
inline const ::pp::UserRefererListReq& ProtoBody::userrefererlistreq() const {
  return userrefererlistreq_ != NULL ? *userrefererlistreq_ : *default_instance_->userrefererlistreq_;
}
inline ::pp::UserRefererListReq* ProtoBody::mutable_userrefererlistreq() {
  set_has_userrefererlistreq();
  if (userrefererlistreq_ == NULL) userrefererlistreq_ = new ::pp::UserRefererListReq;
  return userrefererlistreq_;
}
inline ::pp::UserRefererListReq* ProtoBody::release_userrefererlistreq() {
  clear_has_userrefererlistreq();
  ::pp::UserRefererListReq* temp = userrefererlistreq_;
  userrefererlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userrefererlistreq(::pp::UserRefererListReq* userrefererlistreq) {
  delete userrefererlistreq_;
  userrefererlistreq_ = userrefererlistreq;
  if (userrefererlistreq) {
    set_has_userrefererlistreq();
  } else {
    clear_has_userrefererlistreq();
  }
}

// optional .pp.UserRefererListRes userRefererListRes = 611;
inline bool ProtoBody::has_userrefererlistres() const {
  return (_has_bits_[7] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_userrefererlistres() {
  _has_bits_[7] |= 0x00800000u;
}
inline void ProtoBody::clear_has_userrefererlistres() {
  _has_bits_[7] &= ~0x00800000u;
}
inline void ProtoBody::clear_userrefererlistres() {
  if (userrefererlistres_ != NULL) userrefererlistres_->::pp::UserRefererListRes::Clear();
  clear_has_userrefererlistres();
}
inline const ::pp::UserRefererListRes& ProtoBody::userrefererlistres() const {
  return userrefererlistres_ != NULL ? *userrefererlistres_ : *default_instance_->userrefererlistres_;
}
inline ::pp::UserRefererListRes* ProtoBody::mutable_userrefererlistres() {
  set_has_userrefererlistres();
  if (userrefererlistres_ == NULL) userrefererlistres_ = new ::pp::UserRefererListRes;
  return userrefererlistres_;
}
inline ::pp::UserRefererListRes* ProtoBody::release_userrefererlistres() {
  clear_has_userrefererlistres();
  ::pp::UserRefererListRes* temp = userrefererlistres_;
  userrefererlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userrefererlistres(::pp::UserRefererListRes* userrefererlistres) {
  delete userrefererlistres_;
  userrefererlistres_ = userrefererlistres;
  if (userrefererlistres) {
    set_has_userrefererlistres();
  } else {
    clear_has_userrefererlistres();
  }
}

// optional .pp.UserProductListReq userProductListReq = 626;
inline bool ProtoBody::has_userproductlistreq() const {
  return (_has_bits_[7] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_userproductlistreq() {
  _has_bits_[7] |= 0x01000000u;
}
inline void ProtoBody::clear_has_userproductlistreq() {
  _has_bits_[7] &= ~0x01000000u;
}
inline void ProtoBody::clear_userproductlistreq() {
  if (userproductlistreq_ != NULL) userproductlistreq_->::pp::UserProductListReq::Clear();
  clear_has_userproductlistreq();
}
inline const ::pp::UserProductListReq& ProtoBody::userproductlistreq() const {
  return userproductlistreq_ != NULL ? *userproductlistreq_ : *default_instance_->userproductlistreq_;
}
inline ::pp::UserProductListReq* ProtoBody::mutable_userproductlistreq() {
  set_has_userproductlistreq();
  if (userproductlistreq_ == NULL) userproductlistreq_ = new ::pp::UserProductListReq;
  return userproductlistreq_;
}
inline ::pp::UserProductListReq* ProtoBody::release_userproductlistreq() {
  clear_has_userproductlistreq();
  ::pp::UserProductListReq* temp = userproductlistreq_;
  userproductlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userproductlistreq(::pp::UserProductListReq* userproductlistreq) {
  delete userproductlistreq_;
  userproductlistreq_ = userproductlistreq;
  if (userproductlistreq) {
    set_has_userproductlistreq();
  } else {
    clear_has_userproductlistreq();
  }
}

// optional .pp.UserProductListRes userProductListRes = 627;
inline bool ProtoBody::has_userproductlistres() const {
  return (_has_bits_[7] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_userproductlistres() {
  _has_bits_[7] |= 0x02000000u;
}
inline void ProtoBody::clear_has_userproductlistres() {
  _has_bits_[7] &= ~0x02000000u;
}
inline void ProtoBody::clear_userproductlistres() {
  if (userproductlistres_ != NULL) userproductlistres_->::pp::UserProductListRes::Clear();
  clear_has_userproductlistres();
}
inline const ::pp::UserProductListRes& ProtoBody::userproductlistres() const {
  return userproductlistres_ != NULL ? *userproductlistres_ : *default_instance_->userproductlistres_;
}
inline ::pp::UserProductListRes* ProtoBody::mutable_userproductlistres() {
  set_has_userproductlistres();
  if (userproductlistres_ == NULL) userproductlistres_ = new ::pp::UserProductListRes;
  return userproductlistres_;
}
inline ::pp::UserProductListRes* ProtoBody::release_userproductlistres() {
  clear_has_userproductlistres();
  ::pp::UserProductListRes* temp = userproductlistres_;
  userproductlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userproductlistres(::pp::UserProductListRes* userproductlistres) {
  delete userproductlistres_;
  userproductlistres_ = userproductlistres;
  if (userproductlistres) {
    set_has_userproductlistres();
  } else {
    clear_has_userproductlistres();
  }
}

// optional .pp.UserActiveDataReq userActiveDataReq = 628;
inline bool ProtoBody::has_useractivedatareq() const {
  return (_has_bits_[7] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_useractivedatareq() {
  _has_bits_[7] |= 0x04000000u;
}
inline void ProtoBody::clear_has_useractivedatareq() {
  _has_bits_[7] &= ~0x04000000u;
}
inline void ProtoBody::clear_useractivedatareq() {
  if (useractivedatareq_ != NULL) useractivedatareq_->::pp::UserActiveDataReq::Clear();
  clear_has_useractivedatareq();
}
inline const ::pp::UserActiveDataReq& ProtoBody::useractivedatareq() const {
  return useractivedatareq_ != NULL ? *useractivedatareq_ : *default_instance_->useractivedatareq_;
}
inline ::pp::UserActiveDataReq* ProtoBody::mutable_useractivedatareq() {
  set_has_useractivedatareq();
  if (useractivedatareq_ == NULL) useractivedatareq_ = new ::pp::UserActiveDataReq;
  return useractivedatareq_;
}
inline ::pp::UserActiveDataReq* ProtoBody::release_useractivedatareq() {
  clear_has_useractivedatareq();
  ::pp::UserActiveDataReq* temp = useractivedatareq_;
  useractivedatareq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useractivedatareq(::pp::UserActiveDataReq* useractivedatareq) {
  delete useractivedatareq_;
  useractivedatareq_ = useractivedatareq;
  if (useractivedatareq) {
    set_has_useractivedatareq();
  } else {
    clear_has_useractivedatareq();
  }
}

// optional .pp.UserActiveDataRes userActiveDataRes = 629;
inline bool ProtoBody::has_useractivedatares() const {
  return (_has_bits_[7] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_useractivedatares() {
  _has_bits_[7] |= 0x08000000u;
}
inline void ProtoBody::clear_has_useractivedatares() {
  _has_bits_[7] &= ~0x08000000u;
}
inline void ProtoBody::clear_useractivedatares() {
  if (useractivedatares_ != NULL) useractivedatares_->::pp::UserActiveDataRes::Clear();
  clear_has_useractivedatares();
}
inline const ::pp::UserActiveDataRes& ProtoBody::useractivedatares() const {
  return useractivedatares_ != NULL ? *useractivedatares_ : *default_instance_->useractivedatares_;
}
inline ::pp::UserActiveDataRes* ProtoBody::mutable_useractivedatares() {
  set_has_useractivedatares();
  if (useractivedatares_ == NULL) useractivedatares_ = new ::pp::UserActiveDataRes;
  return useractivedatares_;
}
inline ::pp::UserActiveDataRes* ProtoBody::release_useractivedatares() {
  clear_has_useractivedatares();
  ::pp::UserActiveDataRes* temp = useractivedatares_;
  useractivedatares_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useractivedatares(::pp::UserActiveDataRes* useractivedatares) {
  delete useractivedatares_;
  useractivedatares_ = useractivedatares;
  if (useractivedatares) {
    set_has_useractivedatares();
  } else {
    clear_has_useractivedatares();
  }
}

// optional .pp.UserStatDataReq userStatDataReq = 636;
inline bool ProtoBody::has_userstatdatareq() const {
  return (_has_bits_[7] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_userstatdatareq() {
  _has_bits_[7] |= 0x10000000u;
}
inline void ProtoBody::clear_has_userstatdatareq() {
  _has_bits_[7] &= ~0x10000000u;
}
inline void ProtoBody::clear_userstatdatareq() {
  if (userstatdatareq_ != NULL) userstatdatareq_->::pp::UserStatDataReq::Clear();
  clear_has_userstatdatareq();
}
inline const ::pp::UserStatDataReq& ProtoBody::userstatdatareq() const {
  return userstatdatareq_ != NULL ? *userstatdatareq_ : *default_instance_->userstatdatareq_;
}
inline ::pp::UserStatDataReq* ProtoBody::mutable_userstatdatareq() {
  set_has_userstatdatareq();
  if (userstatdatareq_ == NULL) userstatdatareq_ = new ::pp::UserStatDataReq;
  return userstatdatareq_;
}
inline ::pp::UserStatDataReq* ProtoBody::release_userstatdatareq() {
  clear_has_userstatdatareq();
  ::pp::UserStatDataReq* temp = userstatdatareq_;
  userstatdatareq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userstatdatareq(::pp::UserStatDataReq* userstatdatareq) {
  delete userstatdatareq_;
  userstatdatareq_ = userstatdatareq;
  if (userstatdatareq) {
    set_has_userstatdatareq();
  } else {
    clear_has_userstatdatareq();
  }
}

// optional .pp.UserStatDataRes userStatDataRes = 637;
inline bool ProtoBody::has_userstatdatares() const {
  return (_has_bits_[7] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_userstatdatares() {
  _has_bits_[7] |= 0x20000000u;
}
inline void ProtoBody::clear_has_userstatdatares() {
  _has_bits_[7] &= ~0x20000000u;
}
inline void ProtoBody::clear_userstatdatares() {
  if (userstatdatares_ != NULL) userstatdatares_->::pp::UserStatDataRes::Clear();
  clear_has_userstatdatares();
}
inline const ::pp::UserStatDataRes& ProtoBody::userstatdatares() const {
  return userstatdatares_ != NULL ? *userstatdatares_ : *default_instance_->userstatdatares_;
}
inline ::pp::UserStatDataRes* ProtoBody::mutable_userstatdatares() {
  set_has_userstatdatares();
  if (userstatdatares_ == NULL) userstatdatares_ = new ::pp::UserStatDataRes;
  return userstatdatares_;
}
inline ::pp::UserStatDataRes* ProtoBody::release_userstatdatares() {
  clear_has_userstatdatares();
  ::pp::UserStatDataRes* temp = userstatdatares_;
  userstatdatares_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userstatdatares(::pp::UserStatDataRes* userstatdatares) {
  delete userstatdatares_;
  userstatdatares_ = userstatdatares;
  if (userstatdatares) {
    set_has_userstatdatares();
  } else {
    clear_has_userstatdatares();
  }
}

// optional .pp.UserActiveDataListReq userActiveDataListReq = 638;
inline bool ProtoBody::has_useractivedatalistreq() const {
  return (_has_bits_[7] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_useractivedatalistreq() {
  _has_bits_[7] |= 0x40000000u;
}
inline void ProtoBody::clear_has_useractivedatalistreq() {
  _has_bits_[7] &= ~0x40000000u;
}
inline void ProtoBody::clear_useractivedatalistreq() {
  if (useractivedatalistreq_ != NULL) useractivedatalistreq_->::pp::UserActiveDataListReq::Clear();
  clear_has_useractivedatalistreq();
}
inline const ::pp::UserActiveDataListReq& ProtoBody::useractivedatalistreq() const {
  return useractivedatalistreq_ != NULL ? *useractivedatalistreq_ : *default_instance_->useractivedatalistreq_;
}
inline ::pp::UserActiveDataListReq* ProtoBody::mutable_useractivedatalistreq() {
  set_has_useractivedatalistreq();
  if (useractivedatalistreq_ == NULL) useractivedatalistreq_ = new ::pp::UserActiveDataListReq;
  return useractivedatalistreq_;
}
inline ::pp::UserActiveDataListReq* ProtoBody::release_useractivedatalistreq() {
  clear_has_useractivedatalistreq();
  ::pp::UserActiveDataListReq* temp = useractivedatalistreq_;
  useractivedatalistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useractivedatalistreq(::pp::UserActiveDataListReq* useractivedatalistreq) {
  delete useractivedatalistreq_;
  useractivedatalistreq_ = useractivedatalistreq;
  if (useractivedatalistreq) {
    set_has_useractivedatalistreq();
  } else {
    clear_has_useractivedatalistreq();
  }
}

// optional .pp.UserActiveDataListRes userActiveDataListRes = 639;
inline bool ProtoBody::has_useractivedatalistres() const {
  return (_has_bits_[7] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_useractivedatalistres() {
  _has_bits_[7] |= 0x80000000u;
}
inline void ProtoBody::clear_has_useractivedatalistres() {
  _has_bits_[7] &= ~0x80000000u;
}
inline void ProtoBody::clear_useractivedatalistres() {
  if (useractivedatalistres_ != NULL) useractivedatalistres_->::pp::UserActiveDataListRes::Clear();
  clear_has_useractivedatalistres();
}
inline const ::pp::UserActiveDataListRes& ProtoBody::useractivedatalistres() const {
  return useractivedatalistres_ != NULL ? *useractivedatalistres_ : *default_instance_->useractivedatalistres_;
}
inline ::pp::UserActiveDataListRes* ProtoBody::mutable_useractivedatalistres() {
  set_has_useractivedatalistres();
  if (useractivedatalistres_ == NULL) useractivedatalistres_ = new ::pp::UserActiveDataListRes;
  return useractivedatalistres_;
}
inline ::pp::UserActiveDataListRes* ProtoBody::release_useractivedatalistres() {
  clear_has_useractivedatalistres();
  ::pp::UserActiveDataListRes* temp = useractivedatalistres_;
  useractivedatalistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_useractivedatalistres(::pp::UserActiveDataListRes* useractivedatalistres) {
  delete useractivedatalistres_;
  useractivedatalistres_ = useractivedatalistres;
  if (useractivedatalistres) {
    set_has_useractivedatalistres();
  } else {
    clear_has_useractivedatalistres();
  }
}

// optional .pp.UserProfileViewReq userProfileViewReq = 642;
inline bool ProtoBody::has_userprofileviewreq() const {
  return (_has_bits_[8] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_userprofileviewreq() {
  _has_bits_[8] |= 0x00000001u;
}
inline void ProtoBody::clear_has_userprofileviewreq() {
  _has_bits_[8] &= ~0x00000001u;
}
inline void ProtoBody::clear_userprofileviewreq() {
  if (userprofileviewreq_ != NULL) userprofileviewreq_->::pp::UserProfileViewReq::Clear();
  clear_has_userprofileviewreq();
}
inline const ::pp::UserProfileViewReq& ProtoBody::userprofileviewreq() const {
  return userprofileviewreq_ != NULL ? *userprofileviewreq_ : *default_instance_->userprofileviewreq_;
}
inline ::pp::UserProfileViewReq* ProtoBody::mutable_userprofileviewreq() {
  set_has_userprofileviewreq();
  if (userprofileviewreq_ == NULL) userprofileviewreq_ = new ::pp::UserProfileViewReq;
  return userprofileviewreq_;
}
inline ::pp::UserProfileViewReq* ProtoBody::release_userprofileviewreq() {
  clear_has_userprofileviewreq();
  ::pp::UserProfileViewReq* temp = userprofileviewreq_;
  userprofileviewreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userprofileviewreq(::pp::UserProfileViewReq* userprofileviewreq) {
  delete userprofileviewreq_;
  userprofileviewreq_ = userprofileviewreq;
  if (userprofileviewreq) {
    set_has_userprofileviewreq();
  } else {
    clear_has_userprofileviewreq();
  }
}

// optional .pp.UserProfileViewRes userProfileViewRes = 643;
inline bool ProtoBody::has_userprofileviewres() const {
  return (_has_bits_[8] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_userprofileviewres() {
  _has_bits_[8] |= 0x00000002u;
}
inline void ProtoBody::clear_has_userprofileviewres() {
  _has_bits_[8] &= ~0x00000002u;
}
inline void ProtoBody::clear_userprofileviewres() {
  if (userprofileviewres_ != NULL) userprofileviewres_->::pp::UserProfileViewRes::Clear();
  clear_has_userprofileviewres();
}
inline const ::pp::UserProfileViewRes& ProtoBody::userprofileviewres() const {
  return userprofileviewres_ != NULL ? *userprofileviewres_ : *default_instance_->userprofileviewres_;
}
inline ::pp::UserProfileViewRes* ProtoBody::mutable_userprofileviewres() {
  set_has_userprofileviewres();
  if (userprofileviewres_ == NULL) userprofileviewres_ = new ::pp::UserProfileViewRes;
  return userprofileviewres_;
}
inline ::pp::UserProfileViewRes* ProtoBody::release_userprofileviewres() {
  clear_has_userprofileviewres();
  ::pp::UserProfileViewRes* temp = userprofileviewres_;
  userprofileviewres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userprofileviewres(::pp::UserProfileViewRes* userprofileviewres) {
  delete userprofileviewres_;
  userprofileviewres_ = userprofileviewres;
  if (userprofileviewres) {
    set_has_userprofileviewres();
  } else {
    clear_has_userprofileviewres();
  }
}

// optional .pp.UserAppRateReq userAppRateReq = 644;
inline bool ProtoBody::has_userappratereq() const {
  return (_has_bits_[8] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_userappratereq() {
  _has_bits_[8] |= 0x00000004u;
}
inline void ProtoBody::clear_has_userappratereq() {
  _has_bits_[8] &= ~0x00000004u;
}
inline void ProtoBody::clear_userappratereq() {
  if (userappratereq_ != NULL) userappratereq_->::pp::UserAppRateReq::Clear();
  clear_has_userappratereq();
}
inline const ::pp::UserAppRateReq& ProtoBody::userappratereq() const {
  return userappratereq_ != NULL ? *userappratereq_ : *default_instance_->userappratereq_;
}
inline ::pp::UserAppRateReq* ProtoBody::mutable_userappratereq() {
  set_has_userappratereq();
  if (userappratereq_ == NULL) userappratereq_ = new ::pp::UserAppRateReq;
  return userappratereq_;
}
inline ::pp::UserAppRateReq* ProtoBody::release_userappratereq() {
  clear_has_userappratereq();
  ::pp::UserAppRateReq* temp = userappratereq_;
  userappratereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userappratereq(::pp::UserAppRateReq* userappratereq) {
  delete userappratereq_;
  userappratereq_ = userappratereq;
  if (userappratereq) {
    set_has_userappratereq();
  } else {
    clear_has_userappratereq();
  }
}

// optional .pp.UserAppRateRes userAppRateRes = 645;
inline bool ProtoBody::has_userapprateres() const {
  return (_has_bits_[8] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_userapprateres() {
  _has_bits_[8] |= 0x00000008u;
}
inline void ProtoBody::clear_has_userapprateres() {
  _has_bits_[8] &= ~0x00000008u;
}
inline void ProtoBody::clear_userapprateres() {
  if (userapprateres_ != NULL) userapprateres_->::pp::UserAppRateRes::Clear();
  clear_has_userapprateres();
}
inline const ::pp::UserAppRateRes& ProtoBody::userapprateres() const {
  return userapprateres_ != NULL ? *userapprateres_ : *default_instance_->userapprateres_;
}
inline ::pp::UserAppRateRes* ProtoBody::mutable_userapprateres() {
  set_has_userapprateres();
  if (userapprateres_ == NULL) userapprateres_ = new ::pp::UserAppRateRes;
  return userapprateres_;
}
inline ::pp::UserAppRateRes* ProtoBody::release_userapprateres() {
  clear_has_userapprateres();
  ::pp::UserAppRateRes* temp = userapprateres_;
  userapprateres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userapprateres(::pp::UserAppRateRes* userapprateres) {
  delete userapprateres_;
  userapprateres_ = userapprateres;
  if (userapprateres) {
    set_has_userapprateres();
  } else {
    clear_has_userapprateres();
  }
}

// optional .pp.UserExpressAddrOpReq userExpressAddrOpReq = 646;
inline bool ProtoBody::has_userexpressaddropreq() const {
  return (_has_bits_[8] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_userexpressaddropreq() {
  _has_bits_[8] |= 0x00000010u;
}
inline void ProtoBody::clear_has_userexpressaddropreq() {
  _has_bits_[8] &= ~0x00000010u;
}
inline void ProtoBody::clear_userexpressaddropreq() {
  if (userexpressaddropreq_ != NULL) userexpressaddropreq_->::pp::UserExpressAddrOpReq::Clear();
  clear_has_userexpressaddropreq();
}
inline const ::pp::UserExpressAddrOpReq& ProtoBody::userexpressaddropreq() const {
  return userexpressaddropreq_ != NULL ? *userexpressaddropreq_ : *default_instance_->userexpressaddropreq_;
}
inline ::pp::UserExpressAddrOpReq* ProtoBody::mutable_userexpressaddropreq() {
  set_has_userexpressaddropreq();
  if (userexpressaddropreq_ == NULL) userexpressaddropreq_ = new ::pp::UserExpressAddrOpReq;
  return userexpressaddropreq_;
}
inline ::pp::UserExpressAddrOpReq* ProtoBody::release_userexpressaddropreq() {
  clear_has_userexpressaddropreq();
  ::pp::UserExpressAddrOpReq* temp = userexpressaddropreq_;
  userexpressaddropreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userexpressaddropreq(::pp::UserExpressAddrOpReq* userexpressaddropreq) {
  delete userexpressaddropreq_;
  userexpressaddropreq_ = userexpressaddropreq;
  if (userexpressaddropreq) {
    set_has_userexpressaddropreq();
  } else {
    clear_has_userexpressaddropreq();
  }
}

// optional .pp.UserExpressAddrOpRes userExpressAddrOpRes = 647;
inline bool ProtoBody::has_userexpressaddropres() const {
  return (_has_bits_[8] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_userexpressaddropres() {
  _has_bits_[8] |= 0x00000020u;
}
inline void ProtoBody::clear_has_userexpressaddropres() {
  _has_bits_[8] &= ~0x00000020u;
}
inline void ProtoBody::clear_userexpressaddropres() {
  if (userexpressaddropres_ != NULL) userexpressaddropres_->::pp::UserExpressAddrOpRes::Clear();
  clear_has_userexpressaddropres();
}
inline const ::pp::UserExpressAddrOpRes& ProtoBody::userexpressaddropres() const {
  return userexpressaddropres_ != NULL ? *userexpressaddropres_ : *default_instance_->userexpressaddropres_;
}
inline ::pp::UserExpressAddrOpRes* ProtoBody::mutable_userexpressaddropres() {
  set_has_userexpressaddropres();
  if (userexpressaddropres_ == NULL) userexpressaddropres_ = new ::pp::UserExpressAddrOpRes;
  return userexpressaddropres_;
}
inline ::pp::UserExpressAddrOpRes* ProtoBody::release_userexpressaddropres() {
  clear_has_userexpressaddropres();
  ::pp::UserExpressAddrOpRes* temp = userexpressaddropres_;
  userexpressaddropres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userexpressaddropres(::pp::UserExpressAddrOpRes* userexpressaddropres) {
  delete userexpressaddropres_;
  userexpressaddropres_ = userexpressaddropres;
  if (userexpressaddropres) {
    set_has_userexpressaddropres();
  } else {
    clear_has_userexpressaddropres();
  }
}

// optional .pp.AutoTaskUserListReq autoTaskUserListReq = 648;
inline bool ProtoBody::has_autotaskuserlistreq() const {
  return (_has_bits_[8] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_autotaskuserlistreq() {
  _has_bits_[8] |= 0x00000040u;
}
inline void ProtoBody::clear_has_autotaskuserlistreq() {
  _has_bits_[8] &= ~0x00000040u;
}
inline void ProtoBody::clear_autotaskuserlistreq() {
  if (autotaskuserlistreq_ != NULL) autotaskuserlistreq_->::pp::AutoTaskUserListReq::Clear();
  clear_has_autotaskuserlistreq();
}
inline const ::pp::AutoTaskUserListReq& ProtoBody::autotaskuserlistreq() const {
  return autotaskuserlistreq_ != NULL ? *autotaskuserlistreq_ : *default_instance_->autotaskuserlistreq_;
}
inline ::pp::AutoTaskUserListReq* ProtoBody::mutable_autotaskuserlistreq() {
  set_has_autotaskuserlistreq();
  if (autotaskuserlistreq_ == NULL) autotaskuserlistreq_ = new ::pp::AutoTaskUserListReq;
  return autotaskuserlistreq_;
}
inline ::pp::AutoTaskUserListReq* ProtoBody::release_autotaskuserlistreq() {
  clear_has_autotaskuserlistreq();
  ::pp::AutoTaskUserListReq* temp = autotaskuserlistreq_;
  autotaskuserlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_autotaskuserlistreq(::pp::AutoTaskUserListReq* autotaskuserlistreq) {
  delete autotaskuserlistreq_;
  autotaskuserlistreq_ = autotaskuserlistreq;
  if (autotaskuserlistreq) {
    set_has_autotaskuserlistreq();
  } else {
    clear_has_autotaskuserlistreq();
  }
}

// optional .pp.AutoTaskUserListRes autoTaskUserListRes = 649;
inline bool ProtoBody::has_autotaskuserlistres() const {
  return (_has_bits_[8] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_autotaskuserlistres() {
  _has_bits_[8] |= 0x00000080u;
}
inline void ProtoBody::clear_has_autotaskuserlistres() {
  _has_bits_[8] &= ~0x00000080u;
}
inline void ProtoBody::clear_autotaskuserlistres() {
  if (autotaskuserlistres_ != NULL) autotaskuserlistres_->::pp::AutoTaskUserListRes::Clear();
  clear_has_autotaskuserlistres();
}
inline const ::pp::AutoTaskUserListRes& ProtoBody::autotaskuserlistres() const {
  return autotaskuserlistres_ != NULL ? *autotaskuserlistres_ : *default_instance_->autotaskuserlistres_;
}
inline ::pp::AutoTaskUserListRes* ProtoBody::mutable_autotaskuserlistres() {
  set_has_autotaskuserlistres();
  if (autotaskuserlistres_ == NULL) autotaskuserlistres_ = new ::pp::AutoTaskUserListRes;
  return autotaskuserlistres_;
}
inline ::pp::AutoTaskUserListRes* ProtoBody::release_autotaskuserlistres() {
  clear_has_autotaskuserlistres();
  ::pp::AutoTaskUserListRes* temp = autotaskuserlistres_;
  autotaskuserlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_autotaskuserlistres(::pp::AutoTaskUserListRes* autotaskuserlistres) {
  delete autotaskuserlistres_;
  autotaskuserlistres_ = autotaskuserlistres;
  if (autotaskuserlistres) {
    set_has_autotaskuserlistres();
  } else {
    clear_has_autotaskuserlistres();
  }
}

// optional .pp.UserShowShareReq userShowShareReq = 650;
inline bool ProtoBody::has_usershowsharereq() const {
  return (_has_bits_[8] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_usershowsharereq() {
  _has_bits_[8] |= 0x00000100u;
}
inline void ProtoBody::clear_has_usershowsharereq() {
  _has_bits_[8] &= ~0x00000100u;
}
inline void ProtoBody::clear_usershowsharereq() {
  if (usershowsharereq_ != NULL) usershowsharereq_->::pp::UserShowShareReq::Clear();
  clear_has_usershowsharereq();
}
inline const ::pp::UserShowShareReq& ProtoBody::usershowsharereq() const {
  return usershowsharereq_ != NULL ? *usershowsharereq_ : *default_instance_->usershowsharereq_;
}
inline ::pp::UserShowShareReq* ProtoBody::mutable_usershowsharereq() {
  set_has_usershowsharereq();
  if (usershowsharereq_ == NULL) usershowsharereq_ = new ::pp::UserShowShareReq;
  return usershowsharereq_;
}
inline ::pp::UserShowShareReq* ProtoBody::release_usershowsharereq() {
  clear_has_usershowsharereq();
  ::pp::UserShowShareReq* temp = usershowsharereq_;
  usershowsharereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usershowsharereq(::pp::UserShowShareReq* usershowsharereq) {
  delete usershowsharereq_;
  usershowsharereq_ = usershowsharereq;
  if (usershowsharereq) {
    set_has_usershowsharereq();
  } else {
    clear_has_usershowsharereq();
  }
}

// optional .pp.UserShowShareRes userShowShareRes = 651;
inline bool ProtoBody::has_usershowshareres() const {
  return (_has_bits_[8] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_usershowshareres() {
  _has_bits_[8] |= 0x00000200u;
}
inline void ProtoBody::clear_has_usershowshareres() {
  _has_bits_[8] &= ~0x00000200u;
}
inline void ProtoBody::clear_usershowshareres() {
  if (usershowshareres_ != NULL) usershowshareres_->::pp::UserShowShareRes::Clear();
  clear_has_usershowshareres();
}
inline const ::pp::UserShowShareRes& ProtoBody::usershowshareres() const {
  return usershowshareres_ != NULL ? *usershowshareres_ : *default_instance_->usershowshareres_;
}
inline ::pp::UserShowShareRes* ProtoBody::mutable_usershowshareres() {
  set_has_usershowshareres();
  if (usershowshareres_ == NULL) usershowshareres_ = new ::pp::UserShowShareRes;
  return usershowshareres_;
}
inline ::pp::UserShowShareRes* ProtoBody::release_usershowshareres() {
  clear_has_usershowshareres();
  ::pp::UserShowShareRes* temp = usershowshareres_;
  usershowshareres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usershowshareres(::pp::UserShowShareRes* usershowshareres) {
  delete usershowshareres_;
  usershowshareres_ = usershowshareres;
  if (usershowshareres) {
    set_has_usershowshareres();
  } else {
    clear_has_usershowshareres();
  }
}

// optional .pp.UserThirdPartyAccountReq userThirdPartyAccountReq = 652;
inline bool ProtoBody::has_userthirdpartyaccountreq() const {
  return (_has_bits_[8] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_userthirdpartyaccountreq() {
  _has_bits_[8] |= 0x00000400u;
}
inline void ProtoBody::clear_has_userthirdpartyaccountreq() {
  _has_bits_[8] &= ~0x00000400u;
}
inline void ProtoBody::clear_userthirdpartyaccountreq() {
  if (userthirdpartyaccountreq_ != NULL) userthirdpartyaccountreq_->::pp::UserThirdPartyAccountReq::Clear();
  clear_has_userthirdpartyaccountreq();
}
inline const ::pp::UserThirdPartyAccountReq& ProtoBody::userthirdpartyaccountreq() const {
  return userthirdpartyaccountreq_ != NULL ? *userthirdpartyaccountreq_ : *default_instance_->userthirdpartyaccountreq_;
}
inline ::pp::UserThirdPartyAccountReq* ProtoBody::mutable_userthirdpartyaccountreq() {
  set_has_userthirdpartyaccountreq();
  if (userthirdpartyaccountreq_ == NULL) userthirdpartyaccountreq_ = new ::pp::UserThirdPartyAccountReq;
  return userthirdpartyaccountreq_;
}
inline ::pp::UserThirdPartyAccountReq* ProtoBody::release_userthirdpartyaccountreq() {
  clear_has_userthirdpartyaccountreq();
  ::pp::UserThirdPartyAccountReq* temp = userthirdpartyaccountreq_;
  userthirdpartyaccountreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userthirdpartyaccountreq(::pp::UserThirdPartyAccountReq* userthirdpartyaccountreq) {
  delete userthirdpartyaccountreq_;
  userthirdpartyaccountreq_ = userthirdpartyaccountreq;
  if (userthirdpartyaccountreq) {
    set_has_userthirdpartyaccountreq();
  } else {
    clear_has_userthirdpartyaccountreq();
  }
}

// optional .pp.UserThirdPartyAccountRes userThirdPartyAccountRes = 653;
inline bool ProtoBody::has_userthirdpartyaccountres() const {
  return (_has_bits_[8] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_userthirdpartyaccountres() {
  _has_bits_[8] |= 0x00000800u;
}
inline void ProtoBody::clear_has_userthirdpartyaccountres() {
  _has_bits_[8] &= ~0x00000800u;
}
inline void ProtoBody::clear_userthirdpartyaccountres() {
  if (userthirdpartyaccountres_ != NULL) userthirdpartyaccountres_->::pp::UserThirdPartyAccountRes::Clear();
  clear_has_userthirdpartyaccountres();
}
inline const ::pp::UserThirdPartyAccountRes& ProtoBody::userthirdpartyaccountres() const {
  return userthirdpartyaccountres_ != NULL ? *userthirdpartyaccountres_ : *default_instance_->userthirdpartyaccountres_;
}
inline ::pp::UserThirdPartyAccountRes* ProtoBody::mutable_userthirdpartyaccountres() {
  set_has_userthirdpartyaccountres();
  if (userthirdpartyaccountres_ == NULL) userthirdpartyaccountres_ = new ::pp::UserThirdPartyAccountRes;
  return userthirdpartyaccountres_;
}
inline ::pp::UserThirdPartyAccountRes* ProtoBody::release_userthirdpartyaccountres() {
  clear_has_userthirdpartyaccountres();
  ::pp::UserThirdPartyAccountRes* temp = userthirdpartyaccountres_;
  userthirdpartyaccountres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userthirdpartyaccountres(::pp::UserThirdPartyAccountRes* userthirdpartyaccountres) {
  delete userthirdpartyaccountres_;
  userthirdpartyaccountres_ = userthirdpartyaccountres;
  if (userthirdpartyaccountres) {
    set_has_userthirdpartyaccountres();
  } else {
    clear_has_userthirdpartyaccountres();
  }
}

// optional .pp.UserMsgListReq userMsgListReq = 768;
inline bool ProtoBody::has_usermsglistreq() const {
  return (_has_bits_[8] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_usermsglistreq() {
  _has_bits_[8] |= 0x00001000u;
}
inline void ProtoBody::clear_has_usermsglistreq() {
  _has_bits_[8] &= ~0x00001000u;
}
inline void ProtoBody::clear_usermsglistreq() {
  if (usermsglistreq_ != NULL) usermsglistreq_->::pp::UserMsgListReq::Clear();
  clear_has_usermsglistreq();
}
inline const ::pp::UserMsgListReq& ProtoBody::usermsglistreq() const {
  return usermsglistreq_ != NULL ? *usermsglistreq_ : *default_instance_->usermsglistreq_;
}
inline ::pp::UserMsgListReq* ProtoBody::mutable_usermsglistreq() {
  set_has_usermsglistreq();
  if (usermsglistreq_ == NULL) usermsglistreq_ = new ::pp::UserMsgListReq;
  return usermsglistreq_;
}
inline ::pp::UserMsgListReq* ProtoBody::release_usermsglistreq() {
  clear_has_usermsglistreq();
  ::pp::UserMsgListReq* temp = usermsglistreq_;
  usermsglistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsglistreq(::pp::UserMsgListReq* usermsglistreq) {
  delete usermsglistreq_;
  usermsglistreq_ = usermsglistreq;
  if (usermsglistreq) {
    set_has_usermsglistreq();
  } else {
    clear_has_usermsglistreq();
  }
}

// optional .pp.UserMsgListRes userMsgListRes = 769;
inline bool ProtoBody::has_usermsglistres() const {
  return (_has_bits_[8] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_usermsglistres() {
  _has_bits_[8] |= 0x00002000u;
}
inline void ProtoBody::clear_has_usermsglistres() {
  _has_bits_[8] &= ~0x00002000u;
}
inline void ProtoBody::clear_usermsglistres() {
  if (usermsglistres_ != NULL) usermsglistres_->::pp::UserMsgListRes::Clear();
  clear_has_usermsglistres();
}
inline const ::pp::UserMsgListRes& ProtoBody::usermsglistres() const {
  return usermsglistres_ != NULL ? *usermsglistres_ : *default_instance_->usermsglistres_;
}
inline ::pp::UserMsgListRes* ProtoBody::mutable_usermsglistres() {
  set_has_usermsglistres();
  if (usermsglistres_ == NULL) usermsglistres_ = new ::pp::UserMsgListRes;
  return usermsglistres_;
}
inline ::pp::UserMsgListRes* ProtoBody::release_usermsglistres() {
  clear_has_usermsglistres();
  ::pp::UserMsgListRes* temp = usermsglistres_;
  usermsglistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsglistres(::pp::UserMsgListRes* usermsglistres) {
  delete usermsglistres_;
  usermsglistres_ = usermsglistres;
  if (usermsglistres) {
    set_has_usermsglistres();
  } else {
    clear_has_usermsglistres();
  }
}

// optional .pp.UserMsgBroadcastReq userMsgBroadcastReq = 786;
inline bool ProtoBody::has_usermsgbroadcastreq() const {
  return (_has_bits_[8] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_usermsgbroadcastreq() {
  _has_bits_[8] |= 0x00004000u;
}
inline void ProtoBody::clear_has_usermsgbroadcastreq() {
  _has_bits_[8] &= ~0x00004000u;
}
inline void ProtoBody::clear_usermsgbroadcastreq() {
  if (usermsgbroadcastreq_ != NULL) usermsgbroadcastreq_->::pp::UserMsgBroadcastReq::Clear();
  clear_has_usermsgbroadcastreq();
}
inline const ::pp::UserMsgBroadcastReq& ProtoBody::usermsgbroadcastreq() const {
  return usermsgbroadcastreq_ != NULL ? *usermsgbroadcastreq_ : *default_instance_->usermsgbroadcastreq_;
}
inline ::pp::UserMsgBroadcastReq* ProtoBody::mutable_usermsgbroadcastreq() {
  set_has_usermsgbroadcastreq();
  if (usermsgbroadcastreq_ == NULL) usermsgbroadcastreq_ = new ::pp::UserMsgBroadcastReq;
  return usermsgbroadcastreq_;
}
inline ::pp::UserMsgBroadcastReq* ProtoBody::release_usermsgbroadcastreq() {
  clear_has_usermsgbroadcastreq();
  ::pp::UserMsgBroadcastReq* temp = usermsgbroadcastreq_;
  usermsgbroadcastreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsgbroadcastreq(::pp::UserMsgBroadcastReq* usermsgbroadcastreq) {
  delete usermsgbroadcastreq_;
  usermsgbroadcastreq_ = usermsgbroadcastreq;
  if (usermsgbroadcastreq) {
    set_has_usermsgbroadcastreq();
  } else {
    clear_has_usermsgbroadcastreq();
  }
}

// optional .pp.UserMsgRejectListSetReq userMsgRejectListSetReq = 800;
inline bool ProtoBody::has_usermsgrejectlistsetreq() const {
  return (_has_bits_[8] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_usermsgrejectlistsetreq() {
  _has_bits_[8] |= 0x00008000u;
}
inline void ProtoBody::clear_has_usermsgrejectlistsetreq() {
  _has_bits_[8] &= ~0x00008000u;
}
inline void ProtoBody::clear_usermsgrejectlistsetreq() {
  if (usermsgrejectlistsetreq_ != NULL) usermsgrejectlistsetreq_->::pp::UserMsgRejectListSetReq::Clear();
  clear_has_usermsgrejectlistsetreq();
}
inline const ::pp::UserMsgRejectListSetReq& ProtoBody::usermsgrejectlistsetreq() const {
  return usermsgrejectlistsetreq_ != NULL ? *usermsgrejectlistsetreq_ : *default_instance_->usermsgrejectlistsetreq_;
}
inline ::pp::UserMsgRejectListSetReq* ProtoBody::mutable_usermsgrejectlistsetreq() {
  set_has_usermsgrejectlistsetreq();
  if (usermsgrejectlistsetreq_ == NULL) usermsgrejectlistsetreq_ = new ::pp::UserMsgRejectListSetReq;
  return usermsgrejectlistsetreq_;
}
inline ::pp::UserMsgRejectListSetReq* ProtoBody::release_usermsgrejectlistsetreq() {
  clear_has_usermsgrejectlistsetreq();
  ::pp::UserMsgRejectListSetReq* temp = usermsgrejectlistsetreq_;
  usermsgrejectlistsetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsgrejectlistsetreq(::pp::UserMsgRejectListSetReq* usermsgrejectlistsetreq) {
  delete usermsgrejectlistsetreq_;
  usermsgrejectlistsetreq_ = usermsgrejectlistsetreq;
  if (usermsgrejectlistsetreq) {
    set_has_usermsgrejectlistsetreq();
  } else {
    clear_has_usermsgrejectlistsetreq();
  }
}

// optional .pp.UserMsgRejectListSetRes userMsgRejectListSetRes = 801;
inline bool ProtoBody::has_usermsgrejectlistsetres() const {
  return (_has_bits_[8] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_usermsgrejectlistsetres() {
  _has_bits_[8] |= 0x00010000u;
}
inline void ProtoBody::clear_has_usermsgrejectlistsetres() {
  _has_bits_[8] &= ~0x00010000u;
}
inline void ProtoBody::clear_usermsgrejectlistsetres() {
  if (usermsgrejectlistsetres_ != NULL) usermsgrejectlistsetres_->::pp::UserMsgRejectListSetRes::Clear();
  clear_has_usermsgrejectlistsetres();
}
inline const ::pp::UserMsgRejectListSetRes& ProtoBody::usermsgrejectlistsetres() const {
  return usermsgrejectlistsetres_ != NULL ? *usermsgrejectlistsetres_ : *default_instance_->usermsgrejectlistsetres_;
}
inline ::pp::UserMsgRejectListSetRes* ProtoBody::mutable_usermsgrejectlistsetres() {
  set_has_usermsgrejectlistsetres();
  if (usermsgrejectlistsetres_ == NULL) usermsgrejectlistsetres_ = new ::pp::UserMsgRejectListSetRes;
  return usermsgrejectlistsetres_;
}
inline ::pp::UserMsgRejectListSetRes* ProtoBody::release_usermsgrejectlistsetres() {
  clear_has_usermsgrejectlistsetres();
  ::pp::UserMsgRejectListSetRes* temp = usermsgrejectlistsetres_;
  usermsgrejectlistsetres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsgrejectlistsetres(::pp::UserMsgRejectListSetRes* usermsgrejectlistsetres) {
  delete usermsgrejectlistsetres_;
  usermsgrejectlistsetres_ = usermsgrejectlistsetres;
  if (usermsgrejectlistsetres) {
    set_has_usermsgrejectlistsetres();
  } else {
    clear_has_usermsgrejectlistsetres();
  }
}

// optional .pp.UserMsgRejectListGetReq userMsgRejectListGetReq = 802;
inline bool ProtoBody::has_usermsgrejectlistgetreq() const {
  return (_has_bits_[8] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_usermsgrejectlistgetreq() {
  _has_bits_[8] |= 0x00020000u;
}
inline void ProtoBody::clear_has_usermsgrejectlistgetreq() {
  _has_bits_[8] &= ~0x00020000u;
}
inline void ProtoBody::clear_usermsgrejectlistgetreq() {
  if (usermsgrejectlistgetreq_ != NULL) usermsgrejectlistgetreq_->::pp::UserMsgRejectListGetReq::Clear();
  clear_has_usermsgrejectlistgetreq();
}
inline const ::pp::UserMsgRejectListGetReq& ProtoBody::usermsgrejectlistgetreq() const {
  return usermsgrejectlistgetreq_ != NULL ? *usermsgrejectlistgetreq_ : *default_instance_->usermsgrejectlistgetreq_;
}
inline ::pp::UserMsgRejectListGetReq* ProtoBody::mutable_usermsgrejectlistgetreq() {
  set_has_usermsgrejectlistgetreq();
  if (usermsgrejectlistgetreq_ == NULL) usermsgrejectlistgetreq_ = new ::pp::UserMsgRejectListGetReq;
  return usermsgrejectlistgetreq_;
}
inline ::pp::UserMsgRejectListGetReq* ProtoBody::release_usermsgrejectlistgetreq() {
  clear_has_usermsgrejectlistgetreq();
  ::pp::UserMsgRejectListGetReq* temp = usermsgrejectlistgetreq_;
  usermsgrejectlistgetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsgrejectlistgetreq(::pp::UserMsgRejectListGetReq* usermsgrejectlistgetreq) {
  delete usermsgrejectlistgetreq_;
  usermsgrejectlistgetreq_ = usermsgrejectlistgetreq;
  if (usermsgrejectlistgetreq) {
    set_has_usermsgrejectlistgetreq();
  } else {
    clear_has_usermsgrejectlistgetreq();
  }
}

// optional .pp.UserMsgRejectListGetRes userMsgRejectListGetRes = 803;
inline bool ProtoBody::has_usermsgrejectlistgetres() const {
  return (_has_bits_[8] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_usermsgrejectlistgetres() {
  _has_bits_[8] |= 0x00040000u;
}
inline void ProtoBody::clear_has_usermsgrejectlistgetres() {
  _has_bits_[8] &= ~0x00040000u;
}
inline void ProtoBody::clear_usermsgrejectlistgetres() {
  if (usermsgrejectlistgetres_ != NULL) usermsgrejectlistgetres_->::pp::UserMsgRejectListGetRes::Clear();
  clear_has_usermsgrejectlistgetres();
}
inline const ::pp::UserMsgRejectListGetRes& ProtoBody::usermsgrejectlistgetres() const {
  return usermsgrejectlistgetres_ != NULL ? *usermsgrejectlistgetres_ : *default_instance_->usermsgrejectlistgetres_;
}
inline ::pp::UserMsgRejectListGetRes* ProtoBody::mutable_usermsgrejectlistgetres() {
  set_has_usermsgrejectlistgetres();
  if (usermsgrejectlistgetres_ == NULL) usermsgrejectlistgetres_ = new ::pp::UserMsgRejectListGetRes;
  return usermsgrejectlistgetres_;
}
inline ::pp::UserMsgRejectListGetRes* ProtoBody::release_usermsgrejectlistgetres() {
  clear_has_usermsgrejectlistgetres();
  ::pp::UserMsgRejectListGetRes* temp = usermsgrejectlistgetres_;
  usermsgrejectlistgetres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_usermsgrejectlistgetres(::pp::UserMsgRejectListGetRes* usermsgrejectlistgetres) {
  delete usermsgrejectlistgetres_;
  usermsgrejectlistgetres_ = usermsgrejectlistgetres;
  if (usermsgrejectlistgetres) {
    set_has_usermsgrejectlistgetres();
  } else {
    clear_has_usermsgrejectlistgetres();
  }
}

// optional .pp.MsgReadRevisionSetReq msgReadRevisionSetReq = 816;
inline bool ProtoBody::has_msgreadrevisionsetreq() const {
  return (_has_bits_[8] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_msgreadrevisionsetreq() {
  _has_bits_[8] |= 0x00080000u;
}
inline void ProtoBody::clear_has_msgreadrevisionsetreq() {
  _has_bits_[8] &= ~0x00080000u;
}
inline void ProtoBody::clear_msgreadrevisionsetreq() {
  if (msgreadrevisionsetreq_ != NULL) msgreadrevisionsetreq_->::pp::MsgReadRevisionSetReq::Clear();
  clear_has_msgreadrevisionsetreq();
}
inline const ::pp::MsgReadRevisionSetReq& ProtoBody::msgreadrevisionsetreq() const {
  return msgreadrevisionsetreq_ != NULL ? *msgreadrevisionsetreq_ : *default_instance_->msgreadrevisionsetreq_;
}
inline ::pp::MsgReadRevisionSetReq* ProtoBody::mutable_msgreadrevisionsetreq() {
  set_has_msgreadrevisionsetreq();
  if (msgreadrevisionsetreq_ == NULL) msgreadrevisionsetreq_ = new ::pp::MsgReadRevisionSetReq;
  return msgreadrevisionsetreq_;
}
inline ::pp::MsgReadRevisionSetReq* ProtoBody::release_msgreadrevisionsetreq() {
  clear_has_msgreadrevisionsetreq();
  ::pp::MsgReadRevisionSetReq* temp = msgreadrevisionsetreq_;
  msgreadrevisionsetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgreadrevisionsetreq(::pp::MsgReadRevisionSetReq* msgreadrevisionsetreq) {
  delete msgreadrevisionsetreq_;
  msgreadrevisionsetreq_ = msgreadrevisionsetreq;
  if (msgreadrevisionsetreq) {
    set_has_msgreadrevisionsetreq();
  } else {
    clear_has_msgreadrevisionsetreq();
  }
}

// optional .pp.MsgReadRevisionSetRes msgReadRevisionSetRes = 817;
inline bool ProtoBody::has_msgreadrevisionsetres() const {
  return (_has_bits_[8] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_msgreadrevisionsetres() {
  _has_bits_[8] |= 0x00100000u;
}
inline void ProtoBody::clear_has_msgreadrevisionsetres() {
  _has_bits_[8] &= ~0x00100000u;
}
inline void ProtoBody::clear_msgreadrevisionsetres() {
  if (msgreadrevisionsetres_ != NULL) msgreadrevisionsetres_->::pp::MsgReadRevisionSetRes::Clear();
  clear_has_msgreadrevisionsetres();
}
inline const ::pp::MsgReadRevisionSetRes& ProtoBody::msgreadrevisionsetres() const {
  return msgreadrevisionsetres_ != NULL ? *msgreadrevisionsetres_ : *default_instance_->msgreadrevisionsetres_;
}
inline ::pp::MsgReadRevisionSetRes* ProtoBody::mutable_msgreadrevisionsetres() {
  set_has_msgreadrevisionsetres();
  if (msgreadrevisionsetres_ == NULL) msgreadrevisionsetres_ = new ::pp::MsgReadRevisionSetRes;
  return msgreadrevisionsetres_;
}
inline ::pp::MsgReadRevisionSetRes* ProtoBody::release_msgreadrevisionsetres() {
  clear_has_msgreadrevisionsetres();
  ::pp::MsgReadRevisionSetRes* temp = msgreadrevisionsetres_;
  msgreadrevisionsetres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgreadrevisionsetres(::pp::MsgReadRevisionSetRes* msgreadrevisionsetres) {
  delete msgreadrevisionsetres_;
  msgreadrevisionsetres_ = msgreadrevisionsetres;
  if (msgreadrevisionsetres) {
    set_has_msgreadrevisionsetres();
  } else {
    clear_has_msgreadrevisionsetres();
  }
}

// optional .pp.MsgReadRevisionGetReq msgReadRevisionGetReq = 818;
inline bool ProtoBody::has_msgreadrevisiongetreq() const {
  return (_has_bits_[8] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_msgreadrevisiongetreq() {
  _has_bits_[8] |= 0x00200000u;
}
inline void ProtoBody::clear_has_msgreadrevisiongetreq() {
  _has_bits_[8] &= ~0x00200000u;
}
inline void ProtoBody::clear_msgreadrevisiongetreq() {
  if (msgreadrevisiongetreq_ != NULL) msgreadrevisiongetreq_->::pp::MsgReadRevisionGetReq::Clear();
  clear_has_msgreadrevisiongetreq();
}
inline const ::pp::MsgReadRevisionGetReq& ProtoBody::msgreadrevisiongetreq() const {
  return msgreadrevisiongetreq_ != NULL ? *msgreadrevisiongetreq_ : *default_instance_->msgreadrevisiongetreq_;
}
inline ::pp::MsgReadRevisionGetReq* ProtoBody::mutable_msgreadrevisiongetreq() {
  set_has_msgreadrevisiongetreq();
  if (msgreadrevisiongetreq_ == NULL) msgreadrevisiongetreq_ = new ::pp::MsgReadRevisionGetReq;
  return msgreadrevisiongetreq_;
}
inline ::pp::MsgReadRevisionGetReq* ProtoBody::release_msgreadrevisiongetreq() {
  clear_has_msgreadrevisiongetreq();
  ::pp::MsgReadRevisionGetReq* temp = msgreadrevisiongetreq_;
  msgreadrevisiongetreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgreadrevisiongetreq(::pp::MsgReadRevisionGetReq* msgreadrevisiongetreq) {
  delete msgreadrevisiongetreq_;
  msgreadrevisiongetreq_ = msgreadrevisiongetreq;
  if (msgreadrevisiongetreq) {
    set_has_msgreadrevisiongetreq();
  } else {
    clear_has_msgreadrevisiongetreq();
  }
}

// optional .pp.MsgReadRevisionGetRes msgReadRevisionGetRes = 819;
inline bool ProtoBody::has_msgreadrevisiongetres() const {
  return (_has_bits_[8] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_msgreadrevisiongetres() {
  _has_bits_[8] |= 0x00400000u;
}
inline void ProtoBody::clear_has_msgreadrevisiongetres() {
  _has_bits_[8] &= ~0x00400000u;
}
inline void ProtoBody::clear_msgreadrevisiongetres() {
  if (msgreadrevisiongetres_ != NULL) msgreadrevisiongetres_->::pp::MsgReadRevisionGetRes::Clear();
  clear_has_msgreadrevisiongetres();
}
inline const ::pp::MsgReadRevisionGetRes& ProtoBody::msgreadrevisiongetres() const {
  return msgreadrevisiongetres_ != NULL ? *msgreadrevisiongetres_ : *default_instance_->msgreadrevisiongetres_;
}
inline ::pp::MsgReadRevisionGetRes* ProtoBody::mutable_msgreadrevisiongetres() {
  set_has_msgreadrevisiongetres();
  if (msgreadrevisiongetres_ == NULL) msgreadrevisiongetres_ = new ::pp::MsgReadRevisionGetRes;
  return msgreadrevisiongetres_;
}
inline ::pp::MsgReadRevisionGetRes* ProtoBody::release_msgreadrevisiongetres() {
  clear_has_msgreadrevisiongetres();
  ::pp::MsgReadRevisionGetRes* temp = msgreadrevisiongetres_;
  msgreadrevisiongetres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgreadrevisiongetres(::pp::MsgReadRevisionGetRes* msgreadrevisiongetres) {
  delete msgreadrevisiongetres_;
  msgreadrevisiongetres_ = msgreadrevisiongetres;
  if (msgreadrevisiongetres) {
    set_has_msgreadrevisiongetres();
  } else {
    clear_has_msgreadrevisiongetres();
  }
}

// optional .pp.MsgBroadcastQueryReq msgBroadcastQueryReq = 820;
inline bool ProtoBody::has_msgbroadcastqueryreq() const {
  return (_has_bits_[8] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_msgbroadcastqueryreq() {
  _has_bits_[8] |= 0x00800000u;
}
inline void ProtoBody::clear_has_msgbroadcastqueryreq() {
  _has_bits_[8] &= ~0x00800000u;
}
inline void ProtoBody::clear_msgbroadcastqueryreq() {
  if (msgbroadcastqueryreq_ != NULL) msgbroadcastqueryreq_->::pp::MsgBroadcastQueryReq::Clear();
  clear_has_msgbroadcastqueryreq();
}
inline const ::pp::MsgBroadcastQueryReq& ProtoBody::msgbroadcastqueryreq() const {
  return msgbroadcastqueryreq_ != NULL ? *msgbroadcastqueryreq_ : *default_instance_->msgbroadcastqueryreq_;
}
inline ::pp::MsgBroadcastQueryReq* ProtoBody::mutable_msgbroadcastqueryreq() {
  set_has_msgbroadcastqueryreq();
  if (msgbroadcastqueryreq_ == NULL) msgbroadcastqueryreq_ = new ::pp::MsgBroadcastQueryReq;
  return msgbroadcastqueryreq_;
}
inline ::pp::MsgBroadcastQueryReq* ProtoBody::release_msgbroadcastqueryreq() {
  clear_has_msgbroadcastqueryreq();
  ::pp::MsgBroadcastQueryReq* temp = msgbroadcastqueryreq_;
  msgbroadcastqueryreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgbroadcastqueryreq(::pp::MsgBroadcastQueryReq* msgbroadcastqueryreq) {
  delete msgbroadcastqueryreq_;
  msgbroadcastqueryreq_ = msgbroadcastqueryreq;
  if (msgbroadcastqueryreq) {
    set_has_msgbroadcastqueryreq();
  } else {
    clear_has_msgbroadcastqueryreq();
  }
}

// optional .pp.MsgBroadcastQueryRes msgBroadcastQueryRes = 821;
inline bool ProtoBody::has_msgbroadcastqueryres() const {
  return (_has_bits_[8] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_msgbroadcastqueryres() {
  _has_bits_[8] |= 0x01000000u;
}
inline void ProtoBody::clear_has_msgbroadcastqueryres() {
  _has_bits_[8] &= ~0x01000000u;
}
inline void ProtoBody::clear_msgbroadcastqueryres() {
  if (msgbroadcastqueryres_ != NULL) msgbroadcastqueryres_->::pp::MsgBroadcastQueryRes::Clear();
  clear_has_msgbroadcastqueryres();
}
inline const ::pp::MsgBroadcastQueryRes& ProtoBody::msgbroadcastqueryres() const {
  return msgbroadcastqueryres_ != NULL ? *msgbroadcastqueryres_ : *default_instance_->msgbroadcastqueryres_;
}
inline ::pp::MsgBroadcastQueryRes* ProtoBody::mutable_msgbroadcastqueryres() {
  set_has_msgbroadcastqueryres();
  if (msgbroadcastqueryres_ == NULL) msgbroadcastqueryres_ = new ::pp::MsgBroadcastQueryRes;
  return msgbroadcastqueryres_;
}
inline ::pp::MsgBroadcastQueryRes* ProtoBody::release_msgbroadcastqueryres() {
  clear_has_msgbroadcastqueryres();
  ::pp::MsgBroadcastQueryRes* temp = msgbroadcastqueryres_;
  msgbroadcastqueryres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_msgbroadcastqueryres(::pp::MsgBroadcastQueryRes* msgbroadcastqueryres) {
  delete msgbroadcastqueryres_;
  msgbroadcastqueryres_ = msgbroadcastqueryres;
  if (msgbroadcastqueryres) {
    set_has_msgbroadcastqueryres();
  } else {
    clear_has_msgbroadcastqueryres();
  }
}

// optional .pp.WeiLianJoinReq weiLianJoinReq = 13313;
inline bool ProtoBody::has_weilianjoinreq() const {
  return (_has_bits_[8] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_weilianjoinreq() {
  _has_bits_[8] |= 0x02000000u;
}
inline void ProtoBody::clear_has_weilianjoinreq() {
  _has_bits_[8] &= ~0x02000000u;
}
inline void ProtoBody::clear_weilianjoinreq() {
  if (weilianjoinreq_ != NULL) weilianjoinreq_->::pp::WeiLianJoinReq::Clear();
  clear_has_weilianjoinreq();
}
inline const ::pp::WeiLianJoinReq& ProtoBody::weilianjoinreq() const {
  return weilianjoinreq_ != NULL ? *weilianjoinreq_ : *default_instance_->weilianjoinreq_;
}
inline ::pp::WeiLianJoinReq* ProtoBody::mutable_weilianjoinreq() {
  set_has_weilianjoinreq();
  if (weilianjoinreq_ == NULL) weilianjoinreq_ = new ::pp::WeiLianJoinReq;
  return weilianjoinreq_;
}
inline ::pp::WeiLianJoinReq* ProtoBody::release_weilianjoinreq() {
  clear_has_weilianjoinreq();
  ::pp::WeiLianJoinReq* temp = weilianjoinreq_;
  weilianjoinreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weilianjoinreq(::pp::WeiLianJoinReq* weilianjoinreq) {
  delete weilianjoinreq_;
  weilianjoinreq_ = weilianjoinreq;
  if (weilianjoinreq) {
    set_has_weilianjoinreq();
  } else {
    clear_has_weilianjoinreq();
  }
}

// optional .pp.WeiLianJoinRes weiLianJoinRes = 13314;
inline bool ProtoBody::has_weilianjoinres() const {
  return (_has_bits_[8] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_weilianjoinres() {
  _has_bits_[8] |= 0x04000000u;
}
inline void ProtoBody::clear_has_weilianjoinres() {
  _has_bits_[8] &= ~0x04000000u;
}
inline void ProtoBody::clear_weilianjoinres() {
  if (weilianjoinres_ != NULL) weilianjoinres_->::pp::WeiLianJoinRes::Clear();
  clear_has_weilianjoinres();
}
inline const ::pp::WeiLianJoinRes& ProtoBody::weilianjoinres() const {
  return weilianjoinres_ != NULL ? *weilianjoinres_ : *default_instance_->weilianjoinres_;
}
inline ::pp::WeiLianJoinRes* ProtoBody::mutable_weilianjoinres() {
  set_has_weilianjoinres();
  if (weilianjoinres_ == NULL) weilianjoinres_ = new ::pp::WeiLianJoinRes;
  return weilianjoinres_;
}
inline ::pp::WeiLianJoinRes* ProtoBody::release_weilianjoinres() {
  clear_has_weilianjoinres();
  ::pp::WeiLianJoinRes* temp = weilianjoinres_;
  weilianjoinres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weilianjoinres(::pp::WeiLianJoinRes* weilianjoinres) {
  delete weilianjoinres_;
  weilianjoinres_ = weilianjoinres;
  if (weilianjoinres) {
    set_has_weilianjoinres();
  } else {
    clear_has_weilianjoinres();
  }
}

// optional .pp.WeiLianGoddessRankReq weiLianGoddessRankReq = 13315;
inline bool ProtoBody::has_weiliangoddessrankreq() const {
  return (_has_bits_[8] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_weiliangoddessrankreq() {
  _has_bits_[8] |= 0x08000000u;
}
inline void ProtoBody::clear_has_weiliangoddessrankreq() {
  _has_bits_[8] &= ~0x08000000u;
}
inline void ProtoBody::clear_weiliangoddessrankreq() {
  if (weiliangoddessrankreq_ != NULL) weiliangoddessrankreq_->::pp::WeiLianGoddessRankReq::Clear();
  clear_has_weiliangoddessrankreq();
}
inline const ::pp::WeiLianGoddessRankReq& ProtoBody::weiliangoddessrankreq() const {
  return weiliangoddessrankreq_ != NULL ? *weiliangoddessrankreq_ : *default_instance_->weiliangoddessrankreq_;
}
inline ::pp::WeiLianGoddessRankReq* ProtoBody::mutable_weiliangoddessrankreq() {
  set_has_weiliangoddessrankreq();
  if (weiliangoddessrankreq_ == NULL) weiliangoddessrankreq_ = new ::pp::WeiLianGoddessRankReq;
  return weiliangoddessrankreq_;
}
inline ::pp::WeiLianGoddessRankReq* ProtoBody::release_weiliangoddessrankreq() {
  clear_has_weiliangoddessrankreq();
  ::pp::WeiLianGoddessRankReq* temp = weiliangoddessrankreq_;
  weiliangoddessrankreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weiliangoddessrankreq(::pp::WeiLianGoddessRankReq* weiliangoddessrankreq) {
  delete weiliangoddessrankreq_;
  weiliangoddessrankreq_ = weiliangoddessrankreq;
  if (weiliangoddessrankreq) {
    set_has_weiliangoddessrankreq();
  } else {
    clear_has_weiliangoddessrankreq();
  }
}

// optional .pp.WeiLianGoddessRankRes weiLianGoddessRankRes = 13316;
inline bool ProtoBody::has_weiliangoddessrankres() const {
  return (_has_bits_[8] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_weiliangoddessrankres() {
  _has_bits_[8] |= 0x10000000u;
}
inline void ProtoBody::clear_has_weiliangoddessrankres() {
  _has_bits_[8] &= ~0x10000000u;
}
inline void ProtoBody::clear_weiliangoddessrankres() {
  if (weiliangoddessrankres_ != NULL) weiliangoddessrankres_->::pp::WeiLianGoddessRankRes::Clear();
  clear_has_weiliangoddessrankres();
}
inline const ::pp::WeiLianGoddessRankRes& ProtoBody::weiliangoddessrankres() const {
  return weiliangoddessrankres_ != NULL ? *weiliangoddessrankres_ : *default_instance_->weiliangoddessrankres_;
}
inline ::pp::WeiLianGoddessRankRes* ProtoBody::mutable_weiliangoddessrankres() {
  set_has_weiliangoddessrankres();
  if (weiliangoddessrankres_ == NULL) weiliangoddessrankres_ = new ::pp::WeiLianGoddessRankRes;
  return weiliangoddessrankres_;
}
inline ::pp::WeiLianGoddessRankRes* ProtoBody::release_weiliangoddessrankres() {
  clear_has_weiliangoddessrankres();
  ::pp::WeiLianGoddessRankRes* temp = weiliangoddessrankres_;
  weiliangoddessrankres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weiliangoddessrankres(::pp::WeiLianGoddessRankRes* weiliangoddessrankres) {
  delete weiliangoddessrankres_;
  weiliangoddessrankres_ = weiliangoddessrankres;
  if (weiliangoddessrankres) {
    set_has_weiliangoddessrankres();
  } else {
    clear_has_weiliangoddessrankres();
  }
}

// optional .pp.WeiLianSearchReq weiLianSearchReq = 13317;
inline bool ProtoBody::has_weiliansearchreq() const {
  return (_has_bits_[8] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_weiliansearchreq() {
  _has_bits_[8] |= 0x20000000u;
}
inline void ProtoBody::clear_has_weiliansearchreq() {
  _has_bits_[8] &= ~0x20000000u;
}
inline void ProtoBody::clear_weiliansearchreq() {
  if (weiliansearchreq_ != NULL) weiliansearchreq_->::pp::WeiLianSearchReq::Clear();
  clear_has_weiliansearchreq();
}
inline const ::pp::WeiLianSearchReq& ProtoBody::weiliansearchreq() const {
  return weiliansearchreq_ != NULL ? *weiliansearchreq_ : *default_instance_->weiliansearchreq_;
}
inline ::pp::WeiLianSearchReq* ProtoBody::mutable_weiliansearchreq() {
  set_has_weiliansearchreq();
  if (weiliansearchreq_ == NULL) weiliansearchreq_ = new ::pp::WeiLianSearchReq;
  return weiliansearchreq_;
}
inline ::pp::WeiLianSearchReq* ProtoBody::release_weiliansearchreq() {
  clear_has_weiliansearchreq();
  ::pp::WeiLianSearchReq* temp = weiliansearchreq_;
  weiliansearchreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weiliansearchreq(::pp::WeiLianSearchReq* weiliansearchreq) {
  delete weiliansearchreq_;
  weiliansearchreq_ = weiliansearchreq;
  if (weiliansearchreq) {
    set_has_weiliansearchreq();
  } else {
    clear_has_weiliansearchreq();
  }
}

// optional .pp.WeiLianSearchRes weiLianSearchRes = 13318;
inline bool ProtoBody::has_weiliansearchres() const {
  return (_has_bits_[8] & 0x40000000u) != 0;
}
inline void ProtoBody::set_has_weiliansearchres() {
  _has_bits_[8] |= 0x40000000u;
}
inline void ProtoBody::clear_has_weiliansearchres() {
  _has_bits_[8] &= ~0x40000000u;
}
inline void ProtoBody::clear_weiliansearchres() {
  if (weiliansearchres_ != NULL) weiliansearchres_->::pp::WeiLianSearchRes::Clear();
  clear_has_weiliansearchres();
}
inline const ::pp::WeiLianSearchRes& ProtoBody::weiliansearchres() const {
  return weiliansearchres_ != NULL ? *weiliansearchres_ : *default_instance_->weiliansearchres_;
}
inline ::pp::WeiLianSearchRes* ProtoBody::mutable_weiliansearchres() {
  set_has_weiliansearchres();
  if (weiliansearchres_ == NULL) weiliansearchres_ = new ::pp::WeiLianSearchRes;
  return weiliansearchres_;
}
inline ::pp::WeiLianSearchRes* ProtoBody::release_weiliansearchres() {
  clear_has_weiliansearchres();
  ::pp::WeiLianSearchRes* temp = weiliansearchres_;
  weiliansearchres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weiliansearchres(::pp::WeiLianSearchRes* weiliansearchres) {
  delete weiliansearchres_;
  weiliansearchres_ = weiliansearchres;
  if (weiliansearchres) {
    set_has_weiliansearchres();
  } else {
    clear_has_weiliansearchres();
  }
}

// optional .pp.WeiLianVoteReq weiLianVoteReq = 13319;
inline bool ProtoBody::has_weilianvotereq() const {
  return (_has_bits_[8] & 0x80000000u) != 0;
}
inline void ProtoBody::set_has_weilianvotereq() {
  _has_bits_[8] |= 0x80000000u;
}
inline void ProtoBody::clear_has_weilianvotereq() {
  _has_bits_[8] &= ~0x80000000u;
}
inline void ProtoBody::clear_weilianvotereq() {
  if (weilianvotereq_ != NULL) weilianvotereq_->::pp::WeiLianVoteReq::Clear();
  clear_has_weilianvotereq();
}
inline const ::pp::WeiLianVoteReq& ProtoBody::weilianvotereq() const {
  return weilianvotereq_ != NULL ? *weilianvotereq_ : *default_instance_->weilianvotereq_;
}
inline ::pp::WeiLianVoteReq* ProtoBody::mutable_weilianvotereq() {
  set_has_weilianvotereq();
  if (weilianvotereq_ == NULL) weilianvotereq_ = new ::pp::WeiLianVoteReq;
  return weilianvotereq_;
}
inline ::pp::WeiLianVoteReq* ProtoBody::release_weilianvotereq() {
  clear_has_weilianvotereq();
  ::pp::WeiLianVoteReq* temp = weilianvotereq_;
  weilianvotereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weilianvotereq(::pp::WeiLianVoteReq* weilianvotereq) {
  delete weilianvotereq_;
  weilianvotereq_ = weilianvotereq;
  if (weilianvotereq) {
    set_has_weilianvotereq();
  } else {
    clear_has_weilianvotereq();
  }
}

// optional .pp.WeiLianVoteRes weiLianVoteRes = 13320;
inline bool ProtoBody::has_weilianvoteres() const {
  return (_has_bits_[9] & 0x00000001u) != 0;
}
inline void ProtoBody::set_has_weilianvoteres() {
  _has_bits_[9] |= 0x00000001u;
}
inline void ProtoBody::clear_has_weilianvoteres() {
  _has_bits_[9] &= ~0x00000001u;
}
inline void ProtoBody::clear_weilianvoteres() {
  if (weilianvoteres_ != NULL) weilianvoteres_->::pp::WeiLianVoteRes::Clear();
  clear_has_weilianvoteres();
}
inline const ::pp::WeiLianVoteRes& ProtoBody::weilianvoteres() const {
  return weilianvoteres_ != NULL ? *weilianvoteres_ : *default_instance_->weilianvoteres_;
}
inline ::pp::WeiLianVoteRes* ProtoBody::mutable_weilianvoteres() {
  set_has_weilianvoteres();
  if (weilianvoteres_ == NULL) weilianvoteres_ = new ::pp::WeiLianVoteRes;
  return weilianvoteres_;
}
inline ::pp::WeiLianVoteRes* ProtoBody::release_weilianvoteres() {
  clear_has_weilianvoteres();
  ::pp::WeiLianVoteRes* temp = weilianvoteres_;
  weilianvoteres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weilianvoteres(::pp::WeiLianVoteRes* weilianvoteres) {
  delete weilianvoteres_;
  weilianvoteres_ = weilianvoteres;
  if (weilianvoteres) {
    set_has_weilianvoteres();
  } else {
    clear_has_weilianvoteres();
  }
}

// optional .pp.WeiLianMyRankReq weiLianMyRankReq = 13321;
inline bool ProtoBody::has_weilianmyrankreq() const {
  return (_has_bits_[9] & 0x00000002u) != 0;
}
inline void ProtoBody::set_has_weilianmyrankreq() {
  _has_bits_[9] |= 0x00000002u;
}
inline void ProtoBody::clear_has_weilianmyrankreq() {
  _has_bits_[9] &= ~0x00000002u;
}
inline void ProtoBody::clear_weilianmyrankreq() {
  if (weilianmyrankreq_ != NULL) weilianmyrankreq_->::pp::WeiLianMyRankReq::Clear();
  clear_has_weilianmyrankreq();
}
inline const ::pp::WeiLianMyRankReq& ProtoBody::weilianmyrankreq() const {
  return weilianmyrankreq_ != NULL ? *weilianmyrankreq_ : *default_instance_->weilianmyrankreq_;
}
inline ::pp::WeiLianMyRankReq* ProtoBody::mutable_weilianmyrankreq() {
  set_has_weilianmyrankreq();
  if (weilianmyrankreq_ == NULL) weilianmyrankreq_ = new ::pp::WeiLianMyRankReq;
  return weilianmyrankreq_;
}
inline ::pp::WeiLianMyRankReq* ProtoBody::release_weilianmyrankreq() {
  clear_has_weilianmyrankreq();
  ::pp::WeiLianMyRankReq* temp = weilianmyrankreq_;
  weilianmyrankreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weilianmyrankreq(::pp::WeiLianMyRankReq* weilianmyrankreq) {
  delete weilianmyrankreq_;
  weilianmyrankreq_ = weilianmyrankreq;
  if (weilianmyrankreq) {
    set_has_weilianmyrankreq();
  } else {
    clear_has_weilianmyrankreq();
  }
}

// optional .pp.WeiLianMyRankRes weiLianMyRankRes = 13322;
inline bool ProtoBody::has_weilianmyrankres() const {
  return (_has_bits_[9] & 0x00000004u) != 0;
}
inline void ProtoBody::set_has_weilianmyrankres() {
  _has_bits_[9] |= 0x00000004u;
}
inline void ProtoBody::clear_has_weilianmyrankres() {
  _has_bits_[9] &= ~0x00000004u;
}
inline void ProtoBody::clear_weilianmyrankres() {
  if (weilianmyrankres_ != NULL) weilianmyrankres_->::pp::WeiLianMyRankRes::Clear();
  clear_has_weilianmyrankres();
}
inline const ::pp::WeiLianMyRankRes& ProtoBody::weilianmyrankres() const {
  return weilianmyrankres_ != NULL ? *weilianmyrankres_ : *default_instance_->weilianmyrankres_;
}
inline ::pp::WeiLianMyRankRes* ProtoBody::mutable_weilianmyrankres() {
  set_has_weilianmyrankres();
  if (weilianmyrankres_ == NULL) weilianmyrankres_ = new ::pp::WeiLianMyRankRes;
  return weilianmyrankres_;
}
inline ::pp::WeiLianMyRankRes* ProtoBody::release_weilianmyrankres() {
  clear_has_weilianmyrankres();
  ::pp::WeiLianMyRankRes* temp = weilianmyrankres_;
  weilianmyrankres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_weilianmyrankres(::pp::WeiLianMyRankRes* weilianmyrankres) {
  delete weilianmyrankres_;
  weilianmyrankres_ = weilianmyrankres;
  if (weilianmyrankres) {
    set_has_weilianmyrankres();
  } else {
    clear_has_weilianmyrankres();
  }
}

// optional .pp.WebQRCodeScanReq webQRCodeScanReq = 4609;
inline bool ProtoBody::has_webqrcodescanreq() const {
  return (_has_bits_[9] & 0x00000008u) != 0;
}
inline void ProtoBody::set_has_webqrcodescanreq() {
  _has_bits_[9] |= 0x00000008u;
}
inline void ProtoBody::clear_has_webqrcodescanreq() {
  _has_bits_[9] &= ~0x00000008u;
}
inline void ProtoBody::clear_webqrcodescanreq() {
  if (webqrcodescanreq_ != NULL) webqrcodescanreq_->::pp::WebQRCodeScanReq::Clear();
  clear_has_webqrcodescanreq();
}
inline const ::pp::WebQRCodeScanReq& ProtoBody::webqrcodescanreq() const {
  return webqrcodescanreq_ != NULL ? *webqrcodescanreq_ : *default_instance_->webqrcodescanreq_;
}
inline ::pp::WebQRCodeScanReq* ProtoBody::mutable_webqrcodescanreq() {
  set_has_webqrcodescanreq();
  if (webqrcodescanreq_ == NULL) webqrcodescanreq_ = new ::pp::WebQRCodeScanReq;
  return webqrcodescanreq_;
}
inline ::pp::WebQRCodeScanReq* ProtoBody::release_webqrcodescanreq() {
  clear_has_webqrcodescanreq();
  ::pp::WebQRCodeScanReq* temp = webqrcodescanreq_;
  webqrcodescanreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_webqrcodescanreq(::pp::WebQRCodeScanReq* webqrcodescanreq) {
  delete webqrcodescanreq_;
  webqrcodescanreq_ = webqrcodescanreq;
  if (webqrcodescanreq) {
    set_has_webqrcodescanreq();
  } else {
    clear_has_webqrcodescanreq();
  }
}

// optional .pp.WebTokenVerifyReq webTokenVerifyReq = 4672;
inline bool ProtoBody::has_webtokenverifyreq() const {
  return (_has_bits_[9] & 0x00000010u) != 0;
}
inline void ProtoBody::set_has_webtokenverifyreq() {
  _has_bits_[9] |= 0x00000010u;
}
inline void ProtoBody::clear_has_webtokenverifyreq() {
  _has_bits_[9] &= ~0x00000010u;
}
inline void ProtoBody::clear_webtokenverifyreq() {
  if (webtokenverifyreq_ != NULL) webtokenverifyreq_->::pp::WebTokenVerifyReq::Clear();
  clear_has_webtokenverifyreq();
}
inline const ::pp::WebTokenVerifyReq& ProtoBody::webtokenverifyreq() const {
  return webtokenverifyreq_ != NULL ? *webtokenverifyreq_ : *default_instance_->webtokenverifyreq_;
}
inline ::pp::WebTokenVerifyReq* ProtoBody::mutable_webtokenverifyreq() {
  set_has_webtokenverifyreq();
  if (webtokenverifyreq_ == NULL) webtokenverifyreq_ = new ::pp::WebTokenVerifyReq;
  return webtokenverifyreq_;
}
inline ::pp::WebTokenVerifyReq* ProtoBody::release_webtokenverifyreq() {
  clear_has_webtokenverifyreq();
  ::pp::WebTokenVerifyReq* temp = webtokenverifyreq_;
  webtokenverifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_webtokenverifyreq(::pp::WebTokenVerifyReq* webtokenverifyreq) {
  delete webtokenverifyreq_;
  webtokenverifyreq_ = webtokenverifyreq;
  if (webtokenverifyreq) {
    set_has_webtokenverifyreq();
  } else {
    clear_has_webtokenverifyreq();
  }
}

// optional .pp.UserDataAdjustReq userDataAdjustReq = 4705;
inline bool ProtoBody::has_userdataadjustreq() const {
  return (_has_bits_[9] & 0x00000020u) != 0;
}
inline void ProtoBody::set_has_userdataadjustreq() {
  _has_bits_[9] |= 0x00000020u;
}
inline void ProtoBody::clear_has_userdataadjustreq() {
  _has_bits_[9] &= ~0x00000020u;
}
inline void ProtoBody::clear_userdataadjustreq() {
  if (userdataadjustreq_ != NULL) userdataadjustreq_->::pp::UserDataAdjustReq::Clear();
  clear_has_userdataadjustreq();
}
inline const ::pp::UserDataAdjustReq& ProtoBody::userdataadjustreq() const {
  return userdataadjustreq_ != NULL ? *userdataadjustreq_ : *default_instance_->userdataadjustreq_;
}
inline ::pp::UserDataAdjustReq* ProtoBody::mutable_userdataadjustreq() {
  set_has_userdataadjustreq();
  if (userdataadjustreq_ == NULL) userdataadjustreq_ = new ::pp::UserDataAdjustReq;
  return userdataadjustreq_;
}
inline ::pp::UserDataAdjustReq* ProtoBody::release_userdataadjustreq() {
  clear_has_userdataadjustreq();
  ::pp::UserDataAdjustReq* temp = userdataadjustreq_;
  userdataadjustreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_userdataadjustreq(::pp::UserDataAdjustReq* userdataadjustreq) {
  delete userdataadjustreq_;
  userdataadjustreq_ = userdataadjustreq;
  if (userdataadjustreq) {
    set_has_userdataadjustreq();
  } else {
    clear_has_userdataadjustreq();
  }
}

// optional .pp.ConfigDataReq configDataReq = 4709;
inline bool ProtoBody::has_configdatareq() const {
  return (_has_bits_[9] & 0x00000040u) != 0;
}
inline void ProtoBody::set_has_configdatareq() {
  _has_bits_[9] |= 0x00000040u;
}
inline void ProtoBody::clear_has_configdatareq() {
  _has_bits_[9] &= ~0x00000040u;
}
inline void ProtoBody::clear_configdatareq() {
  if (configdatareq_ != NULL) configdatareq_->::pp::ConfigDataReq::Clear();
  clear_has_configdatareq();
}
inline const ::pp::ConfigDataReq& ProtoBody::configdatareq() const {
  return configdatareq_ != NULL ? *configdatareq_ : *default_instance_->configdatareq_;
}
inline ::pp::ConfigDataReq* ProtoBody::mutable_configdatareq() {
  set_has_configdatareq();
  if (configdatareq_ == NULL) configdatareq_ = new ::pp::ConfigDataReq;
  return configdatareq_;
}
inline ::pp::ConfigDataReq* ProtoBody::release_configdatareq() {
  clear_has_configdatareq();
  ::pp::ConfigDataReq* temp = configdatareq_;
  configdatareq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configdatareq(::pp::ConfigDataReq* configdatareq) {
  delete configdatareq_;
  configdatareq_ = configdatareq;
  if (configdatareq) {
    set_has_configdatareq();
  } else {
    clear_has_configdatareq();
  }
}

// optional .pp.ConfigDataRes configDataRes = 4710;
inline bool ProtoBody::has_configdatares() const {
  return (_has_bits_[9] & 0x00000080u) != 0;
}
inline void ProtoBody::set_has_configdatares() {
  _has_bits_[9] |= 0x00000080u;
}
inline void ProtoBody::clear_has_configdatares() {
  _has_bits_[9] &= ~0x00000080u;
}
inline void ProtoBody::clear_configdatares() {
  if (configdatares_ != NULL) configdatares_->::pp::ConfigDataRes::Clear();
  clear_has_configdatares();
}
inline const ::pp::ConfigDataRes& ProtoBody::configdatares() const {
  return configdatares_ != NULL ? *configdatares_ : *default_instance_->configdatares_;
}
inline ::pp::ConfigDataRes* ProtoBody::mutable_configdatares() {
  set_has_configdatares();
  if (configdatares_ == NULL) configdatares_ = new ::pp::ConfigDataRes;
  return configdatares_;
}
inline ::pp::ConfigDataRes* ProtoBody::release_configdatares() {
  clear_has_configdatares();
  ::pp::ConfigDataRes* temp = configdatares_;
  configdatares_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configdatares(::pp::ConfigDataRes* configdatares) {
  delete configdatares_;
  configdatares_ = configdatares;
  if (configdatares) {
    set_has_configdatares();
  } else {
    clear_has_configdatares();
  }
}

// optional .pp.PageDataExchangeReq pageDataExchangeReq = 4726;
inline bool ProtoBody::has_pagedataexchangereq() const {
  return (_has_bits_[9] & 0x00000100u) != 0;
}
inline void ProtoBody::set_has_pagedataexchangereq() {
  _has_bits_[9] |= 0x00000100u;
}
inline void ProtoBody::clear_has_pagedataexchangereq() {
  _has_bits_[9] &= ~0x00000100u;
}
inline void ProtoBody::clear_pagedataexchangereq() {
  if (pagedataexchangereq_ != NULL) pagedataexchangereq_->::pp::PageDataExchangeReq::Clear();
  clear_has_pagedataexchangereq();
}
inline const ::pp::PageDataExchangeReq& ProtoBody::pagedataexchangereq() const {
  return pagedataexchangereq_ != NULL ? *pagedataexchangereq_ : *default_instance_->pagedataexchangereq_;
}
inline ::pp::PageDataExchangeReq* ProtoBody::mutable_pagedataexchangereq() {
  set_has_pagedataexchangereq();
  if (pagedataexchangereq_ == NULL) pagedataexchangereq_ = new ::pp::PageDataExchangeReq;
  return pagedataexchangereq_;
}
inline ::pp::PageDataExchangeReq* ProtoBody::release_pagedataexchangereq() {
  clear_has_pagedataexchangereq();
  ::pp::PageDataExchangeReq* temp = pagedataexchangereq_;
  pagedataexchangereq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_pagedataexchangereq(::pp::PageDataExchangeReq* pagedataexchangereq) {
  delete pagedataexchangereq_;
  pagedataexchangereq_ = pagedataexchangereq;
  if (pagedataexchangereq) {
    set_has_pagedataexchangereq();
  } else {
    clear_has_pagedataexchangereq();
  }
}

// optional .pp.PageDataExchangeRes pageDataExchangeRes = 4727;
inline bool ProtoBody::has_pagedataexchangeres() const {
  return (_has_bits_[9] & 0x00000200u) != 0;
}
inline void ProtoBody::set_has_pagedataexchangeres() {
  _has_bits_[9] |= 0x00000200u;
}
inline void ProtoBody::clear_has_pagedataexchangeres() {
  _has_bits_[9] &= ~0x00000200u;
}
inline void ProtoBody::clear_pagedataexchangeres() {
  if (pagedataexchangeres_ != NULL) pagedataexchangeres_->::pp::PageDataExchangeRes::Clear();
  clear_has_pagedataexchangeres();
}
inline const ::pp::PageDataExchangeRes& ProtoBody::pagedataexchangeres() const {
  return pagedataexchangeres_ != NULL ? *pagedataexchangeres_ : *default_instance_->pagedataexchangeres_;
}
inline ::pp::PageDataExchangeRes* ProtoBody::mutable_pagedataexchangeres() {
  set_has_pagedataexchangeres();
  if (pagedataexchangeres_ == NULL) pagedataexchangeres_ = new ::pp::PageDataExchangeRes;
  return pagedataexchangeres_;
}
inline ::pp::PageDataExchangeRes* ProtoBody::release_pagedataexchangeres() {
  clear_has_pagedataexchangeres();
  ::pp::PageDataExchangeRes* temp = pagedataexchangeres_;
  pagedataexchangeres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_pagedataexchangeres(::pp::PageDataExchangeRes* pagedataexchangeres) {
  delete pagedataexchangeres_;
  pagedataexchangeres_ = pagedataexchangeres;
  if (pagedataexchangeres) {
    set_has_pagedataexchangeres();
  } else {
    clear_has_pagedataexchangeres();
  }
}

// optional .pp.ActLuckyTryReq actLuckyTryReq = 4736;
inline bool ProtoBody::has_actluckytryreq() const {
  return (_has_bits_[9] & 0x00000400u) != 0;
}
inline void ProtoBody::set_has_actluckytryreq() {
  _has_bits_[9] |= 0x00000400u;
}
inline void ProtoBody::clear_has_actluckytryreq() {
  _has_bits_[9] &= ~0x00000400u;
}
inline void ProtoBody::clear_actluckytryreq() {
  if (actluckytryreq_ != NULL) actluckytryreq_->::pp::ActLuckyTryReq::Clear();
  clear_has_actluckytryreq();
}
inline const ::pp::ActLuckyTryReq& ProtoBody::actluckytryreq() const {
  return actluckytryreq_ != NULL ? *actluckytryreq_ : *default_instance_->actluckytryreq_;
}
inline ::pp::ActLuckyTryReq* ProtoBody::mutable_actluckytryreq() {
  set_has_actluckytryreq();
  if (actluckytryreq_ == NULL) actluckytryreq_ = new ::pp::ActLuckyTryReq;
  return actluckytryreq_;
}
inline ::pp::ActLuckyTryReq* ProtoBody::release_actluckytryreq() {
  clear_has_actluckytryreq();
  ::pp::ActLuckyTryReq* temp = actluckytryreq_;
  actluckytryreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actluckytryreq(::pp::ActLuckyTryReq* actluckytryreq) {
  delete actluckytryreq_;
  actluckytryreq_ = actluckytryreq;
  if (actluckytryreq) {
    set_has_actluckytryreq();
  } else {
    clear_has_actluckytryreq();
  }
}

// optional .pp.ActLuckyTryRes actLuckyTryRes = 4737;
inline bool ProtoBody::has_actluckytryres() const {
  return (_has_bits_[9] & 0x00000800u) != 0;
}
inline void ProtoBody::set_has_actluckytryres() {
  _has_bits_[9] |= 0x00000800u;
}
inline void ProtoBody::clear_has_actluckytryres() {
  _has_bits_[9] &= ~0x00000800u;
}
inline void ProtoBody::clear_actluckytryres() {
  if (actluckytryres_ != NULL) actluckytryres_->::pp::ActLuckyTryRes::Clear();
  clear_has_actluckytryres();
}
inline const ::pp::ActLuckyTryRes& ProtoBody::actluckytryres() const {
  return actluckytryres_ != NULL ? *actluckytryres_ : *default_instance_->actluckytryres_;
}
inline ::pp::ActLuckyTryRes* ProtoBody::mutable_actluckytryres() {
  set_has_actluckytryres();
  if (actluckytryres_ == NULL) actluckytryres_ = new ::pp::ActLuckyTryRes;
  return actluckytryres_;
}
inline ::pp::ActLuckyTryRes* ProtoBody::release_actluckytryres() {
  clear_has_actluckytryres();
  ::pp::ActLuckyTryRes* temp = actluckytryres_;
  actluckytryres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actluckytryres(::pp::ActLuckyTryRes* actluckytryres) {
  delete actluckytryres_;
  actluckytryres_ = actluckytryres;
  if (actluckytryres) {
    set_has_actluckytryres();
  } else {
    clear_has_actluckytryres();
  }
}

// optional .pp.ActRecvDynamicReq actRecvDynamicReq = 4738;
inline bool ProtoBody::has_actrecvdynamicreq() const {
  return (_has_bits_[9] & 0x00001000u) != 0;
}
inline void ProtoBody::set_has_actrecvdynamicreq() {
  _has_bits_[9] |= 0x00001000u;
}
inline void ProtoBody::clear_has_actrecvdynamicreq() {
  _has_bits_[9] &= ~0x00001000u;
}
inline void ProtoBody::clear_actrecvdynamicreq() {
  if (actrecvdynamicreq_ != NULL) actrecvdynamicreq_->::pp::ActRecvDynamicReq::Clear();
  clear_has_actrecvdynamicreq();
}
inline const ::pp::ActRecvDynamicReq& ProtoBody::actrecvdynamicreq() const {
  return actrecvdynamicreq_ != NULL ? *actrecvdynamicreq_ : *default_instance_->actrecvdynamicreq_;
}
inline ::pp::ActRecvDynamicReq* ProtoBody::mutable_actrecvdynamicreq() {
  set_has_actrecvdynamicreq();
  if (actrecvdynamicreq_ == NULL) actrecvdynamicreq_ = new ::pp::ActRecvDynamicReq;
  return actrecvdynamicreq_;
}
inline ::pp::ActRecvDynamicReq* ProtoBody::release_actrecvdynamicreq() {
  clear_has_actrecvdynamicreq();
  ::pp::ActRecvDynamicReq* temp = actrecvdynamicreq_;
  actrecvdynamicreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actrecvdynamicreq(::pp::ActRecvDynamicReq* actrecvdynamicreq) {
  delete actrecvdynamicreq_;
  actrecvdynamicreq_ = actrecvdynamicreq;
  if (actrecvdynamicreq) {
    set_has_actrecvdynamicreq();
  } else {
    clear_has_actrecvdynamicreq();
  }
}

// optional .pp.ActRecvDynamicRes actRecvDynamicRes = 4739;
inline bool ProtoBody::has_actrecvdynamicres() const {
  return (_has_bits_[9] & 0x00002000u) != 0;
}
inline void ProtoBody::set_has_actrecvdynamicres() {
  _has_bits_[9] |= 0x00002000u;
}
inline void ProtoBody::clear_has_actrecvdynamicres() {
  _has_bits_[9] &= ~0x00002000u;
}
inline void ProtoBody::clear_actrecvdynamicres() {
  if (actrecvdynamicres_ != NULL) actrecvdynamicres_->::pp::ActRecvDynamicRes::Clear();
  clear_has_actrecvdynamicres();
}
inline const ::pp::ActRecvDynamicRes& ProtoBody::actrecvdynamicres() const {
  return actrecvdynamicres_ != NULL ? *actrecvdynamicres_ : *default_instance_->actrecvdynamicres_;
}
inline ::pp::ActRecvDynamicRes* ProtoBody::mutable_actrecvdynamicres() {
  set_has_actrecvdynamicres();
  if (actrecvdynamicres_ == NULL) actrecvdynamicres_ = new ::pp::ActRecvDynamicRes;
  return actrecvdynamicres_;
}
inline ::pp::ActRecvDynamicRes* ProtoBody::release_actrecvdynamicres() {
  clear_has_actrecvdynamicres();
  ::pp::ActRecvDynamicRes* temp = actrecvdynamicres_;
  actrecvdynamicres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actrecvdynamicres(::pp::ActRecvDynamicRes* actrecvdynamicres) {
  delete actrecvdynamicres_;
  actrecvdynamicres_ = actrecvdynamicres;
  if (actrecvdynamicres) {
    set_has_actrecvdynamicres();
  } else {
    clear_has_actrecvdynamicres();
  }
}

// optional .pp.ConfigJsonActListReq configJsonActListReq = 4740;
inline bool ProtoBody::has_configjsonactlistreq() const {
  return (_has_bits_[9] & 0x00004000u) != 0;
}
inline void ProtoBody::set_has_configjsonactlistreq() {
  _has_bits_[9] |= 0x00004000u;
}
inline void ProtoBody::clear_has_configjsonactlistreq() {
  _has_bits_[9] &= ~0x00004000u;
}
inline void ProtoBody::clear_configjsonactlistreq() {
  if (configjsonactlistreq_ != NULL) configjsonactlistreq_->::pp::ConfigJsonActListReq::Clear();
  clear_has_configjsonactlistreq();
}
inline const ::pp::ConfigJsonActListReq& ProtoBody::configjsonactlistreq() const {
  return configjsonactlistreq_ != NULL ? *configjsonactlistreq_ : *default_instance_->configjsonactlistreq_;
}
inline ::pp::ConfigJsonActListReq* ProtoBody::mutable_configjsonactlistreq() {
  set_has_configjsonactlistreq();
  if (configjsonactlistreq_ == NULL) configjsonactlistreq_ = new ::pp::ConfigJsonActListReq;
  return configjsonactlistreq_;
}
inline ::pp::ConfigJsonActListReq* ProtoBody::release_configjsonactlistreq() {
  clear_has_configjsonactlistreq();
  ::pp::ConfigJsonActListReq* temp = configjsonactlistreq_;
  configjsonactlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonactlistreq(::pp::ConfigJsonActListReq* configjsonactlistreq) {
  delete configjsonactlistreq_;
  configjsonactlistreq_ = configjsonactlistreq;
  if (configjsonactlistreq) {
    set_has_configjsonactlistreq();
  } else {
    clear_has_configjsonactlistreq();
  }
}

// optional .pp.ConfigJsonActListRes configJsonActListRes = 4741;
inline bool ProtoBody::has_configjsonactlistres() const {
  return (_has_bits_[9] & 0x00008000u) != 0;
}
inline void ProtoBody::set_has_configjsonactlistres() {
  _has_bits_[9] |= 0x00008000u;
}
inline void ProtoBody::clear_has_configjsonactlistres() {
  _has_bits_[9] &= ~0x00008000u;
}
inline void ProtoBody::clear_configjsonactlistres() {
  if (configjsonactlistres_ != NULL) configjsonactlistres_->::pp::ConfigJsonActListRes::Clear();
  clear_has_configjsonactlistres();
}
inline const ::pp::ConfigJsonActListRes& ProtoBody::configjsonactlistres() const {
  return configjsonactlistres_ != NULL ? *configjsonactlistres_ : *default_instance_->configjsonactlistres_;
}
inline ::pp::ConfigJsonActListRes* ProtoBody::mutable_configjsonactlistres() {
  set_has_configjsonactlistres();
  if (configjsonactlistres_ == NULL) configjsonactlistres_ = new ::pp::ConfigJsonActListRes;
  return configjsonactlistres_;
}
inline ::pp::ConfigJsonActListRes* ProtoBody::release_configjsonactlistres() {
  clear_has_configjsonactlistres();
  ::pp::ConfigJsonActListRes* temp = configjsonactlistres_;
  configjsonactlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonactlistres(::pp::ConfigJsonActListRes* configjsonactlistres) {
  delete configjsonactlistres_;
  configjsonactlistres_ = configjsonactlistres;
  if (configjsonactlistres) {
    set_has_configjsonactlistres();
  } else {
    clear_has_configjsonactlistres();
  }
}

// optional .pp.ConfigJsonActModifyReq configJsonActModifyReq = 4742;
inline bool ProtoBody::has_configjsonactmodifyreq() const {
  return (_has_bits_[9] & 0x00010000u) != 0;
}
inline void ProtoBody::set_has_configjsonactmodifyreq() {
  _has_bits_[9] |= 0x00010000u;
}
inline void ProtoBody::clear_has_configjsonactmodifyreq() {
  _has_bits_[9] &= ~0x00010000u;
}
inline void ProtoBody::clear_configjsonactmodifyreq() {
  if (configjsonactmodifyreq_ != NULL) configjsonactmodifyreq_->::pp::ConfigJsonActModifyReq::Clear();
  clear_has_configjsonactmodifyreq();
}
inline const ::pp::ConfigJsonActModifyReq& ProtoBody::configjsonactmodifyreq() const {
  return configjsonactmodifyreq_ != NULL ? *configjsonactmodifyreq_ : *default_instance_->configjsonactmodifyreq_;
}
inline ::pp::ConfigJsonActModifyReq* ProtoBody::mutable_configjsonactmodifyreq() {
  set_has_configjsonactmodifyreq();
  if (configjsonactmodifyreq_ == NULL) configjsonactmodifyreq_ = new ::pp::ConfigJsonActModifyReq;
  return configjsonactmodifyreq_;
}
inline ::pp::ConfigJsonActModifyReq* ProtoBody::release_configjsonactmodifyreq() {
  clear_has_configjsonactmodifyreq();
  ::pp::ConfigJsonActModifyReq* temp = configjsonactmodifyreq_;
  configjsonactmodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonactmodifyreq(::pp::ConfigJsonActModifyReq* configjsonactmodifyreq) {
  delete configjsonactmodifyreq_;
  configjsonactmodifyreq_ = configjsonactmodifyreq;
  if (configjsonactmodifyreq) {
    set_has_configjsonactmodifyreq();
  } else {
    clear_has_configjsonactmodifyreq();
  }
}

// optional .pp.ActStarFormReq actStarFormReq = 4743;
inline bool ProtoBody::has_actstarformreq() const {
  return (_has_bits_[9] & 0x00020000u) != 0;
}
inline void ProtoBody::set_has_actstarformreq() {
  _has_bits_[9] |= 0x00020000u;
}
inline void ProtoBody::clear_has_actstarformreq() {
  _has_bits_[9] &= ~0x00020000u;
}
inline void ProtoBody::clear_actstarformreq() {
  if (actstarformreq_ != NULL) actstarformreq_->::pp::ActStarFormReq::Clear();
  clear_has_actstarformreq();
}
inline const ::pp::ActStarFormReq& ProtoBody::actstarformreq() const {
  return actstarformreq_ != NULL ? *actstarformreq_ : *default_instance_->actstarformreq_;
}
inline ::pp::ActStarFormReq* ProtoBody::mutable_actstarformreq() {
  set_has_actstarformreq();
  if (actstarformreq_ == NULL) actstarformreq_ = new ::pp::ActStarFormReq;
  return actstarformreq_;
}
inline ::pp::ActStarFormReq* ProtoBody::release_actstarformreq() {
  clear_has_actstarformreq();
  ::pp::ActStarFormReq* temp = actstarformreq_;
  actstarformreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actstarformreq(::pp::ActStarFormReq* actstarformreq) {
  delete actstarformreq_;
  actstarformreq_ = actstarformreq;
  if (actstarformreq) {
    set_has_actstarformreq();
  } else {
    clear_has_actstarformreq();
  }
}

// optional .pp.ConfigJsonActStarReq configJsonActStarReq = 4744;
inline bool ProtoBody::has_configjsonactstarreq() const {
  return (_has_bits_[9] & 0x00040000u) != 0;
}
inline void ProtoBody::set_has_configjsonactstarreq() {
  _has_bits_[9] |= 0x00040000u;
}
inline void ProtoBody::clear_has_configjsonactstarreq() {
  _has_bits_[9] &= ~0x00040000u;
}
inline void ProtoBody::clear_configjsonactstarreq() {
  if (configjsonactstarreq_ != NULL) configjsonactstarreq_->::pp::ConfigJsonActStarReq::Clear();
  clear_has_configjsonactstarreq();
}
inline const ::pp::ConfigJsonActStarReq& ProtoBody::configjsonactstarreq() const {
  return configjsonactstarreq_ != NULL ? *configjsonactstarreq_ : *default_instance_->configjsonactstarreq_;
}
inline ::pp::ConfigJsonActStarReq* ProtoBody::mutable_configjsonactstarreq() {
  set_has_configjsonactstarreq();
  if (configjsonactstarreq_ == NULL) configjsonactstarreq_ = new ::pp::ConfigJsonActStarReq;
  return configjsonactstarreq_;
}
inline ::pp::ConfigJsonActStarReq* ProtoBody::release_configjsonactstarreq() {
  clear_has_configjsonactstarreq();
  ::pp::ConfigJsonActStarReq* temp = configjsonactstarreq_;
  configjsonactstarreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonactstarreq(::pp::ConfigJsonActStarReq* configjsonactstarreq) {
  delete configjsonactstarreq_;
  configjsonactstarreq_ = configjsonactstarreq;
  if (configjsonactstarreq) {
    set_has_configjsonactstarreq();
  } else {
    clear_has_configjsonactstarreq();
  }
}

// optional .pp.ConfigJsonActRes configJsonActRes = 4745;
inline bool ProtoBody::has_configjsonactres() const {
  return (_has_bits_[9] & 0x00080000u) != 0;
}
inline void ProtoBody::set_has_configjsonactres() {
  _has_bits_[9] |= 0x00080000u;
}
inline void ProtoBody::clear_has_configjsonactres() {
  _has_bits_[9] &= ~0x00080000u;
}
inline void ProtoBody::clear_configjsonactres() {
  if (configjsonactres_ != NULL) configjsonactres_->::pp::ConfigJsonActRes::Clear();
  clear_has_configjsonactres();
}
inline const ::pp::ConfigJsonActRes& ProtoBody::configjsonactres() const {
  return configjsonactres_ != NULL ? *configjsonactres_ : *default_instance_->configjsonactres_;
}
inline ::pp::ConfigJsonActRes* ProtoBody::mutable_configjsonactres() {
  set_has_configjsonactres();
  if (configjsonactres_ == NULL) configjsonactres_ = new ::pp::ConfigJsonActRes;
  return configjsonactres_;
}
inline ::pp::ConfigJsonActRes* ProtoBody::release_configjsonactres() {
  clear_has_configjsonactres();
  ::pp::ConfigJsonActRes* temp = configjsonactres_;
  configjsonactres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_configjsonactres(::pp::ConfigJsonActRes* configjsonactres) {
  delete configjsonactres_;
  configjsonactres_ = configjsonactres;
  if (configjsonactres) {
    set_has_configjsonactres();
  } else {
    clear_has_configjsonactres();
  }
}

// optional .pp.ActMsgListReq actMsgListReq = 4752;
inline bool ProtoBody::has_actmsglistreq() const {
  return (_has_bits_[9] & 0x00100000u) != 0;
}
inline void ProtoBody::set_has_actmsglistreq() {
  _has_bits_[9] |= 0x00100000u;
}
inline void ProtoBody::clear_has_actmsglistreq() {
  _has_bits_[9] &= ~0x00100000u;
}
inline void ProtoBody::clear_actmsglistreq() {
  if (actmsglistreq_ != NULL) actmsglistreq_->::pp::ActMsgListReq::Clear();
  clear_has_actmsglistreq();
}
inline const ::pp::ActMsgListReq& ProtoBody::actmsglistreq() const {
  return actmsglistreq_ != NULL ? *actmsglistreq_ : *default_instance_->actmsglistreq_;
}
inline ::pp::ActMsgListReq* ProtoBody::mutable_actmsglistreq() {
  set_has_actmsglistreq();
  if (actmsglistreq_ == NULL) actmsglistreq_ = new ::pp::ActMsgListReq;
  return actmsglistreq_;
}
inline ::pp::ActMsgListReq* ProtoBody::release_actmsglistreq() {
  clear_has_actmsglistreq();
  ::pp::ActMsgListReq* temp = actmsglistreq_;
  actmsglistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actmsglistreq(::pp::ActMsgListReq* actmsglistreq) {
  delete actmsglistreq_;
  actmsglistreq_ = actmsglistreq;
  if (actmsglistreq) {
    set_has_actmsglistreq();
  } else {
    clear_has_actmsglistreq();
  }
}

// optional .pp.ActMsgListRes actMsgListRes = 4753;
inline bool ProtoBody::has_actmsglistres() const {
  return (_has_bits_[9] & 0x00200000u) != 0;
}
inline void ProtoBody::set_has_actmsglistres() {
  _has_bits_[9] |= 0x00200000u;
}
inline void ProtoBody::clear_has_actmsglistres() {
  _has_bits_[9] &= ~0x00200000u;
}
inline void ProtoBody::clear_actmsglistres() {
  if (actmsglistres_ != NULL) actmsglistres_->::pp::ActMsgListRes::Clear();
  clear_has_actmsglistres();
}
inline const ::pp::ActMsgListRes& ProtoBody::actmsglistres() const {
  return actmsglistres_ != NULL ? *actmsglistres_ : *default_instance_->actmsglistres_;
}
inline ::pp::ActMsgListRes* ProtoBody::mutable_actmsglistres() {
  set_has_actmsglistres();
  if (actmsglistres_ == NULL) actmsglistres_ = new ::pp::ActMsgListRes;
  return actmsglistres_;
}
inline ::pp::ActMsgListRes* ProtoBody::release_actmsglistres() {
  clear_has_actmsglistres();
  ::pp::ActMsgListRes* temp = actmsglistres_;
  actmsglistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actmsglistres(::pp::ActMsgListRes* actmsglistres) {
  delete actmsglistres_;
  actmsglistres_ = actmsglistres;
  if (actmsglistres) {
    set_has_actmsglistres();
  } else {
    clear_has_actmsglistres();
  }
}

// optional .pp.ActMsgModifyReq actMsgModifyReq = 4754;
inline bool ProtoBody::has_actmsgmodifyreq() const {
  return (_has_bits_[9] & 0x00400000u) != 0;
}
inline void ProtoBody::set_has_actmsgmodifyreq() {
  _has_bits_[9] |= 0x00400000u;
}
inline void ProtoBody::clear_has_actmsgmodifyreq() {
  _has_bits_[9] &= ~0x00400000u;
}
inline void ProtoBody::clear_actmsgmodifyreq() {
  if (actmsgmodifyreq_ != NULL) actmsgmodifyreq_->::pp::ActMsgModifyReq::Clear();
  clear_has_actmsgmodifyreq();
}
inline const ::pp::ActMsgModifyReq& ProtoBody::actmsgmodifyreq() const {
  return actmsgmodifyreq_ != NULL ? *actmsgmodifyreq_ : *default_instance_->actmsgmodifyreq_;
}
inline ::pp::ActMsgModifyReq* ProtoBody::mutable_actmsgmodifyreq() {
  set_has_actmsgmodifyreq();
  if (actmsgmodifyreq_ == NULL) actmsgmodifyreq_ = new ::pp::ActMsgModifyReq;
  return actmsgmodifyreq_;
}
inline ::pp::ActMsgModifyReq* ProtoBody::release_actmsgmodifyreq() {
  clear_has_actmsgmodifyreq();
  ::pp::ActMsgModifyReq* temp = actmsgmodifyreq_;
  actmsgmodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_actmsgmodifyreq(::pp::ActMsgModifyReq* actmsgmodifyreq) {
  delete actmsgmodifyreq_;
  actmsgmodifyreq_ = actmsgmodifyreq;
  if (actmsgmodifyreq) {
    set_has_actmsgmodifyreq();
  } else {
    clear_has_actmsgmodifyreq();
  }
}

// optional .pp.CoinAwardRecordReq coinAwardRecordReq = 4761;
inline bool ProtoBody::has_coinawardrecordreq() const {
  return (_has_bits_[9] & 0x00800000u) != 0;
}
inline void ProtoBody::set_has_coinawardrecordreq() {
  _has_bits_[9] |= 0x00800000u;
}
inline void ProtoBody::clear_has_coinawardrecordreq() {
  _has_bits_[9] &= ~0x00800000u;
}
inline void ProtoBody::clear_coinawardrecordreq() {
  if (coinawardrecordreq_ != NULL) coinawardrecordreq_->::pp::CoinAwardRecordReq::Clear();
  clear_has_coinawardrecordreq();
}
inline const ::pp::CoinAwardRecordReq& ProtoBody::coinawardrecordreq() const {
  return coinawardrecordreq_ != NULL ? *coinawardrecordreq_ : *default_instance_->coinawardrecordreq_;
}
inline ::pp::CoinAwardRecordReq* ProtoBody::mutable_coinawardrecordreq() {
  set_has_coinawardrecordreq();
  if (coinawardrecordreq_ == NULL) coinawardrecordreq_ = new ::pp::CoinAwardRecordReq;
  return coinawardrecordreq_;
}
inline ::pp::CoinAwardRecordReq* ProtoBody::release_coinawardrecordreq() {
  clear_has_coinawardrecordreq();
  ::pp::CoinAwardRecordReq* temp = coinawardrecordreq_;
  coinawardrecordreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_coinawardrecordreq(::pp::CoinAwardRecordReq* coinawardrecordreq) {
  delete coinawardrecordreq_;
  coinawardrecordreq_ = coinawardrecordreq;
  if (coinawardrecordreq) {
    set_has_coinawardrecordreq();
  } else {
    clear_has_coinawardrecordreq();
  }
}

// optional .pp.CoinAwardRecordRes coinAwardRecordRes = 4762;
inline bool ProtoBody::has_coinawardrecordres() const {
  return (_has_bits_[9] & 0x01000000u) != 0;
}
inline void ProtoBody::set_has_coinawardrecordres() {
  _has_bits_[9] |= 0x01000000u;
}
inline void ProtoBody::clear_has_coinawardrecordres() {
  _has_bits_[9] &= ~0x01000000u;
}
inline void ProtoBody::clear_coinawardrecordres() {
  if (coinawardrecordres_ != NULL) coinawardrecordres_->::pp::CoinAwardRecordRes::Clear();
  clear_has_coinawardrecordres();
}
inline const ::pp::CoinAwardRecordRes& ProtoBody::coinawardrecordres() const {
  return coinawardrecordres_ != NULL ? *coinawardrecordres_ : *default_instance_->coinawardrecordres_;
}
inline ::pp::CoinAwardRecordRes* ProtoBody::mutable_coinawardrecordres() {
  set_has_coinawardrecordres();
  if (coinawardrecordres_ == NULL) coinawardrecordres_ = new ::pp::CoinAwardRecordRes;
  return coinawardrecordres_;
}
inline ::pp::CoinAwardRecordRes* ProtoBody::release_coinawardrecordres() {
  clear_has_coinawardrecordres();
  ::pp::CoinAwardRecordRes* temp = coinawardrecordres_;
  coinawardrecordres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_coinawardrecordres(::pp::CoinAwardRecordRes* coinawardrecordres) {
  delete coinawardrecordres_;
  coinawardrecordres_ = coinawardrecordres;
  if (coinawardrecordres) {
    set_has_coinawardrecordres();
  } else {
    clear_has_coinawardrecordres();
  }
}

// optional .pp.CoreUserListReq coreUserListReq = 4763;
inline bool ProtoBody::has_coreuserlistreq() const {
  return (_has_bits_[9] & 0x02000000u) != 0;
}
inline void ProtoBody::set_has_coreuserlistreq() {
  _has_bits_[9] |= 0x02000000u;
}
inline void ProtoBody::clear_has_coreuserlistreq() {
  _has_bits_[9] &= ~0x02000000u;
}
inline void ProtoBody::clear_coreuserlistreq() {
  if (coreuserlistreq_ != NULL) coreuserlistreq_->::pp::CoreUserListReq::Clear();
  clear_has_coreuserlistreq();
}
inline const ::pp::CoreUserListReq& ProtoBody::coreuserlistreq() const {
  return coreuserlistreq_ != NULL ? *coreuserlistreq_ : *default_instance_->coreuserlistreq_;
}
inline ::pp::CoreUserListReq* ProtoBody::mutable_coreuserlistreq() {
  set_has_coreuserlistreq();
  if (coreuserlistreq_ == NULL) coreuserlistreq_ = new ::pp::CoreUserListReq;
  return coreuserlistreq_;
}
inline ::pp::CoreUserListReq* ProtoBody::release_coreuserlistreq() {
  clear_has_coreuserlistreq();
  ::pp::CoreUserListReq* temp = coreuserlistreq_;
  coreuserlistreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_coreuserlistreq(::pp::CoreUserListReq* coreuserlistreq) {
  delete coreuserlistreq_;
  coreuserlistreq_ = coreuserlistreq;
  if (coreuserlistreq) {
    set_has_coreuserlistreq();
  } else {
    clear_has_coreuserlistreq();
  }
}

// optional .pp.CoreUserListRes coreUserListRes = 4764;
inline bool ProtoBody::has_coreuserlistres() const {
  return (_has_bits_[9] & 0x04000000u) != 0;
}
inline void ProtoBody::set_has_coreuserlistres() {
  _has_bits_[9] |= 0x04000000u;
}
inline void ProtoBody::clear_has_coreuserlistres() {
  _has_bits_[9] &= ~0x04000000u;
}
inline void ProtoBody::clear_coreuserlistres() {
  if (coreuserlistres_ != NULL) coreuserlistres_->::pp::CoreUserListRes::Clear();
  clear_has_coreuserlistres();
}
inline const ::pp::CoreUserListRes& ProtoBody::coreuserlistres() const {
  return coreuserlistres_ != NULL ? *coreuserlistres_ : *default_instance_->coreuserlistres_;
}
inline ::pp::CoreUserListRes* ProtoBody::mutable_coreuserlistres() {
  set_has_coreuserlistres();
  if (coreuserlistres_ == NULL) coreuserlistres_ = new ::pp::CoreUserListRes;
  return coreuserlistres_;
}
inline ::pp::CoreUserListRes* ProtoBody::release_coreuserlistres() {
  clear_has_coreuserlistres();
  ::pp::CoreUserListRes* temp = coreuserlistres_;
  coreuserlistres_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_coreuserlistres(::pp::CoreUserListRes* coreuserlistres) {
  delete coreuserlistres_;
  coreuserlistres_ = coreuserlistres;
  if (coreuserlistres) {
    set_has_coreuserlistres();
  } else {
    clear_has_coreuserlistres();
  }
}

// optional .pp.CoreUserModifyReq coreUserModifyReq = 4765;
inline bool ProtoBody::has_coreusermodifyreq() const {
  return (_has_bits_[9] & 0x08000000u) != 0;
}
inline void ProtoBody::set_has_coreusermodifyreq() {
  _has_bits_[9] |= 0x08000000u;
}
inline void ProtoBody::clear_has_coreusermodifyreq() {
  _has_bits_[9] &= ~0x08000000u;
}
inline void ProtoBody::clear_coreusermodifyreq() {
  if (coreusermodifyreq_ != NULL) coreusermodifyreq_->::pp::CoreUserModifyReq::Clear();
  clear_has_coreusermodifyreq();
}
inline const ::pp::CoreUserModifyReq& ProtoBody::coreusermodifyreq() const {
  return coreusermodifyreq_ != NULL ? *coreusermodifyreq_ : *default_instance_->coreusermodifyreq_;
}
inline ::pp::CoreUserModifyReq* ProtoBody::mutable_coreusermodifyreq() {
  set_has_coreusermodifyreq();
  if (coreusermodifyreq_ == NULL) coreusermodifyreq_ = new ::pp::CoreUserModifyReq;
  return coreusermodifyreq_;
}
inline ::pp::CoreUserModifyReq* ProtoBody::release_coreusermodifyreq() {
  clear_has_coreusermodifyreq();
  ::pp::CoreUserModifyReq* temp = coreusermodifyreq_;
  coreusermodifyreq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_coreusermodifyreq(::pp::CoreUserModifyReq* coreusermodifyreq) {
  delete coreusermodifyreq_;
  coreusermodifyreq_ = coreusermodifyreq;
  if (coreusermodifyreq) {
    set_has_coreusermodifyreq();
  } else {
    clear_has_coreusermodifyreq();
  }
}

// optional .pp.YYChannelTreeInfoReq yYChannelTreeInfoReq = 13824;
inline bool ProtoBody::has_yychanneltreeinforeq() const {
  return (_has_bits_[9] & 0x10000000u) != 0;
}
inline void ProtoBody::set_has_yychanneltreeinforeq() {
  _has_bits_[9] |= 0x10000000u;
}
inline void ProtoBody::clear_has_yychanneltreeinforeq() {
  _has_bits_[9] &= ~0x10000000u;
}
inline void ProtoBody::clear_yychanneltreeinforeq() {
  if (yychanneltreeinforeq_ != NULL) yychanneltreeinforeq_->::pp::YYChannelTreeInfoReq::Clear();
  clear_has_yychanneltreeinforeq();
}
inline const ::pp::YYChannelTreeInfoReq& ProtoBody::yychanneltreeinforeq() const {
  return yychanneltreeinforeq_ != NULL ? *yychanneltreeinforeq_ : *default_instance_->yychanneltreeinforeq_;
}
inline ::pp::YYChannelTreeInfoReq* ProtoBody::mutable_yychanneltreeinforeq() {
  set_has_yychanneltreeinforeq();
  if (yychanneltreeinforeq_ == NULL) yychanneltreeinforeq_ = new ::pp::YYChannelTreeInfoReq;
  return yychanneltreeinforeq_;
}
inline ::pp::YYChannelTreeInfoReq* ProtoBody::release_yychanneltreeinforeq() {
  clear_has_yychanneltreeinforeq();
  ::pp::YYChannelTreeInfoReq* temp = yychanneltreeinforeq_;
  yychanneltreeinforeq_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yychanneltreeinforeq(::pp::YYChannelTreeInfoReq* yychanneltreeinforeq) {
  delete yychanneltreeinforeq_;
  yychanneltreeinforeq_ = yychanneltreeinforeq;
  if (yychanneltreeinforeq) {
    set_has_yychanneltreeinforeq();
  } else {
    clear_has_yychanneltreeinforeq();
  }
}

// optional .pp.YYChannelTreeInfoRes yYChannelTreeInfoRes = 13825;
inline bool ProtoBody::has_yychanneltreeinfores() const {
  return (_has_bits_[9] & 0x20000000u) != 0;
}
inline void ProtoBody::set_has_yychanneltreeinfores() {
  _has_bits_[9] |= 0x20000000u;
}
inline void ProtoBody::clear_has_yychanneltreeinfores() {
  _has_bits_[9] &= ~0x20000000u;
}
inline void ProtoBody::clear_yychanneltreeinfores() {
  if (yychanneltreeinfores_ != NULL) yychanneltreeinfores_->::pp::YYChannelTreeInfoRes::Clear();
  clear_has_yychanneltreeinfores();
}
inline const ::pp::YYChannelTreeInfoRes& ProtoBody::yychanneltreeinfores() const {
  return yychanneltreeinfores_ != NULL ? *yychanneltreeinfores_ : *default_instance_->yychanneltreeinfores_;
}
inline ::pp::YYChannelTreeInfoRes* ProtoBody::mutable_yychanneltreeinfores() {
  set_has_yychanneltreeinfores();
  if (yychanneltreeinfores_ == NULL) yychanneltreeinfores_ = new ::pp::YYChannelTreeInfoRes;
  return yychanneltreeinfores_;
}
inline ::pp::YYChannelTreeInfoRes* ProtoBody::release_yychanneltreeinfores() {
  clear_has_yychanneltreeinfores();
  ::pp::YYChannelTreeInfoRes* temp = yychanneltreeinfores_;
  yychanneltreeinfores_ = NULL;
  return temp;
}
inline void ProtoBody::set_allocated_yychanneltreeinfores(::pp::YYChannelTreeInfoRes* yychanneltreeinfores) {
  delete yychanneltreeinfores_;
  yychanneltreeinfores_ = yychanneltreeinfores;
  if (yychanneltreeinfores) {
    set_has_yychanneltreeinfores();
  } else {
    clear_has_yychanneltreeinfores();
  }
}

// -------------------------------------------------------------------

// WebReq

// optional sint32 mt = 1;
inline bool WebReq::has_mt() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WebReq::set_has_mt() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WebReq::clear_has_mt() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WebReq::clear_mt() {
  mt_ = 0;
  clear_has_mt();
}
inline ::google::protobuf::int32 WebReq::mt() const {
  return mt_;
}
inline void WebReq::set_mt(::google::protobuf::int32 value) {
  set_has_mt();
  mt_ = value;
}

// optional sint32 st = 2;
inline bool WebReq::has_st() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WebReq::set_has_st() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WebReq::clear_has_st() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WebReq::clear_st() {
  st_ = 0;
  clear_has_st();
}
inline ::google::protobuf::int32 WebReq::st() const {
  return st_;
}
inline void WebReq::set_st(::google::protobuf::int32 value) {
  set_has_st();
  st_ = value;
}

// optional .pp.ProtoBody body = 7;
inline bool WebReq::has_body() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WebReq::set_has_body() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WebReq::clear_has_body() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WebReq::clear_body() {
  if (body_ != NULL) body_->::pp::ProtoBody::Clear();
  clear_has_body();
}
inline const ::pp::ProtoBody& WebReq::body() const {
  return body_ != NULL ? *body_ : *default_instance_->body_;
}
inline ::pp::ProtoBody* WebReq::mutable_body() {
  set_has_body();
  if (body_ == NULL) body_ = new ::pp::ProtoBody;
  return body_;
}
inline ::pp::ProtoBody* WebReq::release_body() {
  clear_has_body();
  ::pp::ProtoBody* temp = body_;
  body_ = NULL;
  return temp;
}
inline void WebReq::set_allocated_body(::pp::ProtoBody* body) {
  delete body_;
  body_ = body;
  if (body) {
    set_has_body();
  } else {
    clear_has_body();
  }
}

// optional int64 timestamp = 10;
inline bool WebReq::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WebReq::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WebReq::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WebReq::clear_timestamp() {
  timestamp_ = GOOGLE_LONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::int64 WebReq::timestamp() const {
  return timestamp_;
}
inline void WebReq::set_timestamp(::google::protobuf::int64 value) {
  set_has_timestamp();
  timestamp_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pp

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::AppState_Type>() {
  return ::pp::AppState_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ContactIncrement_ContactIncrementType>() {
  return ::pp::ContactIncrement_ContactIncrementType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserYYCoinsRecord_OrderType>() {
  return ::pp::UserYYCoinsRecord_OrderType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserPushTokenRegisterReq_DeviceType>() {
  return ::pp::UserPushTokenRegisterReq_DeviceType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::MessageUserApply_OpType>() {
  return ::pp::MessageUserApply_OpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::MessageGroupApply_OpType>() {
  return ::pp::MessageGroupApply_OpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::RedPacketInfo_ItemType>() {
  return ::pp::RedPacketInfo_ItemType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ReportViolatorReq_ViolatorType>() {
  return ::pp::ReportViolatorReq_ViolatorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ReportViolatorReq_ViolatorReason>() {
  return ::pp::ReportViolatorReq_ViolatorReason_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ProductInfo_Type>() {
  return ::pp::ProductInfo_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserTradeRecord_Type>() {
  return ::pp::UserTradeRecord_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserCoinRecord_Type>() {
  return ::pp::UserCoinRecord_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserTaskState_TaskCategory>() {
  return ::pp::UserTaskState_TaskCategory_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserImageOpReq_Type>() {
  return ::pp::UserImageOpReq_Type_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::PType>() {
  return ::pp::PType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPAd>() {
  return ::pp::SPAd_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::AdPage>() {
  return ::pp::AdPage_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPAdmin>() {
  return ::pp::SPAdmin_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ForbidReasonType>() {
  return ::pp::ForbidReasonType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ForbidStateType>() {
  return ::pp::ForbidStateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ForbidDevType>() {
  return ::pp::ForbidDevType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ForbidSearchBy>() {
  return ::pp::ForbidSearchBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPBackstage>() {
  return ::pp::SPBackstage_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SexType>() {
  return ::pp::SexType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ContactState>() {
  return ::pp::ContactState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPConfig>() {
  return ::pp::SPConfig_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPContact>() {
  return ::pp::SPContact_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ContactType>() {
  return ::pp::ContactType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ContactApplyResult>() {
  return ::pp::ContactApplyResult_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ContactOpType>() {
  return ::pp::ContactOpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPEncrypt>() {
  return ::pp::SPEncrypt_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::EncryptType>() {
  return ::pp::EncryptType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ErrCode>() {
  return ::pp::ErrCode_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPGame>() {
  return ::pp::SPGame_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GameRunReportType>() {
  return ::pp::GameRunReportType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GameSearchSortBy>() {
  return ::pp::GameSearchSortBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GameSearchFilter>() {
  return ::pp::GameSearchFilter_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SendMsgType>() {
  return ::pp::SendMsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GameLibType>() {
  return ::pp::GameLibType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ModifyGameOpType>() {
  return ::pp::ModifyGameOpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GameFilterType>() {
  return ::pp::GameFilterType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SpiderSrcFliter>() {
  return ::pp::SpiderSrcFliter_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SpiderMethodFilter>() {
  return ::pp::SpiderMethodFilter_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPGoldCoin>() {
  return ::pp::SPGoldCoin_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserYYCoinsOrderState>() {
  return ::pp::UserYYCoinsOrderState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPGroup>() {
  return ::pp::SPGroup_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupType>() {
  return ::pp::GroupType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupState>() {
  return ::pp::GroupState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupRolerStateType>() {
  return ::pp::GroupRolerStateType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupApprove>() {
  return ::pp::GroupApprove_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupModeType>() {
  return ::pp::GroupModeType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupSearchBy>() {
  return ::pp::GroupSearchBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupSearchOrderBy>() {
  return ::pp::GroupSearchOrderBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupIncrementType>() {
  return ::pp::GroupIncrementType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPGroupApp>() {
  return ::pp::SPGroupApp_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupAppType>() {
  return ::pp::GroupAppType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupAppOp>() {
  return ::pp::GroupAppOp_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPGroupMember>() {
  return ::pp::SPGroupMember_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberRoler>() {
  return ::pp::GroupMemberRoler_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberState>() {
  return ::pp::GroupMemberState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberIncrementType>() {
  return ::pp::GroupMemberIncrementType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberSearchBy>() {
  return ::pp::GroupMemberSearchBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberSortBy>() {
  return ::pp::GroupMemberSortBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberOrderBy>() {
  return ::pp::GroupMemberOrderBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMemberCountType>() {
  return ::pp::GroupMemberCountType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPGroupMsg>() {
  return ::pp::SPGroupMsg_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMsgSortBy>() {
  return ::pp::GroupMsgSortBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMsgOrderBy>() {
  return ::pp::GroupMsgOrderBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPLogin>() {
  return ::pp::SPLogin_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::ProtoVersion>() {
  return ::pp::ProtoVersion_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::DevType>() {
  return ::pp::DevType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupMsgType>() {
  return ::pp::GroupMsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::MessageImageType>() {
  return ::pp::MessageImageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::MessageEventType>() {
  return ::pp::MessageEventType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::MessageContentType>() {
  return ::pp::MessageContentType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPPresent>() {
  return ::pp::SPPresent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::GroupPresentApplyType>() {
  return ::pp::GroupPresentApplyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPPush>() {
  return ::pp::SPPush_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::MsgPushType>() {
  return ::pp::MsgPushType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPRedPacket>() {
  return ::pp::SPRedPacket_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPReport>() {
  return ::pp::SPReport_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPShop>() {
  return ::pp::SPShop_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::YYGiftPayConfirmOpType>() {
  return ::pp::YYGiftPayConfirmOpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPUserTask>() {
  return ::pp::SPUserTask_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserTaskType>() {
  return ::pp::UserTaskType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPUser>() {
  return ::pp::SPUser_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::AccountType>() {
  return ::pp::AccountType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::RolePrivilege>() {
  return ::pp::RolePrivilege_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::RoleType>() {
  return ::pp::RoleType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserInfoFlags>() {
  return ::pp::UserInfoFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserActiveDataFlags>() {
  return ::pp::UserActiveDataFlags_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserSearchBy>() {
  return ::pp::UserSearchBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserSearchOrderBy>() {
  return ::pp::UserSearchOrderBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserImageOrderBy>() {
  return ::pp::UserImageOrderBy_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserImageType>() {
  return ::pp::UserImageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::EntityOpType>() {
  return ::pp::EntityOpType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPUserMsg>() {
  return ::pp::SPUserMsg_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserMsgType>() {
  return ::pp::UserMsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::BroadcastRange>() {
  return ::pp::BroadcastRange_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::UserMsgBroadcastEvent>() {
  return ::pp::UserMsgBroadcastEvent_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPWebActivity>() {
  return ::pp::SPWebActivity_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPWeb>() {
  return ::pp::SPWeb_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pp::SPYYChannel>() {
  return ::pp::SPYYChannel_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xgame_2eproto__INCLUDED
